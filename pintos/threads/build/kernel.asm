
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020078 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020078:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002007d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002007f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020080:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020082:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020084:	66 05 00 04          	add    $0x400,%ax
c0020088:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002008a:	66 3d 00 00          	cmp    $0x0,%ax
c002008e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020090:	76 06                	jbe    c0020098 <start+0x20>
	mov $0x10000, %eax
c0020092:	66 b8 00 00          	mov    $0x0,%ax
c0020096:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020098:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002009c:	67 66 a3 7e 01       	addr16 mov %ax,0x17e
c00200a1:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c00200a3:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200a5:	a8 02                	test   $0x2,%al
	jnz 1b
c00200a7:	75 fa                	jne    c00200a3 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c00200a9:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c00200ab:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c00200ad:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200af:	a8 02                	test   $0x2,%al
	jnz 1b
c00200b1:	75 fa                	jne    c00200ad <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c00200b3:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c00200b5:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c00200b7:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200b9:	a8 02                	test   $0x2,%al
	jnz 1b
c00200bb:	75 fa                	jne    c00200b7 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c00200bd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200c2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200c5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200c8:	66 b9 00 04          	mov    $0x400,%cx
c00200cc:	00 00                	add    %al,(%eax)
	rep stosl
c00200ce:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200d1:	66 b8 07 00          	mov    $0x7,%ax
c00200d5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200d7:	66 b9 11 00          	mov    $0x11,%cx
c00200db:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200dd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200e7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200e8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200eb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200f2:	00 e2                	add    %ah,%dl
	loop 1b
c00200f4:	eb b8                	jmp    c00200ae <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200f6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200f8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200fa:	66 b8 07 00          	mov    $0x7,%ax
c00200fe:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c0020100:	66 b9 00 40          	mov    $0x4000,%cx
c0020104:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c0020106:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020109:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020110:	66 
	addw $4, %di
	addl $0x1000, %eax
c0020111:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c0020116:	e2 f1                	loop   c0020109 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c0020118:	66 b8 00 f0          	mov    $0xf000,%ax
c002011c:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c002011e:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020121:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020122:	67 66 0f 01 15       	lgdtw  (%di)
c0020127:	78 01                	js     c002012a <start+0xb2>
c0020129:	00 00                	add    %al,(%eax)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002012b:	0f 20 c0             	mov    %cr0,%eax
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002012e:	66 0d 05 00          	or     $0x5,%ax
c0020132:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020138:	ea 3f 01 02 c0 08 00 	ljmp   $0x8,$0xc002013f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002013f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020143:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020145:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020147:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020149:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002014b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002014d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020153:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020158:	e8 79 01 00 00       	call   c00202d6 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002015d:	eb fe                	jmp    c002015d <start+0xe5>
	...

c0020160 <gdt>:
	...
c0020168:	ff                   	(bad)  
c0020169:	ff 00                	incl   (%eax)
c002016b:	00 00                	add    %al,(%eax)
c002016d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020174:	00                   	.byte 0x0
c0020175:	92                   	xchg   %eax,%edx
c0020176:	cf                   	iret   
	...

c0020178 <gdtdesc>:
c0020178:	17                   	pop    %ss
c0020179:	00 60 01             	add    %ah,0x1(%eax)
c002017c:	02 c0                	add    %al,%al

c002017e <init_ram_pages>:
c002017e:	00 00                	add    %al,(%eax)
	...

c0020182 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c0020182:	55                   	push   %ebp
c0020183:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0020185:	8b 45 08             	mov    0x8(%ebp),%eax
c0020188:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002018d:	5d                   	pop    %ebp
c002018e:	c3                   	ret    

c002018f <is_kernel_vaddr>:
}

/* Returns true if VADDR is a kernel virtual address. */
static inline bool
is_kernel_vaddr (const void *vaddr) 
{
c002018f:	55                   	push   %ebp
c0020190:	89 e5                	mov    %esp,%ebp
  return vaddr >= PHYS_BASE;
c0020192:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0020199:	0f 97 c0             	seta   %al
}
c002019c:	5d                   	pop    %ebp
c002019d:	c3                   	ret    

c002019e <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c002019e:	55                   	push   %ebp
c002019f:	89 e5                	mov    %esp,%ebp
c00201a1:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c00201a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00201a7:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00201ac:	76 1e                	jbe    c00201cc <ptov+0x2e>
c00201ae:	83 ec 0c             	sub    $0xc,%esp
c00201b1:	68 20 e5 02 c0       	push   $0xc002e520
c00201b6:	68 3b e5 02 c0       	push   $0xc002e53b
c00201bb:	68 c8 e8 02 c0       	push   $0xc002e8c8
c00201c0:	6a 4a                	push   $0x4a
c00201c2:	68 52 e5 02 c0       	push   $0xc002e552
c00201c7:	e8 65 94 00 00       	call   c0029631 <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c00201cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00201cf:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00201d4:	c9                   	leave  
c00201d5:	c3                   	ret    

c00201d6 <vtop>:

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
c00201d6:	55                   	push   %ebp
c00201d7:	89 e5                	mov    %esp,%ebp
c00201d9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_kernel_vaddr (vaddr));
c00201dc:	ff 75 08             	pushl  0x8(%ebp)
c00201df:	e8 ab ff ff ff       	call   c002018f <is_kernel_vaddr>
c00201e4:	83 c4 04             	add    $0x4,%esp
c00201e7:	84 c0                	test   %al,%al
c00201e9:	75 1e                	jne    c0020209 <vtop+0x33>
c00201eb:	83 ec 0c             	sub    $0xc,%esp
c00201ee:	68 68 e5 02 c0       	push   $0xc002e568
c00201f3:	68 3b e5 02 c0       	push   $0xc002e53b
c00201f8:	68 f0 e8 02 c0       	push   $0xc002e8f0
c00201fd:	6a 54                	push   $0x54
c00201ff:	68 52 e5 02 c0       	push   $0xc002e552
c0020204:	e8 28 94 00 00       	call   c0029631 <debug_panic>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020209:	8b 45 08             	mov    0x8(%ebp),%eax
c002020c:	05 00 00 00 40       	add    $0x40000000,%eax
}
c0020211:	c9                   	leave  
c0020212:	c3                   	ret    

c0020213 <pt_no>:
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
c0020213:	55                   	push   %ebp
c0020214:	89 e5                	mov    %esp,%ebp
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c0020216:	8b 45 08             	mov    0x8(%ebp),%eax
c0020219:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c002021e:	c1 e8 0c             	shr    $0xc,%eax
}
c0020221:	5d                   	pop    %ebp
c0020222:	c3                   	ret    

c0020223 <pd_no>:

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va) {
c0020223:	55                   	push   %ebp
c0020224:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PDSHIFT;
c0020226:	8b 45 08             	mov    0x8(%ebp),%eax
c0020229:	c1 e8 16             	shr    $0x16,%eax
}
c002022c:	5d                   	pop    %ebp
c002022d:	c3                   	ret    

c002022e <pde_create>:
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
c002022e:	55                   	push   %ebp
c002022f:	89 e5                	mov    %esp,%ebp
c0020231:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pg_ofs (pt) == 0);
c0020234:	ff 75 08             	pushl  0x8(%ebp)
c0020237:	e8 46 ff ff ff       	call   c0020182 <pg_ofs>
c002023c:	83 c4 04             	add    $0x4,%esp
c002023f:	85 c0                	test   %eax,%eax
c0020241:	74 1e                	je     c0020261 <pde_create+0x33>
c0020243:	83 ec 0c             	sub    $0xc,%esp
c0020246:	68 80 e5 02 c0       	push   $0xc002e580
c002024b:	68 3b e5 02 c0       	push   $0xc002e53b
c0020250:	68 d0 e8 02 c0       	push   $0xc002e8d0
c0020255:	6a 48                	push   $0x48
c0020257:	68 91 e5 02 c0       	push   $0xc002e591
c002025c:	e8 d0 93 00 00       	call   c0029631 <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c0020261:	83 ec 0c             	sub    $0xc,%esp
c0020264:	ff 75 08             	pushl  0x8(%ebp)
c0020267:	e8 6a ff ff ff       	call   c00201d6 <vtop>
c002026c:	83 c4 10             	add    $0x10,%esp
c002026f:	83 c8 07             	or     $0x7,%eax
}
c0020272:	c9                   	leave  
c0020273:	c3                   	ret    

c0020274 <pte_create_kernel>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c0020274:	55                   	push   %ebp
c0020275:	89 e5                	mov    %esp,%ebp
c0020277:	83 ec 18             	sub    $0x18,%esp
c002027a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002027d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c0020280:	ff 75 08             	pushl  0x8(%ebp)
c0020283:	e8 fa fe ff ff       	call   c0020182 <pg_ofs>
c0020288:	83 c4 04             	add    $0x4,%esp
c002028b:	85 c0                	test   %eax,%eax
c002028d:	74 1e                	je     c00202ad <pte_create_kernel+0x39>
c002028f:	83 ec 0c             	sub    $0xc,%esp
c0020292:	68 a5 e5 02 c0       	push   $0xc002e5a5
c0020297:	68 3b e5 02 c0       	push   $0xc002e53b
c002029c:	68 dc e8 02 c0       	push   $0xc002e8dc
c00202a1:	6a 58                	push   $0x58
c00202a3:	68 91 e5 02 c0       	push   $0xc002e591
c00202a8:	e8 84 93 00 00       	call   c0029631 <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c00202ad:	83 ec 0c             	sub    $0xc,%esp
c00202b0:	ff 75 08             	pushl  0x8(%ebp)
c00202b3:	e8 1e ff ff ff       	call   c00201d6 <vtop>
c00202b8:	83 c4 10             	add    $0x10,%esp
c00202bb:	89 c2                	mov    %eax,%edx
c00202bd:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c00202c1:	74 07                	je     c00202ca <pte_create_kernel+0x56>
c00202c3:	b8 02 00 00 00       	mov    $0x2,%eax
c00202c8:	eb 05                	jmp    c00202cf <pte_create_kernel+0x5b>
c00202ca:	b8 00 00 00 00       	mov    $0x0,%eax
c00202cf:	09 d0                	or     %edx,%eax
c00202d1:	83 c8 01             	or     $0x1,%eax
}
c00202d4:	c9                   	leave  
c00202d5:	c3                   	ret    

c00202d6 <pintos_init>:
int pintos_init (void) NO_RETURN;

/* Pintos main entry point. */
int
pintos_init (void)
{
c00202d6:	55                   	push   %ebp
c00202d7:	89 e5                	mov    %esp,%ebp
c00202d9:	83 ec 18             	sub    $0x18,%esp
  char **argv;

  /* Clear BSS. */  
  bss_init ();
c00202dc:	e8 ae 00 00 00       	call   c002038f <bss_init>

  /* Break command line into arguments and parse options. */
  argv = read_command_line ();
c00202e1:	e8 04 02 00 00       	call   c00204ea <read_command_line>
c00202e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  argv = parse_options (argv);
c00202e9:	83 ec 0c             	sub    $0xc,%esp
c00202ec:	ff 75 f4             	pushl  -0xc(%ebp)
c00202ef:	e8 2a 03 00 00       	call   c002061e <parse_options>
c00202f4:	83 c4 10             	add    $0x10,%esp
c00202f7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Initialize ourselves as a thread so we can use locks,
     then enable console locking. */
  thread_init ();
c00202fa:	e8 c8 05 00 00       	call   c00208c7 <thread_init>
  console_init ();  
c00202ff:	e8 7d b3 00 00       	call   c002b681 <console_init>

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
          init_ram_pages * PGSIZE / 1024);
c0020304:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c0020309:	c1 e0 0c             	shl    $0xc,%eax
     then enable console locking. */
  thread_init ();
  console_init ();  

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c002030c:	c1 e8 0a             	shr    $0xa,%eax
c002030f:	83 ec 08             	sub    $0x8,%esp
c0020312:	50                   	push   %eax
c0020313:	68 b8 e5 02 c0       	push   $0xc002e5b8
c0020318:	e8 e1 6e 00 00       	call   c00271fe <printf>
c002031d:	83 c4 10             	add    $0x10,%esp
          init_ram_pages * PGSIZE / 1024);

  /* Initialize memory system. */
  palloc_init (user_page_limit);
c0020320:	a1 40 78 03 c0       	mov    0xc0037840,%eax
c0020325:	83 ec 0c             	sub    $0xc,%esp
c0020328:	50                   	push   %eax
c0020329:	e8 9f 2c 00 00       	call   c0022fcd <palloc_init>
c002032e:	83 c4 10             	add    $0x10,%esp
  malloc_init ();
c0020331:	e8 a8 30 00 00       	call   c00233de <malloc_init>
  paging_init ();
c0020336:	e8 7e 00 00 00       	call   c00203b9 <paging_init>
  tss_init ();
  gdt_init ();
#endif

  /* Initialize interrupt handlers. */
  intr_init ();
c002033b:	e8 82 10 00 00       	call   c00213c2 <intr_init>
  timer_init ();
c0020340:	e8 47 38 00 00       	call   c0023b8c <timer_init>
  kbd_init ();
c0020345:	e8 40 3e 00 00       	call   c002418a <kbd_init>
  input_init ();
c002034a:	e8 29 61 00 00       	call   c0026478 <input_init>
  exception_init ();
  syscall_init ();
#endif

  /* Start thread scheduler and enable interrupts. */
  thread_start ();
c002034f:	e8 12 06 00 00       	call   c0020966 <thread_start>
  serial_init_queue ();
c0020354:	e8 2c 46 00 00       	call   c0024985 <serial_init_queue>
  timer_calibrate ();
c0020359:	e8 5f 38 00 00       	call   c0023bbd <timer_calibrate>
  ide_init ();
  locate_block_devices ();
  filesys_init (format_filesys);
#endif

  printf ("Boot complete.\n");
c002035e:	83 ec 0c             	sub    $0xc,%esp
c0020361:	68 db e5 02 c0       	push   $0xc002e5db
c0020366:	e8 79 b4 00 00       	call   c002b7e4 <puts>
c002036b:	83 c4 10             	add    $0x10,%esp
  
  if (*argv != NULL) {
c002036e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020371:	8b 00                	mov    (%eax),%eax
c0020373:	85 c0                	test   %eax,%eax
c0020375:	74 0e                	je     c0020385 <pintos_init+0xaf>
    /* Run actions specified on kernel command line. */
    run_actions (argv);
c0020377:	83 ec 0c             	sub    $0xc,%esp
c002037a:	ff 75 f4             	pushl  -0xc(%ebp)
c002037d:	e8 38 04 00 00       	call   c00207ba <run_actions>
c0020382:	83 c4 10             	add    $0x10,%esp
  } else {
    // TODO: no command line passed to kernel. Run interactively 
  }

  /* Finish up. */
  shutdown ();
c0020385:	e8 ac 68 00 00       	call   c0026c36 <shutdown>
  thread_exit ();
c002038a:	e8 72 09 00 00       	call   c0020d01 <thread_exit>

c002038f <bss_init>:

   The start and end of the BSS segment is recorded by the
   linker as _start_bss and _end_bss.  See kernel.lds. */
static void
bss_init (void) 
{
c002038f:	55                   	push   %ebp
c0020390:	89 e5                	mov    %esp,%ebp
c0020392:	83 ec 08             	sub    $0x8,%esp
  extern char _start_bss, _end_bss;
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c0020395:	ba 85 9c 03 c0       	mov    $0xc0039c85,%edx
c002039a:	b8 c4 80 03 c0       	mov    $0xc00380c4,%eax
c002039f:	29 c2                	sub    %eax,%edx
c00203a1:	89 d0                	mov    %edx,%eax
c00203a3:	83 ec 04             	sub    $0x4,%esp
c00203a6:	50                   	push   %eax
c00203a7:	6a 00                	push   $0x0
c00203a9:	68 c4 80 03 c0       	push   $0xc00380c4
c00203ae:	e8 72 86 00 00       	call   c0028a25 <memset>
c00203b3:	83 c4 10             	add    $0x10,%esp
}
c00203b6:	90                   	nop
c00203b7:	c9                   	leave  
c00203b8:	c3                   	ret    

c00203b9 <paging_init>:
   kernel virtual mapping, and then sets up the CPU to use the
   new page directory.  Points init_page_dir to the page
   directory it creates. */
static void
paging_init (void)
{
c00203b9:	55                   	push   %ebp
c00203ba:	89 e5                	mov    %esp,%ebp
c00203bc:	53                   	push   %ebx
c00203bd:	83 ec 24             	sub    $0x24,%esp
  uint32_t *pd, *pt;
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00203c0:	83 ec 0c             	sub    $0xc,%esp
c00203c3:	6a 03                	push   $0x3
c00203c5:	e8 7f 2d 00 00       	call   c0023149 <palloc_get_page>
c00203ca:	83 c4 10             	add    $0x10,%esp
c00203cd:	a3 80 9c 03 c0       	mov    %eax,0xc0039c80
c00203d2:	a1 80 9c 03 c0       	mov    0xc0039c80,%eax
c00203d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pt = NULL;
c00203da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for (page = 0; page < init_ram_pages; page++)
c00203e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00203e8:	e9 d5 00 00 00       	jmp    c00204c2 <paging_init+0x109>
    {
      uintptr_t paddr = page * PGSIZE;
c00203ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00203f0:	c1 e0 0c             	shl    $0xc,%eax
c00203f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
      char *vaddr = ptov (paddr);
c00203f6:	83 ec 0c             	sub    $0xc,%esp
c00203f9:	ff 75 e8             	pushl  -0x18(%ebp)
c00203fc:	e8 9d fd ff ff       	call   c002019e <ptov>
c0020401:	83 c4 10             	add    $0x10,%esp
c0020404:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      size_t pde_idx = pd_no (vaddr);
c0020407:	83 ec 0c             	sub    $0xc,%esp
c002040a:	ff 75 e4             	pushl  -0x1c(%ebp)
c002040d:	e8 11 fe ff ff       	call   c0020223 <pd_no>
c0020412:	83 c4 10             	add    $0x10,%esp
c0020415:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t pte_idx = pt_no (vaddr);
c0020418:	83 ec 0c             	sub    $0xc,%esp
c002041b:	ff 75 e4             	pushl  -0x1c(%ebp)
c002041e:	e8 f0 fd ff ff       	call   c0020213 <pt_no>
c0020423:	83 c4 10             	add    $0x10,%esp
c0020426:	89 45 dc             	mov    %eax,-0x24(%ebp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020429:	81 7d e4 00 00 02 c0 	cmpl   $0xc0020000,-0x1c(%ebp)
c0020430:	72 10                	jb     c0020442 <paging_init+0x89>
c0020432:	81 7d e4 00 40 03 c0 	cmpl   $0xc0034000,-0x1c(%ebp)
c0020439:	73 07                	jae    c0020442 <paging_init+0x89>
c002043b:	b8 01 00 00 00       	mov    $0x1,%eax
c0020440:	eb 05                	jmp    c0020447 <paging_init+0x8e>
c0020442:	b8 00 00 00 00       	mov    $0x0,%eax
c0020447:	88 45 db             	mov    %al,-0x25(%ebp)
c002044a:	80 65 db 01          	andb   $0x1,-0x25(%ebp)

      if (pd[pde_idx] == 0)
c002044e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020451:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020458:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002045b:	01 d0                	add    %edx,%eax
c002045d:	8b 00                	mov    (%eax),%eax
c002045f:	85 c0                	test   %eax,%eax
c0020461:	75 30                	jne    c0020493 <paging_init+0xda>
        {
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020463:	83 ec 0c             	sub    $0xc,%esp
c0020466:	6a 03                	push   $0x3
c0020468:	e8 dc 2c 00 00       	call   c0023149 <palloc_get_page>
c002046d:	83 c4 10             	add    $0x10,%esp
c0020470:	89 45 f4             	mov    %eax,-0xc(%ebp)
          pd[pde_idx] = pde_create (pt);
c0020473:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020476:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002047d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020480:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0020483:	83 ec 0c             	sub    $0xc,%esp
c0020486:	ff 75 f4             	pushl  -0xc(%ebp)
c0020489:	e8 a0 fd ff ff       	call   c002022e <pde_create>
c002048e:	83 c4 10             	add    $0x10,%esp
c0020491:	89 03                	mov    %eax,(%ebx)
        }

      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c0020493:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0020496:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002049d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00204a0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c00204a3:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
c00204a7:	83 f0 01             	xor    $0x1,%eax
c00204aa:	0f b6 c0             	movzbl %al,%eax
c00204ad:	83 ec 08             	sub    $0x8,%esp
c00204b0:	50                   	push   %eax
c00204b1:	ff 75 e4             	pushl  -0x1c(%ebp)
c00204b4:	e8 bb fd ff ff       	call   c0020274 <pte_create_kernel>
c00204b9:	83 c4 10             	add    $0x10,%esp
c00204bc:	89 03                	mov    %eax,(%ebx)
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
  pt = NULL;
  for (page = 0; page < init_ram_pages; page++)
c00204be:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c00204c2:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c00204c7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00204ca:	0f 82 1d ff ff ff    	jb     c00203ed <paging_init+0x34>
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c00204d0:	a1 80 9c 03 c0       	mov    0xc0039c80,%eax
c00204d5:	83 ec 0c             	sub    $0xc,%esp
c00204d8:	50                   	push   %eax
c00204d9:	e8 f8 fc ff ff       	call   c00201d6 <vtop>
c00204de:	83 c4 10             	add    $0x10,%esp
c00204e1:	0f 22 d8             	mov    %eax,%cr3
}
c00204e4:	90                   	nop
c00204e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00204e8:	c9                   	leave  
c00204e9:	c3                   	ret    

c00204ea <read_command_line>:

/* Breaks the kernel command line into words and returns them as
   an argv-like array. */
static char **
read_command_line (void) 
{
c00204ea:	55                   	push   %ebp
c00204eb:	89 e5                	mov    %esp,%ebp
c00204ed:	83 ec 18             	sub    $0x18,%esp
  static char *argv[LOADER_ARGS_LEN / 2 + 1];
  char *p, *end;
  int argc;
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c00204f0:	83 ec 0c             	sub    $0xc,%esp
c00204f3:	68 3a 7d 00 00       	push   $0x7d3a
c00204f8:	e8 a1 fc ff ff       	call   c002019e <ptov>
c00204fd:	83 c4 10             	add    $0x10,%esp
c0020500:	8b 00                	mov    (%eax),%eax
c0020502:	89 45 ec             	mov    %eax,-0x14(%ebp)
  p = ptov (LOADER_ARGS);
c0020505:	83 ec 0c             	sub    $0xc,%esp
c0020508:	68 3e 7d 00 00       	push   $0x7d3e
c002050d:	e8 8c fc ff ff       	call   c002019e <ptov>
c0020512:	83 c4 10             	add    $0x10,%esp
c0020515:	89 45 f4             	mov    %eax,-0xc(%ebp)
  end = p + LOADER_ARGS_LEN;
c0020518:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002051b:	83 e8 80             	sub    $0xffffff80,%eax
c002051e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for (i = 0; i < argc; i++) 
c0020521:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0020528:	eb 51                	jmp    c002057b <read_command_line+0x91>
    {
      if (p >= end)
c002052a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002052d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0020530:	72 19                	jb     c002054b <read_command_line+0x61>
        PANIC ("command line arguments overflow");
c0020532:	68 ec e5 02 c0       	push   $0xc002e5ec
c0020537:	68 f8 e8 02 c0       	push   $0xc002e8f8
c002053c:	68 d3 00 00 00       	push   $0xd3
c0020541:	68 0c e6 02 c0       	push   $0xc002e60c
c0020546:	e8 e6 90 00 00       	call   c0029631 <debug_panic>

      argv[i] = p;
c002054b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002054e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0020551:	89 14 85 e0 80 03 c0 	mov    %edx,-0x3ffc7f20(,%eax,4)
      p += strnlen (p, end - p) + 1;
c0020558:	8b 55 e8             	mov    -0x18(%ebp),%edx
c002055b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002055e:	29 c2                	sub    %eax,%edx
c0020560:	89 d0                	mov    %edx,%eax
c0020562:	83 ec 08             	sub    $0x8,%esp
c0020565:	50                   	push   %eax
c0020566:	ff 75 f4             	pushl  -0xc(%ebp)
c0020569:	e8 5f 85 00 00       	call   c0028acd <strnlen>
c002056e:	83 c4 10             	add    $0x10,%esp
c0020571:	83 c0 01             	add    $0x1,%eax
c0020574:	01 45 f4             	add    %eax,-0xc(%ebp)
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
  p = ptov (LOADER_ARGS);
  end = p + LOADER_ARGS_LEN;
  for (i = 0; i < argc; i++) 
c0020577:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002057b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002057e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020581:	7c a7                	jl     c002052a <read_command_line+0x40>
        PANIC ("command line arguments overflow");

      argv[i] = p;
      p += strnlen (p, end - p) + 1;
    }
  argv[argc] = NULL;
c0020583:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020586:	c7 04 85 e0 80 03 c0 	movl   $0x0,-0x3ffc7f20(,%eax,4)
c002058d:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c0020591:	83 ec 0c             	sub    $0xc,%esp
c0020594:	68 21 e6 02 c0       	push   $0xc002e621
c0020599:	e8 60 6c 00 00       	call   c00271fe <printf>
c002059e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00205a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00205a8:	eb 58                	jmp    c0020602 <read_command_line+0x118>
    if (strchr (argv[i], ' ') == NULL)
c00205aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205ad:	8b 04 85 e0 80 03 c0 	mov    -0x3ffc7f20(,%eax,4),%eax
c00205b4:	83 ec 08             	sub    $0x8,%esp
c00205b7:	6a 20                	push   $0x20
c00205b9:	50                   	push   %eax
c00205ba:	e8 75 81 00 00       	call   c0028734 <strchr>
c00205bf:	83 c4 10             	add    $0x10,%esp
c00205c2:	85 c0                	test   %eax,%eax
c00205c4:	75 1d                	jne    c00205e3 <read_command_line+0xf9>
      printf (" %s", argv[i]);
c00205c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205c9:	8b 04 85 e0 80 03 c0 	mov    -0x3ffc7f20(,%eax,4),%eax
c00205d0:	83 ec 08             	sub    $0x8,%esp
c00205d3:	50                   	push   %eax
c00205d4:	68 36 e6 02 c0       	push   $0xc002e636
c00205d9:	e8 20 6c 00 00       	call   c00271fe <printf>
c00205de:	83 c4 10             	add    $0x10,%esp
c00205e1:	eb 1b                	jmp    c00205fe <read_command_line+0x114>
    else
      printf (" '%s'", argv[i]);
c00205e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205e6:	8b 04 85 e0 80 03 c0 	mov    -0x3ffc7f20(,%eax,4),%eax
c00205ed:	83 ec 08             	sub    $0x8,%esp
c00205f0:	50                   	push   %eax
c00205f1:	68 3a e6 02 c0       	push   $0xc002e63a
c00205f6:	e8 03 6c 00 00       	call   c00271fe <printf>
c00205fb:	83 c4 10             	add    $0x10,%esp
    }
  argv[argc] = NULL;

  /* Print kernel command line. */
  printf ("Kernel command line:");
  for (i = 0; i < argc; i++)
c00205fe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0020602:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020605:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020608:	7c a0                	jl     c00205aa <read_command_line+0xc0>
    if (strchr (argv[i], ' ') == NULL)
      printf (" %s", argv[i]);
    else
      printf (" '%s'", argv[i]);
  printf ("\n");
c002060a:	83 ec 0c             	sub    $0xc,%esp
c002060d:	6a 0a                	push   $0xa
c002060f:	e8 58 b2 00 00       	call   c002b86c <putchar>
c0020614:	83 c4 10             	add    $0x10,%esp

  return argv;
c0020617:	b8 e0 80 03 c0       	mov    $0xc00380e0,%eax
}
c002061c:	c9                   	leave  
c002061d:	c3                   	ret    

c002061e <parse_options>:

/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
c002061e:	55                   	push   %ebp
c002061f:	89 e5                	mov    %esp,%ebp
c0020621:	83 ec 18             	sub    $0x18,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c0020624:	e9 1c 01 00 00       	jmp    c0020745 <parse_options+0x127>
    {
      char *save_ptr;
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020629:	8b 45 08             	mov    0x8(%ebp),%eax
c002062c:	8b 00                	mov    (%eax),%eax
c002062e:	83 ec 04             	sub    $0x4,%esp
c0020631:	8d 55 ec             	lea    -0x14(%ebp),%edx
c0020634:	52                   	push   %edx
c0020635:	68 40 e6 02 c0       	push   $0xc002e640
c002063a:	50                   	push   %eax
c002063b:	e8 d1 82 00 00       	call   c0028911 <strtok_r>
c0020640:	83 c4 10             	add    $0x10,%esp
c0020643:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char *value = strtok_r (NULL, "", &save_ptr);
c0020646:	83 ec 04             	sub    $0x4,%esp
c0020649:	8d 45 ec             	lea    -0x14(%ebp),%eax
c002064c:	50                   	push   %eax
c002064d:	68 42 e6 02 c0       	push   $0xc002e642
c0020652:	6a 00                	push   $0x0
c0020654:	e8 b8 82 00 00       	call   c0028911 <strtok_r>
c0020659:	83 c4 10             	add    $0x10,%esp
c002065c:	89 45 f0             	mov    %eax,-0x10(%ebp)
      
      if (!strcmp (name, "-h"))
c002065f:	83 ec 08             	sub    $0x8,%esp
c0020662:	68 43 e6 02 c0       	push   $0xc002e643
c0020667:	ff 75 f4             	pushl  -0xc(%ebp)
c002066a:	e8 b8 7f 00 00       	call   c0028627 <strcmp>
c002066f:	83 c4 10             	add    $0x10,%esp
c0020672:	85 c0                	test   %eax,%eax
c0020674:	75 0a                	jne    c0020680 <parse_options+0x62>
        usage ();
c0020676:	e8 24 02 00 00       	call   c002089f <usage>
c002067b:	e9 c1 00 00 00       	jmp    c0020741 <parse_options+0x123>
      else if (!strcmp (name, "-q"))
c0020680:	83 ec 08             	sub    $0x8,%esp
c0020683:	68 46 e6 02 c0       	push   $0xc002e646
c0020688:	ff 75 f4             	pushl  -0xc(%ebp)
c002068b:	e8 97 7f 00 00       	call   c0028627 <strcmp>
c0020690:	83 c4 10             	add    $0x10,%esp
c0020693:	85 c0                	test   %eax,%eax
c0020695:	75 12                	jne    c00206a9 <parse_options+0x8b>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c0020697:	83 ec 0c             	sub    $0xc,%esp
c002069a:	6a 01                	push   $0x1
c002069c:	e8 b9 65 00 00       	call   c0026c5a <shutdown_configure>
c00206a1:	83 c4 10             	add    $0x10,%esp
c00206a4:	e9 98 00 00 00       	jmp    c0020741 <parse_options+0x123>
      else if (!strcmp (name, "-r"))
c00206a9:	83 ec 08             	sub    $0x8,%esp
c00206ac:	68 49 e6 02 c0       	push   $0xc002e649
c00206b1:	ff 75 f4             	pushl  -0xc(%ebp)
c00206b4:	e8 6e 7f 00 00       	call   c0028627 <strcmp>
c00206b9:	83 c4 10             	add    $0x10,%esp
c00206bc:	85 c0                	test   %eax,%eax
c00206be:	75 0f                	jne    c00206cf <parse_options+0xb1>
        shutdown_configure (SHUTDOWN_REBOOT);
c00206c0:	83 ec 0c             	sub    $0xc,%esp
c00206c3:	6a 02                	push   $0x2
c00206c5:	e8 90 65 00 00       	call   c0026c5a <shutdown_configure>
c00206ca:	83 c4 10             	add    $0x10,%esp
c00206cd:	eb 72                	jmp    c0020741 <parse_options+0x123>
#ifdef VM
      else if (!strcmp (name, "-swap"))
        swap_bdev_name = value;
#endif
#endif
      else if (!strcmp (name, "-rs"))
c00206cf:	83 ec 08             	sub    $0x8,%esp
c00206d2:	68 4c e6 02 c0       	push   $0xc002e64c
c00206d7:	ff 75 f4             	pushl  -0xc(%ebp)
c00206da:	e8 48 7f 00 00       	call   c0028627 <strcmp>
c00206df:	83 c4 10             	add    $0x10,%esp
c00206e2:	85 c0                	test   %eax,%eax
c00206e4:	75 1c                	jne    c0020702 <parse_options+0xe4>
        random_init (atoi (value));
c00206e6:	83 ec 0c             	sub    $0xc,%esp
c00206e9:	ff 75 f0             	pushl  -0x10(%ebp)
c00206ec:	e8 12 79 00 00       	call   c0028003 <atoi>
c00206f1:	83 c4 10             	add    $0x10,%esp
c00206f4:	83 ec 0c             	sub    $0xc,%esp
c00206f7:	50                   	push   %eax
c00206f8:	e8 80 68 00 00       	call   c0026f7d <random_init>
c00206fd:	83 c4 10             	add    $0x10,%esp
c0020700:	eb 3f                	jmp    c0020741 <parse_options+0x123>
      else if (!strcmp (name, "-mlfqs"))
c0020702:	83 ec 08             	sub    $0x8,%esp
c0020705:	68 50 e6 02 c0       	push   $0xc002e650
c002070a:	ff 75 f4             	pushl  -0xc(%ebp)
c002070d:	e8 15 7f 00 00       	call   c0028627 <strcmp>
c0020712:	83 c4 10             	add    $0x10,%esp
c0020715:	85 c0                	test   %eax,%eax
c0020717:	75 09                	jne    c0020722 <parse_options+0x104>
        thread_mlfqs = true;
c0020719:	c6 05 84 9c 03 c0 01 	movb   $0x1,0xc0039c84
c0020720:	eb 1f                	jmp    c0020741 <parse_options+0x123>
#ifdef USERPROG
      else if (!strcmp (name, "-ul"))
        user_page_limit = atoi (value);
#endif
      else
        PANIC ("unknown option `%s' (use -h for help)", name);
c0020722:	83 ec 0c             	sub    $0xc,%esp
c0020725:	ff 75 f4             	pushl  -0xc(%ebp)
c0020728:	68 58 e6 02 c0       	push   $0xc002e658
c002072d:	68 0c e9 02 c0       	push   $0xc002e90c
c0020732:	68 0c 01 00 00       	push   $0x10c
c0020737:	68 0c e6 02 c0       	push   $0xc002e60c
c002073c:	e8 f0 8e 00 00       	call   c0029631 <debug_panic>
/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
  for (; *argv != NULL && **argv == '-'; argv++)
c0020741:	83 45 08 04          	addl   $0x4,0x8(%ebp)
c0020745:	8b 45 08             	mov    0x8(%ebp),%eax
c0020748:	8b 00                	mov    (%eax),%eax
c002074a:	85 c0                	test   %eax,%eax
c002074c:	74 10                	je     c002075e <parse_options+0x140>
c002074e:	8b 45 08             	mov    0x8(%ebp),%eax
c0020751:	8b 00                	mov    (%eax),%eax
c0020753:	0f b6 00             	movzbl (%eax),%eax
c0020756:	3c 2d                	cmp    $0x2d,%al
c0020758:	0f 84 cb fe ff ff    	je     c0020629 <parse_options+0xb>
     When running under Bochs, this is not enough by itself to
     get a good seed value, because the pintos script sets the
     initial time to a predictable value, not to the local time,
     for reproducibility.  To fix this, give the "-r" option to
     the pintos script to request real-time execution. */
  random_init (rtc_get_time ());
c002075e:	e8 91 62 00 00       	call   c00269f4 <rtc_get_time>
c0020763:	83 ec 0c             	sub    $0xc,%esp
c0020766:	50                   	push   %eax
c0020767:	e8 11 68 00 00       	call   c0026f7d <random_init>
c002076c:	83 c4 10             	add    $0x10,%esp
  
  return argv;
c002076f:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0020772:	c9                   	leave  
c0020773:	c3                   	ret    

c0020774 <run_task>:

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c0020774:	55                   	push   %ebp
c0020775:	89 e5                	mov    %esp,%ebp
c0020777:	83 ec 18             	sub    $0x18,%esp
  const char *task = argv[1];
c002077a:	8b 45 08             	mov    0x8(%ebp),%eax
c002077d:	8b 40 04             	mov    0x4(%eax),%eax
c0020780:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Executing '%s':\n", task);
c0020783:	83 ec 08             	sub    $0x8,%esp
c0020786:	ff 75 f4             	pushl  -0xc(%ebp)
c0020789:	68 7e e6 02 c0       	push   $0xc002e67e
c002078e:	e8 6b 6a 00 00       	call   c00271fe <printf>
c0020793:	83 c4 10             	add    $0x10,%esp
#ifdef USERPROG
  process_wait (process_execute (task));
#else
  run_test (task);
c0020796:	83 ec 0c             	sub    $0xc,%esp
c0020799:	ff 75 f4             	pushl  -0xc(%ebp)
c002079c:	e8 9c b1 00 00       	call   c002b93d <run_test>
c00207a1:	83 c4 10             	add    $0x10,%esp
#endif
  printf ("Execution of '%s' complete.\n", task);
c00207a4:	83 ec 08             	sub    $0x8,%esp
c00207a7:	ff 75 f4             	pushl  -0xc(%ebp)
c00207aa:	68 8f e6 02 c0       	push   $0xc002e68f
c00207af:	e8 4a 6a 00 00       	call   c00271fe <printf>
c00207b4:	83 c4 10             	add    $0x10,%esp
}
c00207b7:	90                   	nop
c00207b8:	c9                   	leave  
c00207b9:	c3                   	ret    

c00207ba <run_actions>:

/* Executes all of the actions specified in ARGV[]
   up to the null pointer sentinel. */
static void
run_actions (char **argv) 
{
c00207ba:	55                   	push   %ebp
c00207bb:	89 e5                	mov    %esp,%ebp
c00207bd:	83 ec 18             	sub    $0x18,%esp
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c00207c0:	e9 ca 00 00 00       	jmp    c002088f <run_actions+0xd5>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c00207c5:	c7 45 f4 20 e9 02 c0 	movl   $0xc002e920,-0xc(%ebp)
        if (a->name == NULL)
c00207cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207cf:	8b 00                	mov    (%eax),%eax
c00207d1:	85 c0                	test   %eax,%eax
c00207d3:	75 22                	jne    c00207f7 <run_actions+0x3d>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c00207d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00207d8:	8b 00                	mov    (%eax),%eax
c00207da:	83 ec 0c             	sub    $0xc,%esp
c00207dd:	50                   	push   %eax
c00207de:	68 ac e6 02 c0       	push   $0xc002e6ac
c00207e3:	68 38 e9 02 c0       	push   $0xc002e938
c00207e8:	68 4e 01 00 00       	push   $0x14e
c00207ed:	68 0c e6 02 c0       	push   $0xc002e60c
c00207f2:	e8 3a 8e 00 00       	call   c0029631 <debug_panic>
        else if (!strcmp (*argv, a->name))
c00207f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207fa:	8b 10                	mov    (%eax),%edx
c00207fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00207ff:	8b 00                	mov    (%eax),%eax
c0020801:	83 ec 08             	sub    $0x8,%esp
c0020804:	52                   	push   %edx
c0020805:	50                   	push   %eax
c0020806:	e8 1c 7e 00 00       	call   c0028627 <strcmp>
c002080b:	83 c4 10             	add    $0x10,%esp
c002080e:	85 c0                	test   %eax,%eax
c0020810:	74 06                	je     c0020818 <run_actions+0x5e>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c0020812:	83 45 f4 0c          	addl   $0xc,-0xc(%ebp)
          PANIC ("unknown action `%s' (use -h for help)", *argv);
        else if (!strcmp (*argv, a->name))
          break;

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020816:	eb b4                	jmp    c00207cc <run_actions+0x12>
      /* Find action name. */
      for (a = actions; ; a++)
        if (a->name == NULL)
          PANIC ("unknown action `%s' (use -h for help)", *argv);
        else if (!strcmp (*argv, a->name))
          break;
c0020818:	90                   	nop

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020819:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0020820:	eb 45                	jmp    c0020867 <run_actions+0xad>
        if (argv[i] == NULL)
c0020822:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020825:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002082c:	8b 45 08             	mov    0x8(%ebp),%eax
c002082f:	01 d0                	add    %edx,%eax
c0020831:	8b 00                	mov    (%eax),%eax
c0020833:	85 c0                	test   %eax,%eax
c0020835:	75 2c                	jne    c0020863 <run_actions+0xa9>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c0020837:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002083a:	8b 40 04             	mov    0x4(%eax),%eax
c002083d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0020840:	8b 45 08             	mov    0x8(%ebp),%eax
c0020843:	8b 00                	mov    (%eax),%eax
c0020845:	83 ec 08             	sub    $0x8,%esp
c0020848:	52                   	push   %edx
c0020849:	50                   	push   %eax
c002084a:	68 d4 e6 02 c0       	push   $0xc002e6d4
c002084f:	68 38 e9 02 c0       	push   $0xc002e938
c0020854:	68 55 01 00 00       	push   $0x155
c0020859:	68 0c e6 02 c0       	push   $0xc002e60c
c002085e:	e8 ce 8d 00 00       	call   c0029631 <debug_panic>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
        else if (!strcmp (*argv, a->name))
          break;

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020863:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0020867:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002086a:	8b 40 04             	mov    0x4(%eax),%eax
c002086d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0020870:	7f b0                	jg     c0020822 <run_actions+0x68>
        if (argv[i] == NULL)
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);

      /* Invoke action and advance. */
      a->function (argv);
c0020872:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020875:	8b 40 08             	mov    0x8(%eax),%eax
c0020878:	83 ec 0c             	sub    $0xc,%esp
c002087b:	ff 75 08             	pushl  0x8(%ebp)
c002087e:	ff d0                	call   *%eax
c0020880:	83 c4 10             	add    $0x10,%esp
      argv += a->argc;
c0020883:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020886:	8b 40 04             	mov    0x4(%eax),%eax
c0020889:	c1 e0 02             	shl    $0x2,%eax
c002088c:	01 45 08             	add    %eax,0x8(%ebp)
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c002088f:	8b 45 08             	mov    0x8(%ebp),%eax
c0020892:	8b 00                	mov    (%eax),%eax
c0020894:	85 c0                	test   %eax,%eax
c0020896:	0f 85 29 ff ff ff    	jne    c00207c5 <run_actions+0xb>
      /* Invoke action and advance. */
      a->function (argv);
      argv += a->argc;
    }
  
}
c002089c:	90                   	nop
c002089d:	c9                   	leave  
c002089e:	c3                   	ret    

c002089f <usage>:

/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
c002089f:	55                   	push   %ebp
c00208a0:	89 e5                	mov    %esp,%ebp
c00208a2:	83 ec 08             	sub    $0x8,%esp
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c00208a5:	83 ec 0c             	sub    $0xc,%esp
c00208a8:	68 f8 e6 02 c0       	push   $0xc002e6f8
c00208ad:	e8 32 af 00 00       	call   c002b7e4 <puts>
c00208b2:	83 c4 10             	add    $0x10,%esp
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c00208b5:	e8 35 64 00 00       	call   c0026cef <shutdown_power_off>

c00208ba <pg_round_down>:
static inline void *pg_round_up (const void *va) {
  return (void *) (((uintptr_t) va + PGSIZE - 1) & ~PGMASK);
}

/* Round down to nearest page boundary. */
static inline void *pg_round_down (const void *va) {
c00208ba:	55                   	push   %ebp
c00208bb:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c00208bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00208c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00208c5:	5d                   	pop    %ebp
c00208c6:	c3                   	ret    

c00208c7 <thread_init>:

   It is not safe to call thread_current() until this function
   finishes. */
void
thread_init (void) 
{
c00208c7:	55                   	push   %ebp
c00208c8:	89 e5                	mov    %esp,%ebp
c00208ca:	53                   	push   %ebx
c00208cb:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00208ce:	e8 66 0a 00 00       	call   c0021339 <intr_get_level>
c00208d3:	85 c0                	test   %eax,%eax
c00208d5:	74 1e                	je     c00208f5 <thread_init+0x2e>
c00208d7:	83 ec 0c             	sub    $0xc,%esp
c00208da:	68 44 e9 02 c0       	push   $0xc002e944
c00208df:	68 62 e9 02 c0       	push   $0xc002e962
c00208e4:	68 04 eb 02 c0       	push   $0xc002eb04
c00208e9:	6a 5a                	push   $0x5a
c00208eb:	68 79 e9 02 c0       	push   $0xc002e979
c00208f0:	e8 3c 8d 00 00       	call   c0029631 <debug_panic>

  lock_init (&tid_lock);
c00208f5:	83 ec 0c             	sub    $0xc,%esp
c00208f8:	68 10 82 03 c0       	push   $0xc0038210
c00208fd:	e8 73 21 00 00       	call   c0022a75 <lock_init>
c0020902:	83 c4 10             	add    $0x10,%esp
  list_init (&ready_list);
c0020905:	83 ec 0c             	sub    $0xc,%esp
c0020908:	68 e8 81 03 c0       	push   $0xc00381e8
c002090d:	e8 92 8f 00 00       	call   c00298a4 <list_init>
c0020912:	83 c4 10             	add    $0x10,%esp
  list_init (&all_list);
c0020915:	83 ec 0c             	sub    $0xc,%esp
c0020918:	68 f8 81 03 c0       	push   $0xc00381f8
c002091d:	e8 82 8f 00 00       	call   c00298a4 <list_init>
c0020922:	83 c4 10             	add    $0x10,%esp

  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread ();
c0020925:	e8 1d 06 00 00       	call   c0020f47 <running_thread>
c002092a:	a3 0c 82 03 c0       	mov    %eax,0xc003820c
  init_thread (initial_thread, "main", PRI_DEFAULT);
c002092f:	a1 0c 82 03 c0       	mov    0xc003820c,%eax
c0020934:	83 ec 04             	sub    $0x4,%esp
c0020937:	6a 1f                	push   $0x1f
c0020939:	68 90 e9 02 c0       	push   $0xc002e990
c002093e:	50                   	push   %eax
c002093f:	e8 42 06 00 00       	call   c0020f86 <init_thread>
c0020944:	83 c4 10             	add    $0x10,%esp
  initial_thread->status = THREAD_RUNNING;
c0020947:	a1 0c 82 03 c0       	mov    0xc003820c,%eax
c002094c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  initial_thread->tid = allocate_tid ();
c0020953:	8b 1d 0c 82 03 c0    	mov    0xc003820c,%ebx
c0020959:	e8 56 09 00 00       	call   c00212b4 <allocate_tid>
c002095e:	89 03                	mov    %eax,(%ebx)
}
c0020960:	90                   	nop
c0020961:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020964:	c9                   	leave  
c0020965:	c3                   	ret    

c0020966 <thread_start>:

/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void
thread_start (void) 
{
c0020966:	55                   	push   %ebp
c0020967:	89 e5                	mov    %esp,%ebp
c0020969:	83 ec 28             	sub    $0x28,%esp
  /* Create the idle thread. */
  struct semaphore idle_started;
  sema_init (&idle_started, 0);
c002096c:	83 ec 08             	sub    $0x8,%esp
c002096f:	6a 00                	push   $0x0
c0020971:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020974:	50                   	push   %eax
c0020975:	e8 40 1e 00 00       	call   c00227ba <sema_init>
c002097a:	83 c4 10             	add    $0x10,%esp
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c002097d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020980:	50                   	push   %eax
c0020981:	68 d0 0e 02 c0       	push   $0xc0020ed0
c0020986:	6a 00                	push   $0x0
c0020988:	68 95 e9 02 c0       	push   $0xc002e995
c002098d:	e8 d6 00 00 00       	call   c0020a68 <thread_create>
c0020992:	83 c4 10             	add    $0x10,%esp

  /* Start preemptive thread scheduling. */
  intr_enable ();
c0020995:	e8 d6 09 00 00       	call   c0021370 <intr_enable>

  /* Wait for the idle thread to initialize idle_thread. */
  sema_down (&idle_started);
c002099a:	83 ec 0c             	sub    $0xc,%esp
c002099d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c00209a0:	50                   	push   %eax
c00209a1:	e8 5b 1e 00 00       	call   c0022801 <sema_down>
c00209a6:	83 c4 10             	add    $0x10,%esp
}
c00209a9:	90                   	nop
c00209aa:	c9                   	leave  
c00209ab:	c3                   	ret    

c00209ac <thread_tick>:

/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void
thread_tick (void) 
{
c00209ac:	55                   	push   %ebp
c00209ad:	89 e5                	mov    %esp,%ebp
c00209af:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current ();
c00209b2:	e8 ca 02 00 00       	call   c0020c81 <thread_current>
c00209b7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Update statistics. */
  if (t == idle_thread)
c00209ba:	a1 08 82 03 c0       	mov    0xc0038208,%eax
c00209bf:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00209c2:	75 1e                	jne    c00209e2 <thread_tick+0x36>
    idle_ticks++;
c00209c4:	a1 28 82 03 c0       	mov    0xc0038228,%eax
c00209c9:	8b 15 2c 82 03 c0    	mov    0xc003822c,%edx
c00209cf:	83 c0 01             	add    $0x1,%eax
c00209d2:	83 d2 00             	adc    $0x0,%edx
c00209d5:	a3 28 82 03 c0       	mov    %eax,0xc0038228
c00209da:	89 15 2c 82 03 c0    	mov    %edx,0xc003822c
c00209e0:	eb 1c                	jmp    c00209fe <thread_tick+0x52>
#ifdef USERPROG
  else if (t->pagedir != NULL)
    user_ticks++;
#endif
  else
    kernel_ticks++;
c00209e2:	a1 30 82 03 c0       	mov    0xc0038230,%eax
c00209e7:	8b 15 34 82 03 c0    	mov    0xc0038234,%edx
c00209ed:	83 c0 01             	add    $0x1,%eax
c00209f0:	83 d2 00             	adc    $0x0,%edx
c00209f3:	a3 30 82 03 c0       	mov    %eax,0xc0038230
c00209f8:	89 15 34 82 03 c0    	mov    %edx,0xc0038234

  /* Enforce preemption. */
  if (++thread_ticks >= TIME_SLICE)
c00209fe:	a1 40 82 03 c0       	mov    0xc0038240,%eax
c0020a03:	83 c0 01             	add    $0x1,%eax
c0020a06:	a3 40 82 03 c0       	mov    %eax,0xc0038240
c0020a0b:	a1 40 82 03 c0       	mov    0xc0038240,%eax
c0020a10:	83 f8 03             	cmp    $0x3,%eax
c0020a13:	76 05                	jbe    c0020a1a <thread_tick+0x6e>
    intr_yield_on_return ();
c0020a15:	e8 6f 0c 00 00       	call   c0021689 <intr_yield_on_return>
}
c0020a1a:	90                   	nop
c0020a1b:	c9                   	leave  
c0020a1c:	c3                   	ret    

c0020a1d <thread_print_stats>:

/* Prints thread statistics. */
void
thread_print_stats (void) 
{
c0020a1d:	55                   	push   %ebp
c0020a1e:	89 e5                	mov    %esp,%ebp
c0020a20:	57                   	push   %edi
c0020a21:	56                   	push   %esi
c0020a22:	53                   	push   %ebx
c0020a23:	83 ec 0c             	sub    $0xc,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020a26:	8b 35 38 82 03 c0    	mov    0xc0038238,%esi
c0020a2c:	8b 3d 3c 82 03 c0    	mov    0xc003823c,%edi
c0020a32:	8b 0d 30 82 03 c0    	mov    0xc0038230,%ecx
c0020a38:	8b 1d 34 82 03 c0    	mov    0xc0038234,%ebx
c0020a3e:	a1 28 82 03 c0       	mov    0xc0038228,%eax
c0020a43:	8b 15 2c 82 03 c0    	mov    0xc003822c,%edx
c0020a49:	83 ec 04             	sub    $0x4,%esp
c0020a4c:	57                   	push   %edi
c0020a4d:	56                   	push   %esi
c0020a4e:	53                   	push   %ebx
c0020a4f:	51                   	push   %ecx
c0020a50:	52                   	push   %edx
c0020a51:	50                   	push   %eax
c0020a52:	68 9c e9 02 c0       	push   $0xc002e99c
c0020a57:	e8 a2 67 00 00       	call   c00271fe <printf>
c0020a5c:	83 c4 20             	add    $0x20,%esp
          idle_ticks, kernel_ticks, user_ticks);
}
c0020a5f:	90                   	nop
c0020a60:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0020a63:	5b                   	pop    %ebx
c0020a64:	5e                   	pop    %esi
c0020a65:	5f                   	pop    %edi
c0020a66:	5d                   	pop    %ebp
c0020a67:	c3                   	ret    

c0020a68 <thread_create>:
   PRIORITY, but no actual priority scheduling is implemented.
   Priority scheduling is the goal of Problem 1-3. */
tid_t
thread_create (const char *name, int priority,
               thread_func *function, void *aux) 
{
c0020a68:	55                   	push   %ebp
c0020a69:	89 e5                	mov    %esp,%ebp
c0020a6b:	83 ec 28             	sub    $0x28,%esp
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;

  ASSERT (function != NULL);
c0020a6e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020a72:	75 21                	jne    c0020a95 <thread_create+0x2d>
c0020a74:	83 ec 0c             	sub    $0xc,%esp
c0020a77:	68 d9 e9 02 c0       	push   $0xc002e9d9
c0020a7c:	68 62 e9 02 c0       	push   $0xc002e962
c0020a81:	68 10 eb 02 c0       	push   $0xc002eb10
c0020a86:	68 af 00 00 00       	push   $0xaf
c0020a8b:	68 79 e9 02 c0       	push   $0xc002e979
c0020a90:	e8 9c 8b 00 00       	call   c0029631 <debug_panic>

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
c0020a95:	83 ec 0c             	sub    $0xc,%esp
c0020a98:	6a 02                	push   $0x2
c0020a9a:	e8 aa 26 00 00       	call   c0023149 <palloc_get_page>
c0020a9f:	83 c4 10             	add    $0x10,%esp
c0020aa2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (t == NULL)
c0020aa5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020aa9:	75 0a                	jne    c0020ab5 <thread_create+0x4d>
    return TID_ERROR;
c0020aab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0020ab0:	e9 aa 00 00 00       	jmp    c0020b5f <thread_create+0xf7>

  /* Initialize thread. */
  init_thread (t, name, priority);
c0020ab5:	83 ec 04             	sub    $0x4,%esp
c0020ab8:	ff 75 0c             	pushl  0xc(%ebp)
c0020abb:	ff 75 08             	pushl  0x8(%ebp)
c0020abe:	ff 75 f4             	pushl  -0xc(%ebp)
c0020ac1:	e8 c0 04 00 00       	call   c0020f86 <init_thread>
c0020ac6:	83 c4 10             	add    $0x10,%esp
  tid = t->tid = allocate_tid ();
c0020ac9:	e8 e6 07 00 00       	call   c00212b4 <allocate_tid>
c0020ace:	89 c2                	mov    %eax,%edx
c0020ad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ad3:	89 10                	mov    %edx,(%eax)
c0020ad5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ad8:	8b 00                	mov    (%eax),%eax
c0020ada:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Stack frame for kernel_thread(). */
  kf = alloc_frame (t, sizeof *kf);
c0020add:	83 ec 08             	sub    $0x8,%esp
c0020ae0:	6a 0c                	push   $0xc
c0020ae2:	ff 75 f4             	pushl  -0xc(%ebp)
c0020ae5:	e8 a2 05 00 00       	call   c002108c <alloc_frame>
c0020aea:	83 c4 10             	add    $0x10,%esp
c0020aed:	89 45 ec             	mov    %eax,-0x14(%ebp)
  kf->eip = NULL;
c0020af0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020af3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c0020af9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020afc:	8b 55 10             	mov    0x10(%ebp),%edx
c0020aff:	89 50 04             	mov    %edx,0x4(%eax)
  kf->aux = aux;
c0020b02:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020b05:	8b 55 14             	mov    0x14(%ebp),%edx
c0020b08:	89 50 08             	mov    %edx,0x8(%eax)

  /* Stack frame for switch_entry(). */
  ef = alloc_frame (t, sizeof *ef);
c0020b0b:	83 ec 08             	sub    $0x8,%esp
c0020b0e:	6a 04                	push   $0x4
c0020b10:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b13:	e8 74 05 00 00       	call   c002108c <alloc_frame>
c0020b18:	83 c4 10             	add    $0x10,%esp
c0020b1b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  ef->eip = (void (*) (void)) kernel_thread;
c0020b1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020b21:	c7 00 02 0f 02 c0    	movl   $0xc0020f02,(%eax)

  /* Stack frame for switch_threads(). */
  sf = alloc_frame (t, sizeof *sf);
c0020b27:	83 ec 08             	sub    $0x8,%esp
c0020b2a:	6a 1c                	push   $0x1c
c0020b2c:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b2f:	e8 58 05 00 00       	call   c002108c <alloc_frame>
c0020b34:	83 c4 10             	add    $0x10,%esp
c0020b37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  sf->eip = switch_entry;
c0020b3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020b3d:	c7 40 10 0d 13 02 c0 	movl   $0xc002130d,0x10(%eax)
  sf->ebp = 0;
c0020b44:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020b47:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  /* Add to run queue. */
  thread_unblock (t);
c0020b4e:	83 ec 0c             	sub    $0xc,%esp
c0020b51:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b54:	e8 79 00 00 00       	call   c0020bd2 <thread_unblock>
c0020b59:	83 c4 10             	add    $0x10,%esp

  return tid;
c0020b5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0020b5f:	c9                   	leave  
c0020b60:	c3                   	ret    

c0020b61 <thread_block>:
   This function must be called with interrupts turned off.  It
   is usually a better idea to use one of the synchronization
   primitives in synch.h. */
void
thread_block (void) 
{
c0020b61:	55                   	push   %ebp
c0020b62:	89 e5                	mov    %esp,%ebp
c0020b64:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020b67:	e8 11 0b 00 00       	call   c002167d <intr_context>
c0020b6c:	83 f0 01             	xor    $0x1,%eax
c0020b6f:	84 c0                	test   %al,%al
c0020b71:	75 21                	jne    c0020b94 <thread_block+0x33>
c0020b73:	83 ec 0c             	sub    $0xc,%esp
c0020b76:	68 ea e9 02 c0       	push   $0xc002e9ea
c0020b7b:	68 62 e9 02 c0       	push   $0xc002e962
c0020b80:	68 20 eb 02 c0       	push   $0xc002eb20
c0020b85:	68 d8 00 00 00       	push   $0xd8
c0020b8a:	68 79 e9 02 c0       	push   $0xc002e979
c0020b8f:	e8 9d 8a 00 00       	call   c0029631 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0020b94:	e8 a0 07 00 00       	call   c0021339 <intr_get_level>
c0020b99:	85 c0                	test   %eax,%eax
c0020b9b:	74 21                	je     c0020bbe <thread_block+0x5d>
c0020b9d:	83 ec 0c             	sub    $0xc,%esp
c0020ba0:	68 44 e9 02 c0       	push   $0xc002e944
c0020ba5:	68 62 e9 02 c0       	push   $0xc002e962
c0020baa:	68 20 eb 02 c0       	push   $0xc002eb20
c0020baf:	68 d9 00 00 00       	push   $0xd9
c0020bb4:	68 79 e9 02 c0       	push   $0xc002e979
c0020bb9:	e8 73 8a 00 00       	call   c0029631 <debug_panic>

  thread_current ()->status = THREAD_BLOCKED;
c0020bbe:	e8 be 00 00 00       	call   c0020c81 <thread_current>
c0020bc3:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c0020bca:	e8 13 06 00 00       	call   c00211e2 <schedule>
}
c0020bcf:	90                   	nop
c0020bd0:	c9                   	leave  
c0020bd1:	c3                   	ret    

c0020bd2 <thread_unblock>:
   be important: if the caller had disabled interrupts itself,
   it may expect that it can atomically unblock a thread and
   update other data. */
void
thread_unblock (struct thread *t) 
{
c0020bd2:	55                   	push   %ebp
c0020bd3:	89 e5                	mov    %esp,%ebp
c0020bd5:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (is_thread (t));
c0020bd8:	83 ec 0c             	sub    $0xc,%esp
c0020bdb:	ff 75 08             	pushl  0x8(%ebp)
c0020bde:	e8 7c 03 00 00       	call   c0020f5f <is_thread>
c0020be3:	83 c4 10             	add    $0x10,%esp
c0020be6:	84 c0                	test   %al,%al
c0020be8:	75 21                	jne    c0020c0b <thread_unblock+0x39>
c0020bea:	83 ec 0c             	sub    $0xc,%esp
c0020bed:	68 fb e9 02 c0       	push   $0xc002e9fb
c0020bf2:	68 62 e9 02 c0       	push   $0xc002e962
c0020bf7:	68 30 eb 02 c0       	push   $0xc002eb30
c0020bfc:	68 ec 00 00 00       	push   $0xec
c0020c01:	68 79 e9 02 c0       	push   $0xc002e979
c0020c06:	e8 26 8a 00 00       	call   c0029631 <debug_panic>

  old_level = intr_disable ();
c0020c0b:	e8 9e 07 00 00       	call   c00213ae <intr_disable>
c0020c10:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (t->status == THREAD_BLOCKED);
c0020c13:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c16:	8b 40 04             	mov    0x4(%eax),%eax
c0020c19:	83 f8 02             	cmp    $0x2,%eax
c0020c1c:	74 21                	je     c0020c3f <thread_unblock+0x6d>
c0020c1e:	83 ec 0c             	sub    $0xc,%esp
c0020c21:	68 09 ea 02 c0       	push   $0xc002ea09
c0020c26:	68 62 e9 02 c0       	push   $0xc002e962
c0020c2b:	68 30 eb 02 c0       	push   $0xc002eb30
c0020c30:	68 ef 00 00 00       	push   $0xef
c0020c35:	68 79 e9 02 c0       	push   $0xc002e979
c0020c3a:	e8 f2 89 00 00       	call   c0029631 <debug_panic>
  list_push_back (&ready_list, &t->elem);
c0020c3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c42:	83 c0 28             	add    $0x28,%eax
c0020c45:	83 ec 08             	sub    $0x8,%esp
c0020c48:	50                   	push   %eax
c0020c49:	68 e8 81 03 c0       	push   $0xc00381e8
c0020c4e:	e8 31 90 00 00       	call   c0029c84 <list_push_back>
c0020c53:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_READY;
c0020c56:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c59:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  intr_set_level (old_level);
c0020c60:	83 ec 0c             	sub    $0xc,%esp
c0020c63:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c66:	e8 eb 06 00 00       	call   c0021356 <intr_set_level>
c0020c6b:	83 c4 10             	add    $0x10,%esp
}
c0020c6e:	90                   	nop
c0020c6f:	c9                   	leave  
c0020c70:	c3                   	ret    

c0020c71 <thread_name>:

/* Returns the name of the running thread. */
const char *
thread_name (void) 
{
c0020c71:	55                   	push   %ebp
c0020c72:	89 e5                	mov    %esp,%ebp
c0020c74:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->name;
c0020c77:	e8 05 00 00 00       	call   c0020c81 <thread_current>
c0020c7c:	83 c0 08             	add    $0x8,%eax
}
c0020c7f:	c9                   	leave  
c0020c80:	c3                   	ret    

c0020c81 <thread_current>:
/* Returns the running thread.
   This is running_thread() plus a couple of sanity checks.
   See the big comment at the top of thread.h for details. */
struct thread *
thread_current (void) 
{
c0020c81:	55                   	push   %ebp
c0020c82:	89 e5                	mov    %esp,%ebp
c0020c84:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = running_thread ();
c0020c87:	e8 bb 02 00 00       	call   c0020f47 <running_thread>
c0020c8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT (is_thread (t));
c0020c8f:	83 ec 0c             	sub    $0xc,%esp
c0020c92:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c95:	e8 c5 02 00 00       	call   c0020f5f <is_thread>
c0020c9a:	83 c4 10             	add    $0x10,%esp
c0020c9d:	84 c0                	test   %al,%al
c0020c9f:	75 21                	jne    c0020cc2 <thread_current+0x41>
c0020ca1:	83 ec 0c             	sub    $0xc,%esp
c0020ca4:	68 fb e9 02 c0       	push   $0xc002e9fb
c0020ca9:	68 62 e9 02 c0       	push   $0xc002e962
c0020cae:	68 40 eb 02 c0       	push   $0xc002eb40
c0020cb3:	68 09 01 00 00       	push   $0x109
c0020cb8:	68 79 e9 02 c0       	push   $0xc002e979
c0020cbd:	e8 6f 89 00 00       	call   c0029631 <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020cc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020cc5:	8b 40 04             	mov    0x4(%eax),%eax
c0020cc8:	85 c0                	test   %eax,%eax
c0020cca:	74 21                	je     c0020ced <thread_current+0x6c>
c0020ccc:	83 ec 0c             	sub    $0xc,%esp
c0020ccf:	68 25 ea 02 c0       	push   $0xc002ea25
c0020cd4:	68 62 e9 02 c0       	push   $0xc002e962
c0020cd9:	68 40 eb 02 c0       	push   $0xc002eb40
c0020cde:	68 0a 01 00 00       	push   $0x10a
c0020ce3:	68 79 e9 02 c0       	push   $0xc002e979
c0020ce8:	e8 44 89 00 00       	call   c0029631 <debug_panic>

  return t;
c0020ced:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0020cf0:	c9                   	leave  
c0020cf1:	c3                   	ret    

c0020cf2 <thread_tid>:

/* Returns the running thread's tid. */
tid_t
thread_tid (void) 
{
c0020cf2:	55                   	push   %ebp
c0020cf3:	89 e5                	mov    %esp,%ebp
c0020cf5:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->tid;
c0020cf8:	e8 84 ff ff ff       	call   c0020c81 <thread_current>
c0020cfd:	8b 00                	mov    (%eax),%eax
}
c0020cff:	c9                   	leave  
c0020d00:	c3                   	ret    

c0020d01 <thread_exit>:

/* Deschedules the current thread and destroys it.  Never
   returns to the caller. */
void
thread_exit (void) 
{
c0020d01:	55                   	push   %ebp
c0020d02:	89 e5                	mov    %esp,%ebp
c0020d04:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020d07:	e8 71 09 00 00       	call   c002167d <intr_context>
c0020d0c:	83 f0 01             	xor    $0x1,%eax
c0020d0f:	84 c0                	test   %al,%al
c0020d11:	75 21                	jne    c0020d34 <thread_exit+0x33>
c0020d13:	83 ec 0c             	sub    $0xc,%esp
c0020d16:	68 ea e9 02 c0       	push   $0xc002e9ea
c0020d1b:	68 62 e9 02 c0       	push   $0xc002e962
c0020d20:	68 50 eb 02 c0       	push   $0xc002eb50
c0020d25:	68 1b 01 00 00       	push   $0x11b
c0020d2a:	68 79 e9 02 c0       	push   $0xc002e979
c0020d2f:	e8 fd 88 00 00       	call   c0029631 <debug_panic>
#endif

  /* Remove thread from all threads list, set our status to dying,
     and schedule another process.  That process will destroy us
     when it calls thread_schedule_tail(). */
  intr_disable ();
c0020d34:	e8 75 06 00 00       	call   c00213ae <intr_disable>
  list_remove (&thread_current()->allelem);
c0020d39:	e8 43 ff ff ff       	call   c0020c81 <thread_current>
c0020d3e:	83 c0 20             	add    $0x20,%eax
c0020d41:	83 ec 0c             	sub    $0xc,%esp
c0020d44:	50                   	push   %eax
c0020d45:	e8 60 8f 00 00       	call   c0029caa <list_remove>
c0020d4a:	83 c4 10             	add    $0x10,%esp
  thread_current ()->status = THREAD_DYING;
c0020d4d:	e8 2f ff ff ff       	call   c0020c81 <thread_current>
c0020d52:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c0020d59:	e8 84 04 00 00       	call   c00211e2 <schedule>
  NOT_REACHED ();
c0020d5e:	68 44 ea 02 c0       	push   $0xc002ea44
c0020d63:	68 50 eb 02 c0       	push   $0xc002eb50
c0020d68:	68 28 01 00 00       	push   $0x128
c0020d6d:	68 79 e9 02 c0       	push   $0xc002e979
c0020d72:	e8 ba 88 00 00       	call   c0029631 <debug_panic>

c0020d77 <thread_yield>:

/* Yields the CPU.  The current thread is not put to sleep and
   may be scheduled again immediately at the scheduler's whim. */
void
thread_yield (void) 
{
c0020d77:	55                   	push   %ebp
c0020d78:	89 e5                	mov    %esp,%ebp
c0020d7a:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = thread_current ();
c0020d7d:	e8 ff fe ff ff       	call   c0020c81 <thread_current>
c0020d82:	89 45 f4             	mov    %eax,-0xc(%ebp)
  enum intr_level old_level;
  
  ASSERT (!intr_context ());
c0020d85:	e8 f3 08 00 00       	call   c002167d <intr_context>
c0020d8a:	83 f0 01             	xor    $0x1,%eax
c0020d8d:	84 c0                	test   %al,%al
c0020d8f:	75 21                	jne    c0020db2 <thread_yield+0x3b>
c0020d91:	83 ec 0c             	sub    $0xc,%esp
c0020d94:	68 ea e9 02 c0       	push   $0xc002e9ea
c0020d99:	68 62 e9 02 c0       	push   $0xc002e962
c0020d9e:	68 5c eb 02 c0       	push   $0xc002eb5c
c0020da3:	68 33 01 00 00       	push   $0x133
c0020da8:	68 79 e9 02 c0       	push   $0xc002e979
c0020dad:	e8 7f 88 00 00       	call   c0029631 <debug_panic>

  old_level = intr_disable ();
c0020db2:	e8 f7 05 00 00       	call   c00213ae <intr_disable>
c0020db7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (cur != idle_thread) 
c0020dba:	a1 08 82 03 c0       	mov    0xc0038208,%eax
c0020dbf:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020dc2:	74 17                	je     c0020ddb <thread_yield+0x64>
    list_push_back (&ready_list, &cur->elem);
c0020dc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020dc7:	83 c0 28             	add    $0x28,%eax
c0020dca:	83 ec 08             	sub    $0x8,%esp
c0020dcd:	50                   	push   %eax
c0020dce:	68 e8 81 03 c0       	push   $0xc00381e8
c0020dd3:	e8 ac 8e 00 00       	call   c0029c84 <list_push_back>
c0020dd8:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c0020ddb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020dde:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  schedule ();
c0020de5:	e8 f8 03 00 00       	call   c00211e2 <schedule>
  intr_set_level (old_level);
c0020dea:	83 ec 0c             	sub    $0xc,%esp
c0020ded:	ff 75 f0             	pushl  -0x10(%ebp)
c0020df0:	e8 61 05 00 00       	call   c0021356 <intr_set_level>
c0020df5:	83 c4 10             	add    $0x10,%esp
}
c0020df8:	90                   	nop
c0020df9:	c9                   	leave  
c0020dfa:	c3                   	ret    

c0020dfb <thread_foreach>:

/* Invoke function 'func' on all threads, passing along 'aux'.
   This function must be called with interrupts off. */
void
thread_foreach (thread_action_func *func, void *aux)
{
c0020dfb:	55                   	push   %ebp
c0020dfc:	89 e5                	mov    %esp,%ebp
c0020dfe:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);
c0020e01:	e8 33 05 00 00       	call   c0021339 <intr_get_level>
c0020e06:	85 c0                	test   %eax,%eax
c0020e08:	74 21                	je     c0020e2b <thread_foreach+0x30>
c0020e0a:	83 ec 0c             	sub    $0xc,%esp
c0020e0d:	68 44 e9 02 c0       	push   $0xc002e944
c0020e12:	68 62 e9 02 c0       	push   $0xc002e962
c0020e17:	68 6c eb 02 c0       	push   $0xc002eb6c
c0020e1c:	68 44 01 00 00       	push   $0x144
c0020e21:	68 79 e9 02 c0       	push   $0xc002e979
c0020e26:	e8 06 88 00 00       	call   c0029631 <debug_panic>

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e2b:	83 ec 0c             	sub    $0xc,%esp
c0020e2e:	68 f8 81 03 c0       	push   $0xc00381f8
c0020e33:	e8 c1 8a 00 00       	call   c00298f9 <list_begin>
c0020e38:	83 c4 10             	add    $0x10,%esp
c0020e3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0020e3e:	eb 2e                	jmp    c0020e6e <thread_foreach+0x73>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
c0020e40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020e43:	83 c0 04             	add    $0x4,%eax
c0020e46:	83 e8 24             	sub    $0x24,%eax
c0020e49:	89 45 f0             	mov    %eax,-0x10(%ebp)
      func (t, aux);
c0020e4c:	83 ec 08             	sub    $0x8,%esp
c0020e4f:	ff 75 0c             	pushl  0xc(%ebp)
c0020e52:	ff 75 f0             	pushl  -0x10(%ebp)
c0020e55:	8b 45 08             	mov    0x8(%ebp),%eax
c0020e58:	ff d0                	call   *%eax
c0020e5a:	83 c4 10             	add    $0x10,%esp
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);

  for (e = list_begin (&all_list); e != list_end (&all_list);
       e = list_next (e))
c0020e5d:	83 ec 0c             	sub    $0xc,%esp
c0020e60:	ff 75 f4             	pushl  -0xc(%ebp)
c0020e63:	e8 c3 8a 00 00       	call   c002992b <list_next>
c0020e68:	83 c4 10             	add    $0x10,%esp
c0020e6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e6e:	83 ec 0c             	sub    $0xc,%esp
c0020e71:	68 f8 81 03 c0       	push   $0xc00381f8
c0020e76:	e8 fa 8a 00 00       	call   c0029975 <list_end>
c0020e7b:	83 c4 10             	add    $0x10,%esp
c0020e7e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0020e81:	75 bd                	jne    c0020e40 <thread_foreach+0x45>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
      func (t, aux);
    }
}
c0020e83:	90                   	nop
c0020e84:	c9                   	leave  
c0020e85:	c3                   	ret    

c0020e86 <thread_set_priority>:

/* Sets the current thread's priority to NEW_PRIORITY. */
void
thread_set_priority (int new_priority) 
{
c0020e86:	55                   	push   %ebp
c0020e87:	89 e5                	mov    %esp,%ebp
c0020e89:	83 ec 08             	sub    $0x8,%esp
  thread_current ()->priority = new_priority;
c0020e8c:	e8 f0 fd ff ff       	call   c0020c81 <thread_current>
c0020e91:	89 c2                	mov    %eax,%edx
c0020e93:	8b 45 08             	mov    0x8(%ebp),%eax
c0020e96:	89 42 1c             	mov    %eax,0x1c(%edx)
}
c0020e99:	90                   	nop
c0020e9a:	c9                   	leave  
c0020e9b:	c3                   	ret    

c0020e9c <thread_get_priority>:

/* Returns the current thread's priority. */
int
thread_get_priority (void) 
{
c0020e9c:	55                   	push   %ebp
c0020e9d:	89 e5                	mov    %esp,%ebp
c0020e9f:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->priority;
c0020ea2:	e8 da fd ff ff       	call   c0020c81 <thread_current>
c0020ea7:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0020eaa:	c9                   	leave  
c0020eab:	c3                   	ret    

c0020eac <thread_set_nice>:

/* Sets the current thread's nice value to NICE. */
void
thread_set_nice (int nice UNUSED) 
{
c0020eac:	55                   	push   %ebp
c0020ead:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
}
c0020eaf:	90                   	nop
c0020eb0:	5d                   	pop    %ebp
c0020eb1:	c3                   	ret    

c0020eb2 <thread_get_nice>:

/* Returns the current thread's nice value. */
int
thread_get_nice (void) 
{
c0020eb2:	55                   	push   %ebp
c0020eb3:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020eb5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020eba:	5d                   	pop    %ebp
c0020ebb:	c3                   	ret    

c0020ebc <thread_get_load_avg>:

/* Returns 100 times the system load average. */
int
thread_get_load_avg (void) 
{
c0020ebc:	55                   	push   %ebp
c0020ebd:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020ebf:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020ec4:	5d                   	pop    %ebp
c0020ec5:	c3                   	ret    

c0020ec6 <thread_get_recent_cpu>:

/* Returns 100 times the current thread's recent_cpu value. */
int
thread_get_recent_cpu (void) 
{
c0020ec6:	55                   	push   %ebp
c0020ec7:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020ec9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020ece:	5d                   	pop    %ebp
c0020ecf:	c3                   	ret    

c0020ed0 <idle>:
   blocks.  After that, the idle thread never appears in the
   ready list.  It is returned by next_thread_to_run() as a
   special case when the ready list is empty. */
static void
idle (void *idle_started_ UNUSED) 
{
c0020ed0:	55                   	push   %ebp
c0020ed1:	89 e5                	mov    %esp,%ebp
c0020ed3:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *idle_started = idle_started_;
c0020ed6:	8b 45 08             	mov    0x8(%ebp),%eax
c0020ed9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  idle_thread = thread_current ();
c0020edc:	e8 a0 fd ff ff       	call   c0020c81 <thread_current>
c0020ee1:	a3 08 82 03 c0       	mov    %eax,0xc0038208
  sema_up (idle_started);
c0020ee6:	83 ec 0c             	sub    $0xc,%esp
c0020ee9:	ff 75 f4             	pushl  -0xc(%ebp)
c0020eec:	e8 1b 1a 00 00       	call   c002290c <sema_up>
c0020ef1:	83 c4 10             	add    $0x10,%esp

  for (;;) 
    {
      /* Let someone else run. */
      intr_disable ();
c0020ef4:	e8 b5 04 00 00       	call   c00213ae <intr_disable>
      thread_block ();
c0020ef9:	e8 63 fc ff ff       	call   c0020b61 <thread_block>
         one to occur, wasting as much as one clock tick worth of
         time.

         See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
         7.11.1 "HLT Instruction". */
      asm volatile ("sti; hlt" : : : "memory");
c0020efe:	fb                   	sti    
c0020eff:	f4                   	hlt    
    }
c0020f00:	eb f2                	jmp    c0020ef4 <idle+0x24>

c0020f02 <kernel_thread>:
}

/* Function used as the basis for a kernel thread. */
static void
kernel_thread (thread_func *function, void *aux) 
{
c0020f02:	55                   	push   %ebp
c0020f03:	89 e5                	mov    %esp,%ebp
c0020f05:	83 ec 08             	sub    $0x8,%esp
  ASSERT (function != NULL);
c0020f08:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020f0c:	75 21                	jne    c0020f2f <kernel_thread+0x2d>
c0020f0e:	83 ec 0c             	sub    $0xc,%esp
c0020f11:	68 d9 e9 02 c0       	push   $0xc002e9d9
c0020f16:	68 62 e9 02 c0       	push   $0xc002e962
c0020f1b:	68 7c eb 02 c0       	push   $0xc002eb7c
c0020f20:	68 a5 01 00 00       	push   $0x1a5
c0020f25:	68 79 e9 02 c0       	push   $0xc002e979
c0020f2a:	e8 02 87 00 00       	call   c0029631 <debug_panic>

  intr_enable ();       /* The scheduler runs with interrupts off. */
c0020f2f:	e8 3c 04 00 00       	call   c0021370 <intr_enable>
  function (aux);       /* Execute the thread function. */
c0020f34:	83 ec 0c             	sub    $0xc,%esp
c0020f37:	ff 75 0c             	pushl  0xc(%ebp)
c0020f3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0020f3d:	ff d0                	call   *%eax
c0020f3f:	83 c4 10             	add    $0x10,%esp
  thread_exit ();       /* If function() returns, kill the thread. */
c0020f42:	e8 ba fd ff ff       	call   c0020d01 <thread_exit>

c0020f47 <running_thread>:
}

/* Returns the running thread. */
struct thread *
running_thread (void) 
{
c0020f47:	55                   	push   %ebp
c0020f48:	89 e5                	mov    %esp,%ebp
c0020f4a:	83 ec 10             	sub    $0x10,%esp

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c0020f4d:	89 e0                	mov    %esp,%eax
c0020f4f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return pg_round_down (esp);
c0020f52:	ff 75 fc             	pushl  -0x4(%ebp)
c0020f55:	e8 60 f9 ff ff       	call   c00208ba <pg_round_down>
c0020f5a:	83 c4 04             	add    $0x4,%esp
}
c0020f5d:	c9                   	leave  
c0020f5e:	c3                   	ret    

c0020f5f <is_thread>:

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
c0020f5f:	55                   	push   %ebp
c0020f60:	89 e5                	mov    %esp,%ebp
  return t != NULL && t->magic == THREAD_MAGIC;
c0020f62:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020f66:	74 14                	je     c0020f7c <is_thread+0x1d>
c0020f68:	8b 45 08             	mov    0x8(%ebp),%eax
c0020f6b:	8b 40 30             	mov    0x30(%eax),%eax
c0020f6e:	3d 4b bf 6a cd       	cmp    $0xcd6abf4b,%eax
c0020f73:	75 07                	jne    c0020f7c <is_thread+0x1d>
c0020f75:	b8 01 00 00 00       	mov    $0x1,%eax
c0020f7a:	eb 05                	jmp    c0020f81 <is_thread+0x22>
c0020f7c:	b8 00 00 00 00       	mov    $0x0,%eax
c0020f81:	83 e0 01             	and    $0x1,%eax
}
c0020f84:	5d                   	pop    %ebp
c0020f85:	c3                   	ret    

c0020f86 <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c0020f86:	55                   	push   %ebp
c0020f87:	89 e5                	mov    %esp,%ebp
c0020f89:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (t != NULL);
c0020f8c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020f90:	75 21                	jne    c0020fb3 <init_thread+0x2d>
c0020f92:	83 ec 0c             	sub    $0xc,%esp
c0020f95:	68 66 ea 02 c0       	push   $0xc002ea66
c0020f9a:	68 62 e9 02 c0       	push   $0xc002e962
c0020f9f:	68 8c eb 02 c0       	push   $0xc002eb8c
c0020fa4:	68 c8 01 00 00       	push   $0x1c8
c0020fa9:	68 79 e9 02 c0       	push   $0xc002e979
c0020fae:	e8 7e 86 00 00       	call   c0029631 <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020fb3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020fb7:	78 06                	js     c0020fbf <init_thread+0x39>
c0020fb9:	83 7d 10 3f          	cmpl   $0x3f,0x10(%ebp)
c0020fbd:	7e 21                	jle    c0020fe0 <init_thread+0x5a>
c0020fbf:	83 ec 0c             	sub    $0xc,%esp
c0020fc2:	68 70 ea 02 c0       	push   $0xc002ea70
c0020fc7:	68 62 e9 02 c0       	push   $0xc002e962
c0020fcc:	68 8c eb 02 c0       	push   $0xc002eb8c
c0020fd1:	68 c9 01 00 00       	push   $0x1c9
c0020fd6:	68 79 e9 02 c0       	push   $0xc002e979
c0020fdb:	e8 51 86 00 00       	call   c0029631 <debug_panic>
  ASSERT (name != NULL);
c0020fe0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0020fe4:	75 21                	jne    c0021007 <init_thread+0x81>
c0020fe6:	83 ec 0c             	sub    $0xc,%esp
c0020fe9:	68 9b ea 02 c0       	push   $0xc002ea9b
c0020fee:	68 62 e9 02 c0       	push   $0xc002e962
c0020ff3:	68 8c eb 02 c0       	push   $0xc002eb8c
c0020ff8:	68 ca 01 00 00       	push   $0x1ca
c0020ffd:	68 79 e9 02 c0       	push   $0xc002e979
c0021002:	e8 2a 86 00 00       	call   c0029631 <debug_panic>

  memset (t, 0, sizeof *t);
c0021007:	83 ec 04             	sub    $0x4,%esp
c002100a:	6a 34                	push   $0x34
c002100c:	6a 00                	push   $0x0
c002100e:	ff 75 08             	pushl  0x8(%ebp)
c0021011:	e8 0f 7a 00 00       	call   c0028a25 <memset>
c0021016:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_BLOCKED;
c0021019:	8b 45 08             	mov    0x8(%ebp),%eax
c002101c:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  strlcpy (t->name, name, sizeof t->name);
c0021023:	8b 45 08             	mov    0x8(%ebp),%eax
c0021026:	83 c0 08             	add    $0x8,%eax
c0021029:	83 ec 04             	sub    $0x4,%esp
c002102c:	6a 10                	push   $0x10
c002102e:	ff 75 0c             	pushl  0xc(%ebp)
c0021031:	50                   	push   %eax
c0021032:	e8 c5 7a 00 00       	call   c0028afc <strlcpy>
c0021037:	83 c4 10             	add    $0x10,%esp
  t->stack = (uint8_t *) t + PGSIZE;
c002103a:	8b 45 08             	mov    0x8(%ebp),%eax
c002103d:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0021043:	8b 45 08             	mov    0x8(%ebp),%eax
c0021046:	89 50 18             	mov    %edx,0x18(%eax)
  t->priority = priority;
c0021049:	8b 45 08             	mov    0x8(%ebp),%eax
c002104c:	8b 55 10             	mov    0x10(%ebp),%edx
c002104f:	89 50 1c             	mov    %edx,0x1c(%eax)
  t->magic = THREAD_MAGIC;
c0021052:	8b 45 08             	mov    0x8(%ebp),%eax
c0021055:	c7 40 30 4b bf 6a cd 	movl   $0xcd6abf4b,0x30(%eax)

  old_level = intr_disable ();
c002105c:	e8 4d 03 00 00       	call   c00213ae <intr_disable>
c0021061:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_push_back (&all_list, &t->allelem);
c0021064:	8b 45 08             	mov    0x8(%ebp),%eax
c0021067:	83 c0 20             	add    $0x20,%eax
c002106a:	83 ec 08             	sub    $0x8,%esp
c002106d:	50                   	push   %eax
c002106e:	68 f8 81 03 c0       	push   $0xc00381f8
c0021073:	e8 0c 8c 00 00       	call   c0029c84 <list_push_back>
c0021078:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c002107b:	83 ec 0c             	sub    $0xc,%esp
c002107e:	ff 75 f4             	pushl  -0xc(%ebp)
c0021081:	e8 d0 02 00 00       	call   c0021356 <intr_set_level>
c0021086:	83 c4 10             	add    $0x10,%esp
}
c0021089:	90                   	nop
c002108a:	c9                   	leave  
c002108b:	c3                   	ret    

c002108c <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c002108c:	55                   	push   %ebp
c002108d:	89 e5                	mov    %esp,%ebp
c002108f:	83 ec 08             	sub    $0x8,%esp
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c0021092:	ff 75 08             	pushl  0x8(%ebp)
c0021095:	e8 c5 fe ff ff       	call   c0020f5f <is_thread>
c002109a:	83 c4 04             	add    $0x4,%esp
c002109d:	84 c0                	test   %al,%al
c002109f:	75 21                	jne    c00210c2 <alloc_frame+0x36>
c00210a1:	83 ec 0c             	sub    $0xc,%esp
c00210a4:	68 fb e9 02 c0       	push   $0xc002e9fb
c00210a9:	68 62 e9 02 c0       	push   $0xc002e962
c00210ae:	68 98 eb 02 c0       	push   $0xc002eb98
c00210b3:	68 de 01 00 00       	push   $0x1de
c00210b8:	68 79 e9 02 c0       	push   $0xc002e979
c00210bd:	e8 6f 85 00 00       	call   c0029631 <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c00210c2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00210c5:	83 e0 03             	and    $0x3,%eax
c00210c8:	85 c0                	test   %eax,%eax
c00210ca:	74 21                	je     c00210ed <alloc_frame+0x61>
c00210cc:	83 ec 0c             	sub    $0xc,%esp
c00210cf:	68 a8 ea 02 c0       	push   $0xc002eaa8
c00210d4:	68 62 e9 02 c0       	push   $0xc002e962
c00210d9:	68 98 eb 02 c0       	push   $0xc002eb98
c00210de:	68 df 01 00 00       	push   $0x1df
c00210e3:	68 79 e9 02 c0       	push   $0xc002e979
c00210e8:	e8 44 85 00 00       	call   c0029631 <debug_panic>

  t->stack -= size;
c00210ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00210f0:	8b 40 18             	mov    0x18(%eax),%eax
c00210f3:	8b 55 0c             	mov    0xc(%ebp),%edx
c00210f6:	f7 da                	neg    %edx
c00210f8:	01 c2                	add    %eax,%edx
c00210fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00210fd:	89 50 18             	mov    %edx,0x18(%eax)
  return t->stack;
c0021100:	8b 45 08             	mov    0x8(%ebp),%eax
c0021103:	8b 40 18             	mov    0x18(%eax),%eax
}
c0021106:	c9                   	leave  
c0021107:	c3                   	ret    

c0021108 <next_thread_to_run>:
   empty.  (If the running thread can continue running, then it
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run (void) 
{
c0021108:	55                   	push   %ebp
c0021109:	89 e5                	mov    %esp,%ebp
c002110b:	83 ec 08             	sub    $0x8,%esp
  if (list_empty (&ready_list))
c002110e:	83 ec 0c             	sub    $0xc,%esp
c0021111:	68 e8 81 03 c0       	push   $0xc00381e8
c0021116:	e8 11 8d 00 00       	call   c0029e2c <list_empty>
c002111b:	83 c4 10             	add    $0x10,%esp
c002111e:	84 c0                	test   %al,%al
c0021120:	74 07                	je     c0021129 <next_thread_to_run+0x21>
    return idle_thread;
c0021122:	a1 08 82 03 c0       	mov    0xc0038208,%eax
c0021127:	eb 16                	jmp    c002113f <next_thread_to_run+0x37>
  else
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c0021129:	83 ec 0c             	sub    $0xc,%esp
c002112c:	68 e8 81 03 c0       	push   $0xc00381e8
c0021131:	e8 cd 8b 00 00       	call   c0029d03 <list_pop_front>
c0021136:	83 c4 10             	add    $0x10,%esp
c0021139:	83 c0 04             	add    $0x4,%eax
c002113c:	83 e8 2c             	sub    $0x2c,%eax
}
c002113f:	c9                   	leave  
c0021140:	c3                   	ret    

c0021141 <thread_schedule_tail>:

   After this function and its caller returns, the thread switch
   is complete. */
void
thread_schedule_tail (struct thread *prev)
{
c0021141:	55                   	push   %ebp
c0021142:	89 e5                	mov    %esp,%ebp
c0021144:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c0021147:	e8 fb fd ff ff       	call   c0020f47 <running_thread>
c002114c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (intr_get_level () == INTR_OFF);
c002114f:	e8 e5 01 00 00       	call   c0021339 <intr_get_level>
c0021154:	85 c0                	test   %eax,%eax
c0021156:	74 21                	je     c0021179 <thread_schedule_tail+0x38>
c0021158:	83 ec 0c             	sub    $0xc,%esp
c002115b:	68 44 e9 02 c0       	push   $0xc002e944
c0021160:	68 62 e9 02 c0       	push   $0xc002e962
c0021165:	68 a4 eb 02 c0       	push   $0xc002eba4
c002116a:	68 08 02 00 00       	push   $0x208
c002116f:	68 79 e9 02 c0       	push   $0xc002e979
c0021174:	e8 b8 84 00 00       	call   c0029631 <debug_panic>

  /* Mark us as running. */
  cur->status = THREAD_RUNNING;
c0021179:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002117c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

  /* Start new time slice. */
  thread_ticks = 0;
c0021183:	c7 05 40 82 03 c0 00 	movl   $0x0,0xc0038240
c002118a:	00 00 00 
  /* If the thread we switched from is dying, destroy its struct
     thread.  This must happen late so that thread_exit() doesn't
     pull out the rug under itself.  (We don't free
     initial_thread because its memory was not obtained via
     palloc().) */
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c002118d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021191:	74 4c                	je     c00211df <thread_schedule_tail+0x9e>
c0021193:	8b 45 08             	mov    0x8(%ebp),%eax
c0021196:	8b 40 04             	mov    0x4(%eax),%eax
c0021199:	83 f8 03             	cmp    $0x3,%eax
c002119c:	75 41                	jne    c00211df <thread_schedule_tail+0x9e>
c002119e:	a1 0c 82 03 c0       	mov    0xc003820c,%eax
c00211a3:	39 45 08             	cmp    %eax,0x8(%ebp)
c00211a6:	74 37                	je     c00211df <thread_schedule_tail+0x9e>
    {
      ASSERT (prev != cur);
c00211a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00211ab:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00211ae:	75 21                	jne    c00211d1 <thread_schedule_tail+0x90>
c00211b0:	83 ec 0c             	sub    $0xc,%esp
c00211b3:	68 c6 ea 02 c0       	push   $0xc002eac6
c00211b8:	68 62 e9 02 c0       	push   $0xc002e962
c00211bd:	68 a4 eb 02 c0       	push   $0xc002eba4
c00211c2:	68 1c 02 00 00       	push   $0x21c
c00211c7:	68 79 e9 02 c0       	push   $0xc002e979
c00211cc:	e8 60 84 00 00       	call   c0029631 <debug_panic>
      palloc_free_page (prev);
c00211d1:	83 ec 0c             	sub    $0xc,%esp
c00211d4:	ff 75 08             	pushl  0x8(%ebp)
c00211d7:	e8 c5 20 00 00       	call   c00232a1 <palloc_free_page>
c00211dc:	83 c4 10             	add    $0x10,%esp
    }
}
c00211df:	90                   	nop
c00211e0:	c9                   	leave  
c00211e1:	c3                   	ret    

c00211e2 <schedule>:

   It's not safe to call printf() until thread_schedule_tail()
   has completed. */
static void
schedule (void) 
{
c00211e2:	55                   	push   %ebp
c00211e3:	89 e5                	mov    %esp,%ebp
c00211e5:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c00211e8:	e8 5a fd ff ff       	call   c0020f47 <running_thread>
c00211ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct thread *next = next_thread_to_run ();
c00211f0:	e8 13 ff ff ff       	call   c0021108 <next_thread_to_run>
c00211f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread *prev = NULL;
c00211f8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c00211ff:	e8 35 01 00 00       	call   c0021339 <intr_get_level>
c0021204:	85 c0                	test   %eax,%eax
c0021206:	74 21                	je     c0021229 <schedule+0x47>
c0021208:	83 ec 0c             	sub    $0xc,%esp
c002120b:	68 44 e9 02 c0       	push   $0xc002e944
c0021210:	68 62 e9 02 c0       	push   $0xc002e962
c0021215:	68 bc eb 02 c0       	push   $0xc002ebbc
c002121a:	68 2f 02 00 00       	push   $0x22f
c002121f:	68 79 e9 02 c0       	push   $0xc002e979
c0021224:	e8 08 84 00 00       	call   c0029631 <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c0021229:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002122c:	8b 40 04             	mov    0x4(%eax),%eax
c002122f:	85 c0                	test   %eax,%eax
c0021231:	75 21                	jne    c0021254 <schedule+0x72>
c0021233:	83 ec 0c             	sub    $0xc,%esp
c0021236:	68 d2 ea 02 c0       	push   $0xc002ead2
c002123b:	68 62 e9 02 c0       	push   $0xc002e962
c0021240:	68 bc eb 02 c0       	push   $0xc002ebbc
c0021245:	68 30 02 00 00       	push   $0x230
c002124a:	68 79 e9 02 c0       	push   $0xc002e979
c002124f:	e8 dd 83 00 00       	call   c0029631 <debug_panic>
  ASSERT (is_thread (next));
c0021254:	83 ec 0c             	sub    $0xc,%esp
c0021257:	ff 75 ec             	pushl  -0x14(%ebp)
c002125a:	e8 00 fd ff ff       	call   c0020f5f <is_thread>
c002125f:	83 c4 10             	add    $0x10,%esp
c0021262:	84 c0                	test   %al,%al
c0021264:	75 21                	jne    c0021287 <schedule+0xa5>
c0021266:	83 ec 0c             	sub    $0xc,%esp
c0021269:	68 f0 ea 02 c0       	push   $0xc002eaf0
c002126e:	68 62 e9 02 c0       	push   $0xc002e962
c0021273:	68 bc eb 02 c0       	push   $0xc002ebbc
c0021278:	68 31 02 00 00       	push   $0x231
c002127d:	68 79 e9 02 c0       	push   $0xc002e979
c0021282:	e8 aa 83 00 00       	call   c0029631 <debug_panic>

  if (cur != next)
c0021287:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002128a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002128d:	74 14                	je     c00212a3 <schedule+0xc1>
    prev = switch_threads (cur, next);
c002128f:	83 ec 08             	sub    $0x8,%esp
c0021292:	ff 75 ec             	pushl  -0x14(%ebp)
c0021295:	ff 75 f0             	pushl  -0x10(%ebp)
c0021298:	e8 53 00 00 00       	call   c00212f0 <switch_threads>
c002129d:	83 c4 10             	add    $0x10,%esp
c00212a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  thread_schedule_tail (prev);
c00212a3:	83 ec 0c             	sub    $0xc,%esp
c00212a6:	ff 75 f4             	pushl  -0xc(%ebp)
c00212a9:	e8 93 fe ff ff       	call   c0021141 <thread_schedule_tail>
c00212ae:	83 c4 10             	add    $0x10,%esp
}
c00212b1:	90                   	nop
c00212b2:	c9                   	leave  
c00212b3:	c3                   	ret    

c00212b4 <allocate_tid>:

/* Returns a tid to use for a new thread. */
static tid_t
allocate_tid (void) 
{
c00212b4:	55                   	push   %ebp
c00212b5:	89 e5                	mov    %esp,%ebp
c00212b7:	83 ec 18             	sub    $0x18,%esp
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c00212ba:	83 ec 0c             	sub    $0xc,%esp
c00212bd:	68 10 82 03 c0       	push   $0xc0038210
c00212c2:	e8 fb 17 00 00       	call   c0022ac2 <lock_acquire>
c00212c7:	83 c4 10             	add    $0x10,%esp
  tid = next_tid++;
c00212ca:	a1 48 78 03 c0       	mov    0xc0037848,%eax
c00212cf:	8d 50 01             	lea    0x1(%eax),%edx
c00212d2:	89 15 48 78 03 c0    	mov    %edx,0xc0037848
c00212d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lock_release (&tid_lock);
c00212db:	83 ec 0c             	sub    $0xc,%esp
c00212de:	68 10 82 03 c0       	push   $0xc0038210
c00212e3:	e8 1b 19 00 00       	call   c0022c03 <lock_release>
c00212e8:	83 c4 10             	add    $0x10,%esp

  return tid;
c00212eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00212ee:	c9                   	leave  
c00212ef:	c3                   	ret    

c00212f0 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c00212f0:	53                   	push   %ebx
	pushl %ebp
c00212f1:	55                   	push   %ebp
	pushl %esi
c00212f2:	56                   	push   %esi
	pushl %edi
c00212f3:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c00212f4:	8b 15 44 78 03 c0    	mov    0xc0037844,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c00212fa:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c00212fe:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021301:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c0021305:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c0021308:	5f                   	pop    %edi
	popl %esi
c0021309:	5e                   	pop    %esi
	popl %ebp
c002130a:	5d                   	pop    %ebp
	popl %ebx
c002130b:	5b                   	pop    %ebx
        ret
c002130c:	c3                   	ret    

c002130d <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c002130d:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021310:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021311:	e8 2b fe ff ff       	call   c0021141 <thread_schedule_tail>
	addl $4, %esp
c0021316:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021319:	c3                   	ret    

c002131a <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c002131a:	55                   	push   %ebp
c002131b:	89 e5                	mov    %esp,%ebp
c002131d:	83 ec 08             	sub    $0x8,%esp
c0021320:	8b 55 08             	mov    0x8(%ebp),%edx
c0021323:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021326:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c002132a:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002132d:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0021331:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0021335:	ee                   	out    %al,(%dx)
}
c0021336:	90                   	nop
c0021337:	c9                   	leave  
c0021338:	c3                   	ret    

c0021339 <intr_get_level>:
static void unexpected_interrupt (const struct intr_frame *);

/* Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
c0021339:	55                   	push   %ebp
c002133a:	89 e5                	mov    %esp,%ebp
c002133c:	83 ec 10             	sub    $0x10,%esp

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c002133f:	9c                   	pushf  
c0021340:	58                   	pop    %eax
c0021341:	89 45 fc             	mov    %eax,-0x4(%ebp)

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021344:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0021347:	25 00 02 00 00       	and    $0x200,%eax
c002134c:	85 c0                	test   %eax,%eax
c002134e:	0f 95 c0             	setne  %al
c0021351:	0f b6 c0             	movzbl %al,%eax
}
c0021354:	c9                   	leave  
c0021355:	c3                   	ret    

c0021356 <intr_set_level>:

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
c0021356:	55                   	push   %ebp
c0021357:	89 e5                	mov    %esp,%ebp
c0021359:	83 ec 08             	sub    $0x8,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c002135c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0021360:	75 07                	jne    c0021369 <intr_set_level+0x13>
c0021362:	e8 09 00 00 00       	call   c0021370 <intr_enable>
c0021367:	eb 05                	jmp    c002136e <intr_set_level+0x18>
c0021369:	e8 40 00 00 00       	call   c00213ae <intr_disable>
}
c002136e:	c9                   	leave  
c002136f:	c3                   	ret    

c0021370 <intr_enable>:

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
c0021370:	55                   	push   %ebp
c0021371:	89 e5                	mov    %esp,%ebp
c0021373:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_get_level ();
c0021376:	e8 be ff ff ff       	call   c0021339 <intr_get_level>
c002137b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (!intr_context ());
c002137e:	e8 fa 02 00 00       	call   c002167d <intr_context>
c0021383:	83 f0 01             	xor    $0x1,%eax
c0021386:	84 c0                	test   %al,%al
c0021388:	75 1e                	jne    c00213a8 <intr_enable+0x38>
c002138a:	83 ec 0c             	sub    $0xc,%esp
c002138d:	68 c8 eb 02 c0       	push   $0xc002ebc8
c0021392:	68 d9 eb 02 c0       	push   $0xc002ebd9
c0021397:	68 d8 ef 02 c0       	push   $0xc002efd8
c002139c:	6a 5b                	push   $0x5b
c002139e:	68 f0 eb 02 c0       	push   $0xc002ebf0
c00213a3:	e8 89 82 00 00       	call   c0029631 <debug_panic>

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti");
c00213a8:	fb                   	sti    

  return old_level;
c00213a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00213ac:	c9                   	leave  
c00213ad:	c3                   	ret    

c00213ae <intr_disable>:

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
c00213ae:	55                   	push   %ebp
c00213af:	89 e5                	mov    %esp,%ebp
c00213b1:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level = intr_get_level ();
c00213b4:	e8 80 ff ff ff       	call   c0021339 <intr_get_level>
c00213b9:	89 45 fc             	mov    %eax,-0x4(%ebp)

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
c00213bc:	fa                   	cli    

  return old_level;
c00213bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00213c0:	c9                   	leave  
c00213c1:	c3                   	ret    

c00213c2 <intr_init>:

/* Initializes the interrupt system. */
void
intr_init (void)
{
c00213c2:	55                   	push   %ebp
c00213c3:	89 e5                	mov    %esp,%ebp
c00213c5:	83 ec 18             	sub    $0x18,%esp
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init ();
c00213c8:	e8 f6 02 00 00       	call   c00216c3 <pic_init>

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c00213cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00213d4:	eb 2d                	jmp    c0021403 <intr_init+0x41>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c00213d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00213d9:	8b 04 85 4c 78 03 c0 	mov    -0x3ffc87b4(,%eax,4),%eax
c00213e0:	83 ec 08             	sub    $0x8,%esp
c00213e3:	6a 00                	push   $0x0
c00213e5:	50                   	push   %eax
c00213e6:	e8 d1 04 00 00       	call   c00218bc <make_intr_gate>
c00213eb:	83 c4 10             	add    $0x10,%esp
c00213ee:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00213f1:	89 04 cd 60 82 03 c0 	mov    %eax,-0x3ffc7da0(,%ecx,8)
c00213f8:	89 14 cd 64 82 03 c0 	mov    %edx,-0x3ffc7d9c(,%ecx,8)

  /* Initialize interrupt controller. */
  pic_init ();

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c00213ff:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0021403:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c002140a:	7e ca                	jle    c00213d6 <intr_init+0x14>
    idt[i] = make_intr_gate (intr_stubs[i], 0);

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
c002140c:	83 ec 08             	sub    $0x8,%esp
c002140f:	68 60 82 03 c0       	push   $0xc0038260
c0021414:	68 ff 07 00 00       	push   $0x7ff
c0021419:	e8 d4 04 00 00       	call   c00218f2 <make_idtr_operand>
c002141e:	83 c4 10             	add    $0x10,%esp
c0021421:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0021424:	89 55 ec             	mov    %edx,-0x14(%ebp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021427:	0f 01 5d e8          	lidtl  -0x18(%ebp)

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c002142b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0021432:	eb 12                	jmp    c0021446 <intr_init+0x84>
    intr_names[i] = "unknown";
c0021434:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021437:	c7 04 85 60 8e 03 c0 	movl   $0xc002ec0a,-0x3ffc71a0(,%eax,4)
c002143e:	0a ec 02 c0 
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
  asm volatile ("lidt %0" : : "m" (idtr_operand));

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c0021442:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0021446:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c002144d:	7e e5                	jle    c0021434 <intr_init+0x72>
    intr_names[i] = "unknown";
  intr_names[0] = "#DE Divide Error";
c002144f:	c7 05 60 8e 03 c0 12 	movl   $0xc002ec12,0xc0038e60
c0021456:	ec 02 c0 
  intr_names[1] = "#DB Debug Exception";
c0021459:	c7 05 64 8e 03 c0 23 	movl   $0xc002ec23,0xc0038e64
c0021460:	ec 02 c0 
  intr_names[2] = "NMI Interrupt";
c0021463:	c7 05 68 8e 03 c0 37 	movl   $0xc002ec37,0xc0038e68
c002146a:	ec 02 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c002146d:	c7 05 6c 8e 03 c0 45 	movl   $0xc002ec45,0xc0038e6c
c0021474:	ec 02 c0 
  intr_names[4] = "#OF Overflow Exception";
c0021477:	c7 05 70 8e 03 c0 5e 	movl   $0xc002ec5e,0xc0038e70
c002147e:	ec 02 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021481:	c7 05 74 8e 03 c0 78 	movl   $0xc002ec78,0xc0038e74
c0021488:	ec 02 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c002148b:	c7 05 78 8e 03 c0 9b 	movl   $0xc002ec9b,0xc0038e78
c0021492:	ec 02 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c0021495:	c7 05 7c 8e 03 c0 b8 	movl   $0xc002ecb8,0xc0038e7c
c002149c:	ec 02 c0 
  intr_names[8] = "#DF Double Fault Exception";
c002149f:	c7 05 80 8e 03 c0 db 	movl   $0xc002ecdb,0xc0038e80
c00214a6:	ec 02 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c00214a9:	c7 05 84 8e 03 c0 f6 	movl   $0xc002ecf6,0xc0038e84
c00214b0:	ec 02 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c00214b3:	c7 05 88 8e 03 c0 12 	movl   $0xc002ed12,0xc0038e88
c00214ba:	ed 02 c0 
  intr_names[11] = "#NP Segment Not Present";
c00214bd:	c7 05 8c 8e 03 c0 2c 	movl   $0xc002ed2c,0xc0038e8c
c00214c4:	ed 02 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c00214c7:	c7 05 90 8e 03 c0 44 	movl   $0xc002ed44,0xc0038e90
c00214ce:	ed 02 c0 
  intr_names[13] = "#GP General Protection Exception";
c00214d1:	c7 05 94 8e 03 c0 60 	movl   $0xc002ed60,0xc0038e94
c00214d8:	ed 02 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c00214db:	c7 05 98 8e 03 c0 81 	movl   $0xc002ed81,0xc0038e98
c00214e2:	ed 02 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c00214e5:	c7 05 a0 8e 03 c0 9c 	movl   $0xc002ed9c,0xc0038ea0
c00214ec:	ed 02 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c00214ef:	c7 05 a4 8e 03 c0 bd 	movl   $0xc002edbd,0xc0038ea4
c00214f6:	ed 02 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c00214f9:	c7 05 a8 8e 03 c0 db 	movl   $0xc002eddb,0xc0038ea8
c0021500:	ed 02 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021503:	c7 05 ac 8e 03 c0 f8 	movl   $0xc002edf8,0xc0038eac
c002150a:	ed 02 c0 
}
c002150d:	90                   	nop
c002150e:	c9                   	leave  
c002150f:	c3                   	ret    

c0021510 <register_handler>:
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
c0021510:	55                   	push   %ebp
c0021511:	89 e5                	mov    %esp,%ebp
c0021513:	53                   	push   %ebx
c0021514:	83 ec 14             	sub    $0x14,%esp
c0021517:	8b 45 08             	mov    0x8(%ebp),%eax
c002151a:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_handlers[vec_no] == NULL);
c002151d:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021521:	8b 04 85 60 8a 03 c0 	mov    -0x3ffc75a0(,%eax,4),%eax
c0021528:	85 c0                	test   %eax,%eax
c002152a:	74 21                	je     c002154d <register_handler+0x3d>
c002152c:	83 ec 0c             	sub    $0xc,%esp
c002152f:	68 1a ee 02 c0       	push   $0xc002ee1a
c0021534:	68 d9 eb 02 c0       	push   $0xc002ebd9
c0021539:	68 e4 ef 02 c0       	push   $0xc002efe4
c002153e:	68 a8 00 00 00       	push   $0xa8
c0021543:	68 f0 eb 02 c0       	push   $0xc002ebf0
c0021548:	e8 e4 80 00 00       	call   c0029631 <debug_panic>
  if (level == INTR_ON)
c002154d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0021551:	75 2e                	jne    c0021581 <register_handler+0x71>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021553:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0021557:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002155b:	8b 04 85 4c 78 03 c0 	mov    -0x3ffc87b4(,%eax,4),%eax
c0021562:	83 ec 08             	sub    $0x8,%esp
c0021565:	ff 75 0c             	pushl  0xc(%ebp)
c0021568:	50                   	push   %eax
c0021569:	e8 69 03 00 00       	call   c00218d7 <make_trap_gate>
c002156e:	83 c4 10             	add    $0x10,%esp
c0021571:	89 04 dd 60 82 03 c0 	mov    %eax,-0x3ffc7da0(,%ebx,8)
c0021578:	89 14 dd 64 82 03 c0 	mov    %edx,-0x3ffc7d9c(,%ebx,8)
c002157f:	eb 2c                	jmp    c00215ad <register_handler+0x9d>
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c0021581:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0021585:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021589:	8b 04 85 4c 78 03 c0 	mov    -0x3ffc87b4(,%eax,4),%eax
c0021590:	83 ec 08             	sub    $0x8,%esp
c0021593:	ff 75 0c             	pushl  0xc(%ebp)
c0021596:	50                   	push   %eax
c0021597:	e8 20 03 00 00       	call   c00218bc <make_intr_gate>
c002159c:	83 c4 10             	add    $0x10,%esp
c002159f:	89 04 dd 60 82 03 c0 	mov    %eax,-0x3ffc7da0(,%ebx,8)
c00215a6:	89 14 dd 64 82 03 c0 	mov    %edx,-0x3ffc7d9c(,%ebx,8)
  intr_handlers[vec_no] = handler;
c00215ad:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00215b1:	8b 55 14             	mov    0x14(%ebp),%edx
c00215b4:	89 14 85 60 8a 03 c0 	mov    %edx,-0x3ffc75a0(,%eax,4)
  intr_names[vec_no] = name;
c00215bb:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00215bf:	8b 55 18             	mov    0x18(%ebp),%edx
c00215c2:	89 14 85 60 8e 03 c0 	mov    %edx,-0x3ffc71a0(,%eax,4)
}
c00215c9:	90                   	nop
c00215ca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00215cd:	c9                   	leave  
c00215ce:	c3                   	ret    

c00215cf <intr_register_ext>:
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
c00215cf:	55                   	push   %ebp
c00215d0:	89 e5                	mov    %esp,%ebp
c00215d2:	83 ec 18             	sub    $0x18,%esp
c00215d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00215d8:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c00215db:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c00215df:	76 06                	jbe    c00215e7 <intr_register_ext+0x18>
c00215e1:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c00215e5:	76 21                	jbe    c0021608 <intr_register_ext+0x39>
c00215e7:	83 ec 0c             	sub    $0xc,%esp
c00215ea:	68 38 ee 02 c0       	push   $0xc002ee38
c00215ef:	68 d9 eb 02 c0       	push   $0xc002ebd9
c00215f4:	68 f8 ef 02 c0       	push   $0xc002eff8
c00215f9:	68 b8 00 00 00       	push   $0xb8
c00215fe:	68 f0 eb 02 c0       	push   $0xc002ebf0
c0021603:	e8 29 80 00 00       	call   c0029631 <debug_panic>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c0021608:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002160c:	83 ec 0c             	sub    $0xc,%esp
c002160f:	ff 75 10             	pushl  0x10(%ebp)
c0021612:	ff 75 0c             	pushl  0xc(%ebp)
c0021615:	6a 00                	push   $0x0
c0021617:	6a 00                	push   $0x0
c0021619:	50                   	push   %eax
c002161a:	e8 f1 fe ff ff       	call   c0021510 <register_handler>
c002161f:	83 c4 20             	add    $0x20,%esp
}
c0021622:	90                   	nop
c0021623:	c9                   	leave  
c0021624:	c3                   	ret    

c0021625 <intr_register_int>:
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
c0021625:	55                   	push   %ebp
c0021626:	89 e5                	mov    %esp,%ebp
c0021628:	83 ec 18             	sub    $0x18,%esp
c002162b:	8b 45 08             	mov    0x8(%ebp),%eax
c002162e:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021631:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0021635:	76 27                	jbe    c002165e <intr_register_int+0x39>
c0021637:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c002163b:	77 21                	ja     c002165e <intr_register_int+0x39>
c002163d:	83 ec 0c             	sub    $0xc,%esp
c0021640:	68 5c ee 02 c0       	push   $0xc002ee5c
c0021645:	68 d9 eb 02 c0       	push   $0xc002ebd9
c002164a:	68 0c f0 02 c0       	push   $0xc002f00c
c002164f:	68 cd 00 00 00       	push   $0xcd
c0021654:	68 f0 eb 02 c0       	push   $0xc002ebf0
c0021659:	e8 d3 7f 00 00       	call   c0029631 <debug_panic>
  register_handler (vec_no, dpl, level, handler, name);
c002165e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021662:	83 ec 0c             	sub    $0xc,%esp
c0021665:	ff 75 18             	pushl  0x18(%ebp)
c0021668:	ff 75 14             	pushl  0x14(%ebp)
c002166b:	ff 75 10             	pushl  0x10(%ebp)
c002166e:	ff 75 0c             	pushl  0xc(%ebp)
c0021671:	50                   	push   %eax
c0021672:	e8 99 fe ff ff       	call   c0021510 <register_handler>
c0021677:	83 c4 20             	add    $0x20,%esp
}
c002167a:	90                   	nop
c002167b:	c9                   	leave  
c002167c:	c3                   	ret    

c002167d <intr_context>:

/* Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
c002167d:	55                   	push   %ebp
c002167e:	89 e5                	mov    %esp,%ebp
  return in_external_intr;
c0021680:	0f b6 05 60 96 03 c0 	movzbl 0xc0039660,%eax
}
c0021687:	5d                   	pop    %ebp
c0021688:	c3                   	ret    

c0021689 <intr_yield_on_return>:
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
c0021689:	55                   	push   %ebp
c002168a:	89 e5                	mov    %esp,%ebp
c002168c:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_context ());
c002168f:	e8 e9 ff ff ff       	call   c002167d <intr_context>
c0021694:	84 c0                	test   %al,%al
c0021696:	75 21                	jne    c00216b9 <intr_yield_on_return+0x30>
c0021698:	83 ec 0c             	sub    $0xc,%esp
c002169b:	68 7b ee 02 c0       	push   $0xc002ee7b
c00216a0:	68 d9 eb 02 c0       	push   $0xc002ebd9
c00216a5:	68 20 f0 02 c0       	push   $0xc002f020
c00216aa:	68 e0 00 00 00       	push   $0xe0
c00216af:	68 f0 eb 02 c0       	push   $0xc002ebf0
c00216b4:	e8 78 7f 00 00       	call   c0029631 <debug_panic>
  yield_on_return = true;
c00216b9:	c6 05 61 96 03 c0 01 	movb   $0x1,0xc0039661
}
c00216c0:	90                   	nop
c00216c1:	c9                   	leave  
c00216c2:	c3                   	ret    

c00216c3 <pic_init>:
   traps and exceptions, so we reprogram the PICs so that
   interrupts 0...15 are delivered to interrupt vectors 32...47
   (0x20...0x2f) instead. */
static void
pic_init (void)
{
c00216c3:	55                   	push   %ebp
c00216c4:	89 e5                	mov    %esp,%ebp
  /* Mask all interrupts on both PICs. */
  outb (PIC0_DATA, 0xff);
c00216c6:	68 ff 00 00 00       	push   $0xff
c00216cb:	6a 21                	push   $0x21
c00216cd:	e8 48 fc ff ff       	call   c002131a <outb>
c00216d2:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0xff);
c00216d5:	68 ff 00 00 00       	push   $0xff
c00216da:	68 a1 00 00 00       	push   $0xa1
c00216df:	e8 36 fc ff ff       	call   c002131a <outb>
c00216e4:	83 c4 08             	add    $0x8,%esp

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c00216e7:	6a 11                	push   $0x11
c00216e9:	6a 20                	push   $0x20
c00216eb:	e8 2a fc ff ff       	call   c002131a <outb>
c00216f0:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
c00216f3:	6a 20                	push   $0x20
c00216f5:	6a 21                	push   $0x21
c00216f7:	e8 1e fc ff ff       	call   c002131a <outb>
c00216fc:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
c00216ff:	6a 04                	push   $0x4
c0021701:	6a 21                	push   $0x21
c0021703:	e8 12 fc ff ff       	call   c002131a <outb>
c0021708:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c002170b:	6a 01                	push   $0x1
c002170d:	6a 21                	push   $0x21
c002170f:	e8 06 fc ff ff       	call   c002131a <outb>
c0021714:	83 c4 08             	add    $0x8,%esp

  /* Initialize slave. */
  outb (PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021717:	6a 11                	push   $0x11
c0021719:	68 a0 00 00 00       	push   $0xa0
c002171e:	e8 f7 fb ff ff       	call   c002131a <outb>
c0021723:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
c0021726:	6a 28                	push   $0x28
c0021728:	68 a1 00 00 00       	push   $0xa1
c002172d:	e8 e8 fb ff ff       	call   c002131a <outb>
c0021732:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */
c0021735:	6a 02                	push   $0x2
c0021737:	68 a1 00 00 00       	push   $0xa1
c002173c:	e8 d9 fb ff ff       	call   c002131a <outb>
c0021741:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c0021744:	6a 01                	push   $0x1
c0021746:	68 a1 00 00 00       	push   $0xa1
c002174b:	e8 ca fb ff ff       	call   c002131a <outb>
c0021750:	83 c4 08             	add    $0x8,%esp

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
c0021753:	6a 00                	push   $0x0
c0021755:	6a 21                	push   $0x21
c0021757:	e8 be fb ff ff       	call   c002131a <outb>
c002175c:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x00);
c002175f:	6a 00                	push   $0x0
c0021761:	68 a1 00 00 00       	push   $0xa1
c0021766:	e8 af fb ff ff       	call   c002131a <outb>
c002176b:	83 c4 08             	add    $0x8,%esp
}
c002176e:	90                   	nop
c002176f:	c9                   	leave  
c0021770:	c3                   	ret    

c0021771 <pic_end_of_interrupt>:
/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
c0021771:	55                   	push   %ebp
c0021772:	89 e5                	mov    %esp,%ebp
c0021774:	83 ec 08             	sub    $0x8,%esp
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021777:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c002177b:	7e 06                	jle    c0021783 <pic_end_of_interrupt+0x12>
c002177d:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0021781:	7e 21                	jle    c00217a4 <pic_end_of_interrupt+0x33>
c0021783:	83 ec 0c             	sub    $0xc,%esp
c0021786:	68 8b ee 02 c0       	push   $0xc002ee8b
c002178b:	68 d9 eb 02 c0       	push   $0xc002ebd9
c0021790:	68 38 f0 02 c0       	push   $0xc002f038
c0021795:	68 0b 01 00 00       	push   $0x10b
c002179a:	68 f0 eb 02 c0       	push   $0xc002ebf0
c002179f:	e8 8d 7e 00 00       	call   c0029631 <debug_panic>

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);
c00217a4:	83 ec 08             	sub    $0x8,%esp
c00217a7:	6a 20                	push   $0x20
c00217a9:	6a 20                	push   $0x20
c00217ab:	e8 6a fb ff ff       	call   c002131a <outb>
c00217b0:	83 c4 10             	add    $0x10,%esp

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
c00217b3:	83 7d 08 27          	cmpl   $0x27,0x8(%ebp)
c00217b7:	7e 12                	jle    c00217cb <pic_end_of_interrupt+0x5a>
    outb (0xa0, 0x20);
c00217b9:	83 ec 08             	sub    $0x8,%esp
c00217bc:	6a 20                	push   $0x20
c00217be:	68 a0 00 00 00       	push   $0xa0
c00217c3:	e8 52 fb ff ff       	call   c002131a <outb>
c00217c8:	83 c4 10             	add    $0x10,%esp
}
c00217cb:	90                   	nop
c00217cc:	c9                   	leave  
c00217cd:	c3                   	ret    

c00217ce <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c00217ce:	55                   	push   %ebp
c00217cf:	89 e5                	mov    %esp,%ebp
c00217d1:	57                   	push   %edi
c00217d2:	56                   	push   %esi
c00217d3:	53                   	push   %ebx
c00217d4:	83 ec 2c             	sub    $0x2c,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c00217d7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00217db:	75 21                	jne    c00217fe <make_gate+0x30>
c00217dd:	83 ec 0c             	sub    $0xc,%esp
c00217e0:	68 a5 ee 02 c0       	push   $0xc002eea5
c00217e5:	68 d9 eb 02 c0       	push   $0xc002ebd9
c00217ea:	68 50 f0 02 c0       	push   $0xc002f050
c00217ef:	68 2a 01 00 00       	push   $0x12a
c00217f4:	68 f0 eb 02 c0       	push   $0xc002ebf0
c00217f9:	e8 33 7e 00 00       	call   c0029631 <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c00217fe:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0021802:	78 06                	js     c002180a <make_gate+0x3c>
c0021804:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0021808:	7e 21                	jle    c002182b <make_gate+0x5d>
c002180a:	83 ec 0c             	sub    $0xc,%esp
c002180d:	68 b6 ee 02 c0       	push   $0xc002eeb6
c0021812:	68 d9 eb 02 c0       	push   $0xc002ebd9
c0021817:	68 50 f0 02 c0       	push   $0xc002f050
c002181c:	68 2b 01 00 00       	push   $0x12b
c0021821:	68 f0 eb 02 c0       	push   $0xc002ebf0
c0021826:	e8 06 7e 00 00       	call   c0029631 <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c002182b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002182f:	78 06                	js     c0021837 <make_gate+0x69>
c0021831:	83 7d 10 0f          	cmpl   $0xf,0x10(%ebp)
c0021835:	7e 21                	jle    c0021858 <make_gate+0x8a>
c0021837:	83 ec 0c             	sub    $0xc,%esp
c002183a:	68 cb ee 02 c0       	push   $0xc002eecb
c002183f:	68 d9 eb 02 c0       	push   $0xc002ebd9
c0021844:	68 50 f0 02 c0       	push   $0xc002f050
c0021849:	68 2c 01 00 00       	push   $0x12c
c002184e:	68 f0 eb 02 c0       	push   $0xc002ebf0
c0021853:	e8 d9 7d 00 00       	call   c0029631 <debug_panic>

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c0021858:	8b 45 08             	mov    0x8(%ebp),%eax
c002185b:	0f b7 c0             	movzwl %ax,%eax
c002185e:	0d 00 00 08 00       	or     $0x80000,%eax
c0021863:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021866:	8b 45 08             	mov    0x8(%ebp),%eax
c0021869:	66 b8 00 00          	mov    $0x0,%ax
c002186d:	89 c2                	mov    %eax,%edx
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c002186f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021872:	c1 e0 0d             	shl    $0xd,%eax
c0021875:	09 c2                	or     %eax,%edx
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c0021877:	8b 45 10             	mov    0x10(%ebp),%eax
c002187a:	c1 e0 08             	shl    $0x8,%eax
c002187d:	09 d0                	or     %edx,%eax
  ASSERT (type >= 0 && type <= 15);

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c002187f:	80 cc 80             	or     $0x80,%ah
c0021882:	89 45 e0             	mov    %eax,-0x20(%ebp)
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */

  return e0 | ((uint64_t) e1 << 32);
c0021885:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0021888:	bf 00 00 00 00       	mov    $0x0,%edi
c002188d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0021890:	ba 00 00 00 00       	mov    $0x0,%edx
c0021895:	89 c2                	mov    %eax,%edx
c0021897:	b8 00 00 00 00       	mov    $0x0,%eax
c002189c:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002189f:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c00218a2:	89 f0                	mov    %esi,%eax
c00218a4:	0b 45 d0             	or     -0x30(%ebp),%eax
c00218a7:	89 c1                	mov    %eax,%ecx
c00218a9:	89 f8                	mov    %edi,%eax
c00218ab:	0b 45 d4             	or     -0x2c(%ebp),%eax
c00218ae:	89 c3                	mov    %eax,%ebx
c00218b0:	89 c8                	mov    %ecx,%eax
c00218b2:	89 da                	mov    %ebx,%edx
}
c00218b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00218b7:	5b                   	pop    %ebx
c00218b8:	5e                   	pop    %esi
c00218b9:	5f                   	pop    %edi
c00218ba:	5d                   	pop    %ebp
c00218bb:	c3                   	ret    

c00218bc <make_intr_gate>:

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
c00218bc:	55                   	push   %ebp
c00218bd:	89 e5                	mov    %esp,%ebp
c00218bf:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 14);
c00218c2:	83 ec 04             	sub    $0x4,%esp
c00218c5:	6a 0e                	push   $0xe
c00218c7:	ff 75 0c             	pushl  0xc(%ebp)
c00218ca:	ff 75 08             	pushl  0x8(%ebp)
c00218cd:	e8 fc fe ff ff       	call   c00217ce <make_gate>
c00218d2:	83 c4 10             	add    $0x10,%esp
}
c00218d5:	c9                   	leave  
c00218d6:	c3                   	ret    

c00218d7 <make_trap_gate>:

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
c00218d7:	55                   	push   %ebp
c00218d8:	89 e5                	mov    %esp,%ebp
c00218da:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 15);
c00218dd:	83 ec 04             	sub    $0x4,%esp
c00218e0:	6a 0f                	push   $0xf
c00218e2:	ff 75 0c             	pushl  0xc(%ebp)
c00218e5:	ff 75 08             	pushl  0x8(%ebp)
c00218e8:	e8 e1 fe ff ff       	call   c00217ce <make_gate>
c00218ed:	83 c4 10             	add    $0x10,%esp
}
c00218f0:	c9                   	leave  
c00218f1:	c3                   	ret    

c00218f2 <make_idtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
c00218f2:	55                   	push   %ebp
c00218f3:	89 e5                	mov    %esp,%ebp
c00218f5:	57                   	push   %edi
c00218f6:	56                   	push   %esi
c00218f7:	53                   	push   %ebx
c00218f8:	83 ec 14             	sub    $0x14,%esp
c00218fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00218fe:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c0021902:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0021906:	89 c6                	mov    %eax,%esi
c0021908:	bf 00 00 00 00       	mov    $0x0,%edi
c002190d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021910:	ba 00 00 00 00       	mov    $0x0,%edx
c0021915:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021919:	c1 e0 10             	shl    $0x10,%eax
c002191c:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002191f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0021922:	89 f0                	mov    %esi,%eax
c0021924:	0b 45 e0             	or     -0x20(%ebp),%eax
c0021927:	89 c1                	mov    %eax,%ecx
c0021929:	89 f8                	mov    %edi,%eax
c002192b:	0b 45 e4             	or     -0x1c(%ebp),%eax
c002192e:	89 c3                	mov    %eax,%ebx
c0021930:	89 c8                	mov    %ecx,%eax
c0021932:	89 da                	mov    %ebx,%edx
}
c0021934:	83 c4 14             	add    $0x14,%esp
c0021937:	5b                   	pop    %ebx
c0021938:	5e                   	pop    %esi
c0021939:	5f                   	pop    %edi
c002193a:	5d                   	pop    %ebp
c002193b:	c3                   	ret    

c002193c <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c002193c:	55                   	push   %ebp
c002193d:	89 e5                	mov    %esp,%ebp
c002193f:	83 ec 18             	sub    $0x18,%esp

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021942:	8b 45 08             	mov    0x8(%ebp),%eax
c0021945:	8b 40 30             	mov    0x30(%eax),%eax
c0021948:	83 f8 1f             	cmp    $0x1f,%eax
c002194b:	76 12                	jbe    c002195f <intr_handler+0x23>
c002194d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021950:	8b 40 30             	mov    0x30(%eax),%eax
c0021953:	83 f8 2f             	cmp    $0x2f,%eax
c0021956:	77 07                	ja     c002195f <intr_handler+0x23>
c0021958:	b8 01 00 00 00       	mov    $0x1,%eax
c002195d:	eb 05                	jmp    c0021964 <intr_handler+0x28>
c002195f:	b8 00 00 00 00       	mov    $0x0,%eax
c0021964:	88 45 f7             	mov    %al,-0x9(%ebp)
c0021967:	80 65 f7 01          	andb   $0x1,-0x9(%ebp)
  if (external) 
c002196b:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c002196f:	74 65                	je     c00219d6 <intr_handler+0x9a>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021971:	e8 c3 f9 ff ff       	call   c0021339 <intr_get_level>
c0021976:	85 c0                	test   %eax,%eax
c0021978:	74 21                	je     c002199b <intr_handler+0x5f>
c002197a:	83 ec 0c             	sub    $0xc,%esp
c002197d:	68 e3 ee 02 c0       	push   $0xc002eee3
c0021982:	68 d9 eb 02 c0       	push   $0xc002ebd9
c0021987:	68 5c f0 02 c0       	push   $0xc002f05c
c002198c:	68 65 01 00 00       	push   $0x165
c0021991:	68 f0 eb 02 c0       	push   $0xc002ebf0
c0021996:	e8 96 7c 00 00       	call   c0029631 <debug_panic>
      ASSERT (!intr_context ());
c002199b:	e8 dd fc ff ff       	call   c002167d <intr_context>
c00219a0:	83 f0 01             	xor    $0x1,%eax
c00219a3:	84 c0                	test   %al,%al
c00219a5:	75 21                	jne    c00219c8 <intr_handler+0x8c>
c00219a7:	83 ec 0c             	sub    $0xc,%esp
c00219aa:	68 c8 eb 02 c0       	push   $0xc002ebc8
c00219af:	68 d9 eb 02 c0       	push   $0xc002ebd9
c00219b4:	68 5c f0 02 c0       	push   $0xc002f05c
c00219b9:	68 66 01 00 00       	push   $0x166
c00219be:	68 f0 eb 02 c0       	push   $0xc002ebf0
c00219c3:	e8 69 7c 00 00       	call   c0029631 <debug_panic>

      in_external_intr = true;
c00219c8:	c6 05 60 96 03 c0 01 	movb   $0x1,0xc0039660
      yield_on_return = false;
c00219cf:	c6 05 61 96 03 c0 00 	movb   $0x0,0xc0039661
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c00219d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00219d9:	8b 40 30             	mov    0x30(%eax),%eax
c00219dc:	8b 04 85 60 8a 03 c0 	mov    -0x3ffc75a0(,%eax,4),%eax
c00219e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (handler != NULL)
c00219e6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00219ea:	74 10                	je     c00219fc <intr_handler+0xc0>
    handler (frame);
c00219ec:	83 ec 0c             	sub    $0xc,%esp
c00219ef:	ff 75 08             	pushl  0x8(%ebp)
c00219f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00219f5:	ff d0                	call   *%eax
c00219f7:	83 c4 10             	add    $0x10,%esp
c00219fa:	eb 24                	jmp    c0021a20 <intr_handler+0xe4>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c00219fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00219ff:	8b 40 30             	mov    0x30(%eax),%eax
c0021a02:	83 f8 27             	cmp    $0x27,%eax
c0021a05:	74 19                	je     c0021a20 <intr_handler+0xe4>
c0021a07:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a0a:	8b 40 30             	mov    0x30(%eax),%eax
c0021a0d:	83 f8 2f             	cmp    $0x2f,%eax
c0021a10:	74 0e                	je     c0021a20 <intr_handler+0xe4>
      /* There is no handler, but this interrupt can trigger
         spuriously due to a hardware fault or hardware race
         condition.  Ignore it. */
    }
  else
    unexpected_interrupt (frame);
c0021a12:	83 ec 0c             	sub    $0xc,%esp
c0021a15:	ff 75 08             	pushl  0x8(%ebp)
c0021a18:	e8 89 00 00 00       	call   c0021aa6 <unexpected_interrupt>
c0021a1d:	83 c4 10             	add    $0x10,%esp

  /* Complete the processing of an external interrupt. */
  if (external) 
c0021a20:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021a24:	74 7d                	je     c0021aa3 <intr_handler+0x167>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021a26:	e8 0e f9 ff ff       	call   c0021339 <intr_get_level>
c0021a2b:	85 c0                	test   %eax,%eax
c0021a2d:	74 21                	je     c0021a50 <intr_handler+0x114>
c0021a2f:	83 ec 0c             	sub    $0xc,%esp
c0021a32:	68 e3 ee 02 c0       	push   $0xc002eee3
c0021a37:	68 d9 eb 02 c0       	push   $0xc002ebd9
c0021a3c:	68 5c f0 02 c0       	push   $0xc002f05c
c0021a41:	68 7c 01 00 00       	push   $0x17c
c0021a46:	68 f0 eb 02 c0       	push   $0xc002ebf0
c0021a4b:	e8 e1 7b 00 00       	call   c0029631 <debug_panic>
      ASSERT (intr_context ());
c0021a50:	e8 28 fc ff ff       	call   c002167d <intr_context>
c0021a55:	84 c0                	test   %al,%al
c0021a57:	75 21                	jne    c0021a7a <intr_handler+0x13e>
c0021a59:	83 ec 0c             	sub    $0xc,%esp
c0021a5c:	68 7b ee 02 c0       	push   $0xc002ee7b
c0021a61:	68 d9 eb 02 c0       	push   $0xc002ebd9
c0021a66:	68 5c f0 02 c0       	push   $0xc002f05c
c0021a6b:	68 7d 01 00 00       	push   $0x17d
c0021a70:	68 f0 eb 02 c0       	push   $0xc002ebf0
c0021a75:	e8 b7 7b 00 00       	call   c0029631 <debug_panic>

      in_external_intr = false;
c0021a7a:	c6 05 60 96 03 c0 00 	movb   $0x0,0xc0039660
      pic_end_of_interrupt (frame->vec_no); 
c0021a81:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a84:	8b 40 30             	mov    0x30(%eax),%eax
c0021a87:	83 ec 0c             	sub    $0xc,%esp
c0021a8a:	50                   	push   %eax
c0021a8b:	e8 e1 fc ff ff       	call   c0021771 <pic_end_of_interrupt>
c0021a90:	83 c4 10             	add    $0x10,%esp

      if (yield_on_return) 
c0021a93:	0f b6 05 61 96 03 c0 	movzbl 0xc0039661,%eax
c0021a9a:	84 c0                	test   %al,%al
c0021a9c:	74 05                	je     c0021aa3 <intr_handler+0x167>
        thread_yield (); 
c0021a9e:	e8 d4 f2 ff ff       	call   c0020d77 <thread_yield>
    }
}
c0021aa3:	90                   	nop
c0021aa4:	c9                   	leave  
c0021aa5:	c3                   	ret    

c0021aa6 <unexpected_interrupt>:

/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
c0021aa6:	55                   	push   %ebp
c0021aa7:	89 e5                	mov    %esp,%ebp
c0021aa9:	83 ec 18             	sub    $0x18,%esp
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0021aac:	8b 45 08             	mov    0x8(%ebp),%eax
c0021aaf:	8b 40 30             	mov    0x30(%eax),%eax
c0021ab2:	8b 14 85 60 92 03 c0 	mov    -0x3ffc6da0(,%eax,4),%edx
c0021ab9:	83 c2 01             	add    $0x1,%edx
c0021abc:	89 14 85 60 92 03 c0 	mov    %edx,-0x3ffc6da0(,%eax,4)
c0021ac3:	8b 04 85 60 92 03 c0 	mov    -0x3ffc6da0(,%eax,4),%eax
c0021aca:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0021acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021ad0:	83 e8 01             	sub    $0x1,%eax
c0021ad3:	23 45 f4             	and    -0xc(%ebp),%eax
c0021ad6:	85 c0                	test   %eax,%eax
c0021ad8:	75 25                	jne    c0021aff <unexpected_interrupt+0x59>
    printf ("Unexpected interrupt %#04x (%s)\n",
    f->vec_no, intr_names[f->vec_no]);
c0021ada:	8b 45 08             	mov    0x8(%ebp),%eax
c0021add:	8b 40 30             	mov    0x30(%eax),%eax
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
    printf ("Unexpected interrupt %#04x (%s)\n",
c0021ae0:	8b 14 85 60 8e 03 c0 	mov    -0x3ffc71a0(,%eax,4),%edx
c0021ae7:	8b 45 08             	mov    0x8(%ebp),%eax
c0021aea:	8b 40 30             	mov    0x30(%eax),%eax
c0021aed:	83 ec 04             	sub    $0x4,%esp
c0021af0:	52                   	push   %edx
c0021af1:	50                   	push   %eax
c0021af2:	68 04 ef 02 c0       	push   $0xc002ef04
c0021af7:	e8 02 57 00 00       	call   c00271fe <printf>
c0021afc:	83 c4 10             	add    $0x10,%esp
    f->vec_no, intr_names[f->vec_no]);
}
c0021aff:	90                   	nop
c0021b00:	c9                   	leave  
c0021b01:	c3                   	ret    

c0021b02 <intr_dump_frame>:

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0021b02:	55                   	push   %ebp
c0021b03:	89 e5                	mov    %esp,%ebp
c0021b05:	53                   	push   %ebx
c0021b06:	83 ec 14             	sub    $0x14,%esp
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0021b09:	0f 20 d0             	mov    %cr2,%eax
c0021b0c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021b0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b12:	8b 48 3c             	mov    0x3c(%eax),%ecx
          f->vec_no, intr_names[f->vec_no], f->eip);
c0021b15:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b18:	8b 40 30             	mov    0x30(%eax),%eax
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021b1b:	8b 14 85 60 8e 03 c0 	mov    -0x3ffc71a0(,%eax,4),%edx
c0021b22:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b25:	8b 40 30             	mov    0x30(%eax),%eax
c0021b28:	51                   	push   %ecx
c0021b29:	52                   	push   %edx
c0021b2a:	50                   	push   %eax
c0021b2b:	68 28 ef 02 c0       	push   $0xc002ef28
c0021b30:	e8 c9 56 00 00       	call   c00271fe <printf>
c0021b35:	83 c4 10             	add    $0x10,%esp
          f->vec_no, intr_names[f->vec_no], f->eip);
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0021b38:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b3b:	8b 40 34             	mov    0x34(%eax),%eax
c0021b3e:	83 ec 04             	sub    $0x4,%esp
c0021b41:	50                   	push   %eax
c0021b42:	ff 75 f4             	pushl  -0xc(%ebp)
c0021b45:	68 48 ef 02 c0       	push   $0xc002ef48
c0021b4a:	e8 af 56 00 00       	call   c00271fe <printf>
c0021b4f:	83 c4 10             	add    $0x10,%esp
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0021b52:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b55:	8b 58 14             	mov    0x14(%eax),%ebx
c0021b58:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b5b:	8b 48 18             	mov    0x18(%eax),%ecx
c0021b5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b61:	8b 50 10             	mov    0x10(%eax),%edx
c0021b64:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b67:	8b 40 1c             	mov    0x1c(%eax),%eax
c0021b6a:	83 ec 0c             	sub    $0xc,%esp
c0021b6d:	53                   	push   %ebx
c0021b6e:	51                   	push   %ecx
c0021b6f:	52                   	push   %edx
c0021b70:	50                   	push   %eax
c0021b71:	68 60 ef 02 c0       	push   $0xc002ef60
c0021b76:	e8 83 56 00 00       	call   c00271fe <printf>
c0021b7b:	83 c4 20             	add    $0x20,%esp
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021b7e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b81:	8b 48 08             	mov    0x8(%eax),%ecx
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
c0021b84:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b87:	8b 40 48             	mov    0x48(%eax),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021b8a:	89 c3                	mov    %eax,%ebx
c0021b8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b8f:	8b 10                	mov    (%eax),%edx
c0021b91:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b94:	8b 40 04             	mov    0x4(%eax),%eax
c0021b97:	83 ec 0c             	sub    $0xc,%esp
c0021b9a:	51                   	push   %ecx
c0021b9b:	53                   	push   %ebx
c0021b9c:	52                   	push   %edx
c0021b9d:	50                   	push   %eax
c0021b9e:	68 88 ef 02 c0       	push   $0xc002ef88
c0021ba3:	e8 56 56 00 00       	call   c00271fe <printf>
c0021ba8:	83 c4 20             	add    $0x20,%esp
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->ss);
c0021bab:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bae:	0f b7 40 4c          	movzwl 0x4c(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021bb2:	0f b7 d8             	movzwl %ax,%ebx
          f->cs, f->ds, f->es, f->ss);
c0021bb5:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bb8:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021bbc:	0f b7 c8             	movzwl %ax,%ecx
          f->cs, f->ds, f->es, f->ss);
c0021bbf:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bc2:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021bc6:	0f b7 d0             	movzwl %ax,%edx
          f->cs, f->ds, f->es, f->ss);
c0021bc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bcc:	0f b7 40 40          	movzwl 0x40(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021bd0:	0f b7 c0             	movzwl %ax,%eax
c0021bd3:	83 ec 0c             	sub    $0xc,%esp
c0021bd6:	53                   	push   %ebx
c0021bd7:	51                   	push   %ecx
c0021bd8:	52                   	push   %edx
c0021bd9:	50                   	push   %eax
c0021bda:	68 b0 ef 02 c0       	push   $0xc002efb0
c0021bdf:	e8 1a 56 00 00       	call   c00271fe <printf>
c0021be4:	83 c4 20             	add    $0x20,%esp
          f->cs, f->ds, f->es, f->ss);
}
c0021be7:	90                   	nop
c0021be8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021beb:	c9                   	leave  
c0021bec:	c3                   	ret    

c0021bed <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c0021bed:	55                   	push   %ebp
c0021bee:	89 e5                	mov    %esp,%ebp
c0021bf0:	83 ec 04             	sub    $0x4,%esp
c0021bf3:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bf6:	88 45 fc             	mov    %al,-0x4(%ebp)
  return intr_names[vec];
c0021bf9:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0021bfd:	8b 04 85 60 8e 03 c0 	mov    -0x3ffc71a0(,%eax,4),%eax
}
c0021c04:	c9                   	leave  
c0021c05:	c3                   	ret    

c0021c06 <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0021c06:	1e                   	push   %ds
	pushl %es
c0021c07:	06                   	push   %es
	pushl %fs
c0021c08:	0f a0                	push   %fs
	pushl %gs
c0021c0a:	0f a8                	push   %gs
	pushal
c0021c0c:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c0021c0d:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c0021c0e:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c0021c13:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c0021c15:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c0021c17:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c0021c1b:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0021c1c:	e8 1b fd ff ff       	call   c002193c <intr_handler>
	addl $4, %esp
c0021c21:	83 c4 04             	add    $0x4,%esp

c0021c24 <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c0021c24:	61                   	popa   
	popl %gs
c0021c25:	0f a9                	pop    %gs
	popl %fs
c0021c27:	0f a1                	pop    %fs
	popl %es
c0021c29:	07                   	pop    %es
	popl %ds
c0021c2a:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0021c2b:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0021c2e:	cf                   	iret   

c0021c2f <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c0021c2f:	55                   	push   %ebp
c0021c30:	6a 00                	push   $0x0
c0021c32:	6a 00                	push   $0x0
c0021c34:	eb d0                	jmp    c0021c06 <intr_entry>

c0021c36 <intr01_stub>:
c0021c36:	55                   	push   %ebp
c0021c37:	6a 00                	push   $0x0
c0021c39:	6a 01                	push   $0x1
c0021c3b:	eb c9                	jmp    c0021c06 <intr_entry>

c0021c3d <intr02_stub>:
c0021c3d:	55                   	push   %ebp
c0021c3e:	6a 00                	push   $0x0
c0021c40:	6a 02                	push   $0x2
c0021c42:	eb c2                	jmp    c0021c06 <intr_entry>

c0021c44 <intr03_stub>:
c0021c44:	55                   	push   %ebp
c0021c45:	6a 00                	push   $0x0
c0021c47:	6a 03                	push   $0x3
c0021c49:	eb bb                	jmp    c0021c06 <intr_entry>

c0021c4b <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0021c4b:	55                   	push   %ebp
c0021c4c:	6a 00                	push   $0x0
c0021c4e:	6a 04                	push   $0x4
c0021c50:	eb b4                	jmp    c0021c06 <intr_entry>

c0021c52 <intr05_stub>:
c0021c52:	55                   	push   %ebp
c0021c53:	6a 00                	push   $0x0
c0021c55:	6a 05                	push   $0x5
c0021c57:	eb ad                	jmp    c0021c06 <intr_entry>

c0021c59 <intr06_stub>:
c0021c59:	55                   	push   %ebp
c0021c5a:	6a 00                	push   $0x0
c0021c5c:	6a 06                	push   $0x6
c0021c5e:	eb a6                	jmp    c0021c06 <intr_entry>

c0021c60 <intr07_stub>:
c0021c60:	55                   	push   %ebp
c0021c61:	6a 00                	push   $0x0
c0021c63:	6a 07                	push   $0x7
c0021c65:	eb 9f                	jmp    c0021c06 <intr_entry>

c0021c67 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0021c67:	ff 34 24             	pushl  (%esp)
c0021c6a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c6e:	6a 08                	push   $0x8
c0021c70:	eb 94                	jmp    c0021c06 <intr_entry>

c0021c72 <intr09_stub>:
c0021c72:	55                   	push   %ebp
c0021c73:	6a 00                	push   $0x0
c0021c75:	6a 09                	push   $0x9
c0021c77:	eb 8d                	jmp    c0021c06 <intr_entry>

c0021c79 <intr0a_stub>:
c0021c79:	ff 34 24             	pushl  (%esp)
c0021c7c:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c80:	6a 0a                	push   $0xa
c0021c82:	eb 82                	jmp    c0021c06 <intr_entry>

c0021c84 <intr0b_stub>:
c0021c84:	ff 34 24             	pushl  (%esp)
c0021c87:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c8b:	6a 0b                	push   $0xb
c0021c8d:	e9 74 ff ff ff       	jmp    c0021c06 <intr_entry>

c0021c92 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0021c92:	55                   	push   %ebp
c0021c93:	6a 00                	push   $0x0
c0021c95:	6a 0c                	push   $0xc
c0021c97:	e9 6a ff ff ff       	jmp    c0021c06 <intr_entry>

c0021c9c <intr0d_stub>:
c0021c9c:	ff 34 24             	pushl  (%esp)
c0021c9f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021ca3:	6a 0d                	push   $0xd
c0021ca5:	e9 5c ff ff ff       	jmp    c0021c06 <intr_entry>

c0021caa <intr0e_stub>:
c0021caa:	ff 34 24             	pushl  (%esp)
c0021cad:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021cb1:	6a 0e                	push   $0xe
c0021cb3:	e9 4e ff ff ff       	jmp    c0021c06 <intr_entry>

c0021cb8 <intr0f_stub>:
c0021cb8:	55                   	push   %ebp
c0021cb9:	6a 00                	push   $0x0
c0021cbb:	6a 0f                	push   $0xf
c0021cbd:	e9 44 ff ff ff       	jmp    c0021c06 <intr_entry>

c0021cc2 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0021cc2:	55                   	push   %ebp
c0021cc3:	6a 00                	push   $0x0
c0021cc5:	6a 10                	push   $0x10
c0021cc7:	e9 3a ff ff ff       	jmp    c0021c06 <intr_entry>

c0021ccc <intr11_stub>:
c0021ccc:	ff 34 24             	pushl  (%esp)
c0021ccf:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021cd3:	6a 11                	push   $0x11
c0021cd5:	e9 2c ff ff ff       	jmp    c0021c06 <intr_entry>

c0021cda <intr12_stub>:
c0021cda:	55                   	push   %ebp
c0021cdb:	6a 00                	push   $0x0
c0021cdd:	6a 12                	push   $0x12
c0021cdf:	e9 22 ff ff ff       	jmp    c0021c06 <intr_entry>

c0021ce4 <intr13_stub>:
c0021ce4:	55                   	push   %ebp
c0021ce5:	6a 00                	push   $0x0
c0021ce7:	6a 13                	push   $0x13
c0021ce9:	e9 18 ff ff ff       	jmp    c0021c06 <intr_entry>

c0021cee <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0021cee:	55                   	push   %ebp
c0021cef:	6a 00                	push   $0x0
c0021cf1:	6a 14                	push   $0x14
c0021cf3:	e9 0e ff ff ff       	jmp    c0021c06 <intr_entry>

c0021cf8 <intr15_stub>:
c0021cf8:	55                   	push   %ebp
c0021cf9:	6a 00                	push   $0x0
c0021cfb:	6a 15                	push   $0x15
c0021cfd:	e9 04 ff ff ff       	jmp    c0021c06 <intr_entry>

c0021d02 <intr16_stub>:
c0021d02:	55                   	push   %ebp
c0021d03:	6a 00                	push   $0x0
c0021d05:	6a 16                	push   $0x16
c0021d07:	e9 fa fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d0c <intr17_stub>:
c0021d0c:	55                   	push   %ebp
c0021d0d:	6a 00                	push   $0x0
c0021d0f:	6a 17                	push   $0x17
c0021d11:	e9 f0 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d16 <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c0021d16:	ff 34 24             	pushl  (%esp)
c0021d19:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d1d:	6a 18                	push   $0x18
c0021d1f:	e9 e2 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d24 <intr19_stub>:
c0021d24:	55                   	push   %ebp
c0021d25:	6a 00                	push   $0x0
c0021d27:	6a 19                	push   $0x19
c0021d29:	e9 d8 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d2e <intr1a_stub>:
c0021d2e:	ff 34 24             	pushl  (%esp)
c0021d31:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d35:	6a 1a                	push   $0x1a
c0021d37:	e9 ca fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d3c <intr1b_stub>:
c0021d3c:	ff 34 24             	pushl  (%esp)
c0021d3f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d43:	6a 1b                	push   $0x1b
c0021d45:	e9 bc fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d4a <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0021d4a:	55                   	push   %ebp
c0021d4b:	6a 00                	push   $0x0
c0021d4d:	6a 1c                	push   $0x1c
c0021d4f:	e9 b2 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d54 <intr1d_stub>:
c0021d54:	ff 34 24             	pushl  (%esp)
c0021d57:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d5b:	6a 1d                	push   $0x1d
c0021d5d:	e9 a4 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d62 <intr1e_stub>:
c0021d62:	ff 34 24             	pushl  (%esp)
c0021d65:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d69:	6a 1e                	push   $0x1e
c0021d6b:	e9 96 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d70 <intr1f_stub>:
c0021d70:	55                   	push   %ebp
c0021d71:	6a 00                	push   $0x0
c0021d73:	6a 1f                	push   $0x1f
c0021d75:	e9 8c fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d7a <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0021d7a:	55                   	push   %ebp
c0021d7b:	6a 00                	push   $0x0
c0021d7d:	6a 20                	push   $0x20
c0021d7f:	e9 82 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d84 <intr21_stub>:
c0021d84:	55                   	push   %ebp
c0021d85:	6a 00                	push   $0x0
c0021d87:	6a 21                	push   $0x21
c0021d89:	e9 78 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d8e <intr22_stub>:
c0021d8e:	55                   	push   %ebp
c0021d8f:	6a 00                	push   $0x0
c0021d91:	6a 22                	push   $0x22
c0021d93:	e9 6e fe ff ff       	jmp    c0021c06 <intr_entry>

c0021d98 <intr23_stub>:
c0021d98:	55                   	push   %ebp
c0021d99:	6a 00                	push   $0x0
c0021d9b:	6a 23                	push   $0x23
c0021d9d:	e9 64 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021da2 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0021da2:	55                   	push   %ebp
c0021da3:	6a 00                	push   $0x0
c0021da5:	6a 24                	push   $0x24
c0021da7:	e9 5a fe ff ff       	jmp    c0021c06 <intr_entry>

c0021dac <intr25_stub>:
c0021dac:	55                   	push   %ebp
c0021dad:	6a 00                	push   $0x0
c0021daf:	6a 25                	push   $0x25
c0021db1:	e9 50 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021db6 <intr26_stub>:
c0021db6:	55                   	push   %ebp
c0021db7:	6a 00                	push   $0x0
c0021db9:	6a 26                	push   $0x26
c0021dbb:	e9 46 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021dc0 <intr27_stub>:
c0021dc0:	55                   	push   %ebp
c0021dc1:	6a 00                	push   $0x0
c0021dc3:	6a 27                	push   $0x27
c0021dc5:	e9 3c fe ff ff       	jmp    c0021c06 <intr_entry>

c0021dca <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c0021dca:	55                   	push   %ebp
c0021dcb:	6a 00                	push   $0x0
c0021dcd:	6a 28                	push   $0x28
c0021dcf:	e9 32 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021dd4 <intr29_stub>:
c0021dd4:	55                   	push   %ebp
c0021dd5:	6a 00                	push   $0x0
c0021dd7:	6a 29                	push   $0x29
c0021dd9:	e9 28 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021dde <intr2a_stub>:
c0021dde:	55                   	push   %ebp
c0021ddf:	6a 00                	push   $0x0
c0021de1:	6a 2a                	push   $0x2a
c0021de3:	e9 1e fe ff ff       	jmp    c0021c06 <intr_entry>

c0021de8 <intr2b_stub>:
c0021de8:	55                   	push   %ebp
c0021de9:	6a 00                	push   $0x0
c0021deb:	6a 2b                	push   $0x2b
c0021ded:	e9 14 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021df2 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c0021df2:	55                   	push   %ebp
c0021df3:	6a 00                	push   $0x0
c0021df5:	6a 2c                	push   $0x2c
c0021df7:	e9 0a fe ff ff       	jmp    c0021c06 <intr_entry>

c0021dfc <intr2d_stub>:
c0021dfc:	55                   	push   %ebp
c0021dfd:	6a 00                	push   $0x0
c0021dff:	6a 2d                	push   $0x2d
c0021e01:	e9 00 fe ff ff       	jmp    c0021c06 <intr_entry>

c0021e06 <intr2e_stub>:
c0021e06:	55                   	push   %ebp
c0021e07:	6a 00                	push   $0x0
c0021e09:	6a 2e                	push   $0x2e
c0021e0b:	e9 f6 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e10 <intr2f_stub>:
c0021e10:	55                   	push   %ebp
c0021e11:	6a 00                	push   $0x0
c0021e13:	6a 2f                	push   $0x2f
c0021e15:	e9 ec fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e1a <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c0021e1a:	55                   	push   %ebp
c0021e1b:	6a 00                	push   $0x0
c0021e1d:	6a 30                	push   $0x30
c0021e1f:	e9 e2 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e24 <intr31_stub>:
c0021e24:	55                   	push   %ebp
c0021e25:	6a 00                	push   $0x0
c0021e27:	6a 31                	push   $0x31
c0021e29:	e9 d8 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e2e <intr32_stub>:
c0021e2e:	55                   	push   %ebp
c0021e2f:	6a 00                	push   $0x0
c0021e31:	6a 32                	push   $0x32
c0021e33:	e9 ce fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e38 <intr33_stub>:
c0021e38:	55                   	push   %ebp
c0021e39:	6a 00                	push   $0x0
c0021e3b:	6a 33                	push   $0x33
c0021e3d:	e9 c4 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e42 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c0021e42:	55                   	push   %ebp
c0021e43:	6a 00                	push   $0x0
c0021e45:	6a 34                	push   $0x34
c0021e47:	e9 ba fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e4c <intr35_stub>:
c0021e4c:	55                   	push   %ebp
c0021e4d:	6a 00                	push   $0x0
c0021e4f:	6a 35                	push   $0x35
c0021e51:	e9 b0 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e56 <intr36_stub>:
c0021e56:	55                   	push   %ebp
c0021e57:	6a 00                	push   $0x0
c0021e59:	6a 36                	push   $0x36
c0021e5b:	e9 a6 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e60 <intr37_stub>:
c0021e60:	55                   	push   %ebp
c0021e61:	6a 00                	push   $0x0
c0021e63:	6a 37                	push   $0x37
c0021e65:	e9 9c fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e6a <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0021e6a:	55                   	push   %ebp
c0021e6b:	6a 00                	push   $0x0
c0021e6d:	6a 38                	push   $0x38
c0021e6f:	e9 92 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e74 <intr39_stub>:
c0021e74:	55                   	push   %ebp
c0021e75:	6a 00                	push   $0x0
c0021e77:	6a 39                	push   $0x39
c0021e79:	e9 88 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e7e <intr3a_stub>:
c0021e7e:	55                   	push   %ebp
c0021e7f:	6a 00                	push   $0x0
c0021e81:	6a 3a                	push   $0x3a
c0021e83:	e9 7e fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e88 <intr3b_stub>:
c0021e88:	55                   	push   %ebp
c0021e89:	6a 00                	push   $0x0
c0021e8b:	6a 3b                	push   $0x3b
c0021e8d:	e9 74 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e92 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0021e92:	55                   	push   %ebp
c0021e93:	6a 00                	push   $0x0
c0021e95:	6a 3c                	push   $0x3c
c0021e97:	e9 6a fd ff ff       	jmp    c0021c06 <intr_entry>

c0021e9c <intr3d_stub>:
c0021e9c:	55                   	push   %ebp
c0021e9d:	6a 00                	push   $0x0
c0021e9f:	6a 3d                	push   $0x3d
c0021ea1:	e9 60 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021ea6 <intr3e_stub>:
c0021ea6:	55                   	push   %ebp
c0021ea7:	6a 00                	push   $0x0
c0021ea9:	6a 3e                	push   $0x3e
c0021eab:	e9 56 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021eb0 <intr3f_stub>:
c0021eb0:	55                   	push   %ebp
c0021eb1:	6a 00                	push   $0x0
c0021eb3:	6a 3f                	push   $0x3f
c0021eb5:	e9 4c fd ff ff       	jmp    c0021c06 <intr_entry>

c0021eba <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c0021eba:	55                   	push   %ebp
c0021ebb:	6a 00                	push   $0x0
c0021ebd:	6a 40                	push   $0x40
c0021ebf:	e9 42 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021ec4 <intr41_stub>:
c0021ec4:	55                   	push   %ebp
c0021ec5:	6a 00                	push   $0x0
c0021ec7:	6a 41                	push   $0x41
c0021ec9:	e9 38 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021ece <intr42_stub>:
c0021ece:	55                   	push   %ebp
c0021ecf:	6a 00                	push   $0x0
c0021ed1:	6a 42                	push   $0x42
c0021ed3:	e9 2e fd ff ff       	jmp    c0021c06 <intr_entry>

c0021ed8 <intr43_stub>:
c0021ed8:	55                   	push   %ebp
c0021ed9:	6a 00                	push   $0x0
c0021edb:	6a 43                	push   $0x43
c0021edd:	e9 24 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021ee2 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c0021ee2:	55                   	push   %ebp
c0021ee3:	6a 00                	push   $0x0
c0021ee5:	6a 44                	push   $0x44
c0021ee7:	e9 1a fd ff ff       	jmp    c0021c06 <intr_entry>

c0021eec <intr45_stub>:
c0021eec:	55                   	push   %ebp
c0021eed:	6a 00                	push   $0x0
c0021eef:	6a 45                	push   $0x45
c0021ef1:	e9 10 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021ef6 <intr46_stub>:
c0021ef6:	55                   	push   %ebp
c0021ef7:	6a 00                	push   $0x0
c0021ef9:	6a 46                	push   $0x46
c0021efb:	e9 06 fd ff ff       	jmp    c0021c06 <intr_entry>

c0021f00 <intr47_stub>:
c0021f00:	55                   	push   %ebp
c0021f01:	6a 00                	push   $0x0
c0021f03:	6a 47                	push   $0x47
c0021f05:	e9 fc fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f0a <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c0021f0a:	55                   	push   %ebp
c0021f0b:	6a 00                	push   $0x0
c0021f0d:	6a 48                	push   $0x48
c0021f0f:	e9 f2 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f14 <intr49_stub>:
c0021f14:	55                   	push   %ebp
c0021f15:	6a 00                	push   $0x0
c0021f17:	6a 49                	push   $0x49
c0021f19:	e9 e8 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f1e <intr4a_stub>:
c0021f1e:	55                   	push   %ebp
c0021f1f:	6a 00                	push   $0x0
c0021f21:	6a 4a                	push   $0x4a
c0021f23:	e9 de fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f28 <intr4b_stub>:
c0021f28:	55                   	push   %ebp
c0021f29:	6a 00                	push   $0x0
c0021f2b:	6a 4b                	push   $0x4b
c0021f2d:	e9 d4 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f32 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c0021f32:	55                   	push   %ebp
c0021f33:	6a 00                	push   $0x0
c0021f35:	6a 4c                	push   $0x4c
c0021f37:	e9 ca fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f3c <intr4d_stub>:
c0021f3c:	55                   	push   %ebp
c0021f3d:	6a 00                	push   $0x0
c0021f3f:	6a 4d                	push   $0x4d
c0021f41:	e9 c0 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f46 <intr4e_stub>:
c0021f46:	55                   	push   %ebp
c0021f47:	6a 00                	push   $0x0
c0021f49:	6a 4e                	push   $0x4e
c0021f4b:	e9 b6 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f50 <intr4f_stub>:
c0021f50:	55                   	push   %ebp
c0021f51:	6a 00                	push   $0x0
c0021f53:	6a 4f                	push   $0x4f
c0021f55:	e9 ac fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f5a <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0021f5a:	55                   	push   %ebp
c0021f5b:	6a 00                	push   $0x0
c0021f5d:	6a 50                	push   $0x50
c0021f5f:	e9 a2 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f64 <intr51_stub>:
c0021f64:	55                   	push   %ebp
c0021f65:	6a 00                	push   $0x0
c0021f67:	6a 51                	push   $0x51
c0021f69:	e9 98 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f6e <intr52_stub>:
c0021f6e:	55                   	push   %ebp
c0021f6f:	6a 00                	push   $0x0
c0021f71:	6a 52                	push   $0x52
c0021f73:	e9 8e fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f78 <intr53_stub>:
c0021f78:	55                   	push   %ebp
c0021f79:	6a 00                	push   $0x0
c0021f7b:	6a 53                	push   $0x53
c0021f7d:	e9 84 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f82 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c0021f82:	55                   	push   %ebp
c0021f83:	6a 00                	push   $0x0
c0021f85:	6a 54                	push   $0x54
c0021f87:	e9 7a fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f8c <intr55_stub>:
c0021f8c:	55                   	push   %ebp
c0021f8d:	6a 00                	push   $0x0
c0021f8f:	6a 55                	push   $0x55
c0021f91:	e9 70 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021f96 <intr56_stub>:
c0021f96:	55                   	push   %ebp
c0021f97:	6a 00                	push   $0x0
c0021f99:	6a 56                	push   $0x56
c0021f9b:	e9 66 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021fa0 <intr57_stub>:
c0021fa0:	55                   	push   %ebp
c0021fa1:	6a 00                	push   $0x0
c0021fa3:	6a 57                	push   $0x57
c0021fa5:	e9 5c fc ff ff       	jmp    c0021c06 <intr_entry>

c0021faa <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c0021faa:	55                   	push   %ebp
c0021fab:	6a 00                	push   $0x0
c0021fad:	6a 58                	push   $0x58
c0021faf:	e9 52 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021fb4 <intr59_stub>:
c0021fb4:	55                   	push   %ebp
c0021fb5:	6a 00                	push   $0x0
c0021fb7:	6a 59                	push   $0x59
c0021fb9:	e9 48 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021fbe <intr5a_stub>:
c0021fbe:	55                   	push   %ebp
c0021fbf:	6a 00                	push   $0x0
c0021fc1:	6a 5a                	push   $0x5a
c0021fc3:	e9 3e fc ff ff       	jmp    c0021c06 <intr_entry>

c0021fc8 <intr5b_stub>:
c0021fc8:	55                   	push   %ebp
c0021fc9:	6a 00                	push   $0x0
c0021fcb:	6a 5b                	push   $0x5b
c0021fcd:	e9 34 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021fd2 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c0021fd2:	55                   	push   %ebp
c0021fd3:	6a 00                	push   $0x0
c0021fd5:	6a 5c                	push   $0x5c
c0021fd7:	e9 2a fc ff ff       	jmp    c0021c06 <intr_entry>

c0021fdc <intr5d_stub>:
c0021fdc:	55                   	push   %ebp
c0021fdd:	6a 00                	push   $0x0
c0021fdf:	6a 5d                	push   $0x5d
c0021fe1:	e9 20 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021fe6 <intr5e_stub>:
c0021fe6:	55                   	push   %ebp
c0021fe7:	6a 00                	push   $0x0
c0021fe9:	6a 5e                	push   $0x5e
c0021feb:	e9 16 fc ff ff       	jmp    c0021c06 <intr_entry>

c0021ff0 <intr5f_stub>:
c0021ff0:	55                   	push   %ebp
c0021ff1:	6a 00                	push   $0x0
c0021ff3:	6a 5f                	push   $0x5f
c0021ff5:	e9 0c fc ff ff       	jmp    c0021c06 <intr_entry>

c0021ffa <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c0021ffa:	55                   	push   %ebp
c0021ffb:	6a 00                	push   $0x0
c0021ffd:	6a 60                	push   $0x60
c0021fff:	e9 02 fc ff ff       	jmp    c0021c06 <intr_entry>

c0022004 <intr61_stub>:
c0022004:	55                   	push   %ebp
c0022005:	6a 00                	push   $0x0
c0022007:	6a 61                	push   $0x61
c0022009:	e9 f8 fb ff ff       	jmp    c0021c06 <intr_entry>

c002200e <intr62_stub>:
c002200e:	55                   	push   %ebp
c002200f:	6a 00                	push   $0x0
c0022011:	6a 62                	push   $0x62
c0022013:	e9 ee fb ff ff       	jmp    c0021c06 <intr_entry>

c0022018 <intr63_stub>:
c0022018:	55                   	push   %ebp
c0022019:	6a 00                	push   $0x0
c002201b:	6a 63                	push   $0x63
c002201d:	e9 e4 fb ff ff       	jmp    c0021c06 <intr_entry>

c0022022 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c0022022:	55                   	push   %ebp
c0022023:	6a 00                	push   $0x0
c0022025:	6a 64                	push   $0x64
c0022027:	e9 da fb ff ff       	jmp    c0021c06 <intr_entry>

c002202c <intr65_stub>:
c002202c:	55                   	push   %ebp
c002202d:	6a 00                	push   $0x0
c002202f:	6a 65                	push   $0x65
c0022031:	e9 d0 fb ff ff       	jmp    c0021c06 <intr_entry>

c0022036 <intr66_stub>:
c0022036:	55                   	push   %ebp
c0022037:	6a 00                	push   $0x0
c0022039:	6a 66                	push   $0x66
c002203b:	e9 c6 fb ff ff       	jmp    c0021c06 <intr_entry>

c0022040 <intr67_stub>:
c0022040:	55                   	push   %ebp
c0022041:	6a 00                	push   $0x0
c0022043:	6a 67                	push   $0x67
c0022045:	e9 bc fb ff ff       	jmp    c0021c06 <intr_entry>

c002204a <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c002204a:	55                   	push   %ebp
c002204b:	6a 00                	push   $0x0
c002204d:	6a 68                	push   $0x68
c002204f:	e9 b2 fb ff ff       	jmp    c0021c06 <intr_entry>

c0022054 <intr69_stub>:
c0022054:	55                   	push   %ebp
c0022055:	6a 00                	push   $0x0
c0022057:	6a 69                	push   $0x69
c0022059:	e9 a8 fb ff ff       	jmp    c0021c06 <intr_entry>

c002205e <intr6a_stub>:
c002205e:	55                   	push   %ebp
c002205f:	6a 00                	push   $0x0
c0022061:	6a 6a                	push   $0x6a
c0022063:	e9 9e fb ff ff       	jmp    c0021c06 <intr_entry>

c0022068 <intr6b_stub>:
c0022068:	55                   	push   %ebp
c0022069:	6a 00                	push   $0x0
c002206b:	6a 6b                	push   $0x6b
c002206d:	e9 94 fb ff ff       	jmp    c0021c06 <intr_entry>

c0022072 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0022072:	55                   	push   %ebp
c0022073:	6a 00                	push   $0x0
c0022075:	6a 6c                	push   $0x6c
c0022077:	e9 8a fb ff ff       	jmp    c0021c06 <intr_entry>

c002207c <intr6d_stub>:
c002207c:	55                   	push   %ebp
c002207d:	6a 00                	push   $0x0
c002207f:	6a 6d                	push   $0x6d
c0022081:	e9 80 fb ff ff       	jmp    c0021c06 <intr_entry>

c0022086 <intr6e_stub>:
c0022086:	55                   	push   %ebp
c0022087:	6a 00                	push   $0x0
c0022089:	6a 6e                	push   $0x6e
c002208b:	e9 76 fb ff ff       	jmp    c0021c06 <intr_entry>

c0022090 <intr6f_stub>:
c0022090:	55                   	push   %ebp
c0022091:	6a 00                	push   $0x0
c0022093:	6a 6f                	push   $0x6f
c0022095:	e9 6c fb ff ff       	jmp    c0021c06 <intr_entry>

c002209a <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c002209a:	55                   	push   %ebp
c002209b:	6a 00                	push   $0x0
c002209d:	6a 70                	push   $0x70
c002209f:	e9 62 fb ff ff       	jmp    c0021c06 <intr_entry>

c00220a4 <intr71_stub>:
c00220a4:	55                   	push   %ebp
c00220a5:	6a 00                	push   $0x0
c00220a7:	6a 71                	push   $0x71
c00220a9:	e9 58 fb ff ff       	jmp    c0021c06 <intr_entry>

c00220ae <intr72_stub>:
c00220ae:	55                   	push   %ebp
c00220af:	6a 00                	push   $0x0
c00220b1:	6a 72                	push   $0x72
c00220b3:	e9 4e fb ff ff       	jmp    c0021c06 <intr_entry>

c00220b8 <intr73_stub>:
c00220b8:	55                   	push   %ebp
c00220b9:	6a 00                	push   $0x0
c00220bb:	6a 73                	push   $0x73
c00220bd:	e9 44 fb ff ff       	jmp    c0021c06 <intr_entry>

c00220c2 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c00220c2:	55                   	push   %ebp
c00220c3:	6a 00                	push   $0x0
c00220c5:	6a 74                	push   $0x74
c00220c7:	e9 3a fb ff ff       	jmp    c0021c06 <intr_entry>

c00220cc <intr75_stub>:
c00220cc:	55                   	push   %ebp
c00220cd:	6a 00                	push   $0x0
c00220cf:	6a 75                	push   $0x75
c00220d1:	e9 30 fb ff ff       	jmp    c0021c06 <intr_entry>

c00220d6 <intr76_stub>:
c00220d6:	55                   	push   %ebp
c00220d7:	6a 00                	push   $0x0
c00220d9:	6a 76                	push   $0x76
c00220db:	e9 26 fb ff ff       	jmp    c0021c06 <intr_entry>

c00220e0 <intr77_stub>:
c00220e0:	55                   	push   %ebp
c00220e1:	6a 00                	push   $0x0
c00220e3:	6a 77                	push   $0x77
c00220e5:	e9 1c fb ff ff       	jmp    c0021c06 <intr_entry>

c00220ea <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c00220ea:	55                   	push   %ebp
c00220eb:	6a 00                	push   $0x0
c00220ed:	6a 78                	push   $0x78
c00220ef:	e9 12 fb ff ff       	jmp    c0021c06 <intr_entry>

c00220f4 <intr79_stub>:
c00220f4:	55                   	push   %ebp
c00220f5:	6a 00                	push   $0x0
c00220f7:	6a 79                	push   $0x79
c00220f9:	e9 08 fb ff ff       	jmp    c0021c06 <intr_entry>

c00220fe <intr7a_stub>:
c00220fe:	55                   	push   %ebp
c00220ff:	6a 00                	push   $0x0
c0022101:	6a 7a                	push   $0x7a
c0022103:	e9 fe fa ff ff       	jmp    c0021c06 <intr_entry>

c0022108 <intr7b_stub>:
c0022108:	55                   	push   %ebp
c0022109:	6a 00                	push   $0x0
c002210b:	6a 7b                	push   $0x7b
c002210d:	e9 f4 fa ff ff       	jmp    c0021c06 <intr_entry>

c0022112 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c0022112:	55                   	push   %ebp
c0022113:	6a 00                	push   $0x0
c0022115:	6a 7c                	push   $0x7c
c0022117:	e9 ea fa ff ff       	jmp    c0021c06 <intr_entry>

c002211c <intr7d_stub>:
c002211c:	55                   	push   %ebp
c002211d:	6a 00                	push   $0x0
c002211f:	6a 7d                	push   $0x7d
c0022121:	e9 e0 fa ff ff       	jmp    c0021c06 <intr_entry>

c0022126 <intr7e_stub>:
c0022126:	55                   	push   %ebp
c0022127:	6a 00                	push   $0x0
c0022129:	6a 7e                	push   $0x7e
c002212b:	e9 d6 fa ff ff       	jmp    c0021c06 <intr_entry>

c0022130 <intr7f_stub>:
c0022130:	55                   	push   %ebp
c0022131:	6a 00                	push   $0x0
c0022133:	6a 7f                	push   $0x7f
c0022135:	e9 cc fa ff ff       	jmp    c0021c06 <intr_entry>

c002213a <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c002213a:	55                   	push   %ebp
c002213b:	6a 00                	push   $0x0
c002213d:	68 80 00 00 00       	push   $0x80
c0022142:	e9 bf fa ff ff       	jmp    c0021c06 <intr_entry>

c0022147 <intr81_stub>:
c0022147:	55                   	push   %ebp
c0022148:	6a 00                	push   $0x0
c002214a:	68 81 00 00 00       	push   $0x81
c002214f:	e9 b2 fa ff ff       	jmp    c0021c06 <intr_entry>

c0022154 <intr82_stub>:
c0022154:	55                   	push   %ebp
c0022155:	6a 00                	push   $0x0
c0022157:	68 82 00 00 00       	push   $0x82
c002215c:	e9 a5 fa ff ff       	jmp    c0021c06 <intr_entry>

c0022161 <intr83_stub>:
c0022161:	55                   	push   %ebp
c0022162:	6a 00                	push   $0x0
c0022164:	68 83 00 00 00       	push   $0x83
c0022169:	e9 98 fa ff ff       	jmp    c0021c06 <intr_entry>

c002216e <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c002216e:	55                   	push   %ebp
c002216f:	6a 00                	push   $0x0
c0022171:	68 84 00 00 00       	push   $0x84
c0022176:	e9 8b fa ff ff       	jmp    c0021c06 <intr_entry>

c002217b <intr85_stub>:
c002217b:	55                   	push   %ebp
c002217c:	6a 00                	push   $0x0
c002217e:	68 85 00 00 00       	push   $0x85
c0022183:	e9 7e fa ff ff       	jmp    c0021c06 <intr_entry>

c0022188 <intr86_stub>:
c0022188:	55                   	push   %ebp
c0022189:	6a 00                	push   $0x0
c002218b:	68 86 00 00 00       	push   $0x86
c0022190:	e9 71 fa ff ff       	jmp    c0021c06 <intr_entry>

c0022195 <intr87_stub>:
c0022195:	55                   	push   %ebp
c0022196:	6a 00                	push   $0x0
c0022198:	68 87 00 00 00       	push   $0x87
c002219d:	e9 64 fa ff ff       	jmp    c0021c06 <intr_entry>

c00221a2 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c00221a2:	55                   	push   %ebp
c00221a3:	6a 00                	push   $0x0
c00221a5:	68 88 00 00 00       	push   $0x88
c00221aa:	e9 57 fa ff ff       	jmp    c0021c06 <intr_entry>

c00221af <intr89_stub>:
c00221af:	55                   	push   %ebp
c00221b0:	6a 00                	push   $0x0
c00221b2:	68 89 00 00 00       	push   $0x89
c00221b7:	e9 4a fa ff ff       	jmp    c0021c06 <intr_entry>

c00221bc <intr8a_stub>:
c00221bc:	55                   	push   %ebp
c00221bd:	6a 00                	push   $0x0
c00221bf:	68 8a 00 00 00       	push   $0x8a
c00221c4:	e9 3d fa ff ff       	jmp    c0021c06 <intr_entry>

c00221c9 <intr8b_stub>:
c00221c9:	55                   	push   %ebp
c00221ca:	6a 00                	push   $0x0
c00221cc:	68 8b 00 00 00       	push   $0x8b
c00221d1:	e9 30 fa ff ff       	jmp    c0021c06 <intr_entry>

c00221d6 <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c00221d6:	55                   	push   %ebp
c00221d7:	6a 00                	push   $0x0
c00221d9:	68 8c 00 00 00       	push   $0x8c
c00221de:	e9 23 fa ff ff       	jmp    c0021c06 <intr_entry>

c00221e3 <intr8d_stub>:
c00221e3:	55                   	push   %ebp
c00221e4:	6a 00                	push   $0x0
c00221e6:	68 8d 00 00 00       	push   $0x8d
c00221eb:	e9 16 fa ff ff       	jmp    c0021c06 <intr_entry>

c00221f0 <intr8e_stub>:
c00221f0:	55                   	push   %ebp
c00221f1:	6a 00                	push   $0x0
c00221f3:	68 8e 00 00 00       	push   $0x8e
c00221f8:	e9 09 fa ff ff       	jmp    c0021c06 <intr_entry>

c00221fd <intr8f_stub>:
c00221fd:	55                   	push   %ebp
c00221fe:	6a 00                	push   $0x0
c0022200:	68 8f 00 00 00       	push   $0x8f
c0022205:	e9 fc f9 ff ff       	jmp    c0021c06 <intr_entry>

c002220a <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c002220a:	55                   	push   %ebp
c002220b:	6a 00                	push   $0x0
c002220d:	68 90 00 00 00       	push   $0x90
c0022212:	e9 ef f9 ff ff       	jmp    c0021c06 <intr_entry>

c0022217 <intr91_stub>:
c0022217:	55                   	push   %ebp
c0022218:	6a 00                	push   $0x0
c002221a:	68 91 00 00 00       	push   $0x91
c002221f:	e9 e2 f9 ff ff       	jmp    c0021c06 <intr_entry>

c0022224 <intr92_stub>:
c0022224:	55                   	push   %ebp
c0022225:	6a 00                	push   $0x0
c0022227:	68 92 00 00 00       	push   $0x92
c002222c:	e9 d5 f9 ff ff       	jmp    c0021c06 <intr_entry>

c0022231 <intr93_stub>:
c0022231:	55                   	push   %ebp
c0022232:	6a 00                	push   $0x0
c0022234:	68 93 00 00 00       	push   $0x93
c0022239:	e9 c8 f9 ff ff       	jmp    c0021c06 <intr_entry>

c002223e <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c002223e:	55                   	push   %ebp
c002223f:	6a 00                	push   $0x0
c0022241:	68 94 00 00 00       	push   $0x94
c0022246:	e9 bb f9 ff ff       	jmp    c0021c06 <intr_entry>

c002224b <intr95_stub>:
c002224b:	55                   	push   %ebp
c002224c:	6a 00                	push   $0x0
c002224e:	68 95 00 00 00       	push   $0x95
c0022253:	e9 ae f9 ff ff       	jmp    c0021c06 <intr_entry>

c0022258 <intr96_stub>:
c0022258:	55                   	push   %ebp
c0022259:	6a 00                	push   $0x0
c002225b:	68 96 00 00 00       	push   $0x96
c0022260:	e9 a1 f9 ff ff       	jmp    c0021c06 <intr_entry>

c0022265 <intr97_stub>:
c0022265:	55                   	push   %ebp
c0022266:	6a 00                	push   $0x0
c0022268:	68 97 00 00 00       	push   $0x97
c002226d:	e9 94 f9 ff ff       	jmp    c0021c06 <intr_entry>

c0022272 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022272:	55                   	push   %ebp
c0022273:	6a 00                	push   $0x0
c0022275:	68 98 00 00 00       	push   $0x98
c002227a:	e9 87 f9 ff ff       	jmp    c0021c06 <intr_entry>

c002227f <intr99_stub>:
c002227f:	55                   	push   %ebp
c0022280:	6a 00                	push   $0x0
c0022282:	68 99 00 00 00       	push   $0x99
c0022287:	e9 7a f9 ff ff       	jmp    c0021c06 <intr_entry>

c002228c <intr9a_stub>:
c002228c:	55                   	push   %ebp
c002228d:	6a 00                	push   $0x0
c002228f:	68 9a 00 00 00       	push   $0x9a
c0022294:	e9 6d f9 ff ff       	jmp    c0021c06 <intr_entry>

c0022299 <intr9b_stub>:
c0022299:	55                   	push   %ebp
c002229a:	6a 00                	push   $0x0
c002229c:	68 9b 00 00 00       	push   $0x9b
c00222a1:	e9 60 f9 ff ff       	jmp    c0021c06 <intr_entry>

c00222a6 <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c00222a6:	55                   	push   %ebp
c00222a7:	6a 00                	push   $0x0
c00222a9:	68 9c 00 00 00       	push   $0x9c
c00222ae:	e9 53 f9 ff ff       	jmp    c0021c06 <intr_entry>

c00222b3 <intr9d_stub>:
c00222b3:	55                   	push   %ebp
c00222b4:	6a 00                	push   $0x0
c00222b6:	68 9d 00 00 00       	push   $0x9d
c00222bb:	e9 46 f9 ff ff       	jmp    c0021c06 <intr_entry>

c00222c0 <intr9e_stub>:
c00222c0:	55                   	push   %ebp
c00222c1:	6a 00                	push   $0x0
c00222c3:	68 9e 00 00 00       	push   $0x9e
c00222c8:	e9 39 f9 ff ff       	jmp    c0021c06 <intr_entry>

c00222cd <intr9f_stub>:
c00222cd:	55                   	push   %ebp
c00222ce:	6a 00                	push   $0x0
c00222d0:	68 9f 00 00 00       	push   $0x9f
c00222d5:	e9 2c f9 ff ff       	jmp    c0021c06 <intr_entry>

c00222da <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c00222da:	55                   	push   %ebp
c00222db:	6a 00                	push   $0x0
c00222dd:	68 a0 00 00 00       	push   $0xa0
c00222e2:	e9 1f f9 ff ff       	jmp    c0021c06 <intr_entry>

c00222e7 <intra1_stub>:
c00222e7:	55                   	push   %ebp
c00222e8:	6a 00                	push   $0x0
c00222ea:	68 a1 00 00 00       	push   $0xa1
c00222ef:	e9 12 f9 ff ff       	jmp    c0021c06 <intr_entry>

c00222f4 <intra2_stub>:
c00222f4:	55                   	push   %ebp
c00222f5:	6a 00                	push   $0x0
c00222f7:	68 a2 00 00 00       	push   $0xa2
c00222fc:	e9 05 f9 ff ff       	jmp    c0021c06 <intr_entry>

c0022301 <intra3_stub>:
c0022301:	55                   	push   %ebp
c0022302:	6a 00                	push   $0x0
c0022304:	68 a3 00 00 00       	push   $0xa3
c0022309:	e9 f8 f8 ff ff       	jmp    c0021c06 <intr_entry>

c002230e <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c002230e:	55                   	push   %ebp
c002230f:	6a 00                	push   $0x0
c0022311:	68 a4 00 00 00       	push   $0xa4
c0022316:	e9 eb f8 ff ff       	jmp    c0021c06 <intr_entry>

c002231b <intra5_stub>:
c002231b:	55                   	push   %ebp
c002231c:	6a 00                	push   $0x0
c002231e:	68 a5 00 00 00       	push   $0xa5
c0022323:	e9 de f8 ff ff       	jmp    c0021c06 <intr_entry>

c0022328 <intra6_stub>:
c0022328:	55                   	push   %ebp
c0022329:	6a 00                	push   $0x0
c002232b:	68 a6 00 00 00       	push   $0xa6
c0022330:	e9 d1 f8 ff ff       	jmp    c0021c06 <intr_entry>

c0022335 <intra7_stub>:
c0022335:	55                   	push   %ebp
c0022336:	6a 00                	push   $0x0
c0022338:	68 a7 00 00 00       	push   $0xa7
c002233d:	e9 c4 f8 ff ff       	jmp    c0021c06 <intr_entry>

c0022342 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c0022342:	55                   	push   %ebp
c0022343:	6a 00                	push   $0x0
c0022345:	68 a8 00 00 00       	push   $0xa8
c002234a:	e9 b7 f8 ff ff       	jmp    c0021c06 <intr_entry>

c002234f <intra9_stub>:
c002234f:	55                   	push   %ebp
c0022350:	6a 00                	push   $0x0
c0022352:	68 a9 00 00 00       	push   $0xa9
c0022357:	e9 aa f8 ff ff       	jmp    c0021c06 <intr_entry>

c002235c <intraa_stub>:
c002235c:	55                   	push   %ebp
c002235d:	6a 00                	push   $0x0
c002235f:	68 aa 00 00 00       	push   $0xaa
c0022364:	e9 9d f8 ff ff       	jmp    c0021c06 <intr_entry>

c0022369 <intrab_stub>:
c0022369:	55                   	push   %ebp
c002236a:	6a 00                	push   $0x0
c002236c:	68 ab 00 00 00       	push   $0xab
c0022371:	e9 90 f8 ff ff       	jmp    c0021c06 <intr_entry>

c0022376 <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c0022376:	55                   	push   %ebp
c0022377:	6a 00                	push   $0x0
c0022379:	68 ac 00 00 00       	push   $0xac
c002237e:	e9 83 f8 ff ff       	jmp    c0021c06 <intr_entry>

c0022383 <intrad_stub>:
c0022383:	55                   	push   %ebp
c0022384:	6a 00                	push   $0x0
c0022386:	68 ad 00 00 00       	push   $0xad
c002238b:	e9 76 f8 ff ff       	jmp    c0021c06 <intr_entry>

c0022390 <intrae_stub>:
c0022390:	55                   	push   %ebp
c0022391:	6a 00                	push   $0x0
c0022393:	68 ae 00 00 00       	push   $0xae
c0022398:	e9 69 f8 ff ff       	jmp    c0021c06 <intr_entry>

c002239d <intraf_stub>:
c002239d:	55                   	push   %ebp
c002239e:	6a 00                	push   $0x0
c00223a0:	68 af 00 00 00       	push   $0xaf
c00223a5:	e9 5c f8 ff ff       	jmp    c0021c06 <intr_entry>

c00223aa <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c00223aa:	55                   	push   %ebp
c00223ab:	6a 00                	push   $0x0
c00223ad:	68 b0 00 00 00       	push   $0xb0
c00223b2:	e9 4f f8 ff ff       	jmp    c0021c06 <intr_entry>

c00223b7 <intrb1_stub>:
c00223b7:	55                   	push   %ebp
c00223b8:	6a 00                	push   $0x0
c00223ba:	68 b1 00 00 00       	push   $0xb1
c00223bf:	e9 42 f8 ff ff       	jmp    c0021c06 <intr_entry>

c00223c4 <intrb2_stub>:
c00223c4:	55                   	push   %ebp
c00223c5:	6a 00                	push   $0x0
c00223c7:	68 b2 00 00 00       	push   $0xb2
c00223cc:	e9 35 f8 ff ff       	jmp    c0021c06 <intr_entry>

c00223d1 <intrb3_stub>:
c00223d1:	55                   	push   %ebp
c00223d2:	6a 00                	push   $0x0
c00223d4:	68 b3 00 00 00       	push   $0xb3
c00223d9:	e9 28 f8 ff ff       	jmp    c0021c06 <intr_entry>

c00223de <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c00223de:	55                   	push   %ebp
c00223df:	6a 00                	push   $0x0
c00223e1:	68 b4 00 00 00       	push   $0xb4
c00223e6:	e9 1b f8 ff ff       	jmp    c0021c06 <intr_entry>

c00223eb <intrb5_stub>:
c00223eb:	55                   	push   %ebp
c00223ec:	6a 00                	push   $0x0
c00223ee:	68 b5 00 00 00       	push   $0xb5
c00223f3:	e9 0e f8 ff ff       	jmp    c0021c06 <intr_entry>

c00223f8 <intrb6_stub>:
c00223f8:	55                   	push   %ebp
c00223f9:	6a 00                	push   $0x0
c00223fb:	68 b6 00 00 00       	push   $0xb6
c0022400:	e9 01 f8 ff ff       	jmp    c0021c06 <intr_entry>

c0022405 <intrb7_stub>:
c0022405:	55                   	push   %ebp
c0022406:	6a 00                	push   $0x0
c0022408:	68 b7 00 00 00       	push   $0xb7
c002240d:	e9 f4 f7 ff ff       	jmp    c0021c06 <intr_entry>

c0022412 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c0022412:	55                   	push   %ebp
c0022413:	6a 00                	push   $0x0
c0022415:	68 b8 00 00 00       	push   $0xb8
c002241a:	e9 e7 f7 ff ff       	jmp    c0021c06 <intr_entry>

c002241f <intrb9_stub>:
c002241f:	55                   	push   %ebp
c0022420:	6a 00                	push   $0x0
c0022422:	68 b9 00 00 00       	push   $0xb9
c0022427:	e9 da f7 ff ff       	jmp    c0021c06 <intr_entry>

c002242c <intrba_stub>:
c002242c:	55                   	push   %ebp
c002242d:	6a 00                	push   $0x0
c002242f:	68 ba 00 00 00       	push   $0xba
c0022434:	e9 cd f7 ff ff       	jmp    c0021c06 <intr_entry>

c0022439 <intrbb_stub>:
c0022439:	55                   	push   %ebp
c002243a:	6a 00                	push   $0x0
c002243c:	68 bb 00 00 00       	push   $0xbb
c0022441:	e9 c0 f7 ff ff       	jmp    c0021c06 <intr_entry>

c0022446 <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c0022446:	55                   	push   %ebp
c0022447:	6a 00                	push   $0x0
c0022449:	68 bc 00 00 00       	push   $0xbc
c002244e:	e9 b3 f7 ff ff       	jmp    c0021c06 <intr_entry>

c0022453 <intrbd_stub>:
c0022453:	55                   	push   %ebp
c0022454:	6a 00                	push   $0x0
c0022456:	68 bd 00 00 00       	push   $0xbd
c002245b:	e9 a6 f7 ff ff       	jmp    c0021c06 <intr_entry>

c0022460 <intrbe_stub>:
c0022460:	55                   	push   %ebp
c0022461:	6a 00                	push   $0x0
c0022463:	68 be 00 00 00       	push   $0xbe
c0022468:	e9 99 f7 ff ff       	jmp    c0021c06 <intr_entry>

c002246d <intrbf_stub>:
c002246d:	55                   	push   %ebp
c002246e:	6a 00                	push   $0x0
c0022470:	68 bf 00 00 00       	push   $0xbf
c0022475:	e9 8c f7 ff ff       	jmp    c0021c06 <intr_entry>

c002247a <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c002247a:	55                   	push   %ebp
c002247b:	6a 00                	push   $0x0
c002247d:	68 c0 00 00 00       	push   $0xc0
c0022482:	e9 7f f7 ff ff       	jmp    c0021c06 <intr_entry>

c0022487 <intrc1_stub>:
c0022487:	55                   	push   %ebp
c0022488:	6a 00                	push   $0x0
c002248a:	68 c1 00 00 00       	push   $0xc1
c002248f:	e9 72 f7 ff ff       	jmp    c0021c06 <intr_entry>

c0022494 <intrc2_stub>:
c0022494:	55                   	push   %ebp
c0022495:	6a 00                	push   $0x0
c0022497:	68 c2 00 00 00       	push   $0xc2
c002249c:	e9 65 f7 ff ff       	jmp    c0021c06 <intr_entry>

c00224a1 <intrc3_stub>:
c00224a1:	55                   	push   %ebp
c00224a2:	6a 00                	push   $0x0
c00224a4:	68 c3 00 00 00       	push   $0xc3
c00224a9:	e9 58 f7 ff ff       	jmp    c0021c06 <intr_entry>

c00224ae <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c00224ae:	55                   	push   %ebp
c00224af:	6a 00                	push   $0x0
c00224b1:	68 c4 00 00 00       	push   $0xc4
c00224b6:	e9 4b f7 ff ff       	jmp    c0021c06 <intr_entry>

c00224bb <intrc5_stub>:
c00224bb:	55                   	push   %ebp
c00224bc:	6a 00                	push   $0x0
c00224be:	68 c5 00 00 00       	push   $0xc5
c00224c3:	e9 3e f7 ff ff       	jmp    c0021c06 <intr_entry>

c00224c8 <intrc6_stub>:
c00224c8:	55                   	push   %ebp
c00224c9:	6a 00                	push   $0x0
c00224cb:	68 c6 00 00 00       	push   $0xc6
c00224d0:	e9 31 f7 ff ff       	jmp    c0021c06 <intr_entry>

c00224d5 <intrc7_stub>:
c00224d5:	55                   	push   %ebp
c00224d6:	6a 00                	push   $0x0
c00224d8:	68 c7 00 00 00       	push   $0xc7
c00224dd:	e9 24 f7 ff ff       	jmp    c0021c06 <intr_entry>

c00224e2 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c00224e2:	55                   	push   %ebp
c00224e3:	6a 00                	push   $0x0
c00224e5:	68 c8 00 00 00       	push   $0xc8
c00224ea:	e9 17 f7 ff ff       	jmp    c0021c06 <intr_entry>

c00224ef <intrc9_stub>:
c00224ef:	55                   	push   %ebp
c00224f0:	6a 00                	push   $0x0
c00224f2:	68 c9 00 00 00       	push   $0xc9
c00224f7:	e9 0a f7 ff ff       	jmp    c0021c06 <intr_entry>

c00224fc <intrca_stub>:
c00224fc:	55                   	push   %ebp
c00224fd:	6a 00                	push   $0x0
c00224ff:	68 ca 00 00 00       	push   $0xca
c0022504:	e9 fd f6 ff ff       	jmp    c0021c06 <intr_entry>

c0022509 <intrcb_stub>:
c0022509:	55                   	push   %ebp
c002250a:	6a 00                	push   $0x0
c002250c:	68 cb 00 00 00       	push   $0xcb
c0022511:	e9 f0 f6 ff ff       	jmp    c0021c06 <intr_entry>

c0022516 <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c0022516:	55                   	push   %ebp
c0022517:	6a 00                	push   $0x0
c0022519:	68 cc 00 00 00       	push   $0xcc
c002251e:	e9 e3 f6 ff ff       	jmp    c0021c06 <intr_entry>

c0022523 <intrcd_stub>:
c0022523:	55                   	push   %ebp
c0022524:	6a 00                	push   $0x0
c0022526:	68 cd 00 00 00       	push   $0xcd
c002252b:	e9 d6 f6 ff ff       	jmp    c0021c06 <intr_entry>

c0022530 <intrce_stub>:
c0022530:	55                   	push   %ebp
c0022531:	6a 00                	push   $0x0
c0022533:	68 ce 00 00 00       	push   $0xce
c0022538:	e9 c9 f6 ff ff       	jmp    c0021c06 <intr_entry>

c002253d <intrcf_stub>:
c002253d:	55                   	push   %ebp
c002253e:	6a 00                	push   $0x0
c0022540:	68 cf 00 00 00       	push   $0xcf
c0022545:	e9 bc f6 ff ff       	jmp    c0021c06 <intr_entry>

c002254a <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c002254a:	55                   	push   %ebp
c002254b:	6a 00                	push   $0x0
c002254d:	68 d0 00 00 00       	push   $0xd0
c0022552:	e9 af f6 ff ff       	jmp    c0021c06 <intr_entry>

c0022557 <intrd1_stub>:
c0022557:	55                   	push   %ebp
c0022558:	6a 00                	push   $0x0
c002255a:	68 d1 00 00 00       	push   $0xd1
c002255f:	e9 a2 f6 ff ff       	jmp    c0021c06 <intr_entry>

c0022564 <intrd2_stub>:
c0022564:	55                   	push   %ebp
c0022565:	6a 00                	push   $0x0
c0022567:	68 d2 00 00 00       	push   $0xd2
c002256c:	e9 95 f6 ff ff       	jmp    c0021c06 <intr_entry>

c0022571 <intrd3_stub>:
c0022571:	55                   	push   %ebp
c0022572:	6a 00                	push   $0x0
c0022574:	68 d3 00 00 00       	push   $0xd3
c0022579:	e9 88 f6 ff ff       	jmp    c0021c06 <intr_entry>

c002257e <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c002257e:	55                   	push   %ebp
c002257f:	6a 00                	push   $0x0
c0022581:	68 d4 00 00 00       	push   $0xd4
c0022586:	e9 7b f6 ff ff       	jmp    c0021c06 <intr_entry>

c002258b <intrd5_stub>:
c002258b:	55                   	push   %ebp
c002258c:	6a 00                	push   $0x0
c002258e:	68 d5 00 00 00       	push   $0xd5
c0022593:	e9 6e f6 ff ff       	jmp    c0021c06 <intr_entry>

c0022598 <intrd6_stub>:
c0022598:	55                   	push   %ebp
c0022599:	6a 00                	push   $0x0
c002259b:	68 d6 00 00 00       	push   $0xd6
c00225a0:	e9 61 f6 ff ff       	jmp    c0021c06 <intr_entry>

c00225a5 <intrd7_stub>:
c00225a5:	55                   	push   %ebp
c00225a6:	6a 00                	push   $0x0
c00225a8:	68 d7 00 00 00       	push   $0xd7
c00225ad:	e9 54 f6 ff ff       	jmp    c0021c06 <intr_entry>

c00225b2 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c00225b2:	55                   	push   %ebp
c00225b3:	6a 00                	push   $0x0
c00225b5:	68 d8 00 00 00       	push   $0xd8
c00225ba:	e9 47 f6 ff ff       	jmp    c0021c06 <intr_entry>

c00225bf <intrd9_stub>:
c00225bf:	55                   	push   %ebp
c00225c0:	6a 00                	push   $0x0
c00225c2:	68 d9 00 00 00       	push   $0xd9
c00225c7:	e9 3a f6 ff ff       	jmp    c0021c06 <intr_entry>

c00225cc <intrda_stub>:
c00225cc:	55                   	push   %ebp
c00225cd:	6a 00                	push   $0x0
c00225cf:	68 da 00 00 00       	push   $0xda
c00225d4:	e9 2d f6 ff ff       	jmp    c0021c06 <intr_entry>

c00225d9 <intrdb_stub>:
c00225d9:	55                   	push   %ebp
c00225da:	6a 00                	push   $0x0
c00225dc:	68 db 00 00 00       	push   $0xdb
c00225e1:	e9 20 f6 ff ff       	jmp    c0021c06 <intr_entry>

c00225e6 <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c00225e6:	55                   	push   %ebp
c00225e7:	6a 00                	push   $0x0
c00225e9:	68 dc 00 00 00       	push   $0xdc
c00225ee:	e9 13 f6 ff ff       	jmp    c0021c06 <intr_entry>

c00225f3 <intrdd_stub>:
c00225f3:	55                   	push   %ebp
c00225f4:	6a 00                	push   $0x0
c00225f6:	68 dd 00 00 00       	push   $0xdd
c00225fb:	e9 06 f6 ff ff       	jmp    c0021c06 <intr_entry>

c0022600 <intrde_stub>:
c0022600:	55                   	push   %ebp
c0022601:	6a 00                	push   $0x0
c0022603:	68 de 00 00 00       	push   $0xde
c0022608:	e9 f9 f5 ff ff       	jmp    c0021c06 <intr_entry>

c002260d <intrdf_stub>:
c002260d:	55                   	push   %ebp
c002260e:	6a 00                	push   $0x0
c0022610:	68 df 00 00 00       	push   $0xdf
c0022615:	e9 ec f5 ff ff       	jmp    c0021c06 <intr_entry>

c002261a <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c002261a:	55                   	push   %ebp
c002261b:	6a 00                	push   $0x0
c002261d:	68 e0 00 00 00       	push   $0xe0
c0022622:	e9 df f5 ff ff       	jmp    c0021c06 <intr_entry>

c0022627 <intre1_stub>:
c0022627:	55                   	push   %ebp
c0022628:	6a 00                	push   $0x0
c002262a:	68 e1 00 00 00       	push   $0xe1
c002262f:	e9 d2 f5 ff ff       	jmp    c0021c06 <intr_entry>

c0022634 <intre2_stub>:
c0022634:	55                   	push   %ebp
c0022635:	6a 00                	push   $0x0
c0022637:	68 e2 00 00 00       	push   $0xe2
c002263c:	e9 c5 f5 ff ff       	jmp    c0021c06 <intr_entry>

c0022641 <intre3_stub>:
c0022641:	55                   	push   %ebp
c0022642:	6a 00                	push   $0x0
c0022644:	68 e3 00 00 00       	push   $0xe3
c0022649:	e9 b8 f5 ff ff       	jmp    c0021c06 <intr_entry>

c002264e <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c002264e:	55                   	push   %ebp
c002264f:	6a 00                	push   $0x0
c0022651:	68 e4 00 00 00       	push   $0xe4
c0022656:	e9 ab f5 ff ff       	jmp    c0021c06 <intr_entry>

c002265b <intre5_stub>:
c002265b:	55                   	push   %ebp
c002265c:	6a 00                	push   $0x0
c002265e:	68 e5 00 00 00       	push   $0xe5
c0022663:	e9 9e f5 ff ff       	jmp    c0021c06 <intr_entry>

c0022668 <intre6_stub>:
c0022668:	55                   	push   %ebp
c0022669:	6a 00                	push   $0x0
c002266b:	68 e6 00 00 00       	push   $0xe6
c0022670:	e9 91 f5 ff ff       	jmp    c0021c06 <intr_entry>

c0022675 <intre7_stub>:
c0022675:	55                   	push   %ebp
c0022676:	6a 00                	push   $0x0
c0022678:	68 e7 00 00 00       	push   $0xe7
c002267d:	e9 84 f5 ff ff       	jmp    c0021c06 <intr_entry>

c0022682 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022682:	55                   	push   %ebp
c0022683:	6a 00                	push   $0x0
c0022685:	68 e8 00 00 00       	push   $0xe8
c002268a:	e9 77 f5 ff ff       	jmp    c0021c06 <intr_entry>

c002268f <intre9_stub>:
c002268f:	55                   	push   %ebp
c0022690:	6a 00                	push   $0x0
c0022692:	68 e9 00 00 00       	push   $0xe9
c0022697:	e9 6a f5 ff ff       	jmp    c0021c06 <intr_entry>

c002269c <intrea_stub>:
c002269c:	55                   	push   %ebp
c002269d:	6a 00                	push   $0x0
c002269f:	68 ea 00 00 00       	push   $0xea
c00226a4:	e9 5d f5 ff ff       	jmp    c0021c06 <intr_entry>

c00226a9 <intreb_stub>:
c00226a9:	55                   	push   %ebp
c00226aa:	6a 00                	push   $0x0
c00226ac:	68 eb 00 00 00       	push   $0xeb
c00226b1:	e9 50 f5 ff ff       	jmp    c0021c06 <intr_entry>

c00226b6 <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c00226b6:	55                   	push   %ebp
c00226b7:	6a 00                	push   $0x0
c00226b9:	68 ec 00 00 00       	push   $0xec
c00226be:	e9 43 f5 ff ff       	jmp    c0021c06 <intr_entry>

c00226c3 <intred_stub>:
c00226c3:	55                   	push   %ebp
c00226c4:	6a 00                	push   $0x0
c00226c6:	68 ed 00 00 00       	push   $0xed
c00226cb:	e9 36 f5 ff ff       	jmp    c0021c06 <intr_entry>

c00226d0 <intree_stub>:
c00226d0:	55                   	push   %ebp
c00226d1:	6a 00                	push   $0x0
c00226d3:	68 ee 00 00 00       	push   $0xee
c00226d8:	e9 29 f5 ff ff       	jmp    c0021c06 <intr_entry>

c00226dd <intref_stub>:
c00226dd:	55                   	push   %ebp
c00226de:	6a 00                	push   $0x0
c00226e0:	68 ef 00 00 00       	push   $0xef
c00226e5:	e9 1c f5 ff ff       	jmp    c0021c06 <intr_entry>

c00226ea <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c00226ea:	55                   	push   %ebp
c00226eb:	6a 00                	push   $0x0
c00226ed:	68 f0 00 00 00       	push   $0xf0
c00226f2:	e9 0f f5 ff ff       	jmp    c0021c06 <intr_entry>

c00226f7 <intrf1_stub>:
c00226f7:	55                   	push   %ebp
c00226f8:	6a 00                	push   $0x0
c00226fa:	68 f1 00 00 00       	push   $0xf1
c00226ff:	e9 02 f5 ff ff       	jmp    c0021c06 <intr_entry>

c0022704 <intrf2_stub>:
c0022704:	55                   	push   %ebp
c0022705:	6a 00                	push   $0x0
c0022707:	68 f2 00 00 00       	push   $0xf2
c002270c:	e9 f5 f4 ff ff       	jmp    c0021c06 <intr_entry>

c0022711 <intrf3_stub>:
c0022711:	55                   	push   %ebp
c0022712:	6a 00                	push   $0x0
c0022714:	68 f3 00 00 00       	push   $0xf3
c0022719:	e9 e8 f4 ff ff       	jmp    c0021c06 <intr_entry>

c002271e <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c002271e:	55                   	push   %ebp
c002271f:	6a 00                	push   $0x0
c0022721:	68 f4 00 00 00       	push   $0xf4
c0022726:	e9 db f4 ff ff       	jmp    c0021c06 <intr_entry>

c002272b <intrf5_stub>:
c002272b:	55                   	push   %ebp
c002272c:	6a 00                	push   $0x0
c002272e:	68 f5 00 00 00       	push   $0xf5
c0022733:	e9 ce f4 ff ff       	jmp    c0021c06 <intr_entry>

c0022738 <intrf6_stub>:
c0022738:	55                   	push   %ebp
c0022739:	6a 00                	push   $0x0
c002273b:	68 f6 00 00 00       	push   $0xf6
c0022740:	e9 c1 f4 ff ff       	jmp    c0021c06 <intr_entry>

c0022745 <intrf7_stub>:
c0022745:	55                   	push   %ebp
c0022746:	6a 00                	push   $0x0
c0022748:	68 f7 00 00 00       	push   $0xf7
c002274d:	e9 b4 f4 ff ff       	jmp    c0021c06 <intr_entry>

c0022752 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022752:	55                   	push   %ebp
c0022753:	6a 00                	push   $0x0
c0022755:	68 f8 00 00 00       	push   $0xf8
c002275a:	e9 a7 f4 ff ff       	jmp    c0021c06 <intr_entry>

c002275f <intrf9_stub>:
c002275f:	55                   	push   %ebp
c0022760:	6a 00                	push   $0x0
c0022762:	68 f9 00 00 00       	push   $0xf9
c0022767:	e9 9a f4 ff ff       	jmp    c0021c06 <intr_entry>

c002276c <intrfa_stub>:
c002276c:	55                   	push   %ebp
c002276d:	6a 00                	push   $0x0
c002276f:	68 fa 00 00 00       	push   $0xfa
c0022774:	e9 8d f4 ff ff       	jmp    c0021c06 <intr_entry>

c0022779 <intrfb_stub>:
c0022779:	55                   	push   %ebp
c002277a:	6a 00                	push   $0x0
c002277c:	68 fb 00 00 00       	push   $0xfb
c0022781:	e9 80 f4 ff ff       	jmp    c0021c06 <intr_entry>

c0022786 <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c0022786:	55                   	push   %ebp
c0022787:	6a 00                	push   $0x0
c0022789:	68 fc 00 00 00       	push   $0xfc
c002278e:	e9 73 f4 ff ff       	jmp    c0021c06 <intr_entry>

c0022793 <intrfd_stub>:
c0022793:	55                   	push   %ebp
c0022794:	6a 00                	push   $0x0
c0022796:	68 fd 00 00 00       	push   $0xfd
c002279b:	e9 66 f4 ff ff       	jmp    c0021c06 <intr_entry>

c00227a0 <intrfe_stub>:
c00227a0:	55                   	push   %ebp
c00227a1:	6a 00                	push   $0x0
c00227a3:	68 fe 00 00 00       	push   $0xfe
c00227a8:	e9 59 f4 ff ff       	jmp    c0021c06 <intr_entry>

c00227ad <intrff_stub>:
c00227ad:	55                   	push   %ebp
c00227ae:	6a 00                	push   $0x0
c00227b0:	68 ff 00 00 00       	push   $0xff
c00227b5:	e9 4c f4 ff ff       	jmp    c0021c06 <intr_entry>

c00227ba <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c00227ba:	55                   	push   %ebp
c00227bb:	89 e5                	mov    %esp,%ebp
c00227bd:	83 ec 08             	sub    $0x8,%esp
  ASSERT (sema != NULL);
c00227c0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00227c4:	75 1e                	jne    c00227e4 <sema_init+0x2a>
c00227c6:	83 ec 0c             	sub    $0xc,%esp
c00227c9:	68 6c f0 02 c0       	push   $0xc002f06c
c00227ce:	68 79 f0 02 c0       	push   $0xc002f079
c00227d3:	68 40 f1 02 c0       	push   $0xc002f140
c00227d8:	6a 2f                	push   $0x2f
c00227da:	68 90 f0 02 c0       	push   $0xc002f090
c00227df:	e8 4d 6e 00 00       	call   c0029631 <debug_panic>

  sema->value = value;
c00227e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00227e7:	8b 55 0c             	mov    0xc(%ebp),%edx
c00227ea:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c00227ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00227ef:	83 c0 04             	add    $0x4,%eax
c00227f2:	83 ec 0c             	sub    $0xc,%esp
c00227f5:	50                   	push   %eax
c00227f6:	e8 a9 70 00 00       	call   c00298a4 <list_init>
c00227fb:	83 c4 10             	add    $0x10,%esp
}
c00227fe:	90                   	nop
c00227ff:	c9                   	leave  
c0022800:	c3                   	ret    

c0022801 <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c0022801:	55                   	push   %ebp
c0022802:	89 e5                	mov    %esp,%ebp
c0022804:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022807:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002280b:	75 1e                	jne    c002282b <sema_down+0x2a>
c002280d:	83 ec 0c             	sub    $0xc,%esp
c0022810:	68 6c f0 02 c0       	push   $0xc002f06c
c0022815:	68 79 f0 02 c0       	push   $0xc002f079
c002281a:	68 4c f1 02 c0       	push   $0xc002f14c
c002281f:	6a 41                	push   $0x41
c0022821:	68 90 f0 02 c0       	push   $0xc002f090
c0022826:	e8 06 6e 00 00       	call   c0029631 <debug_panic>
  ASSERT (!intr_context ());
c002282b:	e8 4d ee ff ff       	call   c002167d <intr_context>
c0022830:	83 f0 01             	xor    $0x1,%eax
c0022833:	84 c0                	test   %al,%al
c0022835:	75 1e                	jne    c0022855 <sema_down+0x54>
c0022837:	83 ec 0c             	sub    $0xc,%esp
c002283a:	68 a6 f0 02 c0       	push   $0xc002f0a6
c002283f:	68 79 f0 02 c0       	push   $0xc002f079
c0022844:	68 4c f1 02 c0       	push   $0xc002f14c
c0022849:	6a 42                	push   $0x42
c002284b:	68 90 f0 02 c0       	push   $0xc002f090
c0022850:	e8 dc 6d 00 00       	call   c0029631 <debug_panic>

  old_level = intr_disable ();
c0022855:	e8 54 eb ff ff       	call   c00213ae <intr_disable>
c002285a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (sema->value == 0) 
c002285d:	eb 20                	jmp    c002287f <sema_down+0x7e>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
c002285f:	e8 1d e4 ff ff       	call   c0020c81 <thread_current>
c0022864:	8d 50 28             	lea    0x28(%eax),%edx
c0022867:	8b 45 08             	mov    0x8(%ebp),%eax
c002286a:	83 c0 04             	add    $0x4,%eax
c002286d:	83 ec 08             	sub    $0x8,%esp
c0022870:	52                   	push   %edx
c0022871:	50                   	push   %eax
c0022872:	e8 0d 74 00 00       	call   c0029c84 <list_push_back>
c0022877:	83 c4 10             	add    $0x10,%esp
      thread_block ();
c002287a:	e8 e2 e2 ff ff       	call   c0020b61 <thread_block>

  ASSERT (sema != NULL);
  ASSERT (!intr_context ());

  old_level = intr_disable ();
  while (sema->value == 0) 
c002287f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022882:	8b 00                	mov    (%eax),%eax
c0022884:	85 c0                	test   %eax,%eax
c0022886:	74 d7                	je     c002285f <sema_down+0x5e>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
      thread_block ();
    }
  sema->value--;
c0022888:	8b 45 08             	mov    0x8(%ebp),%eax
c002288b:	8b 00                	mov    (%eax),%eax
c002288d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022890:	8b 45 08             	mov    0x8(%ebp),%eax
c0022893:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022895:	83 ec 0c             	sub    $0xc,%esp
c0022898:	ff 75 f4             	pushl  -0xc(%ebp)
c002289b:	e8 b6 ea ff ff       	call   c0021356 <intr_set_level>
c00228a0:	83 c4 10             	add    $0x10,%esp
}
c00228a3:	90                   	nop
c00228a4:	c9                   	leave  
c00228a5:	c3                   	ret    

c00228a6 <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c00228a6:	55                   	push   %ebp
c00228a7:	89 e5                	mov    %esp,%ebp
c00228a9:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c00228ac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00228b0:	75 1e                	jne    c00228d0 <sema_try_down+0x2a>
c00228b2:	83 ec 0c             	sub    $0xc,%esp
c00228b5:	68 6c f0 02 c0       	push   $0xc002f06c
c00228ba:	68 79 f0 02 c0       	push   $0xc002f079
c00228bf:	68 58 f1 02 c0       	push   $0xc002f158
c00228c4:	6a 59                	push   $0x59
c00228c6:	68 90 f0 02 c0       	push   $0xc002f090
c00228cb:	e8 61 6d 00 00       	call   c0029631 <debug_panic>

  old_level = intr_disable ();
c00228d0:	e8 d9 ea ff ff       	call   c00213ae <intr_disable>
c00228d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (sema->value > 0) 
c00228d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00228db:	8b 00                	mov    (%eax),%eax
c00228dd:	85 c0                	test   %eax,%eax
c00228df:	74 13                	je     c00228f4 <sema_try_down+0x4e>
    {
      sema->value--;
c00228e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00228e4:	8b 00                	mov    (%eax),%eax
c00228e6:	8d 50 ff             	lea    -0x1(%eax),%edx
c00228e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00228ec:	89 10                	mov    %edx,(%eax)
      success = true; 
c00228ee:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
c00228f2:	eb 04                	jmp    c00228f8 <sema_try_down+0x52>
    }
  else
    success = false;
c00228f4:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  intr_set_level (old_level);
c00228f8:	83 ec 0c             	sub    $0xc,%esp
c00228fb:	ff 75 f0             	pushl  -0x10(%ebp)
c00228fe:	e8 53 ea ff ff       	call   c0021356 <intr_set_level>
c0022903:	83 c4 10             	add    $0x10,%esp

  return success;
c0022906:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c002290a:	c9                   	leave  
c002290b:	c3                   	ret    

c002290c <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c002290c:	55                   	push   %ebp
c002290d:	89 e5                	mov    %esp,%ebp
c002290f:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022912:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022916:	75 1e                	jne    c0022936 <sema_up+0x2a>
c0022918:	83 ec 0c             	sub    $0xc,%esp
c002291b:	68 6c f0 02 c0       	push   $0xc002f06c
c0022920:	68 79 f0 02 c0       	push   $0xc002f079
c0022925:	68 68 f1 02 c0       	push   $0xc002f168
c002292a:	6a 71                	push   $0x71
c002292c:	68 90 f0 02 c0       	push   $0xc002f090
c0022931:	e8 fb 6c 00 00       	call   c0029631 <debug_panic>

  old_level = intr_disable ();
c0022936:	e8 73 ea ff ff       	call   c00213ae <intr_disable>
c002293b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!list_empty (&sema->waiters)) 
c002293e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022941:	83 c0 04             	add    $0x4,%eax
c0022944:	83 ec 0c             	sub    $0xc,%esp
c0022947:	50                   	push   %eax
c0022948:	e8 df 74 00 00       	call   c0029e2c <list_empty>
c002294d:	83 c4 10             	add    $0x10,%esp
c0022950:	83 f0 01             	xor    $0x1,%eax
c0022953:	84 c0                	test   %al,%al
c0022955:	74 24                	je     c002297b <sema_up+0x6f>
    thread_unblock (list_entry (list_pop_front (&sema->waiters),
c0022957:	8b 45 08             	mov    0x8(%ebp),%eax
c002295a:	83 c0 04             	add    $0x4,%eax
c002295d:	83 ec 0c             	sub    $0xc,%esp
c0022960:	50                   	push   %eax
c0022961:	e8 9d 73 00 00       	call   c0029d03 <list_pop_front>
c0022966:	83 c4 10             	add    $0x10,%esp
c0022969:	83 c0 04             	add    $0x4,%eax
c002296c:	83 e8 2c             	sub    $0x2c,%eax
c002296f:	83 ec 0c             	sub    $0xc,%esp
c0022972:	50                   	push   %eax
c0022973:	e8 5a e2 ff ff       	call   c0020bd2 <thread_unblock>
c0022978:	83 c4 10             	add    $0x10,%esp
                                struct thread, elem));
  sema->value++;
c002297b:	8b 45 08             	mov    0x8(%ebp),%eax
c002297e:	8b 00                	mov    (%eax),%eax
c0022980:	8d 50 01             	lea    0x1(%eax),%edx
c0022983:	8b 45 08             	mov    0x8(%ebp),%eax
c0022986:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022988:	83 ec 0c             	sub    $0xc,%esp
c002298b:	ff 75 f4             	pushl  -0xc(%ebp)
c002298e:	e8 c3 e9 ff ff       	call   c0021356 <intr_set_level>
c0022993:	83 c4 10             	add    $0x10,%esp
}
c0022996:	90                   	nop
c0022997:	c9                   	leave  
c0022998:	c3                   	ret    

c0022999 <sema_self_test>:
/* Self-test for semaphores that makes control "ping-pong"
   between a pair of threads.  Insert calls to printf() to see
   what's going on. */
void
sema_self_test (void) 
{
c0022999:	55                   	push   %ebp
c002299a:	89 e5                	mov    %esp,%ebp
c002299c:	83 ec 38             	sub    $0x38,%esp
  struct semaphore sema[2];
  int i;

  printf ("Testing semaphores...");
c002299f:	83 ec 0c             	sub    $0xc,%esp
c00229a2:	68 b7 f0 02 c0       	push   $0xc002f0b7
c00229a7:	e8 52 48 00 00       	call   c00271fe <printf>
c00229ac:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[0], 0);
c00229af:	83 ec 08             	sub    $0x8,%esp
c00229b2:	6a 00                	push   $0x0
c00229b4:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229b7:	50                   	push   %eax
c00229b8:	e8 fd fd ff ff       	call   c00227ba <sema_init>
c00229bd:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[1], 0);
c00229c0:	83 ec 08             	sub    $0x8,%esp
c00229c3:	6a 00                	push   $0x0
c00229c5:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229c8:	83 c0 14             	add    $0x14,%eax
c00229cb:	50                   	push   %eax
c00229cc:	e8 e9 fd ff ff       	call   c00227ba <sema_init>
c00229d1:	83 c4 10             	add    $0x10,%esp
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c00229d4:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229d7:	50                   	push   %eax
c00229d8:	68 33 2a 02 c0       	push   $0xc0022a33
c00229dd:	6a 1f                	push   $0x1f
c00229df:	68 cd f0 02 c0       	push   $0xc002f0cd
c00229e4:	e8 7f e0 ff ff       	call   c0020a68 <thread_create>
c00229e9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c00229ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00229f3:	eb 25                	jmp    c0022a1a <sema_self_test+0x81>
    {
      sema_up (&sema[0]);
c00229f5:	83 ec 0c             	sub    $0xc,%esp
c00229f8:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229fb:	50                   	push   %eax
c00229fc:	e8 0b ff ff ff       	call   c002290c <sema_up>
c0022a01:	83 c4 10             	add    $0x10,%esp
      sema_down (&sema[1]);
c0022a04:	83 ec 0c             	sub    $0xc,%esp
c0022a07:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022a0a:	83 c0 14             	add    $0x14,%eax
c0022a0d:	50                   	push   %eax
c0022a0e:	e8 ee fd ff ff       	call   c0022801 <sema_down>
c0022a13:	83 c4 10             	add    $0x10,%esp

  printf ("Testing semaphores...");
  sema_init (&sema[0], 0);
  sema_init (&sema[1], 0);
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
  for (i = 0; i < 10; i++) 
c0022a16:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0022a1a:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022a1e:	7e d5                	jle    c00229f5 <sema_self_test+0x5c>
    {
      sema_up (&sema[0]);
      sema_down (&sema[1]);
    }
  printf ("done.\n");
c0022a20:	83 ec 0c             	sub    $0xc,%esp
c0022a23:	68 d7 f0 02 c0       	push   $0xc002f0d7
c0022a28:	e8 b7 8d 00 00       	call   c002b7e4 <puts>
c0022a2d:	83 c4 10             	add    $0x10,%esp
}
c0022a30:	90                   	nop
c0022a31:	c9                   	leave  
c0022a32:	c3                   	ret    

c0022a33 <sema_test_helper>:

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0022a33:	55                   	push   %ebp
c0022a34:	89 e5                	mov    %esp,%ebp
c0022a36:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *sema = sema_;
c0022a39:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  for (i = 0; i < 10; i++) 
c0022a3f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022a46:	eb 24                	jmp    c0022a6c <sema_test_helper+0x39>
    {
      sema_down (&sema[0]);
c0022a48:	83 ec 0c             	sub    $0xc,%esp
c0022a4b:	ff 75 f0             	pushl  -0x10(%ebp)
c0022a4e:	e8 ae fd ff ff       	call   c0022801 <sema_down>
c0022a53:	83 c4 10             	add    $0x10,%esp
      sema_up (&sema[1]);
c0022a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0022a59:	83 c0 14             	add    $0x14,%eax
c0022a5c:	83 ec 0c             	sub    $0xc,%esp
c0022a5f:	50                   	push   %eax
c0022a60:	e8 a7 fe ff ff       	call   c002290c <sema_up>
c0022a65:	83 c4 10             	add    $0x10,%esp
sema_test_helper (void *sema_) 
{
  struct semaphore *sema = sema_;
  int i;

  for (i = 0; i < 10; i++) 
c0022a68:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0022a6c:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022a70:	7e d6                	jle    c0022a48 <sema_test_helper+0x15>
    {
      sema_down (&sema[0]);
      sema_up (&sema[1]);
    }
}
c0022a72:	90                   	nop
c0022a73:	c9                   	leave  
c0022a74:	c3                   	ret    

c0022a75 <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c0022a75:	55                   	push   %ebp
c0022a76:	89 e5                	mov    %esp,%ebp
c0022a78:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022a7b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022a7f:	75 21                	jne    c0022aa2 <lock_init+0x2d>
c0022a81:	83 ec 0c             	sub    $0xc,%esp
c0022a84:	68 dd f0 02 c0       	push   $0xc002f0dd
c0022a89:	68 79 f0 02 c0       	push   $0xc002f079
c0022a8e:	68 70 f1 02 c0       	push   $0xc002f170
c0022a93:	68 b2 00 00 00       	push   $0xb2
c0022a98:	68 90 f0 02 c0       	push   $0xc002f090
c0022a9d:	e8 8f 6b 00 00       	call   c0029631 <debug_panic>

  lock->holder = NULL;
c0022aa2:	8b 45 08             	mov    0x8(%ebp),%eax
c0022aa5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c0022aab:	8b 45 08             	mov    0x8(%ebp),%eax
c0022aae:	83 c0 04             	add    $0x4,%eax
c0022ab1:	83 ec 08             	sub    $0x8,%esp
c0022ab4:	6a 01                	push   $0x1
c0022ab6:	50                   	push   %eax
c0022ab7:	e8 fe fc ff ff       	call   c00227ba <sema_init>
c0022abc:	83 c4 10             	add    $0x10,%esp
}
c0022abf:	90                   	nop
c0022ac0:	c9                   	leave  
c0022ac1:	c3                   	ret    

c0022ac2 <lock_acquire>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
lock_acquire (struct lock *lock)
{
c0022ac2:	55                   	push   %ebp
c0022ac3:	89 e5                	mov    %esp,%ebp
c0022ac5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022ac8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022acc:	75 21                	jne    c0022aef <lock_acquire+0x2d>
c0022ace:	83 ec 0c             	sub    $0xc,%esp
c0022ad1:	68 dd f0 02 c0       	push   $0xc002f0dd
c0022ad6:	68 79 f0 02 c0       	push   $0xc002f079
c0022adb:	68 7c f1 02 c0       	push   $0xc002f17c
c0022ae0:	68 c3 00 00 00       	push   $0xc3
c0022ae5:	68 90 f0 02 c0       	push   $0xc002f090
c0022aea:	e8 42 6b 00 00       	call   c0029631 <debug_panic>
  ASSERT (!intr_context ());
c0022aef:	e8 89 eb ff ff       	call   c002167d <intr_context>
c0022af4:	83 f0 01             	xor    $0x1,%eax
c0022af7:	84 c0                	test   %al,%al
c0022af9:	75 21                	jne    c0022b1c <lock_acquire+0x5a>
c0022afb:	83 ec 0c             	sub    $0xc,%esp
c0022afe:	68 a6 f0 02 c0       	push   $0xc002f0a6
c0022b03:	68 79 f0 02 c0       	push   $0xc002f079
c0022b08:	68 7c f1 02 c0       	push   $0xc002f17c
c0022b0d:	68 c4 00 00 00       	push   $0xc4
c0022b12:	68 90 f0 02 c0       	push   $0xc002f090
c0022b17:	e8 15 6b 00 00       	call   c0029631 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022b1c:	83 ec 0c             	sub    $0xc,%esp
c0022b1f:	ff 75 08             	pushl  0x8(%ebp)
c0022b22:	e8 5a 01 00 00       	call   c0022c81 <lock_held_by_current_thread>
c0022b27:	83 c4 10             	add    $0x10,%esp
c0022b2a:	83 f0 01             	xor    $0x1,%eax
c0022b2d:	84 c0                	test   %al,%al
c0022b2f:	75 21                	jne    c0022b52 <lock_acquire+0x90>
c0022b31:	83 ec 0c             	sub    $0xc,%esp
c0022b34:	68 ec f0 02 c0       	push   $0xc002f0ec
c0022b39:	68 79 f0 02 c0       	push   $0xc002f079
c0022b3e:	68 7c f1 02 c0       	push   $0xc002f17c
c0022b43:	68 c5 00 00 00       	push   $0xc5
c0022b48:	68 90 f0 02 c0       	push   $0xc002f090
c0022b4d:	e8 df 6a 00 00       	call   c0029631 <debug_panic>

  sema_down (&lock->semaphore);
c0022b52:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b55:	83 c0 04             	add    $0x4,%eax
c0022b58:	83 ec 0c             	sub    $0xc,%esp
c0022b5b:	50                   	push   %eax
c0022b5c:	e8 a0 fc ff ff       	call   c0022801 <sema_down>
c0022b61:	83 c4 10             	add    $0x10,%esp
  lock->holder = thread_current ();
c0022b64:	e8 18 e1 ff ff       	call   c0020c81 <thread_current>
c0022b69:	89 c2                	mov    %eax,%edx
c0022b6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b6e:	89 10                	mov    %edx,(%eax)
}
c0022b70:	90                   	nop
c0022b71:	c9                   	leave  
c0022b72:	c3                   	ret    

c0022b73 <lock_try_acquire>:

   This function will not sleep, so it may be called within an
   interrupt handler. */
bool
lock_try_acquire (struct lock *lock)
{
c0022b73:	55                   	push   %ebp
c0022b74:	89 e5                	mov    %esp,%ebp
c0022b76:	83 ec 18             	sub    $0x18,%esp
  bool success;

  ASSERT (lock != NULL);
c0022b79:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022b7d:	75 21                	jne    c0022ba0 <lock_try_acquire+0x2d>
c0022b7f:	83 ec 0c             	sub    $0xc,%esp
c0022b82:	68 dd f0 02 c0       	push   $0xc002f0dd
c0022b87:	68 79 f0 02 c0       	push   $0xc002f079
c0022b8c:	68 8c f1 02 c0       	push   $0xc002f18c
c0022b91:	68 d6 00 00 00       	push   $0xd6
c0022b96:	68 90 f0 02 c0       	push   $0xc002f090
c0022b9b:	e8 91 6a 00 00       	call   c0029631 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022ba0:	83 ec 0c             	sub    $0xc,%esp
c0022ba3:	ff 75 08             	pushl  0x8(%ebp)
c0022ba6:	e8 d6 00 00 00       	call   c0022c81 <lock_held_by_current_thread>
c0022bab:	83 c4 10             	add    $0x10,%esp
c0022bae:	83 f0 01             	xor    $0x1,%eax
c0022bb1:	84 c0                	test   %al,%al
c0022bb3:	75 21                	jne    c0022bd6 <lock_try_acquire+0x63>
c0022bb5:	83 ec 0c             	sub    $0xc,%esp
c0022bb8:	68 ec f0 02 c0       	push   $0xc002f0ec
c0022bbd:	68 79 f0 02 c0       	push   $0xc002f079
c0022bc2:	68 8c f1 02 c0       	push   $0xc002f18c
c0022bc7:	68 d7 00 00 00       	push   $0xd7
c0022bcc:	68 90 f0 02 c0       	push   $0xc002f090
c0022bd1:	e8 5b 6a 00 00       	call   c0029631 <debug_panic>

  success = sema_try_down (&lock->semaphore);
c0022bd6:	8b 45 08             	mov    0x8(%ebp),%eax
c0022bd9:	83 c0 04             	add    $0x4,%eax
c0022bdc:	83 ec 0c             	sub    $0xc,%esp
c0022bdf:	50                   	push   %eax
c0022be0:	e8 c1 fc ff ff       	call   c00228a6 <sema_try_down>
c0022be5:	83 c4 10             	add    $0x10,%esp
c0022be8:	88 45 f7             	mov    %al,-0x9(%ebp)
  if (success)
c0022beb:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0022bef:	74 0c                	je     c0022bfd <lock_try_acquire+0x8a>
    lock->holder = thread_current ();
c0022bf1:	e8 8b e0 ff ff       	call   c0020c81 <thread_current>
c0022bf6:	89 c2                	mov    %eax,%edx
c0022bf8:	8b 45 08             	mov    0x8(%ebp),%eax
c0022bfb:	89 10                	mov    %edx,(%eax)
  return success;
c0022bfd:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c0022c01:	c9                   	leave  
c0022c02:	c3                   	ret    

c0022c03 <lock_release>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to release a lock within an interrupt
   handler. */
void
lock_release (struct lock *lock) 
{
c0022c03:	55                   	push   %ebp
c0022c04:	89 e5                	mov    %esp,%ebp
c0022c06:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022c09:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022c0d:	75 21                	jne    c0022c30 <lock_release+0x2d>
c0022c0f:	83 ec 0c             	sub    $0xc,%esp
c0022c12:	68 dd f0 02 c0       	push   $0xc002f0dd
c0022c17:	68 79 f0 02 c0       	push   $0xc002f079
c0022c1c:	68 a0 f1 02 c0       	push   $0xc002f1a0
c0022c21:	68 e7 00 00 00       	push   $0xe7
c0022c26:	68 90 f0 02 c0       	push   $0xc002f090
c0022c2b:	e8 01 6a 00 00       	call   c0029631 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022c30:	83 ec 0c             	sub    $0xc,%esp
c0022c33:	ff 75 08             	pushl  0x8(%ebp)
c0022c36:	e8 46 00 00 00       	call   c0022c81 <lock_held_by_current_thread>
c0022c3b:	83 c4 10             	add    $0x10,%esp
c0022c3e:	84 c0                	test   %al,%al
c0022c40:	75 21                	jne    c0022c63 <lock_release+0x60>
c0022c42:	83 ec 0c             	sub    $0xc,%esp
c0022c45:	68 10 f1 02 c0       	push   $0xc002f110
c0022c4a:	68 79 f0 02 c0       	push   $0xc002f079
c0022c4f:	68 a0 f1 02 c0       	push   $0xc002f1a0
c0022c54:	68 e8 00 00 00       	push   $0xe8
c0022c59:	68 90 f0 02 c0       	push   $0xc002f090
c0022c5e:	e8 ce 69 00 00       	call   c0029631 <debug_panic>

  lock->holder = NULL;
c0022c63:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c66:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_up (&lock->semaphore);
c0022c6c:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c6f:	83 c0 04             	add    $0x4,%eax
c0022c72:	83 ec 0c             	sub    $0xc,%esp
c0022c75:	50                   	push   %eax
c0022c76:	e8 91 fc ff ff       	call   c002290c <sema_up>
c0022c7b:	83 c4 10             	add    $0x10,%esp
}
c0022c7e:	90                   	nop
c0022c7f:	c9                   	leave  
c0022c80:	c3                   	ret    

c0022c81 <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0022c81:	55                   	push   %ebp
c0022c82:	89 e5                	mov    %esp,%ebp
c0022c84:	53                   	push   %ebx
c0022c85:	83 ec 04             	sub    $0x4,%esp
  ASSERT (lock != NULL);
c0022c88:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022c8c:	75 21                	jne    c0022caf <lock_held_by_current_thread+0x2e>
c0022c8e:	83 ec 0c             	sub    $0xc,%esp
c0022c91:	68 dd f0 02 c0       	push   $0xc002f0dd
c0022c96:	68 79 f0 02 c0       	push   $0xc002f079
c0022c9b:	68 b0 f1 02 c0       	push   $0xc002f1b0
c0022ca0:	68 f4 00 00 00       	push   $0xf4
c0022ca5:	68 90 f0 02 c0       	push   $0xc002f090
c0022caa:	e8 82 69 00 00       	call   c0029631 <debug_panic>

  return lock->holder == thread_current ();
c0022caf:	8b 45 08             	mov    0x8(%ebp),%eax
c0022cb2:	8b 18                	mov    (%eax),%ebx
c0022cb4:	e8 c8 df ff ff       	call   c0020c81 <thread_current>
c0022cb9:	39 c3                	cmp    %eax,%ebx
c0022cbb:	0f 94 c0             	sete   %al
}
c0022cbe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0022cc1:	c9                   	leave  
c0022cc2:	c3                   	ret    

c0022cc3 <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c0022cc3:	55                   	push   %ebp
c0022cc4:	89 e5                	mov    %esp,%ebp
c0022cc6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022cc9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022ccd:	75 21                	jne    c0022cf0 <cond_init+0x2d>
c0022ccf:	83 ec 0c             	sub    $0xc,%esp
c0022cd2:	68 33 f1 02 c0       	push   $0xc002f133
c0022cd7:	68 79 f0 02 c0       	push   $0xc002f079
c0022cdc:	68 cc f1 02 c0       	push   $0xc002f1cc
c0022ce1:	68 06 01 00 00       	push   $0x106
c0022ce6:	68 90 f0 02 c0       	push   $0xc002f090
c0022ceb:	e8 41 69 00 00       	call   c0029631 <debug_panic>

  list_init (&cond->waiters);
c0022cf0:	8b 45 08             	mov    0x8(%ebp),%eax
c0022cf3:	83 ec 0c             	sub    $0xc,%esp
c0022cf6:	50                   	push   %eax
c0022cf7:	e8 a8 6b 00 00       	call   c00298a4 <list_init>
c0022cfc:	83 c4 10             	add    $0x10,%esp
}
c0022cff:	90                   	nop
c0022d00:	c9                   	leave  
c0022d01:	c3                   	ret    

c0022d02 <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c0022d02:	55                   	push   %ebp
c0022d03:	89 e5                	mov    %esp,%ebp
c0022d05:	83 ec 28             	sub    $0x28,%esp
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0022d08:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022d0c:	75 21                	jne    c0022d2f <cond_wait+0x2d>
c0022d0e:	83 ec 0c             	sub    $0xc,%esp
c0022d11:	68 33 f1 02 c0       	push   $0xc002f133
c0022d16:	68 79 f0 02 c0       	push   $0xc002f079
c0022d1b:	68 d8 f1 02 c0       	push   $0xc002f1d8
c0022d20:	68 24 01 00 00       	push   $0x124
c0022d25:	68 90 f0 02 c0       	push   $0xc002f090
c0022d2a:	e8 02 69 00 00       	call   c0029631 <debug_panic>
  ASSERT (lock != NULL);
c0022d2f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022d33:	75 21                	jne    c0022d56 <cond_wait+0x54>
c0022d35:	83 ec 0c             	sub    $0xc,%esp
c0022d38:	68 dd f0 02 c0       	push   $0xc002f0dd
c0022d3d:	68 79 f0 02 c0       	push   $0xc002f079
c0022d42:	68 d8 f1 02 c0       	push   $0xc002f1d8
c0022d47:	68 25 01 00 00       	push   $0x125
c0022d4c:	68 90 f0 02 c0       	push   $0xc002f090
c0022d51:	e8 db 68 00 00       	call   c0029631 <debug_panic>
  ASSERT (!intr_context ());
c0022d56:	e8 22 e9 ff ff       	call   c002167d <intr_context>
c0022d5b:	83 f0 01             	xor    $0x1,%eax
c0022d5e:	84 c0                	test   %al,%al
c0022d60:	75 21                	jne    c0022d83 <cond_wait+0x81>
c0022d62:	83 ec 0c             	sub    $0xc,%esp
c0022d65:	68 a6 f0 02 c0       	push   $0xc002f0a6
c0022d6a:	68 79 f0 02 c0       	push   $0xc002f079
c0022d6f:	68 d8 f1 02 c0       	push   $0xc002f1d8
c0022d74:	68 26 01 00 00       	push   $0x126
c0022d79:	68 90 f0 02 c0       	push   $0xc002f090
c0022d7e:	e8 ae 68 00 00       	call   c0029631 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022d83:	83 ec 0c             	sub    $0xc,%esp
c0022d86:	ff 75 0c             	pushl  0xc(%ebp)
c0022d89:	e8 f3 fe ff ff       	call   c0022c81 <lock_held_by_current_thread>
c0022d8e:	83 c4 10             	add    $0x10,%esp
c0022d91:	84 c0                	test   %al,%al
c0022d93:	75 21                	jne    c0022db6 <cond_wait+0xb4>
c0022d95:	83 ec 0c             	sub    $0xc,%esp
c0022d98:	68 10 f1 02 c0       	push   $0xc002f110
c0022d9d:	68 79 f0 02 c0       	push   $0xc002f079
c0022da2:	68 d8 f1 02 c0       	push   $0xc002f1d8
c0022da7:	68 27 01 00 00       	push   $0x127
c0022dac:	68 90 f0 02 c0       	push   $0xc002f090
c0022db1:	e8 7b 68 00 00       	call   c0029631 <debug_panic>
  
  sema_init (&waiter.semaphore, 0);
c0022db6:	83 ec 08             	sub    $0x8,%esp
c0022db9:	6a 00                	push   $0x0
c0022dbb:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0022dbe:	83 c0 08             	add    $0x8,%eax
c0022dc1:	50                   	push   %eax
c0022dc2:	e8 f3 f9 ff ff       	call   c00227ba <sema_init>
c0022dc7:	83 c4 10             	add    $0x10,%esp
  list_push_back (&cond->waiters, &waiter.elem);
c0022dca:	8b 45 08             	mov    0x8(%ebp),%eax
c0022dcd:	83 ec 08             	sub    $0x8,%esp
c0022dd0:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0022dd3:	52                   	push   %edx
c0022dd4:	50                   	push   %eax
c0022dd5:	e8 aa 6e 00 00       	call   c0029c84 <list_push_back>
c0022dda:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c0022ddd:	83 ec 0c             	sub    $0xc,%esp
c0022de0:	ff 75 0c             	pushl  0xc(%ebp)
c0022de3:	e8 1b fe ff ff       	call   c0022c03 <lock_release>
c0022de8:	83 c4 10             	add    $0x10,%esp
  sema_down (&waiter.semaphore);
c0022deb:	83 ec 0c             	sub    $0xc,%esp
c0022dee:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0022df1:	83 c0 08             	add    $0x8,%eax
c0022df4:	50                   	push   %eax
c0022df5:	e8 07 fa ff ff       	call   c0022801 <sema_down>
c0022dfa:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c0022dfd:	83 ec 0c             	sub    $0xc,%esp
c0022e00:	ff 75 0c             	pushl  0xc(%ebp)
c0022e03:	e8 ba fc ff ff       	call   c0022ac2 <lock_acquire>
c0022e08:	83 c4 10             	add    $0x10,%esp
}
c0022e0b:	90                   	nop
c0022e0c:	c9                   	leave  
c0022e0d:	c3                   	ret    

c0022e0e <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c0022e0e:	55                   	push   %ebp
c0022e0f:	89 e5                	mov    %esp,%ebp
c0022e11:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022e14:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022e18:	75 21                	jne    c0022e3b <cond_signal+0x2d>
c0022e1a:	83 ec 0c             	sub    $0xc,%esp
c0022e1d:	68 33 f1 02 c0       	push   $0xc002f133
c0022e22:	68 79 f0 02 c0       	push   $0xc002f079
c0022e27:	68 e4 f1 02 c0       	push   $0xc002f1e4
c0022e2c:	68 3a 01 00 00       	push   $0x13a
c0022e31:	68 90 f0 02 c0       	push   $0xc002f090
c0022e36:	e8 f6 67 00 00       	call   c0029631 <debug_panic>
  ASSERT (lock != NULL);
c0022e3b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022e3f:	75 21                	jne    c0022e62 <cond_signal+0x54>
c0022e41:	83 ec 0c             	sub    $0xc,%esp
c0022e44:	68 dd f0 02 c0       	push   $0xc002f0dd
c0022e49:	68 79 f0 02 c0       	push   $0xc002f079
c0022e4e:	68 e4 f1 02 c0       	push   $0xc002f1e4
c0022e53:	68 3b 01 00 00       	push   $0x13b
c0022e58:	68 90 f0 02 c0       	push   $0xc002f090
c0022e5d:	e8 cf 67 00 00       	call   c0029631 <debug_panic>
  ASSERT (!intr_context ());
c0022e62:	e8 16 e8 ff ff       	call   c002167d <intr_context>
c0022e67:	83 f0 01             	xor    $0x1,%eax
c0022e6a:	84 c0                	test   %al,%al
c0022e6c:	75 21                	jne    c0022e8f <cond_signal+0x81>
c0022e6e:	83 ec 0c             	sub    $0xc,%esp
c0022e71:	68 a6 f0 02 c0       	push   $0xc002f0a6
c0022e76:	68 79 f0 02 c0       	push   $0xc002f079
c0022e7b:	68 e4 f1 02 c0       	push   $0xc002f1e4
c0022e80:	68 3c 01 00 00       	push   $0x13c
c0022e85:	68 90 f0 02 c0       	push   $0xc002f090
c0022e8a:	e8 a2 67 00 00       	call   c0029631 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022e8f:	83 ec 0c             	sub    $0xc,%esp
c0022e92:	ff 75 0c             	pushl  0xc(%ebp)
c0022e95:	e8 e7 fd ff ff       	call   c0022c81 <lock_held_by_current_thread>
c0022e9a:	83 c4 10             	add    $0x10,%esp
c0022e9d:	84 c0                	test   %al,%al
c0022e9f:	75 21                	jne    c0022ec2 <cond_signal+0xb4>
c0022ea1:	83 ec 0c             	sub    $0xc,%esp
c0022ea4:	68 10 f1 02 c0       	push   $0xc002f110
c0022ea9:	68 79 f0 02 c0       	push   $0xc002f079
c0022eae:	68 e4 f1 02 c0       	push   $0xc002f1e4
c0022eb3:	68 3d 01 00 00       	push   $0x13d
c0022eb8:	68 90 f0 02 c0       	push   $0xc002f090
c0022ebd:	e8 6f 67 00 00       	call   c0029631 <debug_panic>

  if (!list_empty (&cond->waiters)) 
c0022ec2:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ec5:	83 ec 0c             	sub    $0xc,%esp
c0022ec8:	50                   	push   %eax
c0022ec9:	e8 5e 6f 00 00       	call   c0029e2c <list_empty>
c0022ece:	83 c4 10             	add    $0x10,%esp
c0022ed1:	83 f0 01             	xor    $0x1,%eax
c0022ed4:	84 c0                	test   %al,%al
c0022ed6:	74 24                	je     c0022efc <cond_signal+0xee>
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c0022ed8:	8b 45 08             	mov    0x8(%ebp),%eax
c0022edb:	83 ec 0c             	sub    $0xc,%esp
c0022ede:	50                   	push   %eax
c0022edf:	e8 1f 6e 00 00       	call   c0029d03 <list_pop_front>
c0022ee4:	83 c4 10             	add    $0x10,%esp
c0022ee7:	83 c0 04             	add    $0x4,%eax
c0022eea:	83 e8 04             	sub    $0x4,%eax
c0022eed:	83 c0 08             	add    $0x8,%eax
c0022ef0:	83 ec 0c             	sub    $0xc,%esp
c0022ef3:	50                   	push   %eax
c0022ef4:	e8 13 fa ff ff       	call   c002290c <sema_up>
c0022ef9:	83 c4 10             	add    $0x10,%esp
                          struct semaphore_elem, elem)->semaphore);
}
c0022efc:	90                   	nop
c0022efd:	c9                   	leave  
c0022efe:	c3                   	ret    

c0022eff <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c0022eff:	55                   	push   %ebp
c0022f00:	89 e5                	mov    %esp,%ebp
c0022f02:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022f05:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022f09:	75 21                	jne    c0022f2c <cond_broadcast+0x2d>
c0022f0b:	83 ec 0c             	sub    $0xc,%esp
c0022f0e:	68 33 f1 02 c0       	push   $0xc002f133
c0022f13:	68 79 f0 02 c0       	push   $0xc002f079
c0022f18:	68 f0 f1 02 c0       	push   $0xc002f1f0
c0022f1d:	68 4d 01 00 00       	push   $0x14d
c0022f22:	68 90 f0 02 c0       	push   $0xc002f090
c0022f27:	e8 05 67 00 00       	call   c0029631 <debug_panic>
  ASSERT (lock != NULL);
c0022f2c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022f30:	75 32                	jne    c0022f64 <cond_broadcast+0x65>
c0022f32:	83 ec 0c             	sub    $0xc,%esp
c0022f35:	68 dd f0 02 c0       	push   $0xc002f0dd
c0022f3a:	68 79 f0 02 c0       	push   $0xc002f079
c0022f3f:	68 f0 f1 02 c0       	push   $0xc002f1f0
c0022f44:	68 4e 01 00 00       	push   $0x14e
c0022f49:	68 90 f0 02 c0       	push   $0xc002f090
c0022f4e:	e8 de 66 00 00       	call   c0029631 <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c0022f53:	83 ec 08             	sub    $0x8,%esp
c0022f56:	ff 75 0c             	pushl  0xc(%ebp)
c0022f59:	ff 75 08             	pushl  0x8(%ebp)
c0022f5c:	e8 ad fe ff ff       	call   c0022e0e <cond_signal>
c0022f61:	83 c4 10             	add    $0x10,%esp
cond_broadcast (struct condition *cond, struct lock *lock) 
{
  ASSERT (cond != NULL);
  ASSERT (lock != NULL);

  while (!list_empty (&cond->waiters))
c0022f64:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f67:	83 ec 0c             	sub    $0xc,%esp
c0022f6a:	50                   	push   %eax
c0022f6b:	e8 bc 6e 00 00       	call   c0029e2c <list_empty>
c0022f70:	83 c4 10             	add    $0x10,%esp
c0022f73:	83 f0 01             	xor    $0x1,%eax
c0022f76:	84 c0                	test   %al,%al
c0022f78:	75 d9                	jne    c0022f53 <cond_broadcast+0x54>
    cond_signal (cond, lock);
}
c0022f7a:	90                   	nop
c0022f7b:	c9                   	leave  
c0022f7c:	c3                   	ret    

c0022f7d <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c0022f7d:	55                   	push   %ebp
c0022f7e:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0022f80:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f83:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c0022f88:	5d                   	pop    %ebp
c0022f89:	c3                   	ret    

c0022f8a <pg_no>:

/* Virtual page number. */
static inline uintptr_t pg_no (const void *va) {
c0022f8a:	55                   	push   %ebp
c0022f8b:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PGBITS;
c0022f8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f90:	c1 e8 0c             	shr    $0xc,%eax
}
c0022f93:	5d                   	pop    %ebp
c0022f94:	c3                   	ret    

c0022f95 <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c0022f95:	55                   	push   %ebp
c0022f96:	89 e5                	mov    %esp,%ebp
c0022f98:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0022f9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f9e:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0022fa3:	76 1e                	jbe    c0022fc3 <ptov+0x2e>
c0022fa5:	83 ec 0c             	sub    $0xc,%esp
c0022fa8:	68 00 f2 02 c0       	push   $0xc002f200
c0022fad:	68 1b f2 02 c0       	push   $0xc002f21b
c0022fb2:	68 38 f3 02 c0       	push   $0xc002f338
c0022fb7:	6a 4a                	push   $0x4a
c0022fb9:	68 32 f2 02 c0       	push   $0xc002f232
c0022fbe:	e8 6e 66 00 00       	call   c0029631 <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c0022fc3:	8b 45 08             	mov    0x8(%ebp),%eax
c0022fc6:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0022fcb:	c9                   	leave  
c0022fcc:	c3                   	ret    

c0022fcd <palloc_init>:

/* Initializes the page allocator.  At most USER_PAGE_LIMIT
   pages are put into the user pool. */
void
palloc_init (size_t user_page_limit)
{
c0022fcd:	55                   	push   %ebp
c0022fce:	89 e5                	mov    %esp,%ebp
c0022fd0:	83 ec 28             	sub    $0x28,%esp
  /* Free memory starts at 1 MB and runs to the end of RAM. */
  uint8_t *free_start = ptov (1024 * 1024);
c0022fd3:	83 ec 0c             	sub    $0xc,%esp
c0022fd6:	68 00 00 10 00       	push   $0x100000
c0022fdb:	e8 b5 ff ff ff       	call   c0022f95 <ptov>
c0022fe0:	83 c4 10             	add    $0x10,%esp
c0022fe3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c0022fe6:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c0022feb:	c1 e0 0c             	shl    $0xc,%eax
c0022fee:	83 ec 0c             	sub    $0xc,%esp
c0022ff1:	50                   	push   %eax
c0022ff2:	e8 9e ff ff ff       	call   c0022f95 <ptov>
c0022ff7:	83 c4 10             	add    $0x10,%esp
c0022ffa:	89 45 ec             	mov    %eax,-0x14(%ebp)
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0022ffd:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023000:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023003:	29 c2                	sub    %eax,%edx
c0023005:	89 d0                	mov    %edx,%eax
c0023007:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
c002300d:	85 c0                	test   %eax,%eax
c002300f:	0f 48 c2             	cmovs  %edx,%eax
c0023012:	c1 f8 0c             	sar    $0xc,%eax
c0023015:	89 45 e8             	mov    %eax,-0x18(%ebp)
  size_t user_pages = free_pages / 2;
c0023018:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002301b:	d1 e8                	shr    %eax
c002301d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t kernel_pages;
  if (user_pages > user_page_limit)
c0023020:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023023:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023026:	76 06                	jbe    c002302e <palloc_init+0x61>
    user_pages = user_page_limit;
c0023028:	8b 45 08             	mov    0x8(%ebp),%eax
c002302b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  kernel_pages = free_pages - user_pages;
c002302e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023031:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0023034:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Give half of memory to kernel, half to user. */
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c0023037:	68 48 f2 02 c0       	push   $0xc002f248
c002303c:	ff 75 e4             	pushl  -0x1c(%ebp)
c002303f:	ff 75 f0             	pushl  -0x10(%ebp)
c0023042:	68 80 96 03 c0       	push   $0xc0039680
c0023047:	e8 6e 02 00 00       	call   c00232ba <init_pool>
c002304c:	83 c4 10             	add    $0x10,%esp
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c002304f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023052:	c1 e0 0c             	shl    $0xc,%eax
c0023055:	89 c2                	mov    %eax,%edx
c0023057:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002305a:	01 d0                	add    %edx,%eax
c002305c:	68 54 f2 02 c0       	push   $0xc002f254
c0023061:	ff 75 f4             	pushl  -0xc(%ebp)
c0023064:	50                   	push   %eax
c0023065:	68 a0 96 03 c0       	push   $0xc00396a0
c002306a:	e8 4b 02 00 00       	call   c00232ba <init_pool>
c002306f:	83 c4 10             	add    $0x10,%esp
             user_pages, "user pool");
}
c0023072:	90                   	nop
c0023073:	c9                   	leave  
c0023074:	c3                   	ret    

c0023075 <palloc_get_multiple>:
   then the pages are filled with zeros.  If too few pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
{
c0023075:	55                   	push   %ebp
c0023076:	89 e5                	mov    %esp,%ebp
c0023078:	83 ec 18             	sub    $0x18,%esp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c002307b:	8b 45 08             	mov    0x8(%ebp),%eax
c002307e:	83 e0 04             	and    $0x4,%eax
c0023081:	85 c0                	test   %eax,%eax
c0023083:	74 07                	je     c002308c <palloc_get_multiple+0x17>
c0023085:	b8 a0 96 03 c0       	mov    $0xc00396a0,%eax
c002308a:	eb 05                	jmp    c0023091 <palloc_get_multiple+0x1c>
c002308c:	b8 80 96 03 c0       	mov    $0xc0039680,%eax
c0023091:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *pages;
  size_t page_idx;

  if (page_cnt == 0)
c0023094:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023098:	75 0a                	jne    c00230a4 <palloc_get_multiple+0x2f>
    return NULL;
c002309a:	b8 00 00 00 00       	mov    $0x0,%eax
c002309f:	e9 a3 00 00 00       	jmp    c0023147 <palloc_get_multiple+0xd2>

  lock_acquire (&pool->lock);
c00230a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00230a7:	83 ec 0c             	sub    $0xc,%esp
c00230aa:	50                   	push   %eax
c00230ab:	e8 12 fa ff ff       	call   c0022ac2 <lock_acquire>
c00230b0:	83 c4 10             	add    $0x10,%esp
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c00230b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00230b6:	8b 40 18             	mov    0x18(%eax),%eax
c00230b9:	6a 00                	push   $0x0
c00230bb:	ff 75 0c             	pushl  0xc(%ebp)
c00230be:	6a 00                	push   $0x0
c00230c0:	50                   	push   %eax
c00230c1:	e8 9a 7c 00 00       	call   c002ad60 <bitmap_scan_and_flip>
c00230c6:	83 c4 10             	add    $0x10,%esp
c00230c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  lock_release (&pool->lock);
c00230cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00230cf:	83 ec 0c             	sub    $0xc,%esp
c00230d2:	50                   	push   %eax
c00230d3:	e8 2b fb ff ff       	call   c0022c03 <lock_release>
c00230d8:	83 c4 10             	add    $0x10,%esp

  if (page_idx != BITMAP_ERROR)
c00230db:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00230df:	74 13                	je     c00230f4 <palloc_get_multiple+0x7f>
    pages = pool->base + PGSIZE * page_idx;
c00230e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00230e4:	8b 40 1c             	mov    0x1c(%eax),%eax
c00230e7:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00230ea:	c1 e2 0c             	shl    $0xc,%edx
c00230ed:	01 d0                	add    %edx,%eax
c00230ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00230f2:	eb 07                	jmp    c00230fb <palloc_get_multiple+0x86>
  else
    pages = NULL;
c00230f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (pages != NULL) 
c00230fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00230ff:	74 23                	je     c0023124 <palloc_get_multiple+0xaf>
    {
      if (flags & PAL_ZERO)
c0023101:	8b 45 08             	mov    0x8(%ebp),%eax
c0023104:	83 e0 02             	and    $0x2,%eax
c0023107:	85 c0                	test   %eax,%eax
c0023109:	74 39                	je     c0023144 <palloc_get_multiple+0xcf>
        memset (pages, 0, PGSIZE * page_cnt);
c002310b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002310e:	c1 e0 0c             	shl    $0xc,%eax
c0023111:	83 ec 04             	sub    $0x4,%esp
c0023114:	50                   	push   %eax
c0023115:	6a 00                	push   $0x0
c0023117:	ff 75 f4             	pushl  -0xc(%ebp)
c002311a:	e8 06 59 00 00       	call   c0028a25 <memset>
c002311f:	83 c4 10             	add    $0x10,%esp
c0023122:	eb 20                	jmp    c0023144 <palloc_get_multiple+0xcf>
    }
  else 
    {
      if (flags & PAL_ASSERT)
c0023124:	8b 45 08             	mov    0x8(%ebp),%eax
c0023127:	83 e0 01             	and    $0x1,%eax
c002312a:	85 c0                	test   %eax,%eax
c002312c:	74 16                	je     c0023144 <palloc_get_multiple+0xcf>
        PANIC ("palloc_get: out of pages");
c002312e:	68 5e f2 02 c0       	push   $0xc002f25e
c0023133:	68 40 f3 02 c0       	push   $0xc002f340
c0023138:	6a 61                	push   $0x61
c002313a:	68 77 f2 02 c0       	push   $0xc002f277
c002313f:	e8 ed 64 00 00       	call   c0029631 <debug_panic>
    }

  return pages;
c0023144:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0023147:	c9                   	leave  
c0023148:	c3                   	ret    

c0023149 <palloc_get_page>:
   then the page is filled with zeros.  If no pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_page (enum palloc_flags flags) 
{
c0023149:	55                   	push   %ebp
c002314a:	89 e5                	mov    %esp,%ebp
c002314c:	83 ec 08             	sub    $0x8,%esp
  return palloc_get_multiple (flags, 1);
c002314f:	83 ec 08             	sub    $0x8,%esp
c0023152:	6a 01                	push   $0x1
c0023154:	ff 75 08             	pushl  0x8(%ebp)
c0023157:	e8 19 ff ff ff       	call   c0023075 <palloc_get_multiple>
c002315c:	83 c4 10             	add    $0x10,%esp
}
c002315f:	c9                   	leave  
c0023160:	c3                   	ret    

c0023161 <palloc_free_multiple>:

/* Frees the PAGE_CNT pages starting at PAGES. */
void
palloc_free_multiple (void *pages, size_t page_cnt) 
{
c0023161:	55                   	push   %ebp
c0023162:	89 e5                	mov    %esp,%ebp
c0023164:	53                   	push   %ebx
c0023165:	83 ec 14             	sub    $0x14,%esp
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
c0023168:	ff 75 08             	pushl  0x8(%ebp)
c002316b:	e8 0d fe ff ff       	call   c0022f7d <pg_ofs>
c0023170:	83 c4 04             	add    $0x4,%esp
c0023173:	85 c0                	test   %eax,%eax
c0023175:	74 1e                	je     c0023195 <palloc_free_multiple+0x34>
c0023177:	83 ec 0c             	sub    $0xc,%esp
c002317a:	68 8e f2 02 c0       	push   $0xc002f28e
c002317f:	68 1b f2 02 c0       	push   $0xc002f21b
c0023184:	68 54 f3 02 c0       	push   $0xc002f354
c0023189:	6a 7b                	push   $0x7b
c002318b:	68 77 f2 02 c0       	push   $0xc002f277
c0023190:	e8 9c 64 00 00       	call   c0029631 <debug_panic>
  if (pages == NULL || page_cnt == 0)
c0023195:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023199:	0f 84 fc 00 00 00    	je     c002329b <palloc_free_multiple+0x13a>
c002319f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00231a3:	0f 84 f2 00 00 00    	je     c002329b <palloc_free_multiple+0x13a>
    return;

  if (page_from_pool (&kernel_pool, pages))
c00231a9:	83 ec 08             	sub    $0x8,%esp
c00231ac:	ff 75 08             	pushl  0x8(%ebp)
c00231af:	68 80 96 03 c0       	push   $0xc0039680
c00231b4:	e8 a8 01 00 00       	call   c0023361 <page_from_pool>
c00231b9:	83 c4 10             	add    $0x10,%esp
c00231bc:	84 c0                	test   %al,%al
c00231be:	74 09                	je     c00231c9 <palloc_free_multiple+0x68>
    pool = &kernel_pool;
c00231c0:	c7 45 f4 80 96 03 c0 	movl   $0xc0039680,-0xc(%ebp)
c00231c7:	eb 39                	jmp    c0023202 <palloc_free_multiple+0xa1>
  else if (page_from_pool (&user_pool, pages))
c00231c9:	83 ec 08             	sub    $0x8,%esp
c00231cc:	ff 75 08             	pushl  0x8(%ebp)
c00231cf:	68 a0 96 03 c0       	push   $0xc00396a0
c00231d4:	e8 88 01 00 00       	call   c0023361 <page_from_pool>
c00231d9:	83 c4 10             	add    $0x10,%esp
c00231dc:	84 c0                	test   %al,%al
c00231de:	74 09                	je     c00231e9 <palloc_free_multiple+0x88>
    pool = &user_pool;
c00231e0:	c7 45 f4 a0 96 03 c0 	movl   $0xc00396a0,-0xc(%ebp)
c00231e7:	eb 19                	jmp    c0023202 <palloc_free_multiple+0xa1>
  else
    NOT_REACHED ();
c00231e9:	68 a4 f2 02 c0       	push   $0xc002f2a4
c00231ee:	68 54 f3 02 c0       	push   $0xc002f354
c00231f3:	68 84 00 00 00       	push   $0x84
c00231f8:	68 77 f2 02 c0       	push   $0xc002f277
c00231fd:	e8 2f 64 00 00       	call   c0029631 <debug_panic>

  page_idx = pg_no (pages) - pg_no (pool->base);
c0023202:	83 ec 0c             	sub    $0xc,%esp
c0023205:	ff 75 08             	pushl  0x8(%ebp)
c0023208:	e8 7d fd ff ff       	call   c0022f8a <pg_no>
c002320d:	83 c4 10             	add    $0x10,%esp
c0023210:	89 c3                	mov    %eax,%ebx
c0023212:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023215:	8b 40 1c             	mov    0x1c(%eax),%eax
c0023218:	83 ec 0c             	sub    $0xc,%esp
c002321b:	50                   	push   %eax
c002321c:	e8 69 fd ff ff       	call   c0022f8a <pg_no>
c0023221:	83 c4 10             	add    $0x10,%esp
c0023224:	29 c3                	sub    %eax,%ebx
c0023226:	89 d8                	mov    %ebx,%eax
c0023228:	89 45 f0             	mov    %eax,-0x10(%ebp)

#ifndef NDEBUG
  memset (pages, 0xcc, PGSIZE * page_cnt);
c002322b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002322e:	c1 e0 0c             	shl    $0xc,%eax
c0023231:	83 ec 04             	sub    $0x4,%esp
c0023234:	50                   	push   %eax
c0023235:	68 cc 00 00 00       	push   $0xcc
c002323a:	ff 75 08             	pushl  0x8(%ebp)
c002323d:	e8 e3 57 00 00       	call   c0028a25 <memset>
c0023242:	83 c4 10             	add    $0x10,%esp
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0023245:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023248:	8b 40 18             	mov    0x18(%eax),%eax
c002324b:	83 ec 04             	sub    $0x4,%esp
c002324e:	ff 75 0c             	pushl  0xc(%ebp)
c0023251:	ff 75 f0             	pushl  -0x10(%ebp)
c0023254:	50                   	push   %eax
c0023255:	e8 24 7a 00 00       	call   c002ac7e <bitmap_all>
c002325a:	83 c4 10             	add    $0x10,%esp
c002325d:	84 c0                	test   %al,%al
c002325f:	75 21                	jne    c0023282 <palloc_free_multiple+0x121>
c0023261:	83 ec 0c             	sub    $0xc,%esp
c0023264:	68 c8 f2 02 c0       	push   $0xc002f2c8
c0023269:	68 1b f2 02 c0       	push   $0xc002f21b
c002326e:	68 54 f3 02 c0       	push   $0xc002f354
c0023273:	68 8c 00 00 00       	push   $0x8c
c0023278:	68 77 f2 02 c0       	push   $0xc002f277
c002327d:	e8 af 63 00 00       	call   c0029631 <debug_panic>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c0023282:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023285:	8b 40 18             	mov    0x18(%eax),%eax
c0023288:	6a 00                	push   $0x0
c002328a:	ff 75 0c             	pushl  0xc(%ebp)
c002328d:	ff 75 f0             	pushl  -0x10(%ebp)
c0023290:	50                   	push   %eax
c0023291:	e8 3d 77 00 00       	call   c002a9d3 <bitmap_set_multiple>
c0023296:	83 c4 10             	add    $0x10,%esp
c0023299:	eb 01                	jmp    c002329c <palloc_free_multiple+0x13b>
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
  if (pages == NULL || page_cnt == 0)
    return;
c002329b:	90                   	nop
  memset (pages, 0xcc, PGSIZE * page_cnt);
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
}
c002329c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002329f:	c9                   	leave  
c00232a0:	c3                   	ret    

c00232a1 <palloc_free_page>:

/* Frees the page at PAGE. */
void
palloc_free_page (void *page) 
{
c00232a1:	55                   	push   %ebp
c00232a2:	89 e5                	mov    %esp,%ebp
c00232a4:	83 ec 08             	sub    $0x8,%esp
  palloc_free_multiple (page, 1);
c00232a7:	83 ec 08             	sub    $0x8,%esp
c00232aa:	6a 01                	push   $0x1
c00232ac:	ff 75 08             	pushl  0x8(%ebp)
c00232af:	e8 ad fe ff ff       	call   c0023161 <palloc_free_multiple>
c00232b4:	83 c4 10             	add    $0x10,%esp
}
c00232b7:	90                   	nop
c00232b8:	c9                   	leave  
c00232b9:	c3                   	ret    

c00232ba <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c00232ba:	55                   	push   %ebp
c00232bb:	89 e5                	mov    %esp,%ebp
c00232bd:	83 ec 18             	sub    $0x18,%esp
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c00232c0:	83 ec 0c             	sub    $0xc,%esp
c00232c3:	ff 75 10             	pushl  0x10(%ebp)
c00232c6:	e8 9e 74 00 00       	call   c002a769 <bitmap_buf_size>
c00232cb:	83 c4 10             	add    $0x10,%esp
c00232ce:	05 ff 0f 00 00       	add    $0xfff,%eax
c00232d3:	c1 e8 0c             	shr    $0xc,%eax
c00232d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (bm_pages > page_cnt)
c00232d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00232dc:	3b 45 10             	cmp    0x10(%ebp),%eax
c00232df:	76 1f                	jbe    c0023300 <init_pool+0x46>
    PANIC ("Not enough memory in %s for bitmap.", name);
c00232e1:	83 ec 0c             	sub    $0xc,%esp
c00232e4:	ff 75 14             	pushl  0x14(%ebp)
c00232e7:	68 f8 f2 02 c0       	push   $0xc002f2f8
c00232ec:	68 6c f3 02 c0       	push   $0xc002f36c
c00232f1:	68 a1 00 00 00       	push   $0xa1
c00232f6:	68 77 f2 02 c0       	push   $0xc002f277
c00232fb:	e8 31 63 00 00       	call   c0029631 <debug_panic>
  page_cnt -= bm_pages;
c0023300:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023303:	29 45 10             	sub    %eax,0x10(%ebp)

  printf ("%zu pages available in %s.\n", page_cnt, name);
c0023306:	83 ec 04             	sub    $0x4,%esp
c0023309:	ff 75 14             	pushl  0x14(%ebp)
c002330c:	ff 75 10             	pushl  0x10(%ebp)
c002330f:	68 1c f3 02 c0       	push   $0xc002f31c
c0023314:	e8 e5 3e 00 00       	call   c00271fe <printf>
c0023319:	83 c4 10             	add    $0x10,%esp

  /* Initialize the pool. */
  lock_init (&p->lock);
c002331c:	8b 45 08             	mov    0x8(%ebp),%eax
c002331f:	83 ec 0c             	sub    $0xc,%esp
c0023322:	50                   	push   %eax
c0023323:	e8 4d f7 ff ff       	call   c0022a75 <lock_init>
c0023328:	83 c4 10             	add    $0x10,%esp
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c002332b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002332e:	c1 e0 0c             	shl    $0xc,%eax
c0023331:	83 ec 04             	sub    $0x4,%esp
c0023334:	50                   	push   %eax
c0023335:	ff 75 0c             	pushl  0xc(%ebp)
c0023338:	ff 75 10             	pushl  0x10(%ebp)
c002333b:	e8 c3 73 00 00       	call   c002a703 <bitmap_create_in_buf>
c0023340:	83 c4 10             	add    $0x10,%esp
c0023343:	89 c2                	mov    %eax,%edx
c0023345:	8b 45 08             	mov    0x8(%ebp),%eax
c0023348:	89 50 18             	mov    %edx,0x18(%eax)
  p->base = base + bm_pages * PGSIZE;
c002334b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002334e:	c1 e0 0c             	shl    $0xc,%eax
c0023351:	89 c2                	mov    %eax,%edx
c0023353:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023356:	01 c2                	add    %eax,%edx
c0023358:	8b 45 08             	mov    0x8(%ebp),%eax
c002335b:	89 50 1c             	mov    %edx,0x1c(%eax)
}
c002335e:	90                   	nop
c002335f:	c9                   	leave  
c0023360:	c3                   	ret    

c0023361 <page_from_pool>:

/* Returns true if PAGE was allocated from POOL,
   false otherwise. */
static bool
page_from_pool (const struct pool *pool, void *page) 
{
c0023361:	55                   	push   %ebp
c0023362:	89 e5                	mov    %esp,%ebp
c0023364:	83 ec 18             	sub    $0x18,%esp
  size_t page_no = pg_no (page);
c0023367:	ff 75 0c             	pushl  0xc(%ebp)
c002336a:	e8 1b fc ff ff       	call   c0022f8a <pg_no>
c002336f:	83 c4 04             	add    $0x4,%esp
c0023372:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t start_page = pg_no (pool->base);
c0023375:	8b 45 08             	mov    0x8(%ebp),%eax
c0023378:	8b 40 1c             	mov    0x1c(%eax),%eax
c002337b:	50                   	push   %eax
c002337c:	e8 09 fc ff ff       	call   c0022f8a <pg_no>
c0023381:	83 c4 04             	add    $0x4,%esp
c0023384:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023387:	8b 45 08             	mov    0x8(%ebp),%eax
c002338a:	8b 40 18             	mov    0x18(%eax),%eax
c002338d:	83 ec 0c             	sub    $0xc,%esp
c0023390:	50                   	push   %eax
c0023391:	e8 15 74 00 00       	call   c002a7ab <bitmap_size>
c0023396:	83 c4 10             	add    $0x10,%esp
c0023399:	89 c2                	mov    %eax,%edx
c002339b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002339e:	01 d0                	add    %edx,%eax
c00233a0:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return page_no >= start_page && page_no < end_page;
c00233a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00233a6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00233a9:	72 0f                	jb     c00233ba <page_from_pool+0x59>
c00233ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00233ae:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00233b1:	73 07                	jae    c00233ba <page_from_pool+0x59>
c00233b3:	b8 01 00 00 00       	mov    $0x1,%eax
c00233b8:	eb 05                	jmp    c00233bf <page_from_pool+0x5e>
c00233ba:	b8 00 00 00 00       	mov    $0x0,%eax
c00233bf:	83 e0 01             	and    $0x1,%eax
}
c00233c2:	c9                   	leave  
c00233c3:	c3                   	ret    

c00233c4 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c00233c4:	55                   	push   %ebp
c00233c5:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c00233c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00233ca:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c00233cf:	5d                   	pop    %ebp
c00233d0:	c3                   	ret    

c00233d1 <pg_round_down>:
static inline void *pg_round_up (const void *va) {
  return (void *) (((uintptr_t) va + PGSIZE - 1) & ~PGMASK);
}

/* Round down to nearest page boundary. */
static inline void *pg_round_down (const void *va) {
c00233d1:	55                   	push   %ebp
c00233d2:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c00233d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00233d7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00233dc:	5d                   	pop    %ebp
c00233dd:	c3                   	ret    

c00233de <malloc_init>:
static struct block *arena_to_block (struct arena *, size_t idx);

/* Initializes the malloc() descriptors. */
void
malloc_init (void) 
{
c00233de:	55                   	push   %ebp
c00233df:	89 e5                	mov    %esp,%ebp
c00233e1:	83 ec 18             	sub    $0x18,%esp
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c00233e4:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c00233eb:	e9 8b 00 00 00       	jmp    c002347b <malloc_init+0x9d>
    {
      struct desc *d = &descs[desc_cnt++];
c00233f0:	8b 15 a0 98 03 c0    	mov    0xc00398a0,%edx
c00233f6:	8d 42 01             	lea    0x1(%edx),%eax
c00233f9:	a3 a0 98 03 c0       	mov    %eax,0xc00398a0
c00233fe:	89 d0                	mov    %edx,%eax
c0023400:	01 c0                	add    %eax,%eax
c0023402:	01 d0                	add    %edx,%eax
c0023404:	c1 e0 04             	shl    $0x4,%eax
c0023407:	05 c0 96 03 c0       	add    $0xc00396c0,%eax
c002340c:	89 45 f0             	mov    %eax,-0x10(%ebp)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c002340f:	a1 a0 98 03 c0       	mov    0xc00398a0,%eax
c0023414:	83 f8 0a             	cmp    $0xa,%eax
c0023417:	76 1e                	jbe    c0023437 <malloc_init+0x59>
c0023419:	83 ec 0c             	sub    $0xc,%esp
c002341c:	68 78 f3 02 c0       	push   $0xc002f378
c0023421:	68 a1 f3 02 c0       	push   $0xc002f3a1
c0023426:	68 ac f4 02 c0       	push   $0xc002f4ac
c002342b:	6a 4f                	push   $0x4f
c002342d:	68 b8 f3 02 c0       	push   $0xc002f3b8
c0023432:	e8 fa 61 00 00       	call   c0029631 <debug_panic>
      d->block_size = block_size;
c0023437:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002343a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002343d:	89 10                	mov    %edx,(%eax)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c002343f:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023444:	ba 00 00 00 00       	mov    $0x0,%edx
c0023449:	f7 75 f4             	divl   -0xc(%ebp)
c002344c:	89 c2                	mov    %eax,%edx
c002344e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023451:	89 50 04             	mov    %edx,0x4(%eax)
      list_init (&d->free_list);
c0023454:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023457:	83 c0 08             	add    $0x8,%eax
c002345a:	83 ec 0c             	sub    $0xc,%esp
c002345d:	50                   	push   %eax
c002345e:	e8 41 64 00 00       	call   c00298a4 <list_init>
c0023463:	83 c4 10             	add    $0x10,%esp
      lock_init (&d->lock);
c0023466:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023469:	83 c0 18             	add    $0x18,%eax
c002346c:	83 ec 0c             	sub    $0xc,%esp
c002346f:	50                   	push   %eax
c0023470:	e8 00 f6 ff ff       	call   c0022a75 <lock_init>
c0023475:	83 c4 10             	add    $0x10,%esp
void
malloc_init (void) 
{
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023478:	d1 65 f4             	shll   -0xc(%ebp)
c002347b:	81 7d f4 ff 07 00 00 	cmpl   $0x7ff,-0xc(%ebp)
c0023482:	0f 86 68 ff ff ff    	jbe    c00233f0 <malloc_init+0x12>
      d->block_size = block_size;
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
      list_init (&d->free_list);
      lock_init (&d->lock);
    }
}
c0023488:	90                   	nop
c0023489:	c9                   	leave  
c002348a:	c3                   	ret    

c002348b <malloc>:

/* Obtains and returns a new block of at least SIZE bytes.
   Returns a null pointer if memory is not available. */
void *
malloc (size_t size) 
{
c002348b:	55                   	push   %ebp
c002348c:	89 e5                	mov    %esp,%ebp
c002348e:	83 ec 28             	sub    $0x28,%esp
  struct desc *d;
  struct block *b;
  struct arena *a;

  /* A null pointer satisfies a request for 0 bytes. */
  if (size == 0)
c0023491:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023495:	75 0a                	jne    c00234a1 <malloc+0x16>
    return NULL;
c0023497:	b8 00 00 00 00       	mov    $0x0,%eax
c002349c:	e9 b2 01 00 00       	jmp    c0023653 <malloc+0x1c8>

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c00234a1:	c7 45 f4 c0 96 03 c0 	movl   $0xc00396c0,-0xc(%ebp)
c00234a8:	eb 0e                	jmp    c00234b8 <malloc+0x2d>
    if (d->block_size >= size)
c00234aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00234ad:	8b 00                	mov    (%eax),%eax
c00234af:	3b 45 08             	cmp    0x8(%ebp),%eax
c00234b2:	73 1f                	jae    c00234d3 <malloc+0x48>
  if (size == 0)
    return NULL;

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c00234b4:	83 45 f4 30          	addl   $0x30,-0xc(%ebp)
c00234b8:	8b 15 a0 98 03 c0    	mov    0xc00398a0,%edx
c00234be:	89 d0                	mov    %edx,%eax
c00234c0:	01 c0                	add    %eax,%eax
c00234c2:	01 d0                	add    %edx,%eax
c00234c4:	c1 e0 04             	shl    $0x4,%eax
c00234c7:	05 c0 96 03 c0       	add    $0xc00396c0,%eax
c00234cc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00234cf:	77 d9                	ja     c00234aa <malloc+0x1f>
c00234d1:	eb 01                	jmp    c00234d4 <malloc+0x49>
    if (d->block_size >= size)
      break;
c00234d3:	90                   	nop
  if (d == descs + desc_cnt) 
c00234d4:	8b 15 a0 98 03 c0    	mov    0xc00398a0,%edx
c00234da:	89 d0                	mov    %edx,%eax
c00234dc:	01 c0                	add    %eax,%eax
c00234de:	01 d0                	add    %edx,%eax
c00234e0:	c1 e0 04             	shl    $0x4,%eax
c00234e3:	05 c0 96 03 c0       	add    $0xc00396c0,%eax
c00234e8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00234eb:	75 58                	jne    c0023545 <malloc+0xba>
    {
      /* SIZE is too big for any descriptor.
         Allocate enough pages to hold SIZE plus an arena. */
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c00234ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00234f0:	05 0b 10 00 00       	add    $0x100b,%eax
c00234f5:	c1 e8 0c             	shr    $0xc,%eax
c00234f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
      a = palloc_get_multiple (0, page_cnt);
c00234fb:	83 ec 08             	sub    $0x8,%esp
c00234fe:	ff 75 ec             	pushl  -0x14(%ebp)
c0023501:	6a 00                	push   $0x0
c0023503:	e8 6d fb ff ff       	call   c0023075 <palloc_get_multiple>
c0023508:	83 c4 10             	add    $0x10,%esp
c002350b:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL)
c002350e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023512:	75 0a                	jne    c002351e <malloc+0x93>
        return NULL;
c0023514:	b8 00 00 00 00       	mov    $0x0,%eax
c0023519:	e9 35 01 00 00       	jmp    c0023653 <malloc+0x1c8>

      /* Initialize the arena to indicate a big block of PAGE_CNT
         pages, and return it. */
      a->magic = ARENA_MAGIC;
c002351e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023521:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c0023527:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002352a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0023531:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023534:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023537:	89 50 08             	mov    %edx,0x8(%eax)
      return a + 1;
c002353a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002353d:	83 c0 0c             	add    $0xc,%eax
c0023540:	e9 0e 01 00 00       	jmp    c0023653 <malloc+0x1c8>
    }

  lock_acquire (&d->lock);
c0023545:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023548:	83 c0 18             	add    $0x18,%eax
c002354b:	83 ec 0c             	sub    $0xc,%esp
c002354e:	50                   	push   %eax
c002354f:	e8 6e f5 ff ff       	call   c0022ac2 <lock_acquire>
c0023554:	83 c4 10             	add    $0x10,%esp

  /* If the free list is empty, create a new arena. */
  if (list_empty (&d->free_list))
c0023557:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002355a:	83 c0 08             	add    $0x8,%eax
c002355d:	83 ec 0c             	sub    $0xc,%esp
c0023560:	50                   	push   %eax
c0023561:	e8 c6 68 00 00       	call   c0029e2c <list_empty>
c0023566:	83 c4 10             	add    $0x10,%esp
c0023569:	84 c0                	test   %al,%al
c002356b:	0f 84 92 00 00 00    	je     c0023603 <malloc+0x178>
    {
      size_t i;

      /* Allocate a page. */
      a = palloc_get_page (0);
c0023571:	83 ec 0c             	sub    $0xc,%esp
c0023574:	6a 00                	push   $0x0
c0023576:	e8 ce fb ff ff       	call   c0023149 <palloc_get_page>
c002357b:	83 c4 10             	add    $0x10,%esp
c002357e:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL) 
c0023581:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023585:	75 1c                	jne    c00235a3 <malloc+0x118>
        {
          lock_release (&d->lock);
c0023587:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002358a:	83 c0 18             	add    $0x18,%eax
c002358d:	83 ec 0c             	sub    $0xc,%esp
c0023590:	50                   	push   %eax
c0023591:	e8 6d f6 ff ff       	call   c0022c03 <lock_release>
c0023596:	83 c4 10             	add    $0x10,%esp
          return NULL; 
c0023599:	b8 00 00 00 00       	mov    $0x0,%eax
c002359e:	e9 b0 00 00 00       	jmp    c0023653 <malloc+0x1c8>
        }

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
c00235a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00235a6:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c00235ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00235af:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00235b2:	89 50 04             	mov    %edx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c00235b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00235b8:	8b 50 04             	mov    0x4(%eax),%edx
c00235bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00235be:	89 50 08             	mov    %edx,0x8(%eax)
      for (i = 0; i < d->blocks_per_arena; i++) 
c00235c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00235c8:	eb 2e                	jmp    c00235f8 <malloc+0x16d>
        {
          struct block *b = arena_to_block (a, i);
c00235ca:	83 ec 08             	sub    $0x8,%esp
c00235cd:	ff 75 f0             	pushl  -0x10(%ebp)
c00235d0:	ff 75 e8             	pushl  -0x18(%ebp)
c00235d3:	e8 ea 03 00 00       	call   c00239c2 <arena_to_block>
c00235d8:	83 c4 10             	add    $0x10,%esp
c00235db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          list_push_back (&d->free_list, &b->free_elem);
c00235de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00235e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00235e4:	83 c2 08             	add    $0x8,%edx
c00235e7:	83 ec 08             	sub    $0x8,%esp
c00235ea:	50                   	push   %eax
c00235eb:	52                   	push   %edx
c00235ec:	e8 93 66 00 00       	call   c0029c84 <list_push_back>
c00235f1:	83 c4 10             	add    $0x10,%esp

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
      a->desc = d;
      a->free_cnt = d->blocks_per_arena;
      for (i = 0; i < d->blocks_per_arena; i++) 
c00235f4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c00235f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00235fb:	8b 40 04             	mov    0x4(%eax),%eax
c00235fe:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0023601:	77 c7                	ja     c00235ca <malloc+0x13f>
          list_push_back (&d->free_list, &b->free_elem);
        }
    }

  /* Get a block from free list and return it. */
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c0023603:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023606:	83 c0 08             	add    $0x8,%eax
c0023609:	83 ec 0c             	sub    $0xc,%esp
c002360c:	50                   	push   %eax
c002360d:	e8 f1 66 00 00       	call   c0029d03 <list_pop_front>
c0023612:	83 c4 10             	add    $0x10,%esp
c0023615:	83 c0 04             	add    $0x4,%eax
c0023618:	83 e8 04             	sub    $0x4,%eax
c002361b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  a = block_to_arena (b);
c002361e:	83 ec 0c             	sub    $0xc,%esp
c0023621:	ff 75 e0             	pushl  -0x20(%ebp)
c0023624:	e8 9b 02 00 00       	call   c00238c4 <block_to_arena>
c0023629:	83 c4 10             	add    $0x10,%esp
c002362c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  a->free_cnt--;
c002362f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023632:	8b 40 08             	mov    0x8(%eax),%eax
c0023635:	8d 50 ff             	lea    -0x1(%eax),%edx
c0023638:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002363b:	89 50 08             	mov    %edx,0x8(%eax)
  lock_release (&d->lock);
c002363e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023641:	83 c0 18             	add    $0x18,%eax
c0023644:	83 ec 0c             	sub    $0xc,%esp
c0023647:	50                   	push   %eax
c0023648:	e8 b6 f5 ff ff       	call   c0022c03 <lock_release>
c002364d:	83 c4 10             	add    $0x10,%esp
  return b;
c0023650:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
c0023653:	c9                   	leave  
c0023654:	c3                   	ret    

c0023655 <calloc>:

/* Allocates and return A times B bytes initialized to zeroes.
   Returns a null pointer if memory is not available. */
void *
calloc (size_t a, size_t b) 
{
c0023655:	55                   	push   %ebp
c0023656:	89 e5                	mov    %esp,%ebp
c0023658:	83 ec 18             	sub    $0x18,%esp
  void *p;
  size_t size;

  /* Calculate block size and make sure it fits in size_t. */
  size = a * b;
c002365b:	8b 45 08             	mov    0x8(%ebp),%eax
c002365e:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023662:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (size < a || size < b)
c0023665:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023668:	3b 45 08             	cmp    0x8(%ebp),%eax
c002366b:	72 08                	jb     c0023675 <calloc+0x20>
c002366d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023670:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023673:	73 07                	jae    c002367c <calloc+0x27>
    return NULL;
c0023675:	b8 00 00 00 00       	mov    $0x0,%eax
c002367a:	eb 2d                	jmp    c00236a9 <calloc+0x54>

  /* Allocate and zero memory. */
  p = malloc (size);
c002367c:	83 ec 0c             	sub    $0xc,%esp
c002367f:	ff 75 f4             	pushl  -0xc(%ebp)
c0023682:	e8 04 fe ff ff       	call   c002348b <malloc>
c0023687:	83 c4 10             	add    $0x10,%esp
c002368a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (p != NULL)
c002368d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0023691:	74 13                	je     c00236a6 <calloc+0x51>
    memset (p, 0, size);
c0023693:	83 ec 04             	sub    $0x4,%esp
c0023696:	ff 75 f4             	pushl  -0xc(%ebp)
c0023699:	6a 00                	push   $0x0
c002369b:	ff 75 f0             	pushl  -0x10(%ebp)
c002369e:	e8 82 53 00 00       	call   c0028a25 <memset>
c00236a3:	83 c4 10             	add    $0x10,%esp

  return p;
c00236a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c00236a9:	c9                   	leave  
c00236aa:	c3                   	ret    

c00236ab <block_size>:

/* Returns the number of bytes allocated for BLOCK. */
static size_t
block_size (void *block) 
{
c00236ab:	55                   	push   %ebp
c00236ac:	89 e5                	mov    %esp,%ebp
c00236ae:	53                   	push   %ebx
c00236af:	83 ec 14             	sub    $0x14,%esp
  struct block *b = block;
c00236b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00236b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct arena *a = block_to_arena (b);
c00236b8:	83 ec 0c             	sub    $0xc,%esp
c00236bb:	ff 75 f4             	pushl  -0xc(%ebp)
c00236be:	e8 01 02 00 00       	call   c00238c4 <block_to_arena>
c00236c3:	83 c4 10             	add    $0x10,%esp
c00236c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct desc *d = a->desc;
c00236c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00236cc:	8b 40 04             	mov    0x4(%eax),%eax
c00236cf:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c00236d2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00236d6:	74 07                	je     c00236df <block_size+0x34>
c00236d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00236db:	8b 00                	mov    (%eax),%eax
c00236dd:	eb 1d                	jmp    c00236fc <block_size+0x51>
c00236df:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00236e2:	8b 40 08             	mov    0x8(%eax),%eax
c00236e5:	c1 e0 0c             	shl    $0xc,%eax
c00236e8:	89 c3                	mov    %eax,%ebx
c00236ea:	83 ec 0c             	sub    $0xc,%esp
c00236ed:	ff 75 08             	pushl  0x8(%ebp)
c00236f0:	e8 cf fc ff ff       	call   c00233c4 <pg_ofs>
c00236f5:	83 c4 10             	add    $0x10,%esp
c00236f8:	29 c3                	sub    %eax,%ebx
c00236fa:	89 d8                	mov    %ebx,%eax
}
c00236fc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00236ff:	c9                   	leave  
c0023700:	c3                   	ret    

c0023701 <realloc>:
   null pointer.
   A call with null OLD_BLOCK is equivalent to malloc(NEW_SIZE).
   A call with zero NEW_SIZE is equivalent to free(OLD_BLOCK). */
void *
realloc (void *old_block, size_t new_size) 
{
c0023701:	55                   	push   %ebp
c0023702:	89 e5                	mov    %esp,%ebp
c0023704:	83 ec 18             	sub    $0x18,%esp
  if (new_size == 0) 
c0023707:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002370b:	75 15                	jne    c0023722 <realloc+0x21>
    {
      free (old_block);
c002370d:	83 ec 0c             	sub    $0xc,%esp
c0023710:	ff 75 08             	pushl  0x8(%ebp)
c0023713:	e8 6c 00 00 00       	call   c0023784 <free>
c0023718:	83 c4 10             	add    $0x10,%esp
      return NULL;
c002371b:	b8 00 00 00 00       	mov    $0x0,%eax
c0023720:	eb 60                	jmp    c0023782 <realloc+0x81>
    }
  else 
    {
      void *new_block = malloc (new_size);
c0023722:	83 ec 0c             	sub    $0xc,%esp
c0023725:	ff 75 0c             	pushl  0xc(%ebp)
c0023728:	e8 5e fd ff ff       	call   c002348b <malloc>
c002372d:	83 c4 10             	add    $0x10,%esp
c0023730:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (old_block != NULL && new_block != NULL)
c0023733:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023737:	74 46                	je     c002377f <realloc+0x7e>
c0023739:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002373d:	74 40                	je     c002377f <realloc+0x7e>
        {
          size_t old_size = block_size (old_block);
c002373f:	83 ec 0c             	sub    $0xc,%esp
c0023742:	ff 75 08             	pushl  0x8(%ebp)
c0023745:	e8 61 ff ff ff       	call   c00236ab <block_size>
c002374a:	83 c4 10             	add    $0x10,%esp
c002374d:	89 45 f0             	mov    %eax,-0x10(%ebp)
          size_t min_size = new_size < old_size ? new_size : old_size;
c0023750:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023753:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0023756:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
c002375a:	89 45 ec             	mov    %eax,-0x14(%ebp)
          memcpy (new_block, old_block, min_size);
c002375d:	83 ec 04             	sub    $0x4,%esp
c0023760:	ff 75 ec             	pushl  -0x14(%ebp)
c0023763:	ff 75 08             	pushl  0x8(%ebp)
c0023766:	ff 75 f4             	pushl  -0xc(%ebp)
c0023769:	e8 b1 4c 00 00       	call   c002841f <memcpy>
c002376e:	83 c4 10             	add    $0x10,%esp
          free (old_block);
c0023771:	83 ec 0c             	sub    $0xc,%esp
c0023774:	ff 75 08             	pushl  0x8(%ebp)
c0023777:	e8 08 00 00 00       	call   c0023784 <free>
c002377c:	83 c4 10             	add    $0x10,%esp
        }
      return new_block;
c002377f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c0023782:	c9                   	leave  
c0023783:	c3                   	ret    

c0023784 <free>:

/* Frees block P, which must have been previously allocated with
   malloc(), calloc(), or realloc(). */
void
free (void *p) 
{
c0023784:	55                   	push   %ebp
c0023785:	89 e5                	mov    %esp,%ebp
c0023787:	83 ec 28             	sub    $0x28,%esp
  if (p != NULL)
c002378a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002378e:	0f 84 2e 01 00 00    	je     c00238c2 <free+0x13e>
    {
      struct block *b = p;
c0023794:	8b 45 08             	mov    0x8(%ebp),%eax
c0023797:	89 45 f0             	mov    %eax,-0x10(%ebp)
      struct arena *a = block_to_arena (b);
c002379a:	83 ec 0c             	sub    $0xc,%esp
c002379d:	ff 75 f0             	pushl  -0x10(%ebp)
c00237a0:	e8 1f 01 00 00       	call   c00238c4 <block_to_arena>
c00237a5:	83 c4 10             	add    $0x10,%esp
c00237a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct desc *d = a->desc;
c00237ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00237ae:	8b 40 04             	mov    0x4(%eax),%eax
c00237b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      if (d != NULL) 
c00237b4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00237b8:	0f 84 ee 00 00 00    	je     c00238ac <free+0x128>
        {
          /* It's a normal block.  We handle it here. */

#ifndef NDEBUG
          /* Clear the block to help detect use-after-free bugs. */
          memset (b, 0xcc, d->block_size);
c00237be:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00237c1:	8b 00                	mov    (%eax),%eax
c00237c3:	83 ec 04             	sub    $0x4,%esp
c00237c6:	50                   	push   %eax
c00237c7:	68 cc 00 00 00       	push   $0xcc
c00237cc:	ff 75 f0             	pushl  -0x10(%ebp)
c00237cf:	e8 51 52 00 00       	call   c0028a25 <memset>
c00237d4:	83 c4 10             	add    $0x10,%esp
#endif
  
          lock_acquire (&d->lock);
c00237d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00237da:	83 c0 18             	add    $0x18,%eax
c00237dd:	83 ec 0c             	sub    $0xc,%esp
c00237e0:	50                   	push   %eax
c00237e1:	e8 dc f2 ff ff       	call   c0022ac2 <lock_acquire>
c00237e6:	83 c4 10             	add    $0x10,%esp

          /* Add block to free list. */
          list_push_front (&d->free_list, &b->free_elem);
c00237e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00237ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00237ef:	83 c2 08             	add    $0x8,%edx
c00237f2:	83 ec 08             	sub    $0x8,%esp
c00237f5:	50                   	push   %eax
c00237f6:	52                   	push   %edx
c00237f7:	e8 62 64 00 00       	call   c0029c5e <list_push_front>
c00237fc:	83 c4 10             	add    $0x10,%esp

          /* If the arena is now entirely unused, free it. */
          if (++a->free_cnt >= d->blocks_per_arena) 
c00237ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023802:	8b 40 08             	mov    0x8(%eax),%eax
c0023805:	8d 50 01             	lea    0x1(%eax),%edx
c0023808:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002380b:	89 50 08             	mov    %edx,0x8(%eax)
c002380e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023811:	8b 50 08             	mov    0x8(%eax),%edx
c0023814:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023817:	8b 40 04             	mov    0x4(%eax),%eax
c002381a:	39 c2                	cmp    %eax,%edx
c002381c:	72 7a                	jb     c0023898 <free+0x114>
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
c002381e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023821:	8b 50 08             	mov    0x8(%eax),%edx
c0023824:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023827:	8b 40 04             	mov    0x4(%eax),%eax
c002382a:	39 c2                	cmp    %eax,%edx
c002382c:	74 21                	je     c002384f <free+0xcb>
c002382e:	83 ec 0c             	sub    $0xc,%esp
c0023831:	68 d0 f3 02 c0       	push   $0xc002f3d0
c0023836:	68 a1 f3 02 c0       	push   $0xc002f3a1
c002383b:	68 b8 f4 02 c0       	push   $0xc002f4b8
c0023840:	68 f6 00 00 00       	push   $0xf6
c0023845:	68 b8 f3 02 c0       	push   $0xc002f3b8
c002384a:	e8 e2 5d 00 00       	call   c0029631 <debug_panic>
              for (i = 0; i < d->blocks_per_arena; i++) 
c002384f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023856:	eb 27                	jmp    c002387f <free+0xfb>
                {
                  struct block *b = arena_to_block (a, i);
c0023858:	83 ec 08             	sub    $0x8,%esp
c002385b:	ff 75 f4             	pushl  -0xc(%ebp)
c002385e:	ff 75 ec             	pushl  -0x14(%ebp)
c0023861:	e8 5c 01 00 00       	call   c00239c2 <arena_to_block>
c0023866:	83 c4 10             	add    $0x10,%esp
c0023869:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                  list_remove (&b->free_elem);
c002386c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002386f:	83 ec 0c             	sub    $0xc,%esp
c0023872:	50                   	push   %eax
c0023873:	e8 32 64 00 00       	call   c0029caa <list_remove>
c0023878:	83 c4 10             	add    $0x10,%esp
          if (++a->free_cnt >= d->blocks_per_arena) 
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
              for (i = 0; i < d->blocks_per_arena; i++) 
c002387b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002387f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023882:	8b 40 04             	mov    0x4(%eax),%eax
c0023885:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023888:	77 ce                	ja     c0023858 <free+0xd4>
                {
                  struct block *b = arena_to_block (a, i);
                  list_remove (&b->free_elem);
                }
              palloc_free_page (a);
c002388a:	83 ec 0c             	sub    $0xc,%esp
c002388d:	ff 75 ec             	pushl  -0x14(%ebp)
c0023890:	e8 0c fa ff ff       	call   c00232a1 <palloc_free_page>
c0023895:	83 c4 10             	add    $0x10,%esp
            }

          lock_release (&d->lock);
c0023898:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002389b:	83 c0 18             	add    $0x18,%eax
c002389e:	83 ec 0c             	sub    $0xc,%esp
c00238a1:	50                   	push   %eax
c00238a2:	e8 5c f3 ff ff       	call   c0022c03 <lock_release>
c00238a7:	83 c4 10             	add    $0x10,%esp
c00238aa:	eb 16                	jmp    c00238c2 <free+0x13e>
        }
      else
        {
          /* It's a big block.  Free its pages. */
          palloc_free_multiple (a, a->free_cnt);
c00238ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00238af:	8b 40 08             	mov    0x8(%eax),%eax
c00238b2:	83 ec 08             	sub    $0x8,%esp
c00238b5:	50                   	push   %eax
c00238b6:	ff 75 ec             	pushl  -0x14(%ebp)
c00238b9:	e8 a3 f8 ff ff       	call   c0023161 <palloc_free_multiple>
c00238be:	83 c4 10             	add    $0x10,%esp
          return;
c00238c1:	90                   	nop
        }
    }
}
c00238c2:	c9                   	leave  
c00238c3:	c3                   	ret    

c00238c4 <block_to_arena>:

/* Returns the arena that block B is inside. */
static struct arena *
block_to_arena (struct block *b)
{
c00238c4:	55                   	push   %ebp
c00238c5:	89 e5                	mov    %esp,%ebp
c00238c7:	83 ec 18             	sub    $0x18,%esp
  struct arena *a = pg_round_down (b);
c00238ca:	ff 75 08             	pushl  0x8(%ebp)
c00238cd:	e8 ff fa ff ff       	call   c00233d1 <pg_round_down>
c00238d2:	83 c4 04             	add    $0x4,%esp
c00238d5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Check that the arena is valid. */
  ASSERT (a != NULL);
c00238d8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00238dc:	75 21                	jne    c00238ff <block_to_arena+0x3b>
c00238de:	83 ec 0c             	sub    $0xc,%esp
c00238e1:	68 f3 f3 02 c0       	push   $0xc002f3f3
c00238e6:	68 a1 f3 02 c0       	push   $0xc002f3a1
c00238eb:	68 c0 f4 02 c0       	push   $0xc002f4c0
c00238f0:	68 11 01 00 00       	push   $0x111
c00238f5:	68 b8 f3 02 c0       	push   $0xc002f3b8
c00238fa:	e8 32 5d 00 00       	call   c0029631 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c00238ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023902:	8b 00                	mov    (%eax),%eax
c0023904:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0023909:	74 21                	je     c002392c <block_to_arena+0x68>
c002390b:	83 ec 0c             	sub    $0xc,%esp
c002390e:	68 fd f3 02 c0       	push   $0xc002f3fd
c0023913:	68 a1 f3 02 c0       	push   $0xc002f3a1
c0023918:	68 c0 f4 02 c0       	push   $0xc002f4c0
c002391d:	68 12 01 00 00       	push   $0x112
c0023922:	68 b8 f3 02 c0       	push   $0xc002f3b8
c0023927:	e8 05 5d 00 00       	call   c0029631 <debug_panic>

  /* Check that the block is properly aligned for the arena. */
  ASSERT (a->desc == NULL
c002392c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002392f:	8b 40 04             	mov    0x4(%eax),%eax
c0023932:	85 c0                	test   %eax,%eax
c0023934:	74 49                	je     c002397f <block_to_arena+0xbb>
c0023936:	83 ec 0c             	sub    $0xc,%esp
c0023939:	ff 75 08             	pushl  0x8(%ebp)
c002393c:	e8 83 fa ff ff       	call   c00233c4 <pg_ofs>
c0023941:	83 c4 10             	add    $0x10,%esp
c0023944:	8d 50 f4             	lea    -0xc(%eax),%edx
c0023947:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002394a:	8b 40 04             	mov    0x4(%eax),%eax
c002394d:	8b 08                	mov    (%eax),%ecx
c002394f:	89 d0                	mov    %edx,%eax
c0023951:	ba 00 00 00 00       	mov    $0x0,%edx
c0023956:	f7 f1                	div    %ecx
c0023958:	89 d0                	mov    %edx,%eax
c002395a:	85 c0                	test   %eax,%eax
c002395c:	74 21                	je     c002397f <block_to_arena+0xbb>
c002395e:	83 ec 0c             	sub    $0xc,%esp
c0023961:	68 18 f4 02 c0       	push   $0xc002f418
c0023966:	68 a1 f3 02 c0       	push   $0xc002f3a1
c002396b:	68 c0 f4 02 c0       	push   $0xc002f4c0
c0023970:	68 16 01 00 00       	push   $0x116
c0023975:	68 b8 f3 02 c0       	push   $0xc002f3b8
c002397a:	e8 b2 5c 00 00       	call   c0029631 <debug_panic>
          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c002397f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023982:	8b 40 04             	mov    0x4(%eax),%eax
c0023985:	85 c0                	test   %eax,%eax
c0023987:	75 34                	jne    c00239bd <block_to_arena+0xf9>
c0023989:	83 ec 0c             	sub    $0xc,%esp
c002398c:	ff 75 08             	pushl  0x8(%ebp)
c002398f:	e8 30 fa ff ff       	call   c00233c4 <pg_ofs>
c0023994:	83 c4 10             	add    $0x10,%esp
c0023997:	83 f8 0c             	cmp    $0xc,%eax
c002399a:	74 21                	je     c00239bd <block_to_arena+0xf9>
c002399c:	83 ec 0c             	sub    $0xc,%esp
c002399f:	68 60 f4 02 c0       	push   $0xc002f460
c00239a4:	68 a1 f3 02 c0       	push   $0xc002f3a1
c00239a9:	68 c0 f4 02 c0       	push   $0xc002f4c0
c00239ae:	68 17 01 00 00       	push   $0x117
c00239b3:	68 b8 f3 02 c0       	push   $0xc002f3b8
c00239b8:	e8 74 5c 00 00       	call   c0029631 <debug_panic>

  return a;
c00239bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00239c0:	c9                   	leave  
c00239c1:	c3                   	ret    

c00239c2 <arena_to_block>:

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c00239c2:	55                   	push   %ebp
c00239c3:	89 e5                	mov    %esp,%ebp
c00239c5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c00239c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00239cc:	75 21                	jne    c00239ef <arena_to_block+0x2d>
c00239ce:	83 ec 0c             	sub    $0xc,%esp
c00239d1:	68 f3 f3 02 c0       	push   $0xc002f3f3
c00239d6:	68 a1 f3 02 c0       	push   $0xc002f3a1
c00239db:	68 d0 f4 02 c0       	push   $0xc002f4d0
c00239e0:	68 20 01 00 00       	push   $0x120
c00239e5:	68 b8 f3 02 c0       	push   $0xc002f3b8
c00239ea:	e8 42 5c 00 00       	call   c0029631 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c00239ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00239f2:	8b 00                	mov    (%eax),%eax
c00239f4:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c00239f9:	74 21                	je     c0023a1c <arena_to_block+0x5a>
c00239fb:	83 ec 0c             	sub    $0xc,%esp
c00239fe:	68 fd f3 02 c0       	push   $0xc002f3fd
c0023a03:	68 a1 f3 02 c0       	push   $0xc002f3a1
c0023a08:	68 d0 f4 02 c0       	push   $0xc002f4d0
c0023a0d:	68 21 01 00 00       	push   $0x121
c0023a12:	68 b8 f3 02 c0       	push   $0xc002f3b8
c0023a17:	e8 15 5c 00 00       	call   c0029631 <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c0023a1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a1f:	8b 40 04             	mov    0x4(%eax),%eax
c0023a22:	8b 40 04             	mov    0x4(%eax),%eax
c0023a25:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023a28:	77 21                	ja     c0023a4b <arena_to_block+0x89>
c0023a2a:	83 ec 0c             	sub    $0xc,%esp
c0023a2d:	68 8c f4 02 c0       	push   $0xc002f48c
c0023a32:	68 a1 f3 02 c0       	push   $0xc002f3a1
c0023a37:	68 d0 f4 02 c0       	push   $0xc002f4d0
c0023a3c:	68 22 01 00 00       	push   $0x122
c0023a41:	68 b8 f3 02 c0       	push   $0xc002f3b8
c0023a46:	e8 e6 5b 00 00       	call   c0029631 <debug_panic>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c0023a4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a4e:	8b 40 04             	mov    0x4(%eax),%eax
c0023a51:	8b 00                	mov    (%eax),%eax
c0023a53:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023a57:	8d 50 0c             	lea    0xc(%eax),%edx
arena_to_block (struct arena *a, size_t idx) 
{
  ASSERT (a != NULL);
  ASSERT (a->magic == ARENA_MAGIC);
  ASSERT (idx < a->desc->blocks_per_arena);
  return (struct block *) ((uint8_t *) a
c0023a5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a5d:	01 d0                	add    %edx,%eax
                           + sizeof *a
                           + idx * a->desc->block_size);
}
c0023a5f:	c9                   	leave  
c0023a60:	c3                   	ret    

c0023a61 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0023a61:	55                   	push   %ebp
c0023a62:	89 e5                	mov    %esp,%ebp
c0023a64:	83 ec 08             	sub    $0x8,%esp
c0023a67:	8b 55 08             	mov    0x8(%ebp),%edx
c0023a6a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023a6d:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0023a71:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0023a74:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0023a78:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0023a7c:	ee                   	out    %al,(%dx)
}
c0023a7d:	90                   	nop
c0023a7e:	c9                   	leave  
c0023a7f:	c3                   	ret    

c0023a80 <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0023a80:	55                   	push   %ebp
c0023a81:	89 e5                	mov    %esp,%ebp
c0023a83:	83 ec 18             	sub    $0x18,%esp
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0023a86:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023a8a:	74 24                	je     c0023ab0 <pit_configure_channel+0x30>
c0023a8c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0023a90:	74 1e                	je     c0023ab0 <pit_configure_channel+0x30>
c0023a92:	83 ec 0c             	sub    $0xc,%esp
c0023a95:	68 e0 f4 02 c0       	push   $0xc002f4e0
c0023a9a:	68 fd f4 02 c0       	push   $0xc002f4fd
c0023a9f:	68 40 f5 02 c0       	push   $0xc002f540
c0023aa4:	6a 33                	push   $0x33
c0023aa6:	68 14 f5 02 c0       	push   $0xc002f514
c0023aab:	e8 81 5b 00 00       	call   c0029631 <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0023ab0:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
c0023ab4:	74 24                	je     c0023ada <pit_configure_channel+0x5a>
c0023ab6:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0023aba:	74 1e                	je     c0023ada <pit_configure_channel+0x5a>
c0023abc:	83 ec 0c             	sub    $0xc,%esp
c0023abf:	68 28 f5 02 c0       	push   $0xc002f528
c0023ac4:	68 fd f4 02 c0       	push   $0xc002f4fd
c0023ac9:	68 40 f5 02 c0       	push   $0xc002f540
c0023ace:	6a 34                	push   $0x34
c0023ad0:	68 14 f5 02 c0       	push   $0xc002f514
c0023ad5:	e8 57 5b 00 00       	call   c0029631 <debug_panic>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0023ada:	83 7d 10 12          	cmpl   $0x12,0x10(%ebp)
c0023ade:	7f 08                	jg     c0023ae8 <pit_configure_channel+0x68>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c0023ae0:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c0023ae6:	eb 2a                	jmp    c0023b12 <pit_configure_channel+0x92>
    }
  else if (frequency > PIT_HZ)
c0023ae8:	81 7d 10 dc 34 12 00 	cmpl   $0x1234dc,0x10(%ebp)
c0023aef:	7e 08                	jle    c0023af9 <pit_configure_channel+0x79>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c0023af1:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
c0023af7:	eb 19                	jmp    c0023b12 <pit_configure_channel+0x92>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0023af9:	8b 45 10             	mov    0x10(%ebp),%eax
c0023afc:	89 c2                	mov    %eax,%edx
c0023afe:	c1 ea 1f             	shr    $0x1f,%edx
c0023b01:	01 d0                	add    %edx,%eax
c0023b03:	d1 f8                	sar    %eax
c0023b05:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023b0a:	99                   	cltd   
c0023b0b:	f7 7d 10             	idivl  0x10(%ebp)
c0023b0e:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0023b12:	e8 97 d8 ff ff       	call   c00213ae <intr_disable>
c0023b17:	89 45 f0             	mov    %eax,-0x10(%ebp)
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023b1a:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b1d:	c1 e0 06             	shl    $0x6,%eax
c0023b20:	83 c8 30             	or     $0x30,%eax
c0023b23:	89 c2                	mov    %eax,%edx
c0023b25:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023b28:	01 c0                	add    %eax,%eax
c0023b2a:	09 d0                	or     %edx,%eax
c0023b2c:	0f b6 c0             	movzbl %al,%eax
c0023b2f:	83 ec 08             	sub    $0x8,%esp
c0023b32:	50                   	push   %eax
c0023b33:	6a 43                	push   $0x43
c0023b35:	e8 27 ff ff ff       	call   c0023a61 <outb>
c0023b3a:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count);
c0023b3d:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0023b41:	0f b6 d0             	movzbl %al,%edx
c0023b44:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b47:	83 c0 40             	add    $0x40,%eax
c0023b4a:	0f b7 c0             	movzwl %ax,%eax
c0023b4d:	83 ec 08             	sub    $0x8,%esp
c0023b50:	52                   	push   %edx
c0023b51:	50                   	push   %eax
c0023b52:	e8 0a ff ff ff       	call   c0023a61 <outb>
c0023b57:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0023b5a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0023b5e:	66 c1 e8 08          	shr    $0x8,%ax
c0023b62:	0f b6 d0             	movzbl %al,%edx
c0023b65:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b68:	83 c0 40             	add    $0x40,%eax
c0023b6b:	0f b7 c0             	movzwl %ax,%eax
c0023b6e:	83 ec 08             	sub    $0x8,%esp
c0023b71:	52                   	push   %edx
c0023b72:	50                   	push   %eax
c0023b73:	e8 e9 fe ff ff       	call   c0023a61 <outb>
c0023b78:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0023b7b:	83 ec 0c             	sub    $0xc,%esp
c0023b7e:	ff 75 f0             	pushl  -0x10(%ebp)
c0023b81:	e8 d0 d7 ff ff       	call   c0021356 <intr_set_level>
c0023b86:	83 c4 10             	add    $0x10,%esp
}
c0023b89:	90                   	nop
c0023b8a:	c9                   	leave  
c0023b8b:	c3                   	ret    

c0023b8c <timer_init>:

/* Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */
void
timer_init (void) 
{
c0023b8c:	55                   	push   %ebp
c0023b8d:	89 e5                	mov    %esp,%ebp
c0023b8f:	83 ec 08             	sub    $0x8,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c0023b92:	83 ec 04             	sub    $0x4,%esp
c0023b95:	6a 64                	push   $0x64
c0023b97:	6a 02                	push   $0x2
c0023b99:	6a 00                	push   $0x0
c0023b9b:	e8 e0 fe ff ff       	call   c0023a80 <pit_configure_channel>
c0023ba0:	83 c4 10             	add    $0x10,%esp
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c0023ba3:	83 ec 04             	sub    $0x4,%esp
c0023ba6:	68 58 f5 02 c0       	push   $0xc002f558
c0023bab:	68 b3 3e 02 c0       	push   $0xc0023eb3
c0023bb0:	6a 20                	push   $0x20
c0023bb2:	e8 18 da ff ff       	call   c00215cf <intr_register_ext>
c0023bb7:	83 c4 10             	add    $0x10,%esp
}
c0023bba:	90                   	nop
c0023bbb:	c9                   	leave  
c0023bbc:	c3                   	ret    

c0023bbd <timer_calibrate>:

/* Calibrates loops_per_tick, used to implement brief delays. */
void
timer_calibrate (void) 
{
c0023bbd:	55                   	push   %ebp
c0023bbe:	89 e5                	mov    %esp,%ebp
c0023bc0:	53                   	push   %ebx
c0023bc1:	83 ec 14             	sub    $0x14,%esp
  unsigned high_bit, test_bit;

  ASSERT (intr_get_level () == INTR_ON);
c0023bc4:	e8 70 d7 ff ff       	call   c0021339 <intr_get_level>
c0023bc9:	83 f8 01             	cmp    $0x1,%eax
c0023bcc:	74 1e                	je     c0023bec <timer_calibrate+0x2f>
c0023bce:	83 ec 0c             	sub    $0xc,%esp
c0023bd1:	68 63 f5 02 c0       	push   $0xc002f563
c0023bd6:	68 80 f5 02 c0       	push   $0xc002f580
c0023bdb:	68 10 f6 02 c0       	push   $0xc002f610
c0023be0:	6a 30                	push   $0x30
c0023be2:	68 97 f5 02 c0       	push   $0xc002f597
c0023be7:	e8 45 5a 00 00       	call   c0029631 <debug_panic>
  printf ("Calibrating timer...  ");
c0023bec:	83 ec 0c             	sub    $0xc,%esp
c0023bef:	68 ad f5 02 c0       	push   $0xc002f5ad
c0023bf4:	e8 05 36 00 00       	call   c00271fe <printf>
c0023bf9:	83 c4 10             	add    $0x10,%esp

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
c0023bfc:	c7 05 b0 98 03 c0 00 	movl   $0x400,0xc00398b0
c0023c03:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0023c06:	eb 33                	jmp    c0023c3b <timer_calibrate+0x7e>
    {
      loops_per_tick <<= 1;
c0023c08:	a1 b0 98 03 c0       	mov    0xc00398b0,%eax
c0023c0d:	01 c0                	add    %eax,%eax
c0023c0f:	a3 b0 98 03 c0       	mov    %eax,0xc00398b0
      ASSERT (loops_per_tick != 0);
c0023c14:	a1 b0 98 03 c0       	mov    0xc00398b0,%eax
c0023c19:	85 c0                	test   %eax,%eax
c0023c1b:	75 1e                	jne    c0023c3b <timer_calibrate+0x7e>
c0023c1d:	83 ec 0c             	sub    $0xc,%esp
c0023c20:	68 c4 f5 02 c0       	push   $0xc002f5c4
c0023c25:	68 80 f5 02 c0       	push   $0xc002f580
c0023c2a:	68 10 f6 02 c0       	push   $0xc002f610
c0023c2f:	6a 39                	push   $0x39
c0023c31:	68 97 f5 02 c0       	push   $0xc002f597
c0023c36:	e8 f6 59 00 00       	call   c0029631 <debug_panic>
  printf ("Calibrating timer...  ");

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
  while (!too_many_loops (loops_per_tick << 1)) 
c0023c3b:	a1 b0 98 03 c0       	mov    0xc00398b0,%eax
c0023c40:	01 c0                	add    %eax,%eax
c0023c42:	83 ec 0c             	sub    $0xc,%esp
c0023c45:	50                   	push   %eax
c0023c46:	e8 92 02 00 00       	call   c0023edd <too_many_loops>
c0023c4b:	83 c4 10             	add    $0x10,%esp
c0023c4e:	83 f0 01             	xor    $0x1,%eax
c0023c51:	84 c0                	test   %al,%al
c0023c53:	75 b3                	jne    c0023c08 <timer_calibrate+0x4b>
      loops_per_tick <<= 1;
      ASSERT (loops_per_tick != 0);
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
c0023c55:	a1 b0 98 03 c0       	mov    0xc00398b0,%eax
c0023c5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023c5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c60:	d1 e8                	shr    %eax
c0023c62:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023c65:	eb 29                	jmp    c0023c90 <timer_calibrate+0xd3>
    if (!too_many_loops (high_bit | test_bit))
c0023c67:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c6a:	0b 45 f4             	or     -0xc(%ebp),%eax
c0023c6d:	83 ec 0c             	sub    $0xc,%esp
c0023c70:	50                   	push   %eax
c0023c71:	e8 67 02 00 00       	call   c0023edd <too_many_loops>
c0023c76:	83 c4 10             	add    $0x10,%esp
c0023c79:	83 f0 01             	xor    $0x1,%eax
c0023c7c:	84 c0                	test   %al,%al
c0023c7e:	74 0d                	je     c0023c8d <timer_calibrate+0xd0>
      loops_per_tick |= test_bit;
c0023c80:	a1 b0 98 03 c0       	mov    0xc00398b0,%eax
c0023c85:	0b 45 f4             	or     -0xc(%ebp),%eax
c0023c88:	a3 b0 98 03 c0       	mov    %eax,0xc00398b0
      ASSERT (loops_per_tick != 0);
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023c8d:	d1 6d f4             	shrl   -0xc(%ebp)
c0023c90:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c93:	c1 e8 0a             	shr    $0xa,%eax
c0023c96:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023c99:	75 cc                	jne    c0023c67 <timer_calibrate+0xaa>
    if (!too_many_loops (high_bit | test_bit))
      loops_per_tick |= test_bit;

  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0023c9b:	a1 b0 98 03 c0       	mov    0xc00398b0,%eax
c0023ca0:	ba 00 00 00 00       	mov    $0x0,%edx
c0023ca5:	6b da 64             	imul   $0x64,%edx,%ebx
c0023ca8:	6b c8 00             	imul   $0x0,%eax,%ecx
c0023cab:	01 d9                	add    %ebx,%ecx
c0023cad:	bb 64 00 00 00       	mov    $0x64,%ebx
c0023cb2:	f7 e3                	mul    %ebx
c0023cb4:	01 d1                	add    %edx,%ecx
c0023cb6:	89 ca                	mov    %ecx,%edx
c0023cb8:	83 ec 04             	sub    $0x4,%esp
c0023cbb:	52                   	push   %edx
c0023cbc:	50                   	push   %eax
c0023cbd:	68 d8 f5 02 c0       	push   $0xc002f5d8
c0023cc2:	e8 37 35 00 00       	call   c00271fe <printf>
c0023cc7:	83 c4 10             	add    $0x10,%esp
}
c0023cca:	90                   	nop
c0023ccb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023cce:	c9                   	leave  
c0023ccf:	c3                   	ret    

c0023cd0 <timer_ticks>:

/* Returns the number of timer ticks since the OS booted. */
int64_t
timer_ticks (void) 
{
c0023cd0:	55                   	push   %ebp
c0023cd1:	89 e5                	mov    %esp,%ebp
c0023cd3:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0023cd6:	e8 d3 d6 ff ff       	call   c00213ae <intr_disable>
c0023cdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t t = ticks;
c0023cde:	a1 a8 98 03 c0       	mov    0xc00398a8,%eax
c0023ce3:	8b 15 ac 98 03 c0    	mov    0xc00398ac,%edx
c0023ce9:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0023cec:	89 55 ec             	mov    %edx,-0x14(%ebp)
  intr_set_level (old_level);
c0023cef:	83 ec 0c             	sub    $0xc,%esp
c0023cf2:	ff 75 f4             	pushl  -0xc(%ebp)
c0023cf5:	e8 5c d6 ff ff       	call   c0021356 <intr_set_level>
c0023cfa:	83 c4 10             	add    $0x10,%esp
  return t;
c0023cfd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023d00:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
c0023d03:	c9                   	leave  
c0023d04:	c3                   	ret    

c0023d05 <timer_elapsed>:

/* Returns the number of timer ticks elapsed since THEN, which
   should be a value once returned by timer_ticks(). */
int64_t
timer_elapsed (int64_t then) 
{
c0023d05:	55                   	push   %ebp
c0023d06:	89 e5                	mov    %esp,%ebp
c0023d08:	83 ec 18             	sub    $0x18,%esp
c0023d0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023d11:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023d14:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return timer_ticks () - then;
c0023d17:	e8 b4 ff ff ff       	call   c0023cd0 <timer_ticks>
c0023d1c:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0023d1f:	1b 55 f4             	sbb    -0xc(%ebp),%edx
}
c0023d22:	c9                   	leave  
c0023d23:	c3                   	ret    

c0023d24 <timer_sleep>:

/* Sleeps for approximately TICKS timer ticks.  Interrupts must
   be turned on. */
void
timer_sleep (int64_t ticks) 
{
c0023d24:	55                   	push   %ebp
c0023d25:	89 e5                	mov    %esp,%ebp
c0023d27:	83 ec 28             	sub    $0x28,%esp
c0023d2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d2d:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0023d30:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023d33:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  int64_t start = timer_ticks ();
c0023d36:	e8 95 ff ff ff       	call   c0023cd0 <timer_ticks>
c0023d3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023d3e:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c0023d41:	e8 f3 d5 ff ff       	call   c0021339 <intr_get_level>
c0023d46:	83 f8 01             	cmp    $0x1,%eax
c0023d49:	74 23                	je     c0023d6e <timer_sleep+0x4a>
c0023d4b:	83 ec 0c             	sub    $0xc,%esp
c0023d4e:	68 63 f5 02 c0       	push   $0xc002f563
c0023d53:	68 80 f5 02 c0       	push   $0xc002f580
c0023d58:	68 20 f6 02 c0       	push   $0xc002f620
c0023d5d:	6a 5e                	push   $0x5e
c0023d5f:	68 97 f5 02 c0       	push   $0xc002f597
c0023d64:	e8 c8 58 00 00       	call   c0029631 <debug_panic>
  while (timer_elapsed (start) < ticks) 
    thread_yield ();
c0023d69:	e8 09 d0 ff ff       	call   c0020d77 <thread_yield>
timer_sleep (int64_t ticks) 
{
  int64_t start = timer_ticks ();

  ASSERT (intr_get_level () == INTR_ON);
  while (timer_elapsed (start) < ticks) 
c0023d6e:	83 ec 08             	sub    $0x8,%esp
c0023d71:	ff 75 f4             	pushl  -0xc(%ebp)
c0023d74:	ff 75 f0             	pushl  -0x10(%ebp)
c0023d77:	e8 89 ff ff ff       	call   c0023d05 <timer_elapsed>
c0023d7c:	83 c4 10             	add    $0x10,%esp
c0023d7f:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
c0023d82:	7c e5                	jl     c0023d69 <timer_sleep+0x45>
c0023d84:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
c0023d87:	7f 05                	jg     c0023d8e <timer_sleep+0x6a>
c0023d89:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0023d8c:	72 db                	jb     c0023d69 <timer_sleep+0x45>
    thread_yield ();
}
c0023d8e:	90                   	nop
c0023d8f:	c9                   	leave  
c0023d90:	c3                   	ret    

c0023d91 <timer_msleep>:

/* Sleeps for approximately MS milliseconds.  Interrupts must be
   turned on. */
void
timer_msleep (int64_t ms) 
{
c0023d91:	55                   	push   %ebp
c0023d92:	89 e5                	mov    %esp,%ebp
c0023d94:	83 ec 18             	sub    $0x18,%esp
c0023d97:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023d9d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023da0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ms, 1000);
c0023da3:	83 ec 04             	sub    $0x4,%esp
c0023da6:	68 e8 03 00 00       	push   $0x3e8
c0023dab:	ff 75 f4             	pushl  -0xc(%ebp)
c0023dae:	ff 75 f0             	pushl  -0x10(%ebp)
c0023db1:	e8 e9 01 00 00       	call   c0023f9f <real_time_sleep>
c0023db6:	83 c4 10             	add    $0x10,%esp
}
c0023db9:	90                   	nop
c0023dba:	c9                   	leave  
c0023dbb:	c3                   	ret    

c0023dbc <timer_usleep>:

/* Sleeps for approximately US microseconds.  Interrupts must be
   turned on. */
void
timer_usleep (int64_t us) 
{
c0023dbc:	55                   	push   %ebp
c0023dbd:	89 e5                	mov    %esp,%ebp
c0023dbf:	83 ec 18             	sub    $0x18,%esp
c0023dc2:	8b 45 08             	mov    0x8(%ebp),%eax
c0023dc5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023dc8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023dcb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (us, 1000 * 1000);
c0023dce:	83 ec 04             	sub    $0x4,%esp
c0023dd1:	68 40 42 0f 00       	push   $0xf4240
c0023dd6:	ff 75 f4             	pushl  -0xc(%ebp)
c0023dd9:	ff 75 f0             	pushl  -0x10(%ebp)
c0023ddc:	e8 be 01 00 00       	call   c0023f9f <real_time_sleep>
c0023de1:	83 c4 10             	add    $0x10,%esp
}
c0023de4:	90                   	nop
c0023de5:	c9                   	leave  
c0023de6:	c3                   	ret    

c0023de7 <timer_nsleep>:

/* Sleeps for approximately NS nanoseconds.  Interrupts must be
   turned on. */
void
timer_nsleep (int64_t ns) 
{
c0023de7:	55                   	push   %ebp
c0023de8:	89 e5                	mov    %esp,%ebp
c0023dea:	83 ec 18             	sub    $0x18,%esp
c0023ded:	8b 45 08             	mov    0x8(%ebp),%eax
c0023df0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023df3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023df6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ns, 1000 * 1000 * 1000);
c0023df9:	83 ec 04             	sub    $0x4,%esp
c0023dfc:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0023e01:	ff 75 f4             	pushl  -0xc(%ebp)
c0023e04:	ff 75 f0             	pushl  -0x10(%ebp)
c0023e07:	e8 93 01 00 00       	call   c0023f9f <real_time_sleep>
c0023e0c:	83 c4 10             	add    $0x10,%esp
}
c0023e0f:	90                   	nop
c0023e10:	c9                   	leave  
c0023e11:	c3                   	ret    

c0023e12 <timer_mdelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_msleep()
   instead if interrupts are enabled. */
void
timer_mdelay (int64_t ms) 
{
c0023e12:	55                   	push   %ebp
c0023e13:	89 e5                	mov    %esp,%ebp
c0023e15:	83 ec 18             	sub    $0x18,%esp
c0023e18:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023e1e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023e21:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ms, 1000);
c0023e24:	83 ec 04             	sub    $0x4,%esp
c0023e27:	68 e8 03 00 00       	push   $0x3e8
c0023e2c:	ff 75 f4             	pushl  -0xc(%ebp)
c0023e2f:	ff 75 f0             	pushl  -0x10(%ebp)
c0023e32:	e8 1a 02 00 00       	call   c0024051 <real_time_delay>
c0023e37:	83 c4 10             	add    $0x10,%esp
}
c0023e3a:	90                   	nop
c0023e3b:	c9                   	leave  
c0023e3c:	c3                   	ret    

c0023e3d <timer_udelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_usleep()
   instead if interrupts are enabled. */
void
timer_udelay (int64_t us) 
{
c0023e3d:	55                   	push   %ebp
c0023e3e:	89 e5                	mov    %esp,%ebp
c0023e40:	83 ec 18             	sub    $0x18,%esp
c0023e43:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e46:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023e49:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023e4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (us, 1000 * 1000);
c0023e4f:	83 ec 04             	sub    $0x4,%esp
c0023e52:	68 40 42 0f 00       	push   $0xf4240
c0023e57:	ff 75 f4             	pushl  -0xc(%ebp)
c0023e5a:	ff 75 f0             	pushl  -0x10(%ebp)
c0023e5d:	e8 ef 01 00 00       	call   c0024051 <real_time_delay>
c0023e62:	83 c4 10             	add    $0x10,%esp
}
c0023e65:	90                   	nop
c0023e66:	c9                   	leave  
c0023e67:	c3                   	ret    

c0023e68 <timer_ndelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_nsleep()
   instead if interrupts are enabled.*/
void
timer_ndelay (int64_t ns) 
{
c0023e68:	55                   	push   %ebp
c0023e69:	89 e5                	mov    %esp,%ebp
c0023e6b:	83 ec 18             	sub    $0x18,%esp
c0023e6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e71:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023e74:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023e77:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ns, 1000 * 1000 * 1000);
c0023e7a:	83 ec 04             	sub    $0x4,%esp
c0023e7d:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0023e82:	ff 75 f4             	pushl  -0xc(%ebp)
c0023e85:	ff 75 f0             	pushl  -0x10(%ebp)
c0023e88:	e8 c4 01 00 00       	call   c0024051 <real_time_delay>
c0023e8d:	83 c4 10             	add    $0x10,%esp
}
c0023e90:	90                   	nop
c0023e91:	c9                   	leave  
c0023e92:	c3                   	ret    

c0023e93 <timer_print_stats>:

/* Prints timer statistics. */
void
timer_print_stats (void) 
{
c0023e93:	55                   	push   %ebp
c0023e94:	89 e5                	mov    %esp,%ebp
c0023e96:	83 ec 08             	sub    $0x8,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c0023e99:	e8 32 fe ff ff       	call   c0023cd0 <timer_ticks>
c0023e9e:	83 ec 04             	sub    $0x4,%esp
c0023ea1:	52                   	push   %edx
c0023ea2:	50                   	push   %eax
c0023ea3:	68 e8 f5 02 c0       	push   $0xc002f5e8
c0023ea8:	e8 51 33 00 00       	call   c00271fe <printf>
c0023ead:	83 c4 10             	add    $0x10,%esp
}
c0023eb0:	90                   	nop
c0023eb1:	c9                   	leave  
c0023eb2:	c3                   	ret    

c0023eb3 <timer_interrupt>:

/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{
c0023eb3:	55                   	push   %ebp
c0023eb4:	89 e5                	mov    %esp,%ebp
c0023eb6:	83 ec 08             	sub    $0x8,%esp
  ticks++;
c0023eb9:	a1 a8 98 03 c0       	mov    0xc00398a8,%eax
c0023ebe:	8b 15 ac 98 03 c0    	mov    0xc00398ac,%edx
c0023ec4:	83 c0 01             	add    $0x1,%eax
c0023ec7:	83 d2 00             	adc    $0x0,%edx
c0023eca:	a3 a8 98 03 c0       	mov    %eax,0xc00398a8
c0023ecf:	89 15 ac 98 03 c0    	mov    %edx,0xc00398ac
  thread_tick ();
c0023ed5:	e8 d2 ca ff ff       	call   c00209ac <thread_tick>
}
c0023eda:	90                   	nop
c0023edb:	c9                   	leave  
c0023edc:	c3                   	ret    

c0023edd <too_many_loops>:

/* Returns true if LOOPS iterations waits for more than one timer
   tick, otherwise false. */
static bool
too_many_loops (unsigned loops) 
{
c0023edd:	55                   	push   %ebp
c0023ede:	89 e5                	mov    %esp,%ebp
c0023ee0:	56                   	push   %esi
c0023ee1:	53                   	push   %ebx
c0023ee2:	83 ec 10             	sub    $0x10,%esp
  /* Wait for a timer tick. */
  int64_t start = ticks;
c0023ee5:	a1 a8 98 03 c0       	mov    0xc00398a8,%eax
c0023eea:	8b 15 ac 98 03 c0    	mov    0xc00398ac,%edx
c0023ef0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023ef3:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (ticks == start)
c0023ef6:	eb 00                	jmp    c0023ef8 <too_many_loops+0x1b>
c0023ef8:	a1 a8 98 03 c0       	mov    0xc00398a8,%eax
c0023efd:	8b 15 ac 98 03 c0    	mov    0xc00398ac,%edx
c0023f03:	89 d1                	mov    %edx,%ecx
c0023f05:	33 4d f4             	xor    -0xc(%ebp),%ecx
c0023f08:	33 45 f0             	xor    -0x10(%ebp),%eax
c0023f0b:	09 c8                	or     %ecx,%eax
c0023f0d:	85 c0                	test   %eax,%eax
c0023f0f:	74 e7                	je     c0023ef8 <too_many_loops+0x1b>
    barrier ();

  /* Run LOOPS loops. */
  start = ticks;
c0023f11:	a1 a8 98 03 c0       	mov    0xc00398a8,%eax
c0023f16:	8b 15 ac 98 03 c0    	mov    0xc00398ac,%edx
c0023f1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023f1f:	89 55 f4             	mov    %edx,-0xc(%ebp)
  busy_wait (loops);
c0023f22:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f25:	ba 00 00 00 00       	mov    $0x0,%edx
c0023f2a:	83 ec 08             	sub    $0x8,%esp
c0023f2d:	52                   	push   %edx
c0023f2e:	50                   	push   %eax
c0023f2f:	e8 2c 00 00 00       	call   c0023f60 <busy_wait>
c0023f34:	83 c4 10             	add    $0x10,%esp

  /* If the tick count changed, we iterated too long. */
  barrier ();
  return start != ticks;
c0023f37:	a1 a8 98 03 c0       	mov    0xc00398a8,%eax
c0023f3c:	8b 15 ac 98 03 c0    	mov    0xc00398ac,%edx
c0023f42:	89 c1                	mov    %eax,%ecx
c0023f44:	33 4d f0             	xor    -0x10(%ebp),%ecx
c0023f47:	89 cb                	mov    %ecx,%ebx
c0023f49:	89 d0                	mov    %edx,%eax
c0023f4b:	33 45 f4             	xor    -0xc(%ebp),%eax
c0023f4e:	89 c6                	mov    %eax,%esi
c0023f50:	89 d8                	mov    %ebx,%eax
c0023f52:	09 f0                	or     %esi,%eax
c0023f54:	85 c0                	test   %eax,%eax
c0023f56:	0f 95 c0             	setne  %al
}
c0023f59:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0023f5c:	5b                   	pop    %ebx
c0023f5d:	5e                   	pop    %esi
c0023f5e:	5d                   	pop    %ebp
c0023f5f:	c3                   	ret    

c0023f60 <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c0023f60:	55                   	push   %ebp
c0023f61:	89 e5                	mov    %esp,%ebp
c0023f63:	53                   	push   %ebx
c0023f64:	83 ec 0c             	sub    $0xc,%esp
c0023f67:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f6a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023f6d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f70:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (loops-- > 0)
c0023f73:	eb 00                	jmp    c0023f75 <busy_wait+0x15>
c0023f75:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023f78:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023f7b:	89 c1                	mov    %eax,%ecx
c0023f7d:	89 d3                	mov    %edx,%ebx
c0023f7f:	83 c1 ff             	add    $0xffffffff,%ecx
c0023f82:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023f85:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0023f88:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c0023f8b:	85 d2                	test   %edx,%edx
c0023f8d:	7f e6                	jg     c0023f75 <busy_wait+0x15>
c0023f8f:	85 d2                	test   %edx,%edx
c0023f91:	78 05                	js     c0023f98 <busy_wait+0x38>
c0023f93:	83 f8 00             	cmp    $0x0,%eax
c0023f96:	77 dd                	ja     c0023f75 <busy_wait+0x15>
    barrier ();
}
c0023f98:	90                   	nop
c0023f99:	83 c4 0c             	add    $0xc,%esp
c0023f9c:	5b                   	pop    %ebx
c0023f9d:	5d                   	pop    %ebp
c0023f9e:	c3                   	ret    

c0023f9f <real_time_sleep>:

/* Sleep for approximately NUM/DENOM seconds. */
static void
real_time_sleep (int64_t num, int32_t denom) 
{
c0023f9f:	55                   	push   %ebp
c0023fa0:	89 e5                	mov    %esp,%ebp
c0023fa2:	53                   	push   %ebx
c0023fa3:	83 ec 24             	sub    $0x24,%esp
c0023fa6:	8b 45 08             	mov    0x8(%ebp),%eax
c0023fa9:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0023fac:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023faf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          
        (NUM / DENOM) s          
     ---------------------- = NUM * TIMER_FREQ / DENOM ticks. 
     1 s / TIMER_FREQ ticks
  */
  int64_t ticks = num * TIMER_FREQ / denom;
c0023fb2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023fb5:	6b d0 64             	imul   $0x64,%eax,%edx
c0023fb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0023fbb:	6b c0 00             	imul   $0x0,%eax,%eax
c0023fbe:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0023fc1:	b8 64 00 00 00       	mov    $0x64,%eax
c0023fc6:	f7 65 e0             	mull   -0x20(%ebp)
c0023fc9:	01 d1                	add    %edx,%ecx
c0023fcb:	89 ca                	mov    %ecx,%edx
c0023fcd:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0023fd0:	89 cb                	mov    %ecx,%ebx
c0023fd2:	c1 fb 1f             	sar    $0x1f,%ebx
c0023fd5:	53                   	push   %ebx
c0023fd6:	51                   	push   %ecx
c0023fd7:	52                   	push   %edx
c0023fd8:	50                   	push   %eax
c0023fd9:	e8 2d 50 00 00       	call   c002900b <__divdi3>
c0023fde:	83 c4 10             	add    $0x10,%esp
c0023fe1:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023fe4:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c0023fe7:	e8 4d d3 ff ff       	call   c0021339 <intr_get_level>
c0023fec:	83 f8 01             	cmp    $0x1,%eax
c0023fef:	74 21                	je     c0024012 <real_time_sleep+0x73>
c0023ff1:	83 ec 0c             	sub    $0xc,%esp
c0023ff4:	68 63 f5 02 c0       	push   $0xc002f563
c0023ff9:	68 80 f5 02 c0       	push   $0xc002f580
c0023ffe:	68 2c f6 02 c0       	push   $0xc002f62c
c0024003:	68 de 00 00 00       	push   $0xde
c0024008:	68 97 f5 02 c0       	push   $0xc002f597
c002400d:	e8 1f 56 00 00       	call   c0029631 <debug_panic>
  if (ticks > 0)
c0024012:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024016:	78 1f                	js     c0024037 <real_time_sleep+0x98>
c0024018:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002401c:	7f 06                	jg     c0024024 <real_time_sleep+0x85>
c002401e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0024022:	76 13                	jbe    c0024037 <real_time_sleep+0x98>
    {
      /* We're waiting for at least one full timer tick.  Use
         timer_sleep() because it will yield the CPU to other
         processes. */                
      timer_sleep (ticks); 
c0024024:	83 ec 08             	sub    $0x8,%esp
c0024027:	ff 75 f4             	pushl  -0xc(%ebp)
c002402a:	ff 75 f0             	pushl  -0x10(%ebp)
c002402d:	e8 f2 fc ff ff       	call   c0023d24 <timer_sleep>
c0024032:	83 c4 10             	add    $0x10,%esp
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
    }
}
c0024035:	eb 14                	jmp    c002404b <real_time_sleep+0xac>
    }
  else 
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
c0024037:	83 ec 04             	sub    $0x4,%esp
c002403a:	ff 75 10             	pushl  0x10(%ebp)
c002403d:	ff 75 e4             	pushl  -0x1c(%ebp)
c0024040:	ff 75 e0             	pushl  -0x20(%ebp)
c0024043:	e8 09 00 00 00       	call   c0024051 <real_time_delay>
c0024048:	83 c4 10             	add    $0x10,%esp
    }
}
c002404b:	90                   	nop
c002404c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002404f:	c9                   	leave  
c0024050:	c3                   	ret    

c0024051 <real_time_delay>:

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c0024051:	55                   	push   %ebp
c0024052:	89 e5                	mov    %esp,%ebp
c0024054:	56                   	push   %esi
c0024055:	53                   	push   %ebx
c0024056:	83 ec 10             	sub    $0x10,%esp
c0024059:	8b 45 08             	mov    0x8(%ebp),%eax
c002405c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002405f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024062:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c0024065:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0024068:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c002406d:	89 c8                	mov    %ecx,%eax
c002406f:	f7 ea                	imul   %edx
c0024071:	c1 fa 06             	sar    $0x6,%edx
c0024074:	89 c8                	mov    %ecx,%eax
c0024076:	c1 f8 1f             	sar    $0x1f,%eax
c0024079:	29 c2                	sub    %eax,%edx
c002407b:	89 d0                	mov    %edx,%eax
c002407d:	69 c0 e8 03 00 00    	imul   $0x3e8,%eax,%eax
c0024083:	29 c1                	sub    %eax,%ecx
c0024085:	89 c8                	mov    %ecx,%eax
c0024087:	85 c0                	test   %eax,%eax
c0024089:	74 21                	je     c00240ac <real_time_delay+0x5b>
c002408b:	83 ec 0c             	sub    $0xc,%esp
c002408e:	68 fb f5 02 c0       	push   $0xc002f5fb
c0024093:	68 80 f5 02 c0       	push   $0xc002f580
c0024098:	68 3c f6 02 c0       	push   $0xc002f63c
c002409d:	68 f4 00 00 00       	push   $0xf4
c00240a2:	68 97 f5 02 c0       	push   $0xc002f597
c00240a7:	e8 85 55 00 00       	call   c0029631 <debug_panic>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c00240ac:	a1 b0 98 03 c0       	mov    0xc00398b0,%eax
c00240b1:	ba 00 00 00 00       	mov    $0x0,%edx
c00240b6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00240b9:	89 cb                	mov    %ecx,%ebx
c00240bb:	0f af da             	imul   %edx,%ebx
c00240be:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00240c1:	0f af c8             	imul   %eax,%ecx
c00240c4:	01 d9                	add    %ebx,%ecx
c00240c6:	f7 65 f0             	mull   -0x10(%ebp)
c00240c9:	01 d1                	add    %edx,%ecx
c00240cb:	89 ca                	mov    %ecx,%edx
c00240cd:	6a 00                	push   $0x0
c00240cf:	68 e8 03 00 00       	push   $0x3e8
c00240d4:	52                   	push   %edx
c00240d5:	50                   	push   %eax
c00240d6:	e8 30 4f 00 00       	call   c002900b <__divdi3>
c00240db:	83 c4 10             	add    $0x10,%esp
c00240de:	6b da 64             	imul   $0x64,%edx,%ebx
c00240e1:	6b c8 00             	imul   $0x0,%eax,%ecx
c00240e4:	8d 34 0b             	lea    (%ebx,%ecx,1),%esi
c00240e7:	b9 64 00 00 00       	mov    $0x64,%ecx
c00240ec:	f7 e1                	mul    %ecx
c00240ee:	89 c1                	mov    %eax,%ecx
c00240f0:	89 d3                	mov    %edx,%ebx
c00240f2:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c00240f5:	89 c3                	mov    %eax,%ebx
c00240f7:	8b 75 10             	mov    0x10(%ebp),%esi
c00240fa:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c00240ff:	89 f0                	mov    %esi,%eax
c0024101:	f7 ea                	imul   %edx
c0024103:	c1 fa 06             	sar    $0x6,%edx
c0024106:	89 f0                	mov    %esi,%eax
c0024108:	c1 f8 1f             	sar    $0x1f,%eax
c002410b:	29 c2                	sub    %eax,%edx
c002410d:	89 d0                	mov    %edx,%eax
c002410f:	99                   	cltd   
c0024110:	52                   	push   %edx
c0024111:	50                   	push   %eax
c0024112:	53                   	push   %ebx
c0024113:	51                   	push   %ecx
c0024114:	e8 f2 4e 00 00       	call   c002900b <__divdi3>
c0024119:	83 c4 10             	add    $0x10,%esp
c002411c:	83 ec 08             	sub    $0x8,%esp
c002411f:	52                   	push   %edx
c0024120:	50                   	push   %eax
c0024121:	e8 3a fe ff ff       	call   c0023f60 <busy_wait>
c0024126:	83 c4 10             	add    $0x10,%esp
}
c0024129:	90                   	nop
c002412a:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002412d:	5b                   	pop    %ebx
c002412e:	5e                   	pop    %esi
c002412f:	5d                   	pop    %ebp
c0024130:	c3                   	ret    

c0024131 <isupper>:
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c0024131:	55                   	push   %ebp
c0024132:	89 e5                	mov    %esp,%ebp
c0024134:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0024138:	7e 0d                	jle    c0024147 <isupper+0x16>
c002413a:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c002413e:	7f 07                	jg     c0024147 <isupper+0x16>
c0024140:	b8 01 00 00 00       	mov    $0x1,%eax
c0024145:	eb 05                	jmp    c002414c <isupper+0x1b>
c0024147:	b8 00 00 00 00       	mov    $0x0,%eax
c002414c:	5d                   	pop    %ebp
c002414d:	c3                   	ret    

c002414e <tolower>:
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c002414e:	55                   	push   %ebp
c002414f:	89 e5                	mov    %esp,%ebp
c0024151:	ff 75 08             	pushl  0x8(%ebp)
c0024154:	e8 d8 ff ff ff       	call   c0024131 <isupper>
c0024159:	83 c4 04             	add    $0x4,%esp
c002415c:	85 c0                	test   %eax,%eax
c002415e:	74 08                	je     c0024168 <tolower+0x1a>
c0024160:	8b 45 08             	mov    0x8(%ebp),%eax
c0024163:	83 c0 20             	add    $0x20,%eax
c0024166:	eb 03                	jmp    c002416b <tolower+0x1d>
c0024168:	8b 45 08             	mov    0x8(%ebp),%eax
c002416b:	c9                   	leave  
c002416c:	c3                   	ret    

c002416d <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c002416d:	55                   	push   %ebp
c002416e:	89 e5                	mov    %esp,%ebp
c0024170:	83 ec 14             	sub    $0x14,%esp
c0024173:	8b 45 08             	mov    0x8(%ebp),%eax
c0024176:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002417a:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c002417e:	89 c2                	mov    %eax,%edx
c0024180:	ec                   	in     (%dx),%al
c0024181:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024184:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0024188:	c9                   	leave  
c0024189:	c3                   	ret    

c002418a <kbd_init>:
static intr_handler_func keyboard_interrupt;

/* Initializes the keyboard. */
void
kbd_init (void) 
{
c002418a:	55                   	push   %ebp
c002418b:	89 e5                	mov    %esp,%ebp
c002418d:	83 ec 08             	sub    $0x8,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c0024190:	83 ec 04             	sub    $0x4,%esp
c0024193:	68 60 f6 02 c0       	push   $0xc002f660
c0024198:	68 d0 41 02 c0       	push   $0xc00241d0
c002419d:	6a 21                	push   $0x21
c002419f:	e8 2b d4 ff ff       	call   c00215cf <intr_register_ext>
c00241a4:	83 c4 10             	add    $0x10,%esp
}
c00241a7:	90                   	nop
c00241a8:	c9                   	leave  
c00241a9:	c3                   	ret    

c00241aa <kbd_print_stats>:

/* Prints keyboard statistics. */
void
kbd_print_stats (void) 
{
c00241aa:	55                   	push   %ebp
c00241ab:	89 e5                	mov    %esp,%ebp
c00241ad:	83 ec 08             	sub    $0x8,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c00241b0:	a1 c0 98 03 c0       	mov    0xc00398c0,%eax
c00241b5:	8b 15 c4 98 03 c0    	mov    0xc00398c4,%edx
c00241bb:	83 ec 04             	sub    $0x4,%esp
c00241be:	52                   	push   %edx
c00241bf:	50                   	push   %eax
c00241c0:	68 6e f6 02 c0       	push   $0xc002f66e
c00241c5:	e8 34 30 00 00       	call   c00271fe <printf>
c00241ca:	83 c4 10             	add    $0x10,%esp
}
c00241cd:	90                   	nop
c00241ce:	c9                   	leave  
c00241cf:	c3                   	ret    

c00241d0 <keyboard_interrupt>:

static bool map_key (const struct keymap[], unsigned scancode, uint8_t *);

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
c00241d0:	55                   	push   %ebp
c00241d1:	89 e5                	mov    %esp,%ebp
c00241d3:	53                   	push   %ebx
c00241d4:	83 ec 14             	sub    $0x14,%esp
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c00241d7:	0f b6 05 b8 98 03 c0 	movzbl 0xc00398b8,%eax
c00241de:	84 c0                	test   %al,%al
c00241e0:	75 0b                	jne    c00241ed <keyboard_interrupt+0x1d>
c00241e2:	0f b6 05 b9 98 03 c0 	movzbl 0xc00398b9,%eax
c00241e9:	84 c0                	test   %al,%al
c00241eb:	74 07                	je     c00241f4 <keyboard_interrupt+0x24>
c00241ed:	b8 01 00 00 00       	mov    $0x1,%eax
c00241f2:	eb 05                	jmp    c00241f9 <keyboard_interrupt+0x29>
c00241f4:	b8 00 00 00 00       	mov    $0x0,%eax
c00241f9:	88 45 ef             	mov    %al,-0x11(%ebp)
c00241fc:	80 65 ef 01          	andb   $0x1,-0x11(%ebp)
  bool alt = left_alt || right_alt;
c0024200:	0f b6 05 ba 98 03 c0 	movzbl 0xc00398ba,%eax
c0024207:	84 c0                	test   %al,%al
c0024209:	75 0b                	jne    c0024216 <keyboard_interrupt+0x46>
c002420b:	0f b6 05 bb 98 03 c0 	movzbl 0xc00398bb,%eax
c0024212:	84 c0                	test   %al,%al
c0024214:	74 07                	je     c002421d <keyboard_interrupt+0x4d>
c0024216:	b8 01 00 00 00       	mov    $0x1,%eax
c002421b:	eb 05                	jmp    c0024222 <keyboard_interrupt+0x52>
c002421d:	b8 00 00 00 00       	mov    $0x0,%eax
c0024222:	88 45 ee             	mov    %al,-0x12(%ebp)
c0024225:	80 65 ee 01          	andb   $0x1,-0x12(%ebp)
  bool ctrl = left_ctrl || right_ctrl;
c0024229:	0f b6 05 bc 98 03 c0 	movzbl 0xc00398bc,%eax
c0024230:	84 c0                	test   %al,%al
c0024232:	75 0b                	jne    c002423f <keyboard_interrupt+0x6f>
c0024234:	0f b6 05 bd 98 03 c0 	movzbl 0xc00398bd,%eax
c002423b:	84 c0                	test   %al,%al
c002423d:	74 07                	je     c0024246 <keyboard_interrupt+0x76>
c002423f:	b8 01 00 00 00       	mov    $0x1,%eax
c0024244:	eb 05                	jmp    c002424b <keyboard_interrupt+0x7b>
c0024246:	b8 00 00 00 00       	mov    $0x0,%eax
c002424b:	88 45 ed             	mov    %al,-0x13(%ebp)
c002424e:	80 65 ed 01          	andb   $0x1,-0x13(%ebp)

  /* Character that corresponds to `code'. */
  uint8_t c;

  /* Read scancode, including second byte if prefix code. */
  code = inb (DATA_REG);
c0024252:	6a 60                	push   $0x60
c0024254:	e8 14 ff ff ff       	call   c002416d <inb>
c0024259:	83 c4 04             	add    $0x4,%esp
c002425c:	0f b6 c0             	movzbl %al,%eax
c002425f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (code == 0xe0)
c0024262:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%ebp)
c0024269:	75 1a                	jne    c0024285 <keyboard_interrupt+0xb5>
    code = (code << 8) | inb (DATA_REG);
c002426b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002426e:	c1 e0 08             	shl    $0x8,%eax
c0024271:	89 c3                	mov    %eax,%ebx
c0024273:	6a 60                	push   $0x60
c0024275:	e8 f3 fe ff ff       	call   c002416d <inb>
c002427a:	83 c4 04             	add    $0x4,%esp
c002427d:	0f b6 c0             	movzbl %al,%eax
c0024280:	09 d8                	or     %ebx,%eax
c0024282:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Bit 0x80 distinguishes key press from key release
     (even if there's a prefix). */
  release = (code & 0x80) != 0;
c0024285:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024288:	25 80 00 00 00       	and    $0x80,%eax
c002428d:	85 c0                	test   %eax,%eax
c002428f:	0f 95 c0             	setne  %al
c0024292:	88 45 ec             	mov    %al,-0x14(%ebp)
  code &= ~0x80u;
c0024295:	81 65 f4 7f ff ff ff 	andl   $0xffffff7f,-0xc(%ebp)

  /* Interpret key. */
  if (code == 0x3a) 
c002429c:	83 7d f4 3a          	cmpl   $0x3a,-0xc(%ebp)
c00242a0:	75 31                	jne    c00242d3 <keyboard_interrupt+0x103>
    {
      /* Caps Lock. */
      if (!release)
c00242a2:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00242a6:	83 f0 01             	xor    $0x1,%eax
c00242a9:	84 c0                	test   %al,%al
c00242ab:	0f 84 84 01 00 00    	je     c0024435 <keyboard_interrupt+0x265>
        caps_lock = !caps_lock;
c00242b1:	0f b6 05 be 98 03 c0 	movzbl 0xc00398be,%eax
c00242b8:	0f b6 c0             	movzbl %al,%eax
c00242bb:	85 c0                	test   %eax,%eax
c00242bd:	0f 95 c0             	setne  %al
c00242c0:	83 f0 01             	xor    $0x1,%eax
c00242c3:	0f b6 c0             	movzbl %al,%eax
c00242c6:	83 e0 01             	and    $0x1,%eax
c00242c9:	a2 be 98 03 c0       	mov    %al,0xc00398be
          {
            *key->state_var = !release;
            break;
          }
    }
}
c00242ce:	e9 62 01 00 00       	jmp    c0024435 <keyboard_interrupt+0x265>
    {
      /* Caps Lock. */
      if (!release)
        caps_lock = !caps_lock;
    }
  else if (map_key (invariant_keymap, code, &c)
c00242d3:	83 ec 04             	sub    $0x4,%esp
c00242d6:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00242d9:	50                   	push   %eax
c00242da:	ff 75 f4             	pushl  -0xc(%ebp)
c00242dd:	68 c0 f6 02 c0       	push   $0xc002f6c0
c00242e2:	e8 54 01 00 00       	call   c002443b <map_key>
c00242e7:	83 c4 10             	add    $0x10,%esp
c00242ea:	84 c0                	test   %al,%al
c00242ec:	75 4f                	jne    c002433d <keyboard_interrupt+0x16d>
           || (!shift && map_key (unshifted_keymap, code, &c))
c00242ee:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c00242f2:	83 f0 01             	xor    $0x1,%eax
c00242f5:	84 c0                	test   %al,%al
c00242f7:	74 1b                	je     c0024314 <keyboard_interrupt+0x144>
c00242f9:	83 ec 04             	sub    $0x4,%esp
c00242fc:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00242ff:	50                   	push   %eax
c0024300:	ff 75 f4             	pushl  -0xc(%ebp)
c0024303:	68 40 f7 02 c0       	push   $0xc002f740
c0024308:	e8 2e 01 00 00       	call   c002443b <map_key>
c002430d:	83 c4 10             	add    $0x10,%esp
c0024310:	84 c0                	test   %al,%al
c0024312:	75 29                	jne    c002433d <keyboard_interrupt+0x16d>
           || (shift && map_key (shifted_keymap, code, &c)))
c0024314:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0024318:	0f 84 d8 00 00 00    	je     c00243f6 <keyboard_interrupt+0x226>
c002431e:	83 ec 04             	sub    $0x4,%esp
c0024321:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0024324:	50                   	push   %eax
c0024325:	ff 75 f4             	pushl  -0xc(%ebp)
c0024328:	68 a0 f7 02 c0       	push   $0xc002f7a0
c002432d:	e8 09 01 00 00       	call   c002443b <map_key>
c0024332:	83 c4 10             	add    $0x10,%esp
c0024335:	84 c0                	test   %al,%al
c0024337:	0f 84 b9 00 00 00    	je     c00243f6 <keyboard_interrupt+0x226>
    {
      /* Ordinary character. */
      if (!release) 
c002433d:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0024341:	83 f0 01             	xor    $0x1,%eax
c0024344:	84 c0                	test   %al,%al
c0024346:	0f 84 e8 00 00 00    	je     c0024434 <keyboard_interrupt+0x264>
        {
          /* Reboot if Ctrl+Alt+Del pressed. */
          if (c == 0177 && ctrl && alt)
c002434c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0024350:	3c 7f                	cmp    $0x7f,%al
c0024352:	75 11                	jne    c0024365 <keyboard_interrupt+0x195>
c0024354:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024358:	74 0b                	je     c0024365 <keyboard_interrupt+0x195>
c002435a:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c002435e:	74 05                	je     c0024365 <keyboard_interrupt+0x195>
            shutdown_reboot ();
c0024360:	e8 03 29 00 00       	call   c0026c68 <shutdown_reboot>

          /* Handle Ctrl, Shift.
             Note that Ctrl overrides Shift. */
          if (ctrl && c >= 0x40 && c < 0x60) 
c0024365:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024369:	74 1c                	je     c0024387 <keyboard_interrupt+0x1b7>
c002436b:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002436f:	3c 3f                	cmp    $0x3f,%al
c0024371:	76 14                	jbe    c0024387 <keyboard_interrupt+0x1b7>
c0024373:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0024377:	3c 5f                	cmp    $0x5f,%al
c0024379:	77 0c                	ja     c0024387 <keyboard_interrupt+0x1b7>
            {
              /* A is 0x41, Ctrl+A is 0x01, etc. */
              c -= 0x40; 
c002437b:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002437f:	83 e8 40             	sub    $0x40,%eax
c0024382:	88 45 eb             	mov    %al,-0x15(%ebp)
c0024385:	eb 22                	jmp    c00243a9 <keyboard_interrupt+0x1d9>
            }
          else if (shift == caps_lock)
c0024387:	0f b6 05 be 98 03 c0 	movzbl 0xc00398be,%eax
c002438e:	38 45 ef             	cmp    %al,-0x11(%ebp)
c0024391:	75 16                	jne    c00243a9 <keyboard_interrupt+0x1d9>
            c = tolower (c);
c0024393:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0024397:	0f b6 c0             	movzbl %al,%eax
c002439a:	83 ec 0c             	sub    $0xc,%esp
c002439d:	50                   	push   %eax
c002439e:	e8 ab fd ff ff       	call   c002414e <tolower>
c00243a3:	83 c4 10             	add    $0x10,%esp
c00243a6:	88 45 eb             	mov    %al,-0x15(%ebp)

          /* Handle Alt by setting the high bit.
             This 0x80 is unrelated to the one used to
             distinguish key press from key release. */
          if (alt)
c00243a9:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c00243ad:	74 0a                	je     c00243b9 <keyboard_interrupt+0x1e9>
            c += 0x80;
c00243af:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c00243b3:	83 c0 80             	add    $0xffffff80,%eax
c00243b6:	88 45 eb             	mov    %al,-0x15(%ebp)

          /* Append to keyboard buffer. */
          if (!input_full ())
c00243b9:	e8 92 21 00 00       	call   c0026550 <input_full>
c00243be:	83 f0 01             	xor    $0x1,%eax
c00243c1:	84 c0                	test   %al,%al
c00243c3:	74 6f                	je     c0024434 <keyboard_interrupt+0x264>
            {
              key_cnt++;
c00243c5:	a1 c0 98 03 c0       	mov    0xc00398c0,%eax
c00243ca:	8b 15 c4 98 03 c0    	mov    0xc00398c4,%edx
c00243d0:	83 c0 01             	add    $0x1,%eax
c00243d3:	83 d2 00             	adc    $0x0,%edx
c00243d6:	a3 c0 98 03 c0       	mov    %eax,0xc00398c0
c00243db:	89 15 c4 98 03 c0    	mov    %edx,0xc00398c4
              input_putc (c);
c00243e1:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c00243e5:	0f b6 c0             	movzbl %al,%eax
c00243e8:	83 ec 0c             	sub    $0xc,%esp
c00243eb:	50                   	push   %eax
c00243ec:	e8 a0 20 00 00       	call   c0026491 <input_putc>
c00243f1:	83 c4 10             	add    $0x10,%esp
  else if (map_key (invariant_keymap, code, &c)
           || (!shift && map_key (unshifted_keymap, code, &c))
           || (shift && map_key (shifted_keymap, code, &c)))
    {
      /* Ordinary character. */
      if (!release) 
c00243f4:	eb 3e                	jmp    c0024434 <keyboard_interrupt+0x264>
        };
  
      const struct shift_key *key;

      /* Scan the table. */
      for (key = shift_keys; key->scancode != 0; key++) 
c00243f6:	c7 45 f0 e0 f7 02 c0 	movl   $0xc002f7e0,-0x10(%ebp)
c00243fd:	eb 2a                	jmp    c0024429 <keyboard_interrupt+0x259>
        if (key->scancode == code)
c00243ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024402:	8b 00                	mov    (%eax),%eax
c0024404:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0024407:	75 1c                	jne    c0024425 <keyboard_interrupt+0x255>
          {
            *key->state_var = !release;
c0024409:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002440c:	8b 50 04             	mov    0x4(%eax),%edx
c002440f:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0024413:	85 c0                	test   %eax,%eax
c0024415:	0f 95 c0             	setne  %al
c0024418:	83 f0 01             	xor    $0x1,%eax
c002441b:	0f b6 c0             	movzbl %al,%eax
c002441e:	83 e0 01             	and    $0x1,%eax
c0024421:	88 02                	mov    %al,(%edx)
            break;
c0024423:	eb 10                	jmp    c0024435 <keyboard_interrupt+0x265>
        };
  
      const struct shift_key *key;

      /* Scan the table. */
      for (key = shift_keys; key->scancode != 0; key++) 
c0024425:	83 45 f0 08          	addl   $0x8,-0x10(%ebp)
c0024429:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002442c:	8b 00                	mov    (%eax),%eax
c002442e:	85 c0                	test   %eax,%eax
c0024430:	75 cd                	jne    c00243ff <keyboard_interrupt+0x22f>
          {
            *key->state_var = !release;
            break;
          }
    }
}
c0024432:	eb 01                	jmp    c0024435 <keyboard_interrupt+0x265>
  else if (map_key (invariant_keymap, code, &c)
           || (!shift && map_key (unshifted_keymap, code, &c))
           || (shift && map_key (shifted_keymap, code, &c)))
    {
      /* Ordinary character. */
      if (!release) 
c0024434:	90                   	nop
          {
            *key->state_var = !release;
            break;
          }
    }
}
c0024435:	90                   	nop
c0024436:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024439:	c9                   	leave  
c002443a:	c3                   	ret    

c002443b <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c002443b:	55                   	push   %ebp
c002443c:	89 e5                	mov    %esp,%ebp
c002443e:	53                   	push   %ebx
c002443f:	83 ec 04             	sub    $0x4,%esp
  for (; k->first_scancode != 0; k++)
c0024442:	eb 5d                	jmp    c00244a1 <map_key+0x66>
    if (scancode >= k->first_scancode
c0024444:	8b 45 08             	mov    0x8(%ebp),%eax
c0024447:	0f b6 00             	movzbl (%eax),%eax
c002444a:	0f b6 c0             	movzbl %al,%eax
c002444d:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024450:	77 4b                	ja     c002449d <map_key+0x62>
        && scancode < k->first_scancode + strlen (k->chars)) 
c0024452:	8b 45 08             	mov    0x8(%ebp),%eax
c0024455:	0f b6 00             	movzbl (%eax),%eax
c0024458:	0f b6 d8             	movzbl %al,%ebx
c002445b:	8b 45 08             	mov    0x8(%ebp),%eax
c002445e:	8b 40 04             	mov    0x4(%eax),%eax
c0024461:	83 ec 0c             	sub    $0xc,%esp
c0024464:	50                   	push   %eax
c0024465:	e8 14 46 00 00       	call   c0028a7e <strlen>
c002446a:	83 c4 10             	add    $0x10,%esp
c002446d:	01 d8                	add    %ebx,%eax
c002446f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024472:	76 29                	jbe    c002449d <map_key+0x62>
      {
        *c = k->chars[scancode - k->first_scancode];
c0024474:	8b 45 08             	mov    0x8(%ebp),%eax
c0024477:	8b 50 04             	mov    0x4(%eax),%edx
c002447a:	8b 45 08             	mov    0x8(%ebp),%eax
c002447d:	0f b6 00             	movzbl (%eax),%eax
c0024480:	0f b6 c0             	movzbl %al,%eax
c0024483:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0024486:	29 c1                	sub    %eax,%ecx
c0024488:	89 c8                	mov    %ecx,%eax
c002448a:	01 d0                	add    %edx,%eax
c002448c:	0f b6 00             	movzbl (%eax),%eax
c002448f:	89 c2                	mov    %eax,%edx
c0024491:	8b 45 10             	mov    0x10(%ebp),%eax
c0024494:	88 10                	mov    %dl,(%eax)
        return true; 
c0024496:	b8 01 00 00 00       	mov    $0x1,%eax
c002449b:	eb 13                	jmp    c00244b0 <map_key+0x75>
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
  for (; k->first_scancode != 0; k++)
c002449d:	83 45 08 08          	addl   $0x8,0x8(%ebp)
c00244a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00244a4:	0f b6 00             	movzbl (%eax),%eax
c00244a7:	84 c0                	test   %al,%al
c00244a9:	75 99                	jne    c0024444 <map_key+0x9>
      {
        *c = k->chars[scancode - k->first_scancode];
        return true; 
      }

  return false;
c00244ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00244b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00244b3:	c9                   	leave  
c00244b4:	c3                   	ret    

c00244b5 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c00244b5:	55                   	push   %ebp
c00244b6:	89 e5                	mov    %esp,%ebp
c00244b8:	83 ec 14             	sub    $0x14,%esp
c00244bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00244be:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00244c2:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00244c6:	89 c2                	mov    %eax,%edx
c00244c8:	ec                   	in     (%dx),%al
c00244c9:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00244cc:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c00244d0:	c9                   	leave  
c00244d1:	c3                   	ret    

c00244d2 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c00244d2:	55                   	push   %ebp
c00244d3:	89 e5                	mov    %esp,%ebp
c00244d5:	83 ec 08             	sub    $0x8,%esp
c00244d8:	8b 55 08             	mov    0x8(%ebp),%edx
c00244db:	8b 45 0c             	mov    0xc(%ebp),%eax
c00244de:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00244e2:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00244e5:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00244e9:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00244ed:	ee                   	out    %al,(%dx)
}
c00244ee:	90                   	nop
c00244ef:	c9                   	leave  
c00244f0:	c3                   	ret    

c00244f1 <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c00244f1:	55                   	push   %ebp
c00244f2:	89 e5                	mov    %esp,%ebp
c00244f4:	83 ec 08             	sub    $0x8,%esp
c00244f7:	8b 55 08             	mov    0x8(%ebp),%edx
c00244fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c00244fd:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0024501:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0024505:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c0024509:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c002450d:	66 ef                	out    %ax,(%dx)
}
c002450f:	90                   	nop
c0024510:	c9                   	leave  
c0024511:	c3                   	ret    

c0024512 <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c0024512:	55                   	push   %ebp
c0024513:	89 e5                	mov    %esp,%ebp
c0024515:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0024518:	8b 45 08             	mov    0x8(%ebp),%eax
c002451b:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0024520:	76 1e                	jbe    c0024540 <ptov+0x2e>
c0024522:	83 ec 0c             	sub    $0xc,%esp
c0024525:	68 18 f8 02 c0       	push   $0xc002f818
c002452a:	68 33 f8 02 c0       	push   $0xc002f833
c002452f:	68 7c f8 02 c0       	push   $0xc002f87c
c0024534:	6a 4a                	push   $0x4a
c0024536:	68 4a f8 02 c0       	push   $0xc002f84a
c002453b:	e8 f1 50 00 00       	call   c0029631 <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c0024540:	8b 45 08             	mov    0x8(%ebp),%eax
c0024543:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0024548:	c9                   	leave  
c0024549:	c3                   	ret    

c002454a <init>:
static void find_cursor (size_t *x, size_t *y);

/* Initializes the VGA text display. */
static void
init (void)
{
c002454a:	55                   	push   %ebp
c002454b:	89 e5                	mov    %esp,%ebp
c002454d:	83 ec 08             	sub    $0x8,%esp
  /* Already initialized? */
  static bool inited;
  if (!inited)
c0024550:	0f b6 05 d4 98 03 c0 	movzbl 0xc00398d4,%eax
c0024557:	83 f0 01             	xor    $0x1,%eax
c002455a:	84 c0                	test   %al,%al
c002455c:	74 31                	je     c002458f <init+0x45>
    {
      fb = ptov (0xb8000);
c002455e:	83 ec 0c             	sub    $0xc,%esp
c0024561:	68 00 80 0b 00       	push   $0xb8000
c0024566:	e8 a7 ff ff ff       	call   c0024512 <ptov>
c002456b:	83 c4 10             	add    $0x10,%esp
c002456e:	a3 d0 98 03 c0       	mov    %eax,0xc00398d0
      find_cursor (&cx, &cy);
c0024573:	83 ec 08             	sub    $0x8,%esp
c0024576:	68 cc 98 03 c0       	push   $0xc00398cc
c002457b:	68 c8 98 03 c0       	push   $0xc00398c8
c0024580:	e8 9a 02 00 00       	call   c002481f <find_cursor>
c0024585:	83 c4 10             	add    $0x10,%esp
      inited = true; 
c0024588:	c6 05 d4 98 03 c0 01 	movb   $0x1,0xc00398d4
    }
}
c002458f:	90                   	nop
c0024590:	c9                   	leave  
c0024591:	c3                   	ret    

c0024592 <vga_putc>:

/* Writes C to the VGA text display, interpreting control
   characters in the conventional ways.  */
void
vga_putc (int c)
{
c0024592:	55                   	push   %ebp
c0024593:	89 e5                	mov    %esp,%ebp
c0024595:	83 ec 18             	sub    $0x18,%esp
  /* Disable interrupts to lock out interrupt handlers
     that might write to the console. */
  enum intr_level old_level = intr_disable ();
c0024598:	e8 11 ce ff ff       	call   c00213ae <intr_disable>
c002459d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  init ();
c00245a0:	e8 a5 ff ff ff       	call   c002454a <init>
  
  switch (c) 
c00245a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00245a8:	83 e8 07             	sub    $0x7,%eax
c00245ab:	83 f8 06             	cmp    $0x6,%eax
c00245ae:	0f 87 90 00 00 00    	ja     c0024644 <vga_putc+0xb2>
c00245b4:	8b 04 85 60 f8 02 c0 	mov    -0x3ffd07a0(,%eax,4),%eax
c00245bb:	ff e0                	jmp    *%eax
    {
    case '\n':
      newline ();
c00245bd:	e8 9e 01 00 00       	call   c0024760 <newline>
      break;
c00245c2:	e9 e9 00 00 00       	jmp    c00246b0 <vga_putc+0x11e>

    case '\f':
      cls ();
c00245c7:	e8 fa 00 00 00       	call   c00246c6 <cls>
      break;
c00245cc:	e9 df 00 00 00       	jmp    c00246b0 <vga_putc+0x11e>

    case '\b':
      if (cx > 0)
c00245d1:	a1 c8 98 03 c0       	mov    0xc00398c8,%eax
c00245d6:	85 c0                	test   %eax,%eax
c00245d8:	0f 84 cb 00 00 00    	je     c00246a9 <vga_putc+0x117>
        cx--;
c00245de:	a1 c8 98 03 c0       	mov    0xc00398c8,%eax
c00245e3:	83 e8 01             	sub    $0x1,%eax
c00245e6:	a3 c8 98 03 c0       	mov    %eax,0xc00398c8
      break;
c00245eb:	e9 b9 00 00 00       	jmp    c00246a9 <vga_putc+0x117>
      
    case '\r':
      cx = 0;
c00245f0:	c7 05 c8 98 03 c0 00 	movl   $0x0,0xc00398c8
c00245f7:	00 00 00 
      break;
c00245fa:	e9 b1 00 00 00       	jmp    c00246b0 <vga_putc+0x11e>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
c00245ff:	a1 c8 98 03 c0       	mov    0xc00398c8,%eax
c0024604:	83 c0 08             	add    $0x8,%eax
c0024607:	c1 e8 03             	shr    $0x3,%eax
c002460a:	c1 e0 03             	shl    $0x3,%eax
c002460d:	a3 c8 98 03 c0       	mov    %eax,0xc00398c8
      if (cx >= COL_CNT)
c0024612:	a1 c8 98 03 c0       	mov    0xc00398c8,%eax
c0024617:	83 f8 4f             	cmp    $0x4f,%eax
c002461a:	0f 86 8c 00 00 00    	jbe    c00246ac <vga_putc+0x11a>
        newline ();
c0024620:	e8 3b 01 00 00       	call   c0024760 <newline>
      break;
c0024625:	e9 82 00 00 00       	jmp    c00246ac <vga_putc+0x11a>

    case '\a':
      intr_set_level (old_level);
c002462a:	83 ec 0c             	sub    $0xc,%esp
c002462d:	ff 75 f4             	pushl  -0xc(%ebp)
c0024630:	e8 21 cd ff ff       	call   c0021356 <intr_set_level>
c0024635:	83 c4 10             	add    $0x10,%esp
      speaker_beep ();
c0024638:	e8 52 28 00 00       	call   c0026e8f <speaker_beep>
      intr_disable ();
c002463d:	e8 6c cd ff ff       	call   c00213ae <intr_disable>
      break;
c0024642:	eb 6c                	jmp    c00246b0 <vga_putc+0x11e>
      
    default:
      fb[cy][cx][0] = c;
c0024644:	8b 0d d0 98 03 c0    	mov    0xc00398d0,%ecx
c002464a:	8b 15 cc 98 03 c0    	mov    0xc00398cc,%edx
c0024650:	89 d0                	mov    %edx,%eax
c0024652:	c1 e0 02             	shl    $0x2,%eax
c0024655:	01 d0                	add    %edx,%eax
c0024657:	c1 e0 05             	shl    $0x5,%eax
c002465a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c002465d:	a1 c8 98 03 c0       	mov    0xc00398c8,%eax
c0024662:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024665:	88 0c 42             	mov    %cl,(%edx,%eax,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0024668:	8b 0d d0 98 03 c0    	mov    0xc00398d0,%ecx
c002466e:	8b 15 cc 98 03 c0    	mov    0xc00398cc,%edx
c0024674:	89 d0                	mov    %edx,%eax
c0024676:	c1 e0 02             	shl    $0x2,%eax
c0024679:	01 d0                	add    %edx,%eax
c002467b:	c1 e0 05             	shl    $0x5,%eax
c002467e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024681:	a1 c8 98 03 c0       	mov    0xc00398c8,%eax
c0024686:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c002468b:	a1 c8 98 03 c0       	mov    0xc00398c8,%eax
c0024690:	83 c0 01             	add    $0x1,%eax
c0024693:	a3 c8 98 03 c0       	mov    %eax,0xc00398c8
c0024698:	a1 c8 98 03 c0       	mov    0xc00398c8,%eax
c002469d:	83 f8 4f             	cmp    $0x4f,%eax
c00246a0:	76 0d                	jbe    c00246af <vga_putc+0x11d>
        newline ();
c00246a2:	e8 b9 00 00 00       	call   c0024760 <newline>
      break;
c00246a7:	eb 06                	jmp    c00246af <vga_putc+0x11d>
      break;

    case '\b':
      if (cx > 0)
        cx--;
      break;
c00246a9:	90                   	nop
c00246aa:	eb 04                	jmp    c00246b0 <vga_putc+0x11e>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
      if (cx >= COL_CNT)
        newline ();
      break;
c00246ac:	90                   	nop
c00246ad:	eb 01                	jmp    c00246b0 <vga_putc+0x11e>
    default:
      fb[cy][cx][0] = c;
      fb[cy][cx][1] = GRAY_ON_BLACK;
      if (++cx >= COL_CNT)
        newline ();
      break;
c00246af:	90                   	nop
    }

  /* Update cursor position. */
  move_cursor ();
c00246b0:	e8 0e 01 00 00       	call   c00247c3 <move_cursor>

  intr_set_level (old_level);
c00246b5:	83 ec 0c             	sub    $0xc,%esp
c00246b8:	ff 75 f4             	pushl  -0xc(%ebp)
c00246bb:	e8 96 cc ff ff       	call   c0021356 <intr_set_level>
c00246c0:	83 c4 10             	add    $0x10,%esp
}
c00246c3:	90                   	nop
c00246c4:	c9                   	leave  
c00246c5:	c3                   	ret    

c00246c6 <cls>:

/* Clears the screen and moves the cursor to the upper left. */
static void
cls (void)
{
c00246c6:	55                   	push   %ebp
c00246c7:	89 e5                	mov    %esp,%ebp
c00246c9:	83 ec 18             	sub    $0x18,%esp
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c00246cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00246d3:	eb 12                	jmp    c00246e7 <cls+0x21>
    clear_row (y);
c00246d5:	83 ec 0c             	sub    $0xc,%esp
c00246d8:	ff 75 f4             	pushl  -0xc(%ebp)
c00246db:	e8 29 00 00 00       	call   c0024709 <clear_row>
c00246e0:	83 c4 10             	add    $0x10,%esp
static void
cls (void)
{
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c00246e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00246e7:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c00246eb:	76 e8                	jbe    c00246d5 <cls+0xf>
    clear_row (y);

  cx = cy = 0;
c00246ed:	c7 05 cc 98 03 c0 00 	movl   $0x0,0xc00398cc
c00246f4:	00 00 00 
c00246f7:	a1 cc 98 03 c0       	mov    0xc00398cc,%eax
c00246fc:	a3 c8 98 03 c0       	mov    %eax,0xc00398c8
  move_cursor ();
c0024701:	e8 bd 00 00 00       	call   c00247c3 <move_cursor>
}
c0024706:	90                   	nop
c0024707:	c9                   	leave  
c0024708:	c3                   	ret    

c0024709 <clear_row>:

/* Clears row Y to spaces. */
static void
clear_row (size_t y) 
{
c0024709:	55                   	push   %ebp
c002470a:	89 e5                	mov    %esp,%ebp
c002470c:	83 ec 10             	sub    $0x10,%esp
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c002470f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0024716:	eb 3f                	jmp    c0024757 <clear_row+0x4e>
    {
      fb[y][x][0] = ' ';
c0024718:	8b 0d d0 98 03 c0    	mov    0xc00398d0,%ecx
c002471e:	8b 55 08             	mov    0x8(%ebp),%edx
c0024721:	89 d0                	mov    %edx,%eax
c0024723:	c1 e0 02             	shl    $0x2,%eax
c0024726:	01 d0                	add    %edx,%eax
c0024728:	c1 e0 05             	shl    $0x5,%eax
c002472b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c002472e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0024731:	c6 04 42 20          	movb   $0x20,(%edx,%eax,2)
      fb[y][x][1] = GRAY_ON_BLACK;
c0024735:	8b 0d d0 98 03 c0    	mov    0xc00398d0,%ecx
c002473b:	8b 55 08             	mov    0x8(%ebp),%edx
c002473e:	89 d0                	mov    %edx,%eax
c0024740:	c1 e0 02             	shl    $0x2,%eax
c0024743:	01 d0                	add    %edx,%eax
c0024745:	c1 e0 05             	shl    $0x5,%eax
c0024748:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c002474b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002474e:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
static void
clear_row (size_t y) 
{
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c0024753:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0024757:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
c002475b:	76 bb                	jbe    c0024718 <clear_row+0xf>
    {
      fb[y][x][0] = ' ';
      fb[y][x][1] = GRAY_ON_BLACK;
    }
}
c002475d:	90                   	nop
c002475e:	c9                   	leave  
c002475f:	c3                   	ret    

c0024760 <newline>:
/* Advances the cursor to the first column in the next line on
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
c0024760:	55                   	push   %ebp
c0024761:	89 e5                	mov    %esp,%ebp
c0024763:	83 ec 08             	sub    $0x8,%esp
  cx = 0;
c0024766:	c7 05 c8 98 03 c0 00 	movl   $0x0,0xc00398c8
c002476d:	00 00 00 
  cy++;
c0024770:	a1 cc 98 03 c0       	mov    0xc00398cc,%eax
c0024775:	83 c0 01             	add    $0x1,%eax
c0024778:	a3 cc 98 03 c0       	mov    %eax,0xc00398cc
  if (cy >= ROW_CNT)
c002477d:	a1 cc 98 03 c0       	mov    0xc00398cc,%eax
c0024782:	83 f8 18             	cmp    $0x18,%eax
c0024785:	76 39                	jbe    c00247c0 <newline+0x60>
    {
      cy = ROW_CNT - 1;
c0024787:	c7 05 cc 98 03 c0 18 	movl   $0x18,0xc00398cc
c002478e:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0024791:	a1 d0 98 03 c0       	mov    0xc00398d0,%eax
c0024796:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c002479c:	a1 d0 98 03 c0       	mov    0xc00398d0,%eax
c00247a1:	83 ec 04             	sub    $0x4,%esp
c00247a4:	68 00 0f 00 00       	push   $0xf00
c00247a9:	52                   	push   %edx
c00247aa:	50                   	push   %eax
c00247ab:	e8 fe 3c 00 00       	call   c00284ae <memmove>
c00247b0:	83 c4 10             	add    $0x10,%esp
      clear_row (ROW_CNT - 1);
c00247b3:	83 ec 0c             	sub    $0xc,%esp
c00247b6:	6a 18                	push   $0x18
c00247b8:	e8 4c ff ff ff       	call   c0024709 <clear_row>
c00247bd:	83 c4 10             	add    $0x10,%esp
    }
}
c00247c0:	90                   	nop
c00247c1:	c9                   	leave  
c00247c2:	c3                   	ret    

c00247c3 <move_cursor>:

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c00247c3:	55                   	push   %ebp
c00247c4:	89 e5                	mov    %esp,%ebp
c00247c6:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c00247c9:	a1 cc 98 03 c0       	mov    0xc00398cc,%eax
c00247ce:	89 c2                	mov    %eax,%edx
c00247d0:	89 d0                	mov    %edx,%eax
c00247d2:	c1 e0 02             	shl    $0x2,%eax
c00247d5:	01 d0                	add    %edx,%eax
c00247d7:	c1 e0 04             	shl    $0x4,%eax
c00247da:	89 c2                	mov    %eax,%edx
c00247dc:	a1 c8 98 03 c0       	mov    0xc00398c8,%eax
c00247e1:	01 d0                	add    %edx,%eax
c00247e3:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  outw (0x3d4, 0x0e | (cp & 0xff00));
c00247e7:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00247eb:	b0 00                	mov    $0x0,%al
c00247ed:	83 c8 0e             	or     $0xe,%eax
c00247f0:	0f b7 c0             	movzwl %ax,%eax
c00247f3:	50                   	push   %eax
c00247f4:	68 d4 03 00 00       	push   $0x3d4
c00247f9:	e8 f3 fc ff ff       	call   c00244f1 <outw>
c00247fe:	83 c4 08             	add    $0x8,%esp
  outw (0x3d4, 0x0f | (cp << 8));
c0024801:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0024805:	c1 e0 08             	shl    $0x8,%eax
c0024808:	83 c8 0f             	or     $0xf,%eax
c002480b:	0f b7 c0             	movzwl %ax,%eax
c002480e:	50                   	push   %eax
c002480f:	68 d4 03 00 00       	push   $0x3d4
c0024814:	e8 d8 fc ff ff       	call   c00244f1 <outw>
c0024819:	83 c4 08             	add    $0x8,%esp
}
c002481c:	90                   	nop
c002481d:	c9                   	leave  
c002481e:	c3                   	ret    

c002481f <find_cursor>:

/* Reads the current hardware cursor position into (*X,*Y). */
static void
find_cursor (size_t *x, size_t *y) 
{
c002481f:	55                   	push   %ebp
c0024820:	89 e5                	mov    %esp,%ebp
c0024822:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
c0024825:	6a 0e                	push   $0xe
c0024827:	68 d4 03 00 00       	push   $0x3d4
c002482c:	e8 a1 fc ff ff       	call   c00244d2 <outb>
c0024831:	83 c4 08             	add    $0x8,%esp
  cp = inb (0x3d5) << 8;
c0024834:	68 d5 03 00 00       	push   $0x3d5
c0024839:	e8 77 fc ff ff       	call   c00244b5 <inb>
c002483e:	83 c4 04             	add    $0x4,%esp
c0024841:	0f b6 c0             	movzbl %al,%eax
c0024844:	c1 e0 08             	shl    $0x8,%eax
c0024847:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

  outb (0x3d4, 0x0f);
c002484b:	6a 0f                	push   $0xf
c002484d:	68 d4 03 00 00       	push   $0x3d4
c0024852:	e8 7b fc ff ff       	call   c00244d2 <outb>
c0024857:	83 c4 08             	add    $0x8,%esp
  cp |= inb (0x3d5);
c002485a:	68 d5 03 00 00       	push   $0x3d5
c002485f:	e8 51 fc ff ff       	call   c00244b5 <inb>
c0024864:	83 c4 04             	add    $0x4,%esp
c0024867:	0f b6 c0             	movzbl %al,%eax
c002486a:	66 09 45 fe          	or     %ax,-0x2(%ebp)

  *x = cp % COL_CNT;
c002486e:	0f b7 4d fe          	movzwl -0x2(%ebp),%ecx
c0024872:	0f b7 c1             	movzwl %cx,%eax
c0024875:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c002487b:	c1 e8 10             	shr    $0x10,%eax
c002487e:	89 c2                	mov    %eax,%edx
c0024880:	66 c1 ea 06          	shr    $0x6,%dx
c0024884:	89 d0                	mov    %edx,%eax
c0024886:	c1 e0 02             	shl    $0x2,%eax
c0024889:	01 d0                	add    %edx,%eax
c002488b:	c1 e0 04             	shl    $0x4,%eax
c002488e:	29 c1                	sub    %eax,%ecx
c0024890:	89 ca                	mov    %ecx,%edx
c0024892:	0f b7 d2             	movzwl %dx,%edx
c0024895:	8b 45 08             	mov    0x8(%ebp),%eax
c0024898:	89 10                	mov    %edx,(%eax)
  *y = cp / COL_CNT;
c002489a:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c002489e:	0f b7 c0             	movzwl %ax,%eax
c00248a1:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c00248a7:	c1 e8 10             	shr    $0x10,%eax
c00248aa:	66 c1 e8 06          	shr    $0x6,%ax
c00248ae:	0f b7 d0             	movzwl %ax,%edx
c00248b1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00248b4:	89 10                	mov    %edx,(%eax)
}
c00248b6:	90                   	nop
c00248b7:	c9                   	leave  
c00248b8:	c3                   	ret    

c00248b9 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c00248b9:	55                   	push   %ebp
c00248ba:	89 e5                	mov    %esp,%ebp
c00248bc:	83 ec 14             	sub    $0x14,%esp
c00248bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00248c2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00248c6:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00248ca:	89 c2                	mov    %eax,%edx
c00248cc:	ec                   	in     (%dx),%al
c00248cd:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00248d0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c00248d4:	c9                   	leave  
c00248d5:	c3                   	ret    

c00248d6 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c00248d6:	55                   	push   %ebp
c00248d7:	89 e5                	mov    %esp,%ebp
c00248d9:	83 ec 08             	sub    $0x8,%esp
c00248dc:	8b 55 08             	mov    0x8(%ebp),%edx
c00248df:	8b 45 0c             	mov    0xc(%ebp),%eax
c00248e2:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00248e6:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00248e9:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00248ed:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00248f1:	ee                   	out    %al,(%dx)
}
c00248f2:	90                   	nop
c00248f3:	c9                   	leave  
c00248f4:	c3                   	ret    

c00248f5 <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c00248f5:	55                   	push   %ebp
c00248f6:	89 e5                	mov    %esp,%ebp
c00248f8:	83 ec 08             	sub    $0x8,%esp
  ASSERT (mode == UNINIT);
c00248fb:	a1 e0 98 03 c0       	mov    0xc00398e0,%eax
c0024900:	85 c0                	test   %eax,%eax
c0024902:	74 1e                	je     c0024922 <init_poll+0x2d>
c0024904:	83 ec 0c             	sub    $0xc,%esp
c0024907:	68 84 f8 02 c0       	push   $0xc002f884
c002490c:	68 93 f8 02 c0       	push   $0xc002f893
c0024911:	68 10 f9 02 c0       	push   $0xc002f910
c0024916:	6a 45                	push   $0x45
c0024918:	68 aa f8 02 c0       	push   $0xc002f8aa
c002491d:	e8 0f 4d 00 00       	call   c0029631 <debug_panic>
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
c0024922:	83 ec 08             	sub    $0x8,%esp
c0024925:	6a 00                	push   $0x0
c0024927:	68 f9 03 00 00       	push   $0x3f9
c002492c:	e8 a5 ff ff ff       	call   c00248d6 <outb>
c0024931:	83 c4 10             	add    $0x10,%esp
  outb (FCR_REG, 0);                    /* Disable FIFO. */
c0024934:	83 ec 08             	sub    $0x8,%esp
c0024937:	6a 00                	push   $0x0
c0024939:	68 fa 03 00 00       	push   $0x3fa
c002493e:	e8 93 ff ff ff       	call   c00248d6 <outb>
c0024943:	83 c4 10             	add    $0x10,%esp
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
c0024946:	83 ec 0c             	sub    $0xc,%esp
c0024949:	68 80 25 00 00       	push   $0x2580
c002494e:	e8 e8 01 00 00       	call   c0024b3b <set_serial>
c0024953:	83 c4 10             	add    $0x10,%esp
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
c0024956:	83 ec 08             	sub    $0x8,%esp
c0024959:	6a 08                	push   $0x8
c002495b:	68 fc 03 00 00       	push   $0x3fc
c0024960:	e8 71 ff ff ff       	call   c00248d6 <outb>
c0024965:	83 c4 10             	add    $0x10,%esp
  intq_init (&txq);
c0024968:	83 ec 0c             	sub    $0xc,%esp
c002496b:	68 00 99 03 c0       	push   $0xc0039900
c0024970:	e8 1a 1c 00 00       	call   c002658f <intq_init>
c0024975:	83 c4 10             	add    $0x10,%esp
  mode = POLL;
c0024978:	c7 05 e0 98 03 c0 01 	movl   $0x1,0xc00398e0
c002497f:	00 00 00 
} 
c0024982:	90                   	nop
c0024983:	c9                   	leave  
c0024984:	c3                   	ret    

c0024985 <serial_init_queue>:
/* Initializes the serial port device for queued interrupt-driven
   I/O.  With interrupt-driven I/O we don't waste CPU time
   waiting for the serial device to become ready. */
void
serial_init_queue (void) 
{
c0024985:	55                   	push   %ebp
c0024986:	89 e5                	mov    %esp,%ebp
c0024988:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  if (mode == UNINIT)
c002498b:	a1 e0 98 03 c0       	mov    0xc00398e0,%eax
c0024990:	85 c0                	test   %eax,%eax
c0024992:	75 05                	jne    c0024999 <serial_init_queue+0x14>
    init_poll ();
c0024994:	e8 5c ff ff ff       	call   c00248f5 <init_poll>
  ASSERT (mode == POLL);
c0024999:	a1 e0 98 03 c0       	mov    0xc00398e0,%eax
c002499e:	83 f8 01             	cmp    $0x1,%eax
c00249a1:	74 1e                	je     c00249c1 <serial_init_queue+0x3c>
c00249a3:	83 ec 0c             	sub    $0xc,%esp
c00249a6:	68 c1 f8 02 c0       	push   $0xc002f8c1
c00249ab:	68 93 f8 02 c0       	push   $0xc002f893
c00249b0:	68 1c f9 02 c0       	push   $0xc002f91c
c00249b5:	6a 58                	push   $0x58
c00249b7:	68 aa f8 02 c0       	push   $0xc002f8aa
c00249bc:	e8 70 4c 00 00       	call   c0029631 <debug_panic>

  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c00249c1:	83 ec 04             	sub    $0x4,%esp
c00249c4:	68 ce f8 02 c0       	push   $0xc002f8ce
c00249c9:	68 c4 4c 02 c0       	push   $0xc0024cc4
c00249ce:	6a 24                	push   $0x24
c00249d0:	e8 fa cb ff ff       	call   c00215cf <intr_register_ext>
c00249d5:	83 c4 10             	add    $0x10,%esp
  mode = QUEUE;
c00249d8:	c7 05 e0 98 03 c0 02 	movl   $0x2,0xc00398e0
c00249df:	00 00 00 
  old_level = intr_disable ();
c00249e2:	e8 c7 c9 ff ff       	call   c00213ae <intr_disable>
c00249e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  write_ier ();
c00249ea:	e8 f5 01 00 00       	call   c0024be4 <write_ier>
  intr_set_level (old_level);
c00249ef:	83 ec 0c             	sub    $0xc,%esp
c00249f2:	ff 75 f4             	pushl  -0xc(%ebp)
c00249f5:	e8 5c c9 ff ff       	call   c0021356 <intr_set_level>
c00249fa:	83 c4 10             	add    $0x10,%esp
}
c00249fd:	90                   	nop
c00249fe:	c9                   	leave  
c00249ff:	c3                   	ret    

c0024a00 <serial_putc>:

/* Sends BYTE to the serial port. */
void
serial_putc (uint8_t byte) 
{
c0024a00:	55                   	push   %ebp
c0024a01:	89 e5                	mov    %esp,%ebp
c0024a03:	83 ec 28             	sub    $0x28,%esp
c0024a06:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a09:	88 45 e4             	mov    %al,-0x1c(%ebp)
  enum intr_level old_level = intr_disable ();
c0024a0c:	e8 9d c9 ff ff       	call   c00213ae <intr_disable>
c0024a11:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (mode != QUEUE)
c0024a14:	a1 e0 98 03 c0       	mov    0xc00398e0,%eax
c0024a19:	83 f8 02             	cmp    $0x2,%eax
c0024a1c:	74 20                	je     c0024a3e <serial_putc+0x3e>
    {
      /* If we're not set up for interrupt-driven I/O yet,
         use dumb polling to transmit a byte. */
      if (mode == UNINIT)
c0024a1e:	a1 e0 98 03 c0       	mov    0xc00398e0,%eax
c0024a23:	85 c0                	test   %eax,%eax
c0024a25:	75 05                	jne    c0024a2c <serial_putc+0x2c>
        init_poll ();
c0024a27:	e8 c9 fe ff ff       	call   c00248f5 <init_poll>
      putc_poll (byte); 
c0024a2c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0024a30:	83 ec 0c             	sub    $0xc,%esp
c0024a33:	50                   	push   %eax
c0024a34:	e8 22 02 00 00       	call   c0024c5b <putc_poll>
c0024a39:	83 c4 10             	add    $0x10,%esp
c0024a3c:	eb 53                	jmp    c0024a91 <serial_putc+0x91>
    }
  else 
    {
      /* Otherwise, queue a byte and update the interrupt enable
         register. */
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024a3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024a42:	75 33                	jne    c0024a77 <serial_putc+0x77>
c0024a44:	83 ec 0c             	sub    $0xc,%esp
c0024a47:	68 00 99 03 c0       	push   $0xc0039900
c0024a4c:	e8 c2 1b 00 00       	call   c0026613 <intq_full>
c0024a51:	83 c4 10             	add    $0x10,%esp
c0024a54:	84 c0                	test   %al,%al
c0024a56:	74 1f                	je     c0024a77 <serial_putc+0x77>
          /* Interrupts are off and the transmit queue is full.
             If we wanted to wait for the queue to empty,
             we'd have to reenable interrupts.
             That's impolite, so we'll send a character via
             polling instead. */
          putc_poll (intq_getc (&txq)); 
c0024a58:	83 ec 0c             	sub    $0xc,%esp
c0024a5b:	68 00 99 03 c0       	push   $0xc0039900
c0024a60:	e8 fc 1b 00 00       	call   c0026661 <intq_getc>
c0024a65:	83 c4 10             	add    $0x10,%esp
c0024a68:	0f b6 c0             	movzbl %al,%eax
c0024a6b:	83 ec 0c             	sub    $0xc,%esp
c0024a6e:	50                   	push   %eax
c0024a6f:	e8 e7 01 00 00       	call   c0024c5b <putc_poll>
c0024a74:	83 c4 10             	add    $0x10,%esp
        }

      intq_putc (&txq, byte); 
c0024a77:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0024a7b:	83 ec 08             	sub    $0x8,%esp
c0024a7e:	50                   	push   %eax
c0024a7f:	68 00 99 03 c0       	push   $0xc0039900
c0024a84:	e8 ba 1c 00 00       	call   c0026743 <intq_putc>
c0024a89:	83 c4 10             	add    $0x10,%esp
      write_ier ();
c0024a8c:	e8 53 01 00 00       	call   c0024be4 <write_ier>
    }
  
  intr_set_level (old_level);
c0024a91:	83 ec 0c             	sub    $0xc,%esp
c0024a94:	ff 75 f4             	pushl  -0xc(%ebp)
c0024a97:	e8 ba c8 ff ff       	call   c0021356 <intr_set_level>
c0024a9c:	83 c4 10             	add    $0x10,%esp
}
c0024a9f:	90                   	nop
c0024aa0:	c9                   	leave  
c0024aa1:	c3                   	ret    

c0024aa2 <serial_flush>:

/* Flushes anything in the serial buffer out the port in polling
   mode. */
void
serial_flush (void) 
{
c0024aa2:	55                   	push   %ebp
c0024aa3:	89 e5                	mov    %esp,%ebp
c0024aa5:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0024aa8:	e8 01 c9 ff ff       	call   c00213ae <intr_disable>
c0024aad:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!intq_empty (&txq))
c0024ab0:	eb 1f                	jmp    c0024ad1 <serial_flush+0x2f>
    putc_poll (intq_getc (&txq));
c0024ab2:	83 ec 0c             	sub    $0xc,%esp
c0024ab5:	68 00 99 03 c0       	push   $0xc0039900
c0024aba:	e8 a2 1b 00 00       	call   c0026661 <intq_getc>
c0024abf:	83 c4 10             	add    $0x10,%esp
c0024ac2:	0f b6 c0             	movzbl %al,%eax
c0024ac5:	83 ec 0c             	sub    $0xc,%esp
c0024ac8:	50                   	push   %eax
c0024ac9:	e8 8d 01 00 00       	call   c0024c5b <putc_poll>
c0024ace:	83 c4 10             	add    $0x10,%esp
   mode. */
void
serial_flush (void) 
{
  enum intr_level old_level = intr_disable ();
  while (!intq_empty (&txq))
c0024ad1:	83 ec 0c             	sub    $0xc,%esp
c0024ad4:	68 00 99 03 c0       	push   $0xc0039900
c0024ad9:	e8 f5 1a 00 00       	call   c00265d3 <intq_empty>
c0024ade:	83 c4 10             	add    $0x10,%esp
c0024ae1:	83 f0 01             	xor    $0x1,%eax
c0024ae4:	84 c0                	test   %al,%al
c0024ae6:	75 ca                	jne    c0024ab2 <serial_flush+0x10>
    putc_poll (intq_getc (&txq));
  intr_set_level (old_level);
c0024ae8:	83 ec 0c             	sub    $0xc,%esp
c0024aeb:	ff 75 f4             	pushl  -0xc(%ebp)
c0024aee:	e8 63 c8 ff ff       	call   c0021356 <intr_set_level>
c0024af3:	83 c4 10             	add    $0x10,%esp
}
c0024af6:	90                   	nop
c0024af7:	c9                   	leave  
c0024af8:	c3                   	ret    

c0024af9 <serial_notify>:
   whether we should block receive interrupts.
   Called by the input buffer routines when characters are added
   to or removed from the buffer. */
void
serial_notify (void) 
{
c0024af9:	55                   	push   %ebp
c0024afa:	89 e5                	mov    %esp,%ebp
c0024afc:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0024aff:	e8 35 c8 ff ff       	call   c0021339 <intr_get_level>
c0024b04:	85 c0                	test   %eax,%eax
c0024b06:	74 21                	je     c0024b29 <serial_notify+0x30>
c0024b08:	83 ec 0c             	sub    $0xc,%esp
c0024b0b:	68 d5 f8 02 c0       	push   $0xc002f8d5
c0024b10:	68 93 f8 02 c0       	push   $0xc002f893
c0024b15:	68 30 f9 02 c0       	push   $0xc002f930
c0024b1a:	68 96 00 00 00       	push   $0x96
c0024b1f:	68 aa f8 02 c0       	push   $0xc002f8aa
c0024b24:	e8 08 4b 00 00       	call   c0029631 <debug_panic>
  if (mode == QUEUE)
c0024b29:	a1 e0 98 03 c0       	mov    0xc00398e0,%eax
c0024b2e:	83 f8 02             	cmp    $0x2,%eax
c0024b31:	75 05                	jne    c0024b38 <serial_notify+0x3f>
    write_ier ();
c0024b33:	e8 ac 00 00 00       	call   c0024be4 <write_ier>
}
c0024b38:	90                   	nop
c0024b39:	c9                   	leave  
c0024b3a:	c3                   	ret    

c0024b3b <set_serial>:

/* Configures the serial port for BPS bits per second. */
static void
set_serial (int bps)
{
c0024b3b:	55                   	push   %ebp
c0024b3c:	89 e5                	mov    %esp,%ebp
c0024b3e:	83 ec 18             	sub    $0x18,%esp
  int base_rate = 1843200 / 16;         /* Base rate of 16550A, in Hz. */
c0024b41:	c7 45 f4 00 c2 01 00 	movl   $0x1c200,-0xc(%ebp)
  uint16_t divisor = base_rate / bps;   /* Clock rate divisor. */
c0024b48:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024b4b:	99                   	cltd   
c0024b4c:	f7 7d 08             	idivl  0x8(%ebp)
c0024b4f:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

  ASSERT (bps >= 300 && bps <= 115200);
c0024b53:	81 7d 08 2b 01 00 00 	cmpl   $0x12b,0x8(%ebp)
c0024b5a:	7e 09                	jle    c0024b65 <set_serial+0x2a>
c0024b5c:	81 7d 08 00 c2 01 00 	cmpl   $0x1c200,0x8(%ebp)
c0024b63:	7e 21                	jle    c0024b86 <set_serial+0x4b>
c0024b65:	83 ec 0c             	sub    $0xc,%esp
c0024b68:	68 f3 f8 02 c0       	push   $0xc002f8f3
c0024b6d:	68 93 f8 02 c0       	push   $0xc002f893
c0024b72:	68 40 f9 02 c0       	push   $0xc002f940
c0024b77:	68 a2 00 00 00       	push   $0xa2
c0024b7c:	68 aa f8 02 c0       	push   $0xc002f8aa
c0024b81:	e8 ab 4a 00 00       	call   c0029631 <debug_panic>

  /* Enable DLAB. */
  outb (LCR_REG, LCR_N81 | LCR_DLAB);
c0024b86:	83 ec 08             	sub    $0x8,%esp
c0024b89:	68 83 00 00 00       	push   $0x83
c0024b8e:	68 fb 03 00 00       	push   $0x3fb
c0024b93:	e8 3e fd ff ff       	call   c00248d6 <outb>
c0024b98:	83 c4 10             	add    $0x10,%esp

  /* Set data rate. */
  outb (LS_REG, divisor & 0xff);
c0024b9b:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c0024b9f:	0f b6 c0             	movzbl %al,%eax
c0024ba2:	83 ec 08             	sub    $0x8,%esp
c0024ba5:	50                   	push   %eax
c0024ba6:	68 f8 03 00 00       	push   $0x3f8
c0024bab:	e8 26 fd ff ff       	call   c00248d6 <outb>
c0024bb0:	83 c4 10             	add    $0x10,%esp
  outb (MS_REG, divisor >> 8);
c0024bb3:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c0024bb7:	66 c1 e8 08          	shr    $0x8,%ax
c0024bbb:	0f b6 c0             	movzbl %al,%eax
c0024bbe:	83 ec 08             	sub    $0x8,%esp
c0024bc1:	50                   	push   %eax
c0024bc2:	68 f9 03 00 00       	push   $0x3f9
c0024bc7:	e8 0a fd ff ff       	call   c00248d6 <outb>
c0024bcc:	83 c4 10             	add    $0x10,%esp
  
  /* Reset DLAB. */
  outb (LCR_REG, LCR_N81);
c0024bcf:	83 ec 08             	sub    $0x8,%esp
c0024bd2:	6a 03                	push   $0x3
c0024bd4:	68 fb 03 00 00       	push   $0x3fb
c0024bd9:	e8 f8 fc ff ff       	call   c00248d6 <outb>
c0024bde:	83 c4 10             	add    $0x10,%esp
}
c0024be1:	90                   	nop
c0024be2:	c9                   	leave  
c0024be3:	c3                   	ret    

c0024be4 <write_ier>:

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0024be4:	55                   	push   %ebp
c0024be5:	89 e5                	mov    %esp,%ebp
c0024be7:	83 ec 18             	sub    $0x18,%esp
  uint8_t ier = 0;
c0024bea:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c0024bee:	e8 46 c7 ff ff       	call   c0021339 <intr_get_level>
c0024bf3:	85 c0                	test   %eax,%eax
c0024bf5:	74 21                	je     c0024c18 <write_ier+0x34>
c0024bf7:	83 ec 0c             	sub    $0xc,%esp
c0024bfa:	68 d5 f8 02 c0       	push   $0xc002f8d5
c0024bff:	68 93 f8 02 c0       	push   $0xc002f893
c0024c04:	68 4c f9 02 c0       	push   $0xc002f94c
c0024c09:	68 b5 00 00 00       	push   $0xb5
c0024c0e:	68 aa f8 02 c0       	push   $0xc002f8aa
c0024c13:	e8 19 4a 00 00       	call   c0029631 <debug_panic>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0024c18:	83 ec 0c             	sub    $0xc,%esp
c0024c1b:	68 00 99 03 c0       	push   $0xc0039900
c0024c20:	e8 ae 19 00 00       	call   c00265d3 <intq_empty>
c0024c25:	83 c4 10             	add    $0x10,%esp
c0024c28:	83 f0 01             	xor    $0x1,%eax
c0024c2b:	84 c0                	test   %al,%al
c0024c2d:	74 04                	je     c0024c33 <write_ier+0x4f>
    ier |= IER_XMIT;
c0024c2f:	80 4d f7 02          	orb    $0x2,-0x9(%ebp)

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c0024c33:	e8 18 19 00 00       	call   c0026550 <input_full>
c0024c38:	83 f0 01             	xor    $0x1,%eax
c0024c3b:	84 c0                	test   %al,%al
c0024c3d:	74 04                	je     c0024c43 <write_ier+0x5f>
    ier |= IER_RECV;
c0024c3f:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
  
  outb (IER_REG, ier);
c0024c43:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0024c47:	83 ec 08             	sub    $0x8,%esp
c0024c4a:	50                   	push   %eax
c0024c4b:	68 f9 03 00 00       	push   $0x3f9
c0024c50:	e8 81 fc ff ff       	call   c00248d6 <outb>
c0024c55:	83 c4 10             	add    $0x10,%esp
}
c0024c58:	90                   	nop
c0024c59:	c9                   	leave  
c0024c5a:	c3                   	ret    

c0024c5b <putc_poll>:

/* Polls the serial port until it's ready,
   and then transmits BYTE. */
static void
putc_poll (uint8_t byte) 
{
c0024c5b:	55                   	push   %ebp
c0024c5c:	89 e5                	mov    %esp,%ebp
c0024c5e:	83 ec 18             	sub    $0x18,%esp
c0024c61:	8b 45 08             	mov    0x8(%ebp),%eax
c0024c64:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0024c67:	e8 cd c6 ff ff       	call   c0021339 <intr_get_level>
c0024c6c:	85 c0                	test   %eax,%eax
c0024c6e:	74 22                	je     c0024c92 <putc_poll+0x37>
c0024c70:	83 ec 0c             	sub    $0xc,%esp
c0024c73:	68 d5 f8 02 c0       	push   $0xc002f8d5
c0024c78:	68 93 f8 02 c0       	push   $0xc002f893
c0024c7d:	68 58 f9 02 c0       	push   $0xc002f958
c0024c82:	68 c9 00 00 00       	push   $0xc9
c0024c87:	68 aa f8 02 c0       	push   $0xc002f8aa
c0024c8c:	e8 a0 49 00 00       	call   c0029631 <debug_panic>

  while ((inb (LSR_REG) & LSR_THRE) == 0)
    continue;
c0024c91:	90                   	nop
static void
putc_poll (uint8_t byte) 
{
  ASSERT (intr_get_level () == INTR_OFF);

  while ((inb (LSR_REG) & LSR_THRE) == 0)
c0024c92:	83 ec 0c             	sub    $0xc,%esp
c0024c95:	68 fd 03 00 00       	push   $0x3fd
c0024c9a:	e8 1a fc ff ff       	call   c00248b9 <inb>
c0024c9f:	83 c4 10             	add    $0x10,%esp
c0024ca2:	0f b6 c0             	movzbl %al,%eax
c0024ca5:	83 e0 20             	and    $0x20,%eax
c0024ca8:	85 c0                	test   %eax,%eax
c0024caa:	74 e5                	je     c0024c91 <putc_poll+0x36>
    continue;
  outb (THR_REG, byte);
c0024cac:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0024cb0:	83 ec 08             	sub    $0x8,%esp
c0024cb3:	50                   	push   %eax
c0024cb4:	68 f8 03 00 00       	push   $0x3f8
c0024cb9:	e8 18 fc ff ff       	call   c00248d6 <outb>
c0024cbe:	83 c4 10             	add    $0x10,%esp
}
c0024cc1:	90                   	nop
c0024cc2:	c9                   	leave  
c0024cc3:	c3                   	ret    

c0024cc4 <serial_interrupt>:

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c0024cc4:	55                   	push   %ebp
c0024cc5:	89 e5                	mov    %esp,%ebp
c0024cc7:	83 ec 08             	sub    $0x8,%esp
  /* Inquire about interrupt in UART.  Without this, we can
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);
c0024cca:	68 fa 03 00 00       	push   $0x3fa
c0024ccf:	e8 e5 fb ff ff       	call   c00248b9 <inb>
c0024cd4:	83 c4 04             	add    $0x4,%esp

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024cd7:	eb 1c                	jmp    c0024cf5 <serial_interrupt+0x31>
    input_putc (inb (RBR_REG));
c0024cd9:	68 f8 03 00 00       	push   $0x3f8
c0024cde:	e8 d6 fb ff ff       	call   c00248b9 <inb>
c0024ce3:	83 c4 04             	add    $0x4,%esp
c0024ce6:	0f b6 c0             	movzbl %al,%eax
c0024ce9:	83 ec 0c             	sub    $0xc,%esp
c0024cec:	50                   	push   %eax
c0024ced:	e8 9f 17 00 00       	call   c0026491 <input_putc>
c0024cf2:	83 c4 10             	add    $0x10,%esp
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024cf5:	e8 56 18 00 00       	call   c0026550 <input_full>
c0024cfa:	83 f0 01             	xor    $0x1,%eax
c0024cfd:	84 c0                	test   %al,%al
c0024cff:	74 40                	je     c0024d41 <serial_interrupt+0x7d>
c0024d01:	83 ec 0c             	sub    $0xc,%esp
c0024d04:	68 fd 03 00 00       	push   $0x3fd
c0024d09:	e8 ab fb ff ff       	call   c00248b9 <inb>
c0024d0e:	83 c4 10             	add    $0x10,%esp
c0024d11:	0f b6 c0             	movzbl %al,%eax
c0024d14:	83 e0 01             	and    $0x1,%eax
c0024d17:	85 c0                	test   %eax,%eax
c0024d19:	75 be                	jne    c0024cd9 <serial_interrupt+0x15>
    input_putc (inb (RBR_REG));

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024d1b:	eb 24                	jmp    c0024d41 <serial_interrupt+0x7d>
    outb (THR_REG, intq_getc (&txq));
c0024d1d:	83 ec 0c             	sub    $0xc,%esp
c0024d20:	68 00 99 03 c0       	push   $0xc0039900
c0024d25:	e8 37 19 00 00       	call   c0026661 <intq_getc>
c0024d2a:	83 c4 10             	add    $0x10,%esp
c0024d2d:	0f b6 c0             	movzbl %al,%eax
c0024d30:	83 ec 08             	sub    $0x8,%esp
c0024d33:	50                   	push   %eax
c0024d34:	68 f8 03 00 00       	push   $0x3f8
c0024d39:	e8 98 fb ff ff       	call   c00248d6 <outb>
c0024d3e:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
    input_putc (inb (RBR_REG));

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024d41:	83 ec 0c             	sub    $0xc,%esp
c0024d44:	68 00 99 03 c0       	push   $0xc0039900
c0024d49:	e8 85 18 00 00       	call   c00265d3 <intq_empty>
c0024d4e:	83 c4 10             	add    $0x10,%esp
c0024d51:	83 f0 01             	xor    $0x1,%eax
c0024d54:	84 c0                	test   %al,%al
c0024d56:	74 1a                	je     c0024d72 <serial_interrupt+0xae>
c0024d58:	83 ec 0c             	sub    $0xc,%esp
c0024d5b:	68 fd 03 00 00       	push   $0x3fd
c0024d60:	e8 54 fb ff ff       	call   c00248b9 <inb>
c0024d65:	83 c4 10             	add    $0x10,%esp
c0024d68:	0f b6 c0             	movzbl %al,%eax
c0024d6b:	83 e0 20             	and    $0x20,%eax
c0024d6e:	85 c0                	test   %eax,%eax
c0024d70:	75 ab                	jne    c0024d1d <serial_interrupt+0x59>
    outb (THR_REG, intq_getc (&txq));

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024d72:	e8 6d fe ff ff       	call   c0024be4 <write_ier>
}
c0024d77:	90                   	nop
c0024d78:	c9                   	leave  
c0024d79:	c3                   	ret    

c0024d7a <block_type_name>:

/* Returns a human-readable name for the given block device
   TYPE. */
const char *
block_type_name (enum block_type type)
{
c0024d7a:	55                   	push   %ebp
c0024d7b:	89 e5                	mov    %esp,%ebp
c0024d7d:	83 ec 08             	sub    $0x8,%esp
      "swap",
      "raw",
      "foreign",
    };

  ASSERT (type < BLOCK_CNT);
c0024d80:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
c0024d84:	76 1e                	jbe    c0024da4 <block_type_name+0x2a>
c0024d86:	83 ec 0c             	sub    $0xc,%esp
c0024d89:	68 64 f9 02 c0       	push   $0xc002f964
c0024d8e:	68 75 f9 02 c0       	push   $0xc002f975
c0024d93:	68 7c fa 02 c0       	push   $0xc002fa7c
c0024d98:	6a 2f                	push   $0x2f
c0024d9a:	68 8c f9 02 c0       	push   $0xc002f98c
c0024d9f:	e8 8d 48 00 00       	call   c0029631 <debug_panic>
  return block_type_names[type];
c0024da4:	8b 45 08             	mov    0x8(%ebp),%eax
c0024da7:	8b 04 85 5c 7c 03 c0 	mov    -0x3ffc83a4(,%eax,4),%eax
}
c0024dae:	c9                   	leave  
c0024daf:	c3                   	ret    

c0024db0 <block_get_role>:

/* Returns the block device fulfilling the given ROLE, or a null
   pointer if no block device has been assigned that role. */
struct block *
block_get_role (enum block_type role)
{
c0024db0:	55                   	push   %ebp
c0024db1:	89 e5                	mov    %esp,%ebp
c0024db3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0024db6:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0024dba:	76 1e                	jbe    c0024dda <block_get_role+0x2a>
c0024dbc:	83 ec 0c             	sub    $0xc,%esp
c0024dbf:	68 a2 f9 02 c0       	push   $0xc002f9a2
c0024dc4:	68 75 f9 02 c0       	push   $0xc002f975
c0024dc9:	68 b4 fa 02 c0       	push   $0xc002fab4
c0024dce:	6a 38                	push   $0x38
c0024dd0:	68 8c f9 02 c0       	push   $0xc002f98c
c0024dd5:	e8 57 48 00 00       	call   c0029631 <debug_panic>
  return block_by_role[role];
c0024dda:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ddd:	8b 04 85 68 99 03 c0 	mov    -0x3ffc6698(,%eax,4),%eax
}
c0024de4:	c9                   	leave  
c0024de5:	c3                   	ret    

c0024de6 <block_set_role>:

/* Assigns BLOCK the given ROLE. */
void
block_set_role (enum block_type role, struct block *block)
{
c0024de6:	55                   	push   %ebp
c0024de7:	89 e5                	mov    %esp,%ebp
c0024de9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0024dec:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0024df0:	76 1e                	jbe    c0024e10 <block_set_role+0x2a>
c0024df2:	83 ec 0c             	sub    $0xc,%esp
c0024df5:	68 a2 f9 02 c0       	push   $0xc002f9a2
c0024dfa:	68 75 f9 02 c0       	push   $0xc002f975
c0024dff:	68 c4 fa 02 c0       	push   $0xc002fac4
c0024e04:	6a 40                	push   $0x40
c0024e06:	68 8c f9 02 c0       	push   $0xc002f98c
c0024e0b:	e8 21 48 00 00       	call   c0029631 <debug_panic>
  block_by_role[role] = block;
c0024e10:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e13:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024e16:	89 14 85 68 99 03 c0 	mov    %edx,-0x3ffc6698(,%eax,4)
}
c0024e1d:	90                   	nop
c0024e1e:	c9                   	leave  
c0024e1f:	c3                   	ret    

c0024e20 <block_first>:

/* Returns the first block device in kernel probe order, or a
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
c0024e20:	55                   	push   %ebp
c0024e21:	89 e5                	mov    %esp,%ebp
c0024e23:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c0024e26:	83 ec 0c             	sub    $0xc,%esp
c0024e29:	68 4c 7c 03 c0       	push   $0xc0037c4c
c0024e2e:	e8 c6 4a 00 00       	call   c00298f9 <list_begin>
c0024e33:	83 c4 10             	add    $0x10,%esp
c0024e36:	83 ec 0c             	sub    $0xc,%esp
c0024e39:	50                   	push   %eax
c0024e3a:	e8 6d 03 00 00       	call   c00251ac <list_elem_to_block>
c0024e3f:	83 c4 10             	add    $0x10,%esp
}
c0024e42:	c9                   	leave  
c0024e43:	c3                   	ret    

c0024e44 <block_next>:

/* Returns the block device following BLOCK in kernel probe
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
c0024e44:	55                   	push   %ebp
c0024e45:	89 e5                	mov    %esp,%ebp
c0024e47:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c0024e4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e4d:	83 ec 0c             	sub    $0xc,%esp
c0024e50:	50                   	push   %eax
c0024e51:	e8 d5 4a 00 00       	call   c002992b <list_next>
c0024e56:	83 c4 10             	add    $0x10,%esp
c0024e59:	83 ec 0c             	sub    $0xc,%esp
c0024e5c:	50                   	push   %eax
c0024e5d:	e8 4a 03 00 00       	call   c00251ac <list_elem_to_block>
c0024e62:	83 c4 10             	add    $0x10,%esp
}
c0024e65:	c9                   	leave  
c0024e66:	c3                   	ret    

c0024e67 <block_get_by_name>:

/* Returns the block device with the given NAME, or a null
   pointer if no block device has that name. */
struct block *
block_get_by_name (const char *name)
{
c0024e67:	55                   	push   %ebp
c0024e68:	89 e5                	mov    %esp,%ebp
c0024e6a:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024e6d:	83 ec 0c             	sub    $0xc,%esp
c0024e70:	68 4c 7c 03 c0       	push   $0xc0037c4c
c0024e75:	e8 7f 4a 00 00       	call   c00298f9 <list_begin>
c0024e7a:	83 c4 10             	add    $0x10,%esp
c0024e7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0024e80:	eb 3b                	jmp    c0024ebd <block_get_by_name+0x56>
       e = list_next (e))
    {
      struct block *block = list_entry (e, struct block, list_elem);
c0024e82:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024e85:	83 c0 04             	add    $0x4,%eax
c0024e88:	83 e8 04             	sub    $0x4,%eax
c0024e8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!strcmp (name, block->name))
c0024e8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024e91:	83 c0 08             	add    $0x8,%eax
c0024e94:	83 ec 08             	sub    $0x8,%esp
c0024e97:	50                   	push   %eax
c0024e98:	ff 75 08             	pushl  0x8(%ebp)
c0024e9b:	e8 87 37 00 00       	call   c0028627 <strcmp>
c0024ea0:	83 c4 10             	add    $0x10,%esp
c0024ea3:	85 c0                	test   %eax,%eax
c0024ea5:	75 05                	jne    c0024eac <block_get_by_name+0x45>
        return block;
c0024ea7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024eaa:	eb 2b                	jmp    c0024ed7 <block_get_by_name+0x70>
block_get_by_name (const char *name)
{
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
       e = list_next (e))
c0024eac:	83 ec 0c             	sub    $0xc,%esp
c0024eaf:	ff 75 f4             	pushl  -0xc(%ebp)
c0024eb2:	e8 74 4a 00 00       	call   c002992b <list_next>
c0024eb7:	83 c4 10             	add    $0x10,%esp
c0024eba:	89 45 f4             	mov    %eax,-0xc(%ebp)
struct block *
block_get_by_name (const char *name)
{
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024ebd:	83 ec 0c             	sub    $0xc,%esp
c0024ec0:	68 4c 7c 03 c0       	push   $0xc0037c4c
c0024ec5:	e8 ab 4a 00 00       	call   c0029975 <list_end>
c0024eca:	83 c4 10             	add    $0x10,%esp
c0024ecd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0024ed0:	75 b0                	jne    c0024e82 <block_get_by_name+0x1b>
      struct block *block = list_entry (e, struct block, list_elem);
      if (!strcmp (name, block->name))
        return block;
    }

  return NULL;
c0024ed2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0024ed7:	c9                   	leave  
c0024ed8:	c3                   	ret    

c0024ed9 <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c0024ed9:	55                   	push   %ebp
c0024eda:	89 e5                	mov    %esp,%ebp
c0024edc:	53                   	push   %ebx
c0024edd:	83 ec 04             	sub    $0x4,%esp
  if (sector >= block->size)
c0024ee0:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ee3:	8b 40 1c             	mov    0x1c(%eax),%eax
c0024ee6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024ee9:	77 32                	ja     c0024f1d <check_sector+0x44>
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0024eeb:	8b 45 08             	mov    0x8(%ebp),%eax
c0024eee:	8b 58 1c             	mov    0x1c(%eax),%ebx
c0024ef1:	83 ec 0c             	sub    $0xc,%esp
c0024ef4:	ff 75 08             	pushl  0x8(%ebp)
c0024ef7:	e8 fd 00 00 00       	call   c0024ff9 <block_name>
c0024efc:	83 c4 10             	add    $0x10,%esp
c0024eff:	83 ec 04             	sub    $0x4,%esp
c0024f02:	53                   	push   %ebx
c0024f03:	ff 75 0c             	pushl  0xc(%ebp)
c0024f06:	50                   	push   %eax
c0024f07:	68 b8 f9 02 c0       	push   $0xc002f9b8
c0024f0c:	68 d4 fa 02 c0       	push   $0xc002fad4
c0024f11:	6a 70                	push   $0x70
c0024f13:	68 8c f9 02 c0       	push   $0xc002f98c
c0024f18:	e8 14 47 00 00       	call   c0029631 <debug_panic>
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c0024f1d:	90                   	nop
c0024f1e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024f21:	c9                   	leave  
c0024f22:	c3                   	ret    

c0024f23 <block_read>:
   have room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_read (struct block *block, block_sector_t sector, void *buffer)
{
c0024f23:	55                   	push   %ebp
c0024f24:	89 e5                	mov    %esp,%ebp
c0024f26:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0024f29:	83 ec 08             	sub    $0x8,%esp
c0024f2c:	ff 75 0c             	pushl  0xc(%ebp)
c0024f2f:	ff 75 08             	pushl  0x8(%ebp)
c0024f32:	e8 a2 ff ff ff       	call   c0024ed9 <check_sector>
c0024f37:	83 c4 10             	add    $0x10,%esp
  block->ops->read (block->aux, sector, buffer);
c0024f3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f3d:	8b 40 20             	mov    0x20(%eax),%eax
c0024f40:	8b 00                	mov    (%eax),%eax
c0024f42:	8b 55 08             	mov    0x8(%ebp),%edx
c0024f45:	8b 52 24             	mov    0x24(%edx),%edx
c0024f48:	83 ec 04             	sub    $0x4,%esp
c0024f4b:	ff 75 10             	pushl  0x10(%ebp)
c0024f4e:	ff 75 0c             	pushl  0xc(%ebp)
c0024f51:	52                   	push   %edx
c0024f52:	ff d0                	call   *%eax
c0024f54:	83 c4 10             	add    $0x10,%esp
  block->read_cnt++;
c0024f57:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f5a:	8b 50 2c             	mov    0x2c(%eax),%edx
c0024f5d:	8b 40 28             	mov    0x28(%eax),%eax
c0024f60:	83 c0 01             	add    $0x1,%eax
c0024f63:	83 d2 00             	adc    $0x0,%edx
c0024f66:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024f69:	89 41 28             	mov    %eax,0x28(%ecx)
c0024f6c:	89 51 2c             	mov    %edx,0x2c(%ecx)
}
c0024f6f:	90                   	nop
c0024f70:	c9                   	leave  
c0024f71:	c3                   	ret    

c0024f72 <block_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_write (struct block *block, block_sector_t sector, const void *buffer)
{
c0024f72:	55                   	push   %ebp
c0024f73:	89 e5                	mov    %esp,%ebp
c0024f75:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0024f78:	83 ec 08             	sub    $0x8,%esp
c0024f7b:	ff 75 0c             	pushl  0xc(%ebp)
c0024f7e:	ff 75 08             	pushl  0x8(%ebp)
c0024f81:	e8 53 ff ff ff       	call   c0024ed9 <check_sector>
c0024f86:	83 c4 10             	add    $0x10,%esp
  ASSERT (block->type != BLOCK_FOREIGN);
c0024f89:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f8c:	8b 40 18             	mov    0x18(%eax),%eax
c0024f8f:	83 f8 05             	cmp    $0x5,%eax
c0024f92:	75 21                	jne    c0024fb5 <block_write+0x43>
c0024f94:	83 ec 0c             	sub    $0xc,%esp
c0024f97:	68 eb f9 02 c0       	push   $0xc002f9eb
c0024f9c:	68 75 f9 02 c0       	push   $0xc002f975
c0024fa1:	68 e4 fa 02 c0       	push   $0xc002fae4
c0024fa6:	68 89 00 00 00       	push   $0x89
c0024fab:	68 8c f9 02 c0       	push   $0xc002f98c
c0024fb0:	e8 7c 46 00 00       	call   c0029631 <debug_panic>
  block->ops->write (block->aux, sector, buffer);
c0024fb5:	8b 45 08             	mov    0x8(%ebp),%eax
c0024fb8:	8b 40 20             	mov    0x20(%eax),%eax
c0024fbb:	8b 40 04             	mov    0x4(%eax),%eax
c0024fbe:	8b 55 08             	mov    0x8(%ebp),%edx
c0024fc1:	8b 52 24             	mov    0x24(%edx),%edx
c0024fc4:	83 ec 04             	sub    $0x4,%esp
c0024fc7:	ff 75 10             	pushl  0x10(%ebp)
c0024fca:	ff 75 0c             	pushl  0xc(%ebp)
c0024fcd:	52                   	push   %edx
c0024fce:	ff d0                	call   *%eax
c0024fd0:	83 c4 10             	add    $0x10,%esp
  block->write_cnt++;
c0024fd3:	8b 45 08             	mov    0x8(%ebp),%eax
c0024fd6:	8b 50 34             	mov    0x34(%eax),%edx
c0024fd9:	8b 40 30             	mov    0x30(%eax),%eax
c0024fdc:	83 c0 01             	add    $0x1,%eax
c0024fdf:	83 d2 00             	adc    $0x0,%edx
c0024fe2:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024fe5:	89 41 30             	mov    %eax,0x30(%ecx)
c0024fe8:	89 51 34             	mov    %edx,0x34(%ecx)
}
c0024feb:	90                   	nop
c0024fec:	c9                   	leave  
c0024fed:	c3                   	ret    

c0024fee <block_size>:

/* Returns the number of sectors in BLOCK. */
block_sector_t
block_size (struct block *block)
{
c0024fee:	55                   	push   %ebp
c0024fef:	89 e5                	mov    %esp,%ebp
  return block->size;
c0024ff1:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ff4:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0024ff7:	5d                   	pop    %ebp
c0024ff8:	c3                   	ret    

c0024ff9 <block_name>:

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
c0024ff9:	55                   	push   %ebp
c0024ffa:	89 e5                	mov    %esp,%ebp
  return block->name;
c0024ffc:	8b 45 08             	mov    0x8(%ebp),%eax
c0024fff:	83 c0 08             	add    $0x8,%eax
}
c0025002:	5d                   	pop    %ebp
c0025003:	c3                   	ret    

c0025004 <block_type>:

/* Returns BLOCK's type. */
enum block_type
block_type (struct block *block)
{
c0025004:	55                   	push   %ebp
c0025005:	89 e5                	mov    %esp,%ebp
  return block->type;
c0025007:	8b 45 08             	mov    0x8(%ebp),%eax
c002500a:	8b 40 18             	mov    0x18(%eax),%eax
}
c002500d:	5d                   	pop    %ebp
c002500e:	c3                   	ret    

c002500f <block_print_stats>:

/* Prints statistics for each block device used for a Pintos role. */
void
block_print_stats (void)
{
c002500f:	55                   	push   %ebp
c0025010:	89 e5                	mov    %esp,%ebp
c0025012:	56                   	push   %esi
c0025013:	53                   	push   %ebx
c0025014:	83 ec 20             	sub    $0x20,%esp
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0025017:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002501e:	eb 63                	jmp    c0025083 <block_print_stats+0x74>
    {
      struct block *block = block_by_role[i];
c0025020:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025023:	8b 04 85 68 99 03 c0 	mov    -0x3ffc6698(,%eax,4),%eax
c002502a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (block != NULL)
c002502d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025031:	74 4c                	je     c002507f <block_print_stats+0x70>
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c0025033:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025036:	8b 50 34             	mov    0x34(%eax),%edx
c0025039:	8b 40 30             	mov    0x30(%eax),%eax
c002503c:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002503f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0025042:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025045:	8b 58 28             	mov    0x28(%eax),%ebx
c0025048:	8b 70 2c             	mov    0x2c(%eax),%esi
c002504b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002504e:	8b 40 18             	mov    0x18(%eax),%eax
c0025051:	83 ec 0c             	sub    $0xc,%esp
c0025054:	50                   	push   %eax
c0025055:	e8 20 fd ff ff       	call   c0024d7a <block_type_name>
c002505a:	83 c4 10             	add    $0x10,%esp
c002505d:	89 c2                	mov    %eax,%edx
                  block->name, block_type_name (block->type),
c002505f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025062:	83 c0 08             	add    $0x8,%eax
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
    {
      struct block *block = block_by_role[i];
      if (block != NULL)
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c0025065:	83 ec 04             	sub    $0x4,%esp
c0025068:	ff 75 e4             	pushl  -0x1c(%ebp)
c002506b:	ff 75 e0             	pushl  -0x20(%ebp)
c002506e:	56                   	push   %esi
c002506f:	53                   	push   %ebx
c0025070:	52                   	push   %edx
c0025071:	50                   	push   %eax
c0025072:	68 08 fa 02 c0       	push   $0xc002fa08
c0025077:	e8 82 21 00 00       	call   c00271fe <printf>
c002507c:	83 c4 20             	add    $0x20,%esp
void
block_print_stats (void)
{
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c002507f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0025083:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c0025087:	7e 97                	jle    c0025020 <block_print_stats+0x11>
          printf ("%s (%s): %llu reads, %llu writes\n",
                  block->name, block_type_name (block->type),
                  block->read_cnt, block->write_cnt);
        }
    }
}
c0025089:	90                   	nop
c002508a:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002508d:	5b                   	pop    %ebx
c002508e:	5e                   	pop    %esi
c002508f:	5d                   	pop    %ebp
c0025090:	c3                   	ret    

c0025091 <block_register>:
   will be passed AUX in each function call. */
struct block *
block_register (const char *name, enum block_type type,
                const char *extra_info, block_sector_t size,
                const struct block_operations *ops, void *aux)
{
c0025091:	55                   	push   %ebp
c0025092:	89 e5                	mov    %esp,%ebp
c0025094:	83 ec 18             	sub    $0x18,%esp
  struct block *block = malloc (sizeof *block);
c0025097:	83 ec 0c             	sub    $0xc,%esp
c002509a:	6a 38                	push   $0x38
c002509c:	e8 ea e3 ff ff       	call   c002348b <malloc>
c00250a1:	83 c4 10             	add    $0x10,%esp
c00250a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (block == NULL)
c00250a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00250ab:	75 19                	jne    c00250c6 <block_register+0x35>
    PANIC ("Failed to allocate memory for block device descriptor");
c00250ad:	68 2c fa 02 c0       	push   $0xc002fa2c
c00250b2:	68 f0 fa 02 c0       	push   $0xc002faf0
c00250b7:	68 c1 00 00 00       	push   $0xc1
c00250bc:	68 8c f9 02 c0       	push   $0xc002f98c
c00250c1:	e8 6b 45 00 00       	call   c0029631 <debug_panic>

  list_push_back (&all_blocks, &block->list_elem);
c00250c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250c9:	83 ec 08             	sub    $0x8,%esp
c00250cc:	50                   	push   %eax
c00250cd:	68 4c 7c 03 c0       	push   $0xc0037c4c
c00250d2:	e8 ad 4b 00 00       	call   c0029c84 <list_push_back>
c00250d7:	83 c4 10             	add    $0x10,%esp
  strlcpy (block->name, name, sizeof block->name);
c00250da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250dd:	83 c0 08             	add    $0x8,%eax
c00250e0:	83 ec 04             	sub    $0x4,%esp
c00250e3:	6a 10                	push   $0x10
c00250e5:	ff 75 08             	pushl  0x8(%ebp)
c00250e8:	50                   	push   %eax
c00250e9:	e8 0e 3a 00 00       	call   c0028afc <strlcpy>
c00250ee:	83 c4 10             	add    $0x10,%esp
  block->type = type;
c00250f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250f4:	8b 55 0c             	mov    0xc(%ebp),%edx
c00250f7:	89 50 18             	mov    %edx,0x18(%eax)
  block->size = size;
c00250fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250fd:	8b 55 14             	mov    0x14(%ebp),%edx
c0025100:	89 50 1c             	mov    %edx,0x1c(%eax)
  block->ops = ops;
c0025103:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025106:	8b 55 18             	mov    0x18(%ebp),%edx
c0025109:	89 50 20             	mov    %edx,0x20(%eax)
  block->aux = aux;
c002510c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002510f:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0025112:	89 50 24             	mov    %edx,0x24(%eax)
  block->read_cnt = 0;
c0025115:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025118:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c002511f:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  block->write_cnt = 0;
c0025126:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025129:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
c0025130:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c0025137:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002513a:	8b 40 1c             	mov    0x1c(%eax),%eax
c002513d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025140:	83 c2 08             	add    $0x8,%edx
c0025143:	83 ec 04             	sub    $0x4,%esp
c0025146:	50                   	push   %eax
c0025147:	52                   	push   %edx
c0025148:	68 62 fa 02 c0       	push   $0xc002fa62
c002514d:	e8 ac 20 00 00       	call   c00271fe <printf>
c0025152:	83 c4 10             	add    $0x10,%esp
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c0025155:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025158:	8b 40 1c             	mov    0x1c(%eax),%eax
c002515b:	ba 00 00 00 00       	mov    $0x0,%edx
c0025160:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c0025164:	c1 e0 09             	shl    $0x9,%eax
c0025167:	83 ec 08             	sub    $0x8,%esp
c002516a:	52                   	push   %edx
c002516b:	50                   	push   %eax
c002516c:	e8 b2 2d 00 00       	call   c0027f23 <print_human_readable_size>
c0025171:	83 c4 10             	add    $0x10,%esp
  printf (")");
c0025174:	83 ec 0c             	sub    $0xc,%esp
c0025177:	6a 29                	push   $0x29
c0025179:	e8 ee 66 00 00       	call   c002b86c <putchar>
c002517e:	83 c4 10             	add    $0x10,%esp
  if (extra_info != NULL)
c0025181:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0025185:	74 13                	je     c002519a <block_register+0x109>
    printf (", %s", extra_info);
c0025187:	83 ec 08             	sub    $0x8,%esp
c002518a:	ff 75 10             	pushl  0x10(%ebp)
c002518d:	68 74 fa 02 c0       	push   $0xc002fa74
c0025192:	e8 67 20 00 00       	call   c00271fe <printf>
c0025197:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c002519a:	83 ec 0c             	sub    $0xc,%esp
c002519d:	6a 0a                	push   $0xa
c002519f:	e8 c8 66 00 00       	call   c002b86c <putchar>
c00251a4:	83 c4 10             	add    $0x10,%esp

  return block;
c00251a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00251aa:	c9                   	leave  
c00251ab:	c3                   	ret    

c00251ac <list_elem_to_block>:

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
c00251ac:	55                   	push   %ebp
c00251ad:	89 e5                	mov    %esp,%ebp
c00251af:	83 ec 08             	sub    $0x8,%esp
  return (list_elem != list_end (&all_blocks)
c00251b2:	83 ec 0c             	sub    $0xc,%esp
c00251b5:	68 4c 7c 03 c0       	push   $0xc0037c4c
c00251ba:	e8 b6 47 00 00       	call   c0029975 <list_end>
c00251bf:	83 c4 10             	add    $0x10,%esp
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c00251c2:	3b 45 08             	cmp    0x8(%ebp),%eax
c00251c5:	74 0b                	je     c00251d2 <list_elem_to_block+0x26>
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
          ? list_entry (list_elem, struct block, list_elem)
c00251c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00251ca:	83 c0 04             	add    $0x4,%eax
          : NULL);
c00251cd:	83 e8 04             	sub    $0x4,%eax
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
c00251d0:	eb 05                	jmp    c00251d7 <list_elem_to_block+0x2b>
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c00251d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00251d7:	c9                   	leave  
c00251d8:	c3                   	ret    

c00251d9 <partition_scan>:
static const char *partition_type_name (uint8_t);

/* Scans BLOCK for partitions of interest to Pintos. */
void
partition_scan (struct block *block)
{
c00251d9:	55                   	push   %ebp
c00251da:	89 e5                	mov    %esp,%ebp
c00251dc:	83 ec 18             	sub    $0x18,%esp
  int part_nr = 0;
c00251df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  read_partition_table (block, 0, 0, &part_nr);
c00251e6:	8d 45 f4             	lea    -0xc(%ebp),%eax
c00251e9:	50                   	push   %eax
c00251ea:	6a 00                	push   $0x0
c00251ec:	6a 00                	push   $0x0
c00251ee:	ff 75 08             	pushl  0x8(%ebp)
c00251f1:	e8 2c 00 00 00       	call   c0025222 <read_partition_table>
c00251f6:	83 c4 10             	add    $0x10,%esp
  if (part_nr == 0)
c00251f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00251fc:	85 c0                	test   %eax,%eax
c00251fe:	75 1f                	jne    c002521f <partition_scan+0x46>
    printf ("%s: Device contains no partitions\n", block_name (block));
c0025200:	83 ec 0c             	sub    $0xc,%esp
c0025203:	ff 75 08             	pushl  0x8(%ebp)
c0025206:	e8 ee fd ff ff       	call   c0024ff9 <block_name>
c002520b:	83 c4 10             	add    $0x10,%esp
c002520e:	83 ec 08             	sub    $0x8,%esp
c0025211:	50                   	push   %eax
c0025212:	68 00 fb 02 c0       	push   $0xc002fb00
c0025217:	e8 e2 1f 00 00       	call   c00271fe <printf>
c002521c:	83 c4 10             	add    $0x10,%esp
}
c002521f:	90                   	nop
c0025220:	c9                   	leave  
c0025221:	c3                   	ret    

c0025222 <read_partition_table>:
   partitions are found. */
static void
read_partition_table (struct block *block, block_sector_t sector,
                      block_sector_t primary_extended_sector,
                      int *part_nr)
{
c0025222:	55                   	push   %ebp
c0025223:	89 e5                	mov    %esp,%ebp
c0025225:	53                   	push   %ebx
c0025226:	83 ec 14             	sub    $0x14,%esp

  struct partition_table *pt;
  size_t i;

  /* Check SECTOR validity. */
  if (sector >= block_size (block))
c0025229:	83 ec 0c             	sub    $0xc,%esp
c002522c:	ff 75 08             	pushl  0x8(%ebp)
c002522f:	e8 ba fd ff ff       	call   c0024fee <block_size>
c0025234:	83 c4 10             	add    $0x10,%esp
c0025237:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002523a:	77 27                	ja     c0025263 <read_partition_table+0x41>
    {
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c002523c:	83 ec 0c             	sub    $0xc,%esp
c002523f:	ff 75 08             	pushl  0x8(%ebp)
c0025242:	e8 b2 fd ff ff       	call   c0024ff9 <block_name>
c0025247:	83 c4 10             	add    $0x10,%esp
c002524a:	83 ec 04             	sub    $0x4,%esp
c002524d:	ff 75 0c             	pushl  0xc(%ebp)
c0025250:	50                   	push   %eax
c0025251:	68 24 fb 02 c0       	push   $0xc002fb24
c0025256:	e8 a3 1f 00 00       	call   c00271fe <printf>
c002525b:	83 c4 10             	add    $0x10,%esp
              block_name (block), sector);
      return;
c002525e:	e9 d9 01 00 00       	jmp    c002543c <read_partition_table+0x21a>
    }

  /* Read sector. */
  ASSERT (sizeof *pt == BLOCK_SECTOR_SIZE);
  pt = malloc (sizeof *pt);
c0025263:	83 ec 0c             	sub    $0xc,%esp
c0025266:	68 00 02 00 00       	push   $0x200
c002526b:	e8 1b e2 ff ff       	call   c002348b <malloc>
c0025270:	83 c4 10             	add    $0x10,%esp
c0025273:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pt == NULL)
c0025276:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002527a:	75 16                	jne    c0025292 <read_partition_table+0x70>
    PANIC ("Failed to allocate memory for partition table.");
c002527c:	68 5c fb 02 c0       	push   $0xc002fb5c
c0025281:	68 e4 fc 02 c0       	push   $0xc002fce4
c0025286:	6a 5a                	push   $0x5a
c0025288:	68 8b fb 02 c0       	push   $0xc002fb8b
c002528d:	e8 9f 43 00 00       	call   c0029631 <debug_panic>
  block_read (block, 0, pt);
c0025292:	83 ec 04             	sub    $0x4,%esp
c0025295:	ff 75 f0             	pushl  -0x10(%ebp)
c0025298:	6a 00                	push   $0x0
c002529a:	ff 75 08             	pushl  0x8(%ebp)
c002529d:	e8 81 fc ff ff       	call   c0024f23 <block_read>
c00252a2:	83 c4 10             	add    $0x10,%esp

  /* Check signature. */
  if (pt->signature != 0xaa55)
c00252a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00252a8:	0f b7 80 fe 01 00 00 	movzwl 0x1fe(%eax),%eax
c00252af:	66 3d 55 aa          	cmp    $0xaa55,%ax
c00252b3:	74 5c                	je     c0025311 <read_partition_table+0xef>
    {
      if (primary_extended_sector == 0)
c00252b5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00252b9:	75 21                	jne    c00252dc <read_partition_table+0xba>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c00252bb:	83 ec 0c             	sub    $0xc,%esp
c00252be:	ff 75 08             	pushl  0x8(%ebp)
c00252c1:	e8 33 fd ff ff       	call   c0024ff9 <block_name>
c00252c6:	83 c4 10             	add    $0x10,%esp
c00252c9:	83 ec 08             	sub    $0x8,%esp
c00252cc:	50                   	push   %eax
c00252cd:	68 a8 fb 02 c0       	push   $0xc002fba8
c00252d2:	e8 27 1f 00 00       	call   c00271fe <printf>
c00252d7:	83 c4 10             	add    $0x10,%esp
c00252da:	eb 22                	jmp    c00252fe <read_partition_table+0xdc>
      else
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c00252dc:	83 ec 0c             	sub    $0xc,%esp
c00252df:	ff 75 08             	pushl  0x8(%ebp)
c00252e2:	e8 12 fd ff ff       	call   c0024ff9 <block_name>
c00252e7:	83 c4 10             	add    $0x10,%esp
c00252ea:	83 ec 04             	sub    $0x4,%esp
c00252ed:	ff 75 0c             	pushl  0xc(%ebp)
c00252f0:	50                   	push   %eax
c00252f1:	68 d0 fb 02 c0       	push   $0xc002fbd0
c00252f6:	e8 03 1f 00 00       	call   c00271fe <printf>
c00252fb:	83 c4 10             	add    $0x10,%esp
                block_name (block), sector);
      free (pt);
c00252fe:	83 ec 0c             	sub    $0xc,%esp
c0025301:	ff 75 f0             	pushl  -0x10(%ebp)
c0025304:	e8 7b e4 ff ff       	call   c0023784 <free>
c0025309:	83 c4 10             	add    $0x10,%esp
      return;
c002530c:	e9 2b 01 00 00       	jmp    c002543c <read_partition_table+0x21a>
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0025311:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025318:	e9 07 01 00 00       	jmp    c0025424 <read_partition_table+0x202>
    {
      struct partition_table_entry *e = &pt->partitions[i];
c002531d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025320:	83 c0 1b             	add    $0x1b,%eax
c0025323:	c1 e0 04             	shl    $0x4,%eax
c0025326:	89 c2                	mov    %eax,%edx
c0025328:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002532b:	01 d0                	add    %edx,%eax
c002532d:	83 c0 0e             	add    $0xe,%eax
c0025330:	89 45 ec             	mov    %eax,-0x14(%ebp)

      if (e->size == 0 || e->type == 0)
c0025333:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025336:	8b 40 0c             	mov    0xc(%eax),%eax
c0025339:	85 c0                	test   %eax,%eax
c002533b:	0f 84 df 00 00 00    	je     c0025420 <read_partition_table+0x1fe>
c0025341:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025344:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0025348:	84 c0                	test   %al,%al
c002534a:	0f 84 d0 00 00 00    	je     c0025420 <read_partition_table+0x1fe>
        {
          /* Ignore empty partition. */
        }
      else if (e->type == 0x05       /* Extended partition. */
c0025350:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025353:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0025357:	3c 05                	cmp    $0x5,%al
c0025359:	74 21                	je     c002537c <read_partition_table+0x15a>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c002535b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002535e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0025362:	3c 0f                	cmp    $0xf,%al
c0025364:	74 16                	je     c002537c <read_partition_table+0x15a>
               || e->type == 0x85    /* Linux extended partition. */
c0025366:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025369:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c002536d:	3c 85                	cmp    $0x85,%al
c002536f:	74 0b                	je     c002537c <read_partition_table+0x15a>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025371:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025374:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0025378:	3c c5                	cmp    $0xc5,%al
c002537a:	75 65                	jne    c00253e1 <read_partition_table+0x1bf>
        {
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c002537c:	83 ec 0c             	sub    $0xc,%esp
c002537f:	ff 75 08             	pushl  0x8(%ebp)
c0025382:	e8 72 fc ff ff       	call   c0024ff9 <block_name>
c0025387:	83 c4 10             	add    $0x10,%esp
c002538a:	83 ec 04             	sub    $0x4,%esp
c002538d:	ff 75 0c             	pushl  0xc(%ebp)
c0025390:	50                   	push   %eax
c0025391:	68 04 fc 02 c0       	push   $0xc002fc04
c0025396:	e8 63 1e 00 00       	call   c00271fe <printf>
c002539b:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c002539e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00253a2:	75 1e                	jne    c00253c2 <read_partition_table+0x1a0>
            read_partition_table (block, e->offset, e->offset, part_nr);
c00253a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00253a7:	8b 50 08             	mov    0x8(%eax),%edx
c00253aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00253ad:	8b 40 08             	mov    0x8(%eax),%eax
c00253b0:	ff 75 14             	pushl  0x14(%ebp)
c00253b3:	52                   	push   %edx
c00253b4:	50                   	push   %eax
c00253b5:	ff 75 08             	pushl  0x8(%ebp)
c00253b8:	e8 65 fe ff ff       	call   c0025222 <read_partition_table>
c00253bd:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c00253c0:	eb 5e                	jmp    c0025420 <read_partition_table+0x1fe>
            read_partition_table (block, e->offset, e->offset, part_nr);
          else
            read_partition_table (block, e->offset + primary_extended_sector,
c00253c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00253c5:	8b 50 08             	mov    0x8(%eax),%edx
c00253c8:	8b 45 10             	mov    0x10(%ebp),%eax
c00253cb:	01 d0                	add    %edx,%eax
c00253cd:	ff 75 14             	pushl  0x14(%ebp)
c00253d0:	ff 75 10             	pushl  0x10(%ebp)
c00253d3:	50                   	push   %eax
c00253d4:	ff 75 08             	pushl  0x8(%ebp)
c00253d7:	e8 46 fe ff ff       	call   c0025222 <read_partition_table>
c00253dc:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c00253df:	eb 3f                	jmp    c0025420 <read_partition_table+0x1fe>
            read_partition_table (block, e->offset + primary_extended_sector,
                                  primary_extended_sector, part_nr);
        }
      else
        {
          ++*part_nr;
c00253e1:	8b 45 14             	mov    0x14(%ebp),%eax
c00253e4:	8b 00                	mov    (%eax),%eax
c00253e6:	8d 50 01             	lea    0x1(%eax),%edx
c00253e9:	8b 45 14             	mov    0x14(%ebp),%eax
c00253ec:	89 10                	mov    %edx,(%eax)

          found_partition (block, e->type, e->offset + sector,
c00253ee:	8b 45 14             	mov    0x14(%ebp),%eax
c00253f1:	8b 08                	mov    (%eax),%ecx
c00253f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00253f6:	8b 50 0c             	mov    0xc(%eax),%edx
c00253f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00253fc:	8b 58 08             	mov    0x8(%eax),%ebx
c00253ff:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025402:	01 c3                	add    %eax,%ebx
c0025404:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025407:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c002540b:	0f b6 c0             	movzbl %al,%eax
c002540e:	83 ec 0c             	sub    $0xc,%esp
c0025411:	51                   	push   %ecx
c0025412:	52                   	push   %edx
c0025413:	53                   	push   %ebx
c0025414:	50                   	push   %eax
c0025415:	ff 75 08             	pushl  0x8(%ebp)
c0025418:	e8 24 00 00 00       	call   c0025441 <found_partition>
c002541d:	83 c4 20             	add    $0x20,%esp
      free (pt);
      return;
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0025420:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0025424:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c0025428:	0f 86 ef fe ff ff    	jbe    c002531d <read_partition_table+0xfb>
          found_partition (block, e->type, e->offset + sector,
                           e->size, *part_nr);
        }
    }

  free (pt);
c002542e:	83 ec 0c             	sub    $0xc,%esp
c0025431:	ff 75 f0             	pushl  -0x10(%ebp)
c0025434:	e8 4b e3 ff ff       	call   c0023784 <free>
c0025439:	83 c4 10             	add    $0x10,%esp
}
c002543c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002543f:	c9                   	leave  
c0025440:	c3                   	ret    

c0025441 <found_partition>:
   if so then add it to the proper element of partitions[]. */
static void
found_partition (struct block *block, uint8_t part_type,
                 block_sector_t start, block_sector_t size,
                 int part_nr)
{
c0025441:	55                   	push   %ebp
c0025442:	89 e5                	mov    %esp,%ebp
c0025444:	56                   	push   %esi
c0025445:	53                   	push   %ebx
c0025446:	81 ec b0 00 00 00    	sub    $0xb0,%esp
c002544c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002544f:	88 85 54 ff ff ff    	mov    %al,-0xac(%ebp)
  if (start >= block_size (block))
c0025455:	83 ec 0c             	sub    $0xc,%esp
c0025458:	ff 75 08             	pushl  0x8(%ebp)
c002545b:	e8 8e fb ff ff       	call   c0024fee <block_size>
c0025460:	83 c4 10             	add    $0x10,%esp
c0025463:	3b 45 10             	cmp    0x10(%ebp),%eax
c0025466:	77 27                	ja     c002548f <found_partition+0x4e>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0025468:	83 ec 0c             	sub    $0xc,%esp
c002546b:	ff 75 08             	pushl  0x8(%ebp)
c002546e:	e8 86 fb ff ff       	call   c0024ff9 <block_name>
c0025473:	83 c4 10             	add    $0x10,%esp
c0025476:	ff 75 10             	pushl  0x10(%ebp)
c0025479:	ff 75 18             	pushl  0x18(%ebp)
c002547c:	50                   	push   %eax
c002547d:	68 2c fc 02 c0       	push   $0xc002fc2c
c0025482:	e8 77 1d 00 00       	call   c00271fe <printf>
c0025487:	83 c4 10             	add    $0x10,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c002548a:	e9 76 01 00 00       	jmp    c0025605 <found_partition+0x1c4>
                 int part_nr)
{
  if (start >= block_size (block))
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
            block_name (block), part_nr, start);
  else if (start + size < start || start + size > block_size (block))
c002548f:	8b 55 10             	mov    0x10(%ebp),%edx
c0025492:	8b 45 14             	mov    0x14(%ebp),%eax
c0025495:	01 d0                	add    %edx,%eax
c0025497:	3b 45 10             	cmp    0x10(%ebp),%eax
c002549a:	72 1b                	jb     c00254b7 <found_partition+0x76>
c002549c:	8b 55 10             	mov    0x10(%ebp),%edx
c002549f:	8b 45 14             	mov    0x14(%ebp),%eax
c00254a2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c00254a5:	83 ec 0c             	sub    $0xc,%esp
c00254a8:	ff 75 08             	pushl  0x8(%ebp)
c00254ab:	e8 3e fb ff ff       	call   c0024fee <block_size>
c00254b0:	83 c4 10             	add    $0x10,%esp
c00254b3:	39 c3                	cmp    %eax,%ebx
c00254b5:	76 42                	jbe    c00254f9 <found_partition+0xb8>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c00254b7:	83 ec 0c             	sub    $0xc,%esp
c00254ba:	ff 75 08             	pushl  0x8(%ebp)
c00254bd:	e8 2c fb ff ff       	call   c0024fee <block_size>
c00254c2:	83 c4 10             	add    $0x10,%esp
c00254c5:	89 c6                	mov    %eax,%esi
c00254c7:	8b 55 10             	mov    0x10(%ebp),%edx
c00254ca:	8b 45 14             	mov    0x14(%ebp),%eax
c00254cd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c00254d0:	83 ec 0c             	sub    $0xc,%esp
c00254d3:	ff 75 08             	pushl  0x8(%ebp)
c00254d6:	e8 1e fb ff ff       	call   c0024ff9 <block_name>
c00254db:	83 c4 10             	add    $0x10,%esp
c00254de:	83 ec 0c             	sub    $0xc,%esp
c00254e1:	56                   	push   %esi
c00254e2:	53                   	push   %ebx
c00254e3:	ff 75 18             	pushl  0x18(%ebp)
c00254e6:	50                   	push   %eax
c00254e7:	68 64 fc 02 c0       	push   $0xc002fc64
c00254ec:	e8 0d 1d 00 00       	call   c00271fe <printf>
c00254f1:	83 c4 20             	add    $0x20,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c00254f4:	e9 0c 01 00 00       	jmp    c0025605 <found_partition+0x1c4>
  else if (start + size < start || start + size > block_size (block))
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
            block_name (block), part_nr, start + size, block_size (block));
  else
    {
      enum block_type type = (part_type == 0x20 ? BLOCK_KERNEL
c00254f9:	80 bd 54 ff ff ff 20 	cmpb   $0x20,-0xac(%ebp)
c0025500:	74 37                	je     c0025539 <found_partition+0xf8>
c0025502:	80 bd 54 ff ff ff 21 	cmpb   $0x21,-0xac(%ebp)
c0025509:	74 27                	je     c0025532 <found_partition+0xf1>
c002550b:	80 bd 54 ff ff ff 22 	cmpb   $0x22,-0xac(%ebp)
c0025512:	74 17                	je     c002552b <found_partition+0xea>
c0025514:	80 bd 54 ff ff ff 23 	cmpb   $0x23,-0xac(%ebp)
c002551b:	75 07                	jne    c0025524 <found_partition+0xe3>
c002551d:	b8 03 00 00 00       	mov    $0x3,%eax
c0025522:	eb 1a                	jmp    c002553e <found_partition+0xfd>
c0025524:	b8 05 00 00 00       	mov    $0x5,%eax
c0025529:	eb 13                	jmp    c002553e <found_partition+0xfd>
c002552b:	b8 02 00 00 00       	mov    $0x2,%eax
c0025530:	eb 0c                	jmp    c002553e <found_partition+0xfd>
c0025532:	b8 01 00 00 00       	mov    $0x1,%eax
c0025537:	eb 05                	jmp    c002553e <found_partition+0xfd>
c0025539:	b8 00 00 00 00       	mov    $0x0,%eax
c002553e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              : BLOCK_FOREIGN);
      struct partition *p;
      char extra_info[128];
      char name[16];

      p = malloc (sizeof *p);
c0025541:	83 ec 0c             	sub    $0xc,%esp
c0025544:	6a 08                	push   $0x8
c0025546:	e8 40 df ff ff       	call   c002348b <malloc>
c002554b:	83 c4 10             	add    $0x10,%esp
c002554e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (p == NULL)
c0025551:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025555:	75 19                	jne    c0025570 <found_partition+0x12f>
        PANIC ("Failed to allocate memory for partition descriptor");
c0025557:	68 98 fc 02 c0       	push   $0xc002fc98
c002555c:	68 fc fc 02 c0       	push   $0xc002fcfc
c0025561:	68 b1 00 00 00       	push   $0xb1
c0025566:	68 8b fb 02 c0       	push   $0xc002fb8b
c002556b:	e8 c1 40 00 00       	call   c0029631 <debug_panic>
      p->block = block;
c0025570:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025573:	8b 55 08             	mov    0x8(%ebp),%edx
c0025576:	89 10                	mov    %edx,(%eax)
      p->start = start;
c0025578:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002557b:	8b 55 10             	mov    0x10(%ebp),%edx
c002557e:	89 50 04             	mov    %edx,0x4(%eax)

      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025581:	83 ec 0c             	sub    $0xc,%esp
c0025584:	ff 75 08             	pushl  0x8(%ebp)
c0025587:	e8 6d fa ff ff       	call   c0024ff9 <block_name>
c002558c:	83 c4 10             	add    $0x10,%esp
c002558f:	83 ec 0c             	sub    $0xc,%esp
c0025592:	ff 75 18             	pushl  0x18(%ebp)
c0025595:	50                   	push   %eax
c0025596:	68 cb fc 02 c0       	push   $0xc002fccb
c002559b:	6a 10                	push   $0x10
c002559d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00255a0:	50                   	push   %eax
c00255a1:	e8 2f 1c 00 00       	call   c00271d5 <snprintf>
c00255a6:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c00255a9:	0f b6 9d 54 ff ff ff 	movzbl -0xac(%ebp),%ebx
c00255b0:	0f b6 85 54 ff ff ff 	movzbl -0xac(%ebp),%eax
c00255b7:	83 ec 0c             	sub    $0xc,%esp
c00255ba:	50                   	push   %eax
c00255bb:	e8 4d 00 00 00       	call   c002560d <partition_type_name>
c00255c0:	83 c4 10             	add    $0x10,%esp
c00255c3:	83 ec 0c             	sub    $0xc,%esp
c00255c6:	53                   	push   %ebx
c00255c7:	50                   	push   %eax
c00255c8:	68 d0 fc 02 c0       	push   $0xc002fcd0
c00255cd:	68 80 00 00 00       	push   $0x80
c00255d2:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c00255d8:	50                   	push   %eax
c00255d9:	e8 f7 1b 00 00       	call   c00271d5 <snprintf>
c00255de:	83 c4 20             	add    $0x20,%esp
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
c00255e1:	83 ec 08             	sub    $0x8,%esp
c00255e4:	ff 75 f0             	pushl  -0x10(%ebp)
c00255e7:	68 80 7c 03 c0       	push   $0xc0037c80
c00255ec:	ff 75 14             	pushl  0x14(%ebp)
c00255ef:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c00255f5:	50                   	push   %eax
c00255f6:	ff 75 f4             	pushl  -0xc(%ebp)
c00255f9:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00255fc:	50                   	push   %eax
c00255fd:	e8 8f fa ff ff       	call   c0025091 <block_register>
c0025602:	83 c4 20             	add    $0x20,%esp
    }
}
c0025605:	90                   	nop
c0025606:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025609:	5b                   	pop    %ebx
c002560a:	5e                   	pop    %esi
c002560b:	5d                   	pop    %ebp
c002560c:	c3                   	ret    

c002560d <partition_type_name>:

/* Returns a human-readable name for the given partition TYPE. */
static const char *
partition_type_name (uint8_t type)
{
c002560d:	55                   	push   %ebp
c002560e:	89 e5                	mov    %esp,%ebp
c0025610:	83 ec 04             	sub    $0x4,%esp
c0025613:	8b 45 08             	mov    0x8(%ebp),%eax
c0025616:	88 45 fc             	mov    %al,-0x4(%ebp)
      [0xfd] = "Linux raid autodetect",
      [0xfe] = "LANstep",
      [0xff] = "BBT",
    };

  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025619:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c002561d:	8b 04 85 a0 7c 03 c0 	mov    -0x3ffc8360(,%eax,4),%eax
c0025624:	85 c0                	test   %eax,%eax
c0025626:	74 0d                	je     c0025635 <partition_type_name+0x28>
c0025628:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c002562c:	8b 04 85 a0 7c 03 c0 	mov    -0x3ffc8360(,%eax,4),%eax
c0025633:	eb 05                	jmp    c002563a <partition_type_name+0x2d>
c0025635:	b8 da fc 02 c0       	mov    $0xc002fcda,%eax
}
c002563a:	c9                   	leave  
c002563b:	c3                   	ret    

c002563c <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c002563c:	55                   	push   %ebp
c002563d:	89 e5                	mov    %esp,%ebp
c002563f:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025642:	8b 45 08             	mov    0x8(%ebp),%eax
c0025645:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_read (p->block, p->start + sector, buffer);
c0025648:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002564b:	8b 50 04             	mov    0x4(%eax),%edx
c002564e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025651:	01 c2                	add    %eax,%edx
c0025653:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025656:	8b 00                	mov    (%eax),%eax
c0025658:	83 ec 04             	sub    $0x4,%esp
c002565b:	ff 75 10             	pushl  0x10(%ebp)
c002565e:	52                   	push   %edx
c002565f:	50                   	push   %eax
c0025660:	e8 be f8 ff ff       	call   c0024f23 <block_read>
c0025665:	83 c4 10             	add    $0x10,%esp
}
c0025668:	90                   	nop
c0025669:	c9                   	leave  
c002566a:	c3                   	ret    

c002566b <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c002566b:	55                   	push   %ebp
c002566c:	89 e5                	mov    %esp,%ebp
c002566e:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025671:	8b 45 08             	mov    0x8(%ebp),%eax
c0025674:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_write (p->block, p->start + sector, buffer);
c0025677:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002567a:	8b 50 04             	mov    0x4(%eax),%edx
c002567d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025680:	01 c2                	add    %eax,%edx
c0025682:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025685:	8b 00                	mov    (%eax),%eax
c0025687:	83 ec 04             	sub    $0x4,%esp
c002568a:	ff 75 10             	pushl  0x10(%ebp)
c002568d:	52                   	push   %edx
c002568e:	50                   	push   %eax
c002568f:	e8 de f8 ff ff       	call   c0024f72 <block_write>
c0025694:	83 c4 10             	add    $0x10,%esp
}
c0025697:	90                   	nop
c0025698:	c9                   	leave  
c0025699:	c3                   	ret    

c002569a <isspace>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
c002569a:	55                   	push   %ebp
c002569b:	89 e5                	mov    %esp,%ebp
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
c002569d:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c00256a1:	74 1e                	je     c00256c1 <isspace+0x27>
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
  return (c == ' ' || c == '\f' || c == '\n'
c00256a3:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c00256a7:	74 18                	je     c00256c1 <isspace+0x27>
c00256a9:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c00256ad:	74 12                	je     c00256c1 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c00256af:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c00256b3:	74 0c                	je     c00256c1 <isspace+0x27>
c00256b5:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c00256b9:	74 06                	je     c00256c1 <isspace+0x27>
c00256bb:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c00256bf:	75 07                	jne    c00256c8 <isspace+0x2e>
c00256c1:	b8 01 00 00 00       	mov    $0x1,%eax
c00256c6:	eb 05                	jmp    c00256cd <isspace+0x33>
c00256c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00256cd:	5d                   	pop    %ebp
c00256ce:	c3                   	ret    

c00256cf <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c00256cf:	55                   	push   %ebp
c00256d0:	89 e5                	mov    %esp,%ebp
c00256d2:	83 ec 14             	sub    $0x14,%esp
c00256d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00256d8:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00256dc:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00256e0:	89 c2                	mov    %eax,%edx
c00256e2:	ec                   	in     (%dx),%al
c00256e3:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00256e6:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c00256ea:	c9                   	leave  
c00256eb:	c3                   	ret    

c00256ec <insw>:

/* Reads CNT 16-bit (halfword) units from PORT, one after
   another, and stores them into the buffer starting at ADDR. */
static inline void
insw (uint16_t port, void *addr, size_t cnt)
{
c00256ec:	55                   	push   %ebp
c00256ed:	89 e5                	mov    %esp,%ebp
c00256ef:	57                   	push   %edi
c00256f0:	53                   	push   %ebx
c00256f1:	83 ec 04             	sub    $0x4,%esp
c00256f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00256f7:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2a] "INS". */
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c00256fb:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c00256ff:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0025702:	8b 45 10             	mov    0x10(%ebp),%eax
c0025705:	89 cb                	mov    %ecx,%ebx
c0025707:	89 df                	mov    %ebx,%edi
c0025709:	89 c1                	mov    %eax,%ecx
c002570b:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c002570e:	89 c8                	mov    %ecx,%eax
c0025710:	89 fb                	mov    %edi,%ebx
c0025712:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0025715:	89 45 10             	mov    %eax,0x10(%ebp)
}
c0025718:	90                   	nop
c0025719:	83 c4 04             	add    $0x4,%esp
c002571c:	5b                   	pop    %ebx
c002571d:	5f                   	pop    %edi
c002571e:	5d                   	pop    %ebp
c002571f:	c3                   	ret    

c0025720 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0025720:	55                   	push   %ebp
c0025721:	89 e5                	mov    %esp,%ebp
c0025723:	83 ec 08             	sub    $0x8,%esp
c0025726:	8b 55 08             	mov    0x8(%ebp),%edx
c0025729:	8b 45 0c             	mov    0xc(%ebp),%eax
c002572c:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0025730:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025733:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0025737:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c002573b:	ee                   	out    %al,(%dx)
}
c002573c:	90                   	nop
c002573d:	c9                   	leave  
c002573e:	c3                   	ret    

c002573f <outsw>:

/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
c002573f:	55                   	push   %ebp
c0025740:	89 e5                	mov    %esp,%ebp
c0025742:	56                   	push   %esi
c0025743:	53                   	push   %ebx
c0025744:	83 ec 04             	sub    $0x4,%esp
c0025747:	8b 45 08             	mov    0x8(%ebp),%eax
c002574a:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c002574e:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c0025752:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0025755:	8b 45 10             	mov    0x10(%ebp),%eax
c0025758:	89 cb                	mov    %ecx,%ebx
c002575a:	89 de                	mov    %ebx,%esi
c002575c:	89 c1                	mov    %eax,%ecx
c002575e:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c0025761:	89 c8                	mov    %ecx,%eax
c0025763:	89 f3                	mov    %esi,%ebx
c0025765:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0025768:	89 45 10             	mov    %eax,0x10(%ebp)
}
c002576b:	90                   	nop
c002576c:	83 c4 04             	add    $0x4,%esp
c002576f:	5b                   	pop    %ebx
c0025770:	5e                   	pop    %esi
c0025771:	5d                   	pop    %ebp
c0025772:	c3                   	ret    

c0025773 <ide_init>:
static void interrupt_handler (struct intr_frame *);

/* Initialize the disk subsystem and detect disks. */
void
ide_init (void) 
{
c0025773:	55                   	push   %ebp
c0025774:	89 e5                	mov    %esp,%ebp
c0025776:	83 ec 18             	sub    $0x18,%esp
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c0025779:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025780:	e9 ae 01 00 00       	jmp    c0025933 <ide_init+0x1c0>
    {
      struct channel *c = &channels[chan_no];
c0025785:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025788:	6b c0 64             	imul   $0x64,%eax,%eax
c002578b:	05 80 99 03 c0       	add    $0xc0039980,%eax
c0025790:	89 45 ec             	mov    %eax,-0x14(%ebp)
      int dev_no;

      /* Initialize channel. */
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025793:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025796:	ff 75 f4             	pushl  -0xc(%ebp)
c0025799:	68 d0 01 03 c0       	push   $0xc00301d0
c002579e:	6a 08                	push   $0x8
c00257a0:	50                   	push   %eax
c00257a1:	e8 2f 1a 00 00       	call   c00271d5 <snprintf>
c00257a6:	83 c4 10             	add    $0x10,%esp
      switch (chan_no) 
c00257a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00257ac:	85 c0                	test   %eax,%eax
c00257ae:	74 07                	je     c00257b7 <ide_init+0x44>
c00257b0:	83 f8 01             	cmp    $0x1,%eax
c00257b3:	74 14                	je     c00257c9 <ide_init+0x56>
c00257b5:	eb 24                	jmp    c00257db <ide_init+0x68>
        {
        case 0:
          c->reg_base = 0x1f0;
c00257b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00257ba:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
          c->irq = 14 + 0x20;
c00257c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00257c3:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
          break;
c00257c7:	eb 28                	jmp    c00257f1 <ide_init+0x7e>
        case 1:
          c->reg_base = 0x170;
c00257c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00257cc:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
          c->irq = 15 + 0x20;
c00257d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00257d5:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
          break;
c00257d9:	eb 16                	jmp    c00257f1 <ide_init+0x7e>
        default:
          NOT_REACHED ();
c00257db:	68 d8 01 03 c0       	push   $0xc00301d8
c00257e0:	68 2c 03 03 c0       	push   $0xc003032c
c00257e5:	6a 7c                	push   $0x7c
c00257e7:	68 fa 01 03 c0       	push   $0xc00301fa
c00257ec:	e8 40 3e 00 00       	call   c0029631 <debug_panic>
        }
      lock_init (&c->lock);
c00257f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00257f4:	83 c0 0c             	add    $0xc,%eax
c00257f7:	83 ec 0c             	sub    $0xc,%esp
c00257fa:	50                   	push   %eax
c00257fb:	e8 75 d2 ff ff       	call   c0022a75 <lock_init>
c0025800:	83 c4 10             	add    $0x10,%esp
      c->expecting_interrupt = false;
c0025803:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025806:	c6 40 24 00          	movb   $0x0,0x24(%eax)
      sema_init (&c->completion_wait, 0);
c002580a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002580d:	83 c0 28             	add    $0x28,%eax
c0025810:	83 ec 08             	sub    $0x8,%esp
c0025813:	6a 00                	push   $0x0
c0025815:	50                   	push   %eax
c0025816:	e8 9f cf ff ff       	call   c00227ba <sema_init>
c002581b:	83 c4 10             	add    $0x10,%esp
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c002581e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025825:	eb 5a                	jmp    c0025881 <ide_init+0x10e>
        {
          struct ata_disk *d = &c->devices[dev_no];
c0025827:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002582a:	89 d0                	mov    %edx,%eax
c002582c:	c1 e0 02             	shl    $0x2,%eax
c002582f:	01 d0                	add    %edx,%eax
c0025831:	c1 e0 02             	shl    $0x2,%eax
c0025834:	8d 50 30             	lea    0x30(%eax),%edx
c0025837:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002583a:	01 d0                	add    %edx,%eax
c002583c:	83 c0 0c             	add    $0xc,%eax
c002583f:	89 45 e8             	mov    %eax,-0x18(%ebp)
          snprintf (d->name, sizeof d->name,
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
c0025842:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025845:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0025848:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002584b:	01 d0                	add    %edx,%eax
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        {
          struct ata_disk *d = &c->devices[dev_no];
          snprintf (d->name, sizeof d->name,
c002584d:	8d 50 61             	lea    0x61(%eax),%edx
c0025850:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025853:	52                   	push   %edx
c0025854:	68 0e 02 03 c0       	push   $0xc003020e
c0025859:	6a 08                	push   $0x8
c002585b:	50                   	push   %eax
c002585c:	e8 74 19 00 00       	call   c00271d5 <snprintf>
c0025861:	83 c4 10             	add    $0x10,%esp
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
          d->channel = c;
c0025864:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025867:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002586a:	89 50 08             	mov    %edx,0x8(%eax)
          d->dev_no = dev_no;
c002586d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025870:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025873:	89 50 0c             	mov    %edx,0xc(%eax)
          d->is_ata = false;
c0025876:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025879:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      lock_init (&c->lock);
      c->expecting_interrupt = false;
      sema_init (&c->completion_wait, 0);
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c002587d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0025881:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c0025885:	7e a0                	jle    c0025827 <ide_init+0xb4>
          d->dev_no = dev_no;
          d->is_ata = false;
        }

      /* Register interrupt handler. */
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0025887:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002588a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002588d:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c0025891:	0f b6 c0             	movzbl %al,%eax
c0025894:	83 ec 04             	sub    $0x4,%esp
c0025897:	52                   	push   %edx
c0025898:	68 e1 63 02 c0       	push   $0xc00263e1
c002589d:	50                   	push   %eax
c002589e:	e8 2c bd ff ff       	call   c00215cf <intr_register_ext>
c00258a3:	83 c4 10             	add    $0x10,%esp

      /* Reset hardware. */
      reset_channel (c);
c00258a6:	83 ec 0c             	sub    $0xc,%esp
c00258a9:	ff 75 ec             	pushl  -0x14(%ebp)
c00258ac:	e8 8f 00 00 00       	call   c0025940 <reset_channel>
c00258b1:	83 c4 10             	add    $0x10,%esp

      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
c00258b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00258b7:	83 c0 3c             	add    $0x3c,%eax
c00258ba:	83 ec 0c             	sub    $0xc,%esp
c00258bd:	50                   	push   %eax
c00258be:	e8 09 03 00 00       	call   c0025bcc <check_device_type>
c00258c3:	83 c4 10             	add    $0x10,%esp
c00258c6:	84 c0                	test   %al,%al
c00258c8:	74 12                	je     c00258dc <ide_init+0x169>
        check_device_type (&c->devices[1]);
c00258ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00258cd:	83 c0 50             	add    $0x50,%eax
c00258d0:	83 ec 0c             	sub    $0xc,%esp
c00258d3:	50                   	push   %eax
c00258d4:	e8 f3 02 00 00       	call   c0025bcc <check_device_type>
c00258d9:	83 c4 10             	add    $0x10,%esp

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c00258dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00258e3:	eb 44                	jmp    c0025929 <ide_init+0x1b6>
        if (c->devices[dev_no].is_ata)
c00258e5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c00258e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00258eb:	89 d0                	mov    %edx,%eax
c00258ed:	c1 e0 02             	shl    $0x2,%eax
c00258f0:	01 d0                	add    %edx,%eax
c00258f2:	c1 e0 02             	shl    $0x2,%eax
c00258f5:	01 c8                	add    %ecx,%eax
c00258f7:	83 c0 4c             	add    $0x4c,%eax
c00258fa:	0f b6 00             	movzbl (%eax),%eax
c00258fd:	84 c0                	test   %al,%al
c00258ff:	74 24                	je     c0025925 <ide_init+0x1b2>
          identify_ata_device (&c->devices[dev_no]);
c0025901:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025904:	89 d0                	mov    %edx,%eax
c0025906:	c1 e0 02             	shl    $0x2,%eax
c0025909:	01 d0                	add    %edx,%eax
c002590b:	c1 e0 02             	shl    $0x2,%eax
c002590e:	8d 50 30             	lea    0x30(%eax),%edx
c0025911:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025914:	01 d0                	add    %edx,%eax
c0025916:	83 c0 0c             	add    $0xc,%eax
c0025919:	83 ec 0c             	sub    $0xc,%esp
c002591c:	50                   	push   %eax
c002591d:	e8 a5 03 00 00       	call   c0025cc7 <identify_ata_device>
c0025922:	83 c4 10             	add    $0x10,%esp
      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
        check_device_type (&c->devices[1]);

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025925:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0025929:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c002592d:	7e b6                	jle    c00258e5 <ide_init+0x172>
void
ide_init (void) 
{
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c002592f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0025933:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025937:	0f 86 48 fe ff ff    	jbe    c0025785 <ide_init+0x12>
      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        if (c->devices[dev_no].is_ata)
          identify_ata_device (&c->devices[dev_no]);
    }
}
c002593d:	90                   	nop
c002593e:	c9                   	leave  
c002593f:	c3                   	ret    

c0025940 <reset_channel>:

/* Resets an ATA channel and waits for any devices present on it
   to finish the reset. */
static void
reset_channel (struct channel *c) 
{
c0025940:	55                   	push   %ebp
c0025941:	89 e5                	mov    %esp,%ebp
c0025943:	83 ec 18             	sub    $0x18,%esp
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025946:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002594d:	e9 2b 01 00 00       	jmp    c0025a7d <reset_channel+0x13d>
    {
      struct ata_disk *d = &c->devices[dev_no];
c0025952:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025955:	89 d0                	mov    %edx,%eax
c0025957:	c1 e0 02             	shl    $0x2,%eax
c002595a:	01 d0                	add    %edx,%eax
c002595c:	c1 e0 02             	shl    $0x2,%eax
c002595f:	8d 50 30             	lea    0x30(%eax),%edx
c0025962:	8b 45 08             	mov    0x8(%ebp),%eax
c0025965:	01 d0                	add    %edx,%eax
c0025967:	83 c0 0c             	add    $0xc,%eax
c002596a:	89 45 ec             	mov    %eax,-0x14(%ebp)

      select_device (d);
c002596d:	83 ec 0c             	sub    $0xc,%esp
c0025970:	ff 75 ec             	pushl  -0x14(%ebp)
c0025973:	e8 cd 09 00 00       	call   c0026345 <select_device>
c0025978:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c002597b:	8b 45 08             	mov    0x8(%ebp),%eax
c002597e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025982:	83 c0 02             	add    $0x2,%eax
c0025985:	0f b7 c0             	movzwl %ax,%eax
c0025988:	83 ec 08             	sub    $0x8,%esp
c002598b:	6a 55                	push   $0x55
c002598d:	50                   	push   %eax
c002598e:	e8 8d fd ff ff       	call   c0025720 <outb>
c0025993:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025996:	8b 45 08             	mov    0x8(%ebp),%eax
c0025999:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002599d:	83 c0 03             	add    $0x3,%eax
c00259a0:	0f b7 c0             	movzwl %ax,%eax
c00259a3:	83 ec 08             	sub    $0x8,%esp
c00259a6:	68 aa 00 00 00       	push   $0xaa
c00259ab:	50                   	push   %eax
c00259ac:	e8 6f fd ff ff       	call   c0025720 <outb>
c00259b1:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0xaa);
c00259b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00259b7:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00259bb:	83 c0 02             	add    $0x2,%eax
c00259be:	0f b7 c0             	movzwl %ax,%eax
c00259c1:	83 ec 08             	sub    $0x8,%esp
c00259c4:	68 aa 00 00 00       	push   $0xaa
c00259c9:	50                   	push   %eax
c00259ca:	e8 51 fd ff ff       	call   c0025720 <outb>
c00259cf:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0x55);
c00259d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00259d5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00259d9:	83 c0 03             	add    $0x3,%eax
c00259dc:	0f b7 c0             	movzwl %ax,%eax
c00259df:	83 ec 08             	sub    $0x8,%esp
c00259e2:	6a 55                	push   $0x55
c00259e4:	50                   	push   %eax
c00259e5:	e8 36 fd ff ff       	call   c0025720 <outb>
c00259ea:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c00259ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00259f0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00259f4:	83 c0 02             	add    $0x2,%eax
c00259f7:	0f b7 c0             	movzwl %ax,%eax
c00259fa:	83 ec 08             	sub    $0x8,%esp
c00259fd:	6a 55                	push   $0x55
c00259ff:	50                   	push   %eax
c0025a00:	e8 1b fd ff ff       	call   c0025720 <outb>
c0025a05:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025a08:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a0b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025a0f:	83 c0 03             	add    $0x3,%eax
c0025a12:	0f b7 c0             	movzwl %ax,%eax
c0025a15:	83 ec 08             	sub    $0x8,%esp
c0025a18:	68 aa 00 00 00       	push   $0xaa
c0025a1d:	50                   	push   %eax
c0025a1e:	e8 fd fc ff ff       	call   c0025720 <outb>
c0025a23:	83 c4 10             	add    $0x10,%esp

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025a26:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a29:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025a2d:	83 c0 02             	add    $0x2,%eax
c0025a30:	0f b7 c0             	movzwl %ax,%eax
c0025a33:	83 ec 0c             	sub    $0xc,%esp
c0025a36:	50                   	push   %eax
c0025a37:	e8 93 fc ff ff       	call   c00256cf <inb>
c0025a3c:	83 c4 10             	add    $0x10,%esp
                         && inb (reg_lbal (c)) == 0xaa);
c0025a3f:	3c 55                	cmp    $0x55,%al
c0025a41:	75 24                	jne    c0025a67 <reset_channel+0x127>
c0025a43:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a46:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025a4a:	83 c0 03             	add    $0x3,%eax
c0025a4d:	0f b7 c0             	movzwl %ax,%eax
c0025a50:	83 ec 0c             	sub    $0xc,%esp
c0025a53:	50                   	push   %eax
c0025a54:	e8 76 fc ff ff       	call   c00256cf <inb>
c0025a59:	83 c4 10             	add    $0x10,%esp
c0025a5c:	3c aa                	cmp    $0xaa,%al
c0025a5e:	75 07                	jne    c0025a67 <reset_channel+0x127>
c0025a60:	b8 01 00 00 00       	mov    $0x1,%eax
c0025a65:	eb 05                	jmp    c0025a6c <reset_channel+0x12c>
c0025a67:	b8 00 00 00 00       	mov    $0x0,%eax
c0025a6c:	83 e0 01             	and    $0x1,%eax
      outb (reg_lbal (c), 0x55);

      outb (reg_nsect (c), 0x55);
      outb (reg_lbal (c), 0xaa);

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025a6f:	8d 4d ea             	lea    -0x16(%ebp),%ecx
c0025a72:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025a75:	01 ca                	add    %ecx,%edx
c0025a77:	88 02                	mov    %al,(%edx)
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025a79:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0025a7d:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025a81:	0f 8e cb fe ff ff    	jle    c0025952 <reset_channel+0x12>
                         && inb (reg_lbal (c)) == 0xaa);
    }

  /* Issue soft reset sequence, which selects device 0 as a side effect.
     Also enable interrupts. */
  outb (reg_ctl (c), 0);
c0025a87:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a8a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025a8e:	66 05 06 02          	add    $0x206,%ax
c0025a92:	0f b7 c0             	movzwl %ax,%eax
c0025a95:	83 ec 08             	sub    $0x8,%esp
c0025a98:	6a 00                	push   $0x0
c0025a9a:	50                   	push   %eax
c0025a9b:	e8 80 fc ff ff       	call   c0025720 <outb>
c0025aa0:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0025aa3:	83 ec 08             	sub    $0x8,%esp
c0025aa6:	6a 00                	push   $0x0
c0025aa8:	6a 0a                	push   $0xa
c0025aaa:	e8 0d e3 ff ff       	call   c0023dbc <timer_usleep>
c0025aaf:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), CTL_SRST);
c0025ab2:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ab5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025ab9:	66 05 06 02          	add    $0x206,%ax
c0025abd:	0f b7 c0             	movzwl %ax,%eax
c0025ac0:	83 ec 08             	sub    $0x8,%esp
c0025ac3:	6a 04                	push   $0x4
c0025ac5:	50                   	push   %eax
c0025ac6:	e8 55 fc ff ff       	call   c0025720 <outb>
c0025acb:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0025ace:	83 ec 08             	sub    $0x8,%esp
c0025ad1:	6a 00                	push   $0x0
c0025ad3:	6a 0a                	push   $0xa
c0025ad5:	e8 e2 e2 ff ff       	call   c0023dbc <timer_usleep>
c0025ada:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), 0);
c0025add:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ae0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025ae4:	66 05 06 02          	add    $0x206,%ax
c0025ae8:	0f b7 c0             	movzwl %ax,%eax
c0025aeb:	83 ec 08             	sub    $0x8,%esp
c0025aee:	6a 00                	push   $0x0
c0025af0:	50                   	push   %eax
c0025af1:	e8 2a fc ff ff       	call   c0025720 <outb>
c0025af6:	83 c4 10             	add    $0x10,%esp

  timer_msleep (150);
c0025af9:	83 ec 08             	sub    $0x8,%esp
c0025afc:	6a 00                	push   $0x0
c0025afe:	68 96 00 00 00       	push   $0x96
c0025b03:	e8 89 e2 ff ff       	call   c0023d91 <timer_msleep>
c0025b08:	83 c4 10             	add    $0x10,%esp

  /* Wait for device 0 to clear BSY. */
  if (present[0]) 
c0025b0b:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
c0025b0f:	84 c0                	test   %al,%al
c0025b11:	74 24                	je     c0025b37 <reset_channel+0x1f7>
    {
      select_device (&c->devices[0]);
c0025b13:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b16:	83 c0 3c             	add    $0x3c,%eax
c0025b19:	83 ec 0c             	sub    $0xc,%esp
c0025b1c:	50                   	push   %eax
c0025b1d:	e8 23 08 00 00       	call   c0026345 <select_device>
c0025b22:	83 c4 10             	add    $0x10,%esp
      wait_while_busy (&c->devices[0]); 
c0025b25:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b28:	83 c0 3c             	add    $0x3c,%eax
c0025b2b:	83 ec 0c             	sub    $0xc,%esp
c0025b2e:	50                   	push   %eax
c0025b2f:	e8 44 07 00 00       	call   c0026278 <wait_while_busy>
c0025b34:	83 c4 10             	add    $0x10,%esp
    }

  /* Wait for device 1 to clear BSY. */
  if (present[1])
c0025b37:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0025b3b:	84 c0                	test   %al,%al
c0025b3d:	0f 84 86 00 00 00    	je     c0025bc9 <reset_channel+0x289>
    {
      int i;

      select_device (&c->devices[1]);
c0025b43:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b46:	83 c0 50             	add    $0x50,%eax
c0025b49:	83 ec 0c             	sub    $0xc,%esp
c0025b4c:	50                   	push   %eax
c0025b4d:	e8 f3 07 00 00       	call   c0026345 <select_device>
c0025b52:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c0025b55:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025b5c:	eb 4d                	jmp    c0025bab <reset_channel+0x26b>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0025b5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b61:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025b65:	83 c0 02             	add    $0x2,%eax
c0025b68:	0f b7 c0             	movzwl %ax,%eax
c0025b6b:	83 ec 0c             	sub    $0xc,%esp
c0025b6e:	50                   	push   %eax
c0025b6f:	e8 5b fb ff ff       	call   c00256cf <inb>
c0025b74:	83 c4 10             	add    $0x10,%esp
c0025b77:	3c 01                	cmp    $0x1,%al
c0025b79:	75 1d                	jne    c0025b98 <reset_channel+0x258>
c0025b7b:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b7e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025b82:	83 c0 03             	add    $0x3,%eax
c0025b85:	0f b7 c0             	movzwl %ax,%eax
c0025b88:	83 ec 0c             	sub    $0xc,%esp
c0025b8b:	50                   	push   %eax
c0025b8c:	e8 3e fb ff ff       	call   c00256cf <inb>
c0025b91:	83 c4 10             	add    $0x10,%esp
c0025b94:	3c 01                	cmp    $0x1,%al
c0025b96:	74 1e                	je     c0025bb6 <reset_channel+0x276>
            break;
          timer_msleep (10);
c0025b98:	83 ec 08             	sub    $0x8,%esp
c0025b9b:	6a 00                	push   $0x0
c0025b9d:	6a 0a                	push   $0xa
c0025b9f:	e8 ed e1 ff ff       	call   c0023d91 <timer_msleep>
c0025ba4:	83 c4 10             	add    $0x10,%esp
  if (present[1])
    {
      int i;

      select_device (&c->devices[1]);
      for (i = 0; i < 3000; i++) 
c0025ba7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0025bab:	81 7d f0 b7 0b 00 00 	cmpl   $0xbb7,-0x10(%ebp)
c0025bb2:	7e aa                	jle    c0025b5e <reset_channel+0x21e>
c0025bb4:	eb 01                	jmp    c0025bb7 <reset_channel+0x277>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
            break;
c0025bb6:	90                   	nop
          timer_msleep (10);
        }
      wait_while_busy (&c->devices[1]);
c0025bb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0025bba:	83 c0 50             	add    $0x50,%eax
c0025bbd:	83 ec 0c             	sub    $0xc,%esp
c0025bc0:	50                   	push   %eax
c0025bc1:	e8 b2 06 00 00       	call   c0026278 <wait_while_busy>
c0025bc6:	83 c4 10             	add    $0x10,%esp
    }
}
c0025bc9:	90                   	nop
c0025bca:	c9                   	leave  
c0025bcb:	c3                   	ret    

c0025bcc <check_device_type>:
   if it's possible that a slave (device 1) exists on this
   channel.  If D is device 1 (slave), the return value is not
   meaningful. */
static bool
check_device_type (struct ata_disk *d) 
{
c0025bcc:	55                   	push   %ebp
c0025bcd:	89 e5                	mov    %esp,%ebp
c0025bcf:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0025bd2:	8b 45 08             	mov    0x8(%ebp),%eax
c0025bd5:	8b 40 08             	mov    0x8(%eax),%eax
c0025bd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint8_t error, lbam, lbah, status;

  select_device (d);
c0025bdb:	83 ec 0c             	sub    $0xc,%esp
c0025bde:	ff 75 08             	pushl  0x8(%ebp)
c0025be1:	e8 5f 07 00 00       	call   c0026345 <select_device>
c0025be6:	83 c4 10             	add    $0x10,%esp

  error = inb (reg_error (c));
c0025be9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025bec:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025bf0:	83 c0 01             	add    $0x1,%eax
c0025bf3:	0f b7 c0             	movzwl %ax,%eax
c0025bf6:	83 ec 0c             	sub    $0xc,%esp
c0025bf9:	50                   	push   %eax
c0025bfa:	e8 d0 fa ff ff       	call   c00256cf <inb>
c0025bff:	83 c4 10             	add    $0x10,%esp
c0025c02:	88 45 f3             	mov    %al,-0xd(%ebp)
  lbam = inb (reg_lbam (c));
c0025c05:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c08:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025c0c:	83 c0 04             	add    $0x4,%eax
c0025c0f:	0f b7 c0             	movzwl %ax,%eax
c0025c12:	83 ec 0c             	sub    $0xc,%esp
c0025c15:	50                   	push   %eax
c0025c16:	e8 b4 fa ff ff       	call   c00256cf <inb>
c0025c1b:	83 c4 10             	add    $0x10,%esp
c0025c1e:	88 45 f2             	mov    %al,-0xe(%ebp)
  lbah = inb (reg_lbah (c));
c0025c21:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c24:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025c28:	83 c0 05             	add    $0x5,%eax
c0025c2b:	0f b7 c0             	movzwl %ax,%eax
c0025c2e:	83 ec 0c             	sub    $0xc,%esp
c0025c31:	50                   	push   %eax
c0025c32:	e8 98 fa ff ff       	call   c00256cf <inb>
c0025c37:	83 c4 10             	add    $0x10,%esp
c0025c3a:	88 45 f1             	mov    %al,-0xf(%ebp)
  status = inb (reg_status (c));
c0025c3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c40:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025c44:	83 c0 07             	add    $0x7,%eax
c0025c47:	0f b7 c0             	movzwl %ax,%eax
c0025c4a:	83 ec 0c             	sub    $0xc,%esp
c0025c4d:	50                   	push   %eax
c0025c4e:	e8 7c fa ff ff       	call   c00256cf <inb>
c0025c53:	83 c4 10             	add    $0x10,%esp
c0025c56:	88 45 f0             	mov    %al,-0x10(%ebp)

  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025c59:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
c0025c5d:	74 11                	je     c0025c70 <check_device_type+0xa4>
c0025c5f:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0025c63:	75 1e                	jne    c0025c83 <check_device_type+0xb7>
c0025c65:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c68:	8b 40 0c             	mov    0xc(%eax),%eax
c0025c6b:	83 f8 01             	cmp    $0x1,%eax
c0025c6e:	74 13                	je     c0025c83 <check_device_type+0xb7>
      || (status & STA_DRDY) == 0
c0025c70:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0025c74:	83 e0 40             	and    $0x40,%eax
c0025c77:	85 c0                	test   %eax,%eax
c0025c79:	74 08                	je     c0025c83 <check_device_type+0xb7>
      || (status & STA_BSY) != 0)
c0025c7b:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0025c7f:	84 c0                	test   %al,%al
c0025c81:	79 10                	jns    c0025c93 <check_device_type+0xc7>
    {
      d->is_ata = false;
c0025c83:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c86:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return error != 0x81;      
c0025c8a:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0025c8e:	0f 95 c0             	setne  %al
c0025c91:	eb 32                	jmp    c0025cc5 <check_device_type+0xf9>
    }
  else 
    {
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025c93:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c0025c97:	75 06                	jne    c0025c9f <check_device_type+0xd3>
c0025c99:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c0025c9d:	74 0c                	je     c0025cab <check_device_type+0xdf>
c0025c9f:	80 7d f2 3c          	cmpb   $0x3c,-0xe(%ebp)
c0025ca3:	75 0d                	jne    c0025cb2 <check_device_type+0xe6>
c0025ca5:	80 7d f1 c3          	cmpb   $0xc3,-0xf(%ebp)
c0025ca9:	75 07                	jne    c0025cb2 <check_device_type+0xe6>
c0025cab:	b8 01 00 00 00       	mov    $0x1,%eax
c0025cb0:	eb 05                	jmp    c0025cb7 <check_device_type+0xeb>
c0025cb2:	b8 00 00 00 00       	mov    $0x0,%eax
c0025cb7:	83 e0 01             	and    $0x1,%eax
c0025cba:	8b 55 08             	mov    0x8(%ebp),%edx
c0025cbd:	88 42 10             	mov    %al,0x10(%edx)
      return true; 
c0025cc0:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
c0025cc5:	c9                   	leave  
c0025cc6:	c3                   	ret    

c0025cc7 <identify_ata_device>:
/* Sends an IDENTIFY DEVICE command to disk D and reads the
   response.  Registers the disk with the block device
   layer. */
static void
identify_ata_device (struct ata_disk *d) 
{
c0025cc7:	55                   	push   %ebp
c0025cc8:	89 e5                	mov    %esp,%ebp
c0025cca:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
  struct channel *c = d->channel;
c0025cd0:	8b 45 08             	mov    0x8(%ebp),%eax
c0025cd3:	8b 40 08             	mov    0x8(%eax),%eax
c0025cd6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_sector_t capacity;
  char *model, *serial;
  char extra_info[128];
  struct block *block;

  ASSERT (d->is_ata);
c0025cd9:	8b 45 08             	mov    0x8(%ebp),%eax
c0025cdc:	0f b6 40 10          	movzbl 0x10(%eax),%eax
c0025ce0:	84 c0                	test   %al,%al
c0025ce2:	75 21                	jne    c0025d05 <identify_ata_device+0x3e>
c0025ce4:	83 ec 0c             	sub    $0xc,%esp
c0025ce7:	68 13 02 03 c0       	push   $0xc0030213
c0025cec:	68 1d 02 03 c0       	push   $0xc003021d
c0025cf1:	68 38 03 03 c0       	push   $0xc0030338
c0025cf6:	68 0d 01 00 00       	push   $0x10d
c0025cfb:	68 fa 01 03 c0       	push   $0xc00301fa
c0025d00:	e8 2c 39 00 00       	call   c0029631 <debug_panic>

  /* Send the IDENTIFY DEVICE command, wait for an interrupt
     indicating the device's response is ready, and read the data
     into our buffer. */
  select_device_wait (d);
c0025d05:	83 ec 0c             	sub    $0xc,%esp
c0025d08:	ff 75 08             	pushl  0x8(%ebp)
c0025d0b:	e8 9e 06 00 00       	call   c00263ae <select_device_wait>
c0025d10:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0025d13:	83 ec 08             	sub    $0x8,%esp
c0025d16:	68 ec 00 00 00       	push   $0xec
c0025d1b:	ff 75 f4             	pushl  -0xc(%ebp)
c0025d1e:	e8 4b 04 00 00       	call   c002616e <issue_pio_command>
c0025d23:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0025d26:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025d29:	83 c0 28             	add    $0x28,%eax
c0025d2c:	83 ec 0c             	sub    $0xc,%esp
c0025d2f:	50                   	push   %eax
c0025d30:	e8 cc ca ff ff       	call   c0022801 <sema_down>
c0025d35:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025d38:	83 ec 0c             	sub    $0xc,%esp
c0025d3b:	ff 75 08             	pushl  0x8(%ebp)
c0025d3e:	e8 35 05 00 00       	call   c0026278 <wait_while_busy>
c0025d43:	83 c4 10             	add    $0x10,%esp
c0025d46:	83 f0 01             	xor    $0x1,%eax
c0025d49:	84 c0                	test   %al,%al
c0025d4b:	74 0c                	je     c0025d59 <identify_ata_device+0x92>
    {
      d->is_ata = false;
c0025d4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d50:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0025d54:	e9 fb 00 00 00       	jmp    c0025e54 <identify_ata_device+0x18d>
    }
  input_sector (c, id);
c0025d59:	83 ec 08             	sub    $0x8,%esp
c0025d5c:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025d62:	50                   	push   %eax
c0025d63:	ff 75 f4             	pushl  -0xc(%ebp)
c0025d66:	e8 62 04 00 00       	call   c00261cd <input_sector>
c0025d6b:	83 c4 10             	add    $0x10,%esp

  /* Calculate capacity.
     Read model name and serial number. */
  capacity = *(uint32_t *) &id[60 * 2];
c0025d6e:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025d74:	83 c0 78             	add    $0x78,%eax
c0025d77:	8b 00                	mov    (%eax),%eax
c0025d79:	89 45 f0             	mov    %eax,-0x10(%ebp)
  model = descramble_ata_string (&id[10 * 2], 20);
c0025d7c:	83 ec 08             	sub    $0x8,%esp
c0025d7f:	6a 14                	push   $0x14
c0025d81:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025d87:	83 c0 14             	add    $0x14,%eax
c0025d8a:	50                   	push   %eax
c0025d8b:	e8 c6 00 00 00       	call   c0025e56 <descramble_ata_string>
c0025d90:	83 c4 10             	add    $0x10,%esp
c0025d93:	89 45 ec             	mov    %eax,-0x14(%ebp)
  serial = descramble_ata_string (&id[27 * 2], 40);
c0025d96:	83 ec 08             	sub    $0x8,%esp
c0025d99:	6a 28                	push   $0x28
c0025d9b:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025da1:	83 c0 36             	add    $0x36,%eax
c0025da4:	50                   	push   %eax
c0025da5:	e8 ac 00 00 00       	call   c0025e56 <descramble_ata_string>
c0025daa:	83 c4 10             	add    $0x10,%esp
c0025dad:	89 45 e8             	mov    %eax,-0x18(%ebp)
  snprintf (extra_info, sizeof extra_info,
c0025db0:	83 ec 0c             	sub    $0xc,%esp
c0025db3:	ff 75 e8             	pushl  -0x18(%ebp)
c0025db6:	ff 75 ec             	pushl  -0x14(%ebp)
c0025db9:	68 34 02 03 c0       	push   $0xc0030234
c0025dbe:	68 80 00 00 00       	push   $0x80
c0025dc3:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c0025dc9:	50                   	push   %eax
c0025dca:	e8 06 14 00 00       	call   c00271d5 <snprintf>
c0025dcf:	83 c4 20             	add    $0x20,%esp
  /* Disable access to IDE disks over 1 GB, which are likely
     physical IDE disks rather than virtual ones.  If we don't
     allow access to those, we're less likely to scribble on
     someone's important data.  You can disable this check by
     hand if you really want to do so. */
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c0025dd2:	81 7d f0 ff ff 1f 00 	cmpl   $0x1fffff,-0x10(%ebp)
c0025dd9:	76 45                	jbe    c0025e20 <identify_ata_device+0x159>
    {
      printf ("%s: ignoring ", d->name);
c0025ddb:	8b 45 08             	mov    0x8(%ebp),%eax
c0025dde:	83 ec 08             	sub    $0x8,%esp
c0025de1:	50                   	push   %eax
c0025de2:	68 4c 02 03 c0       	push   $0xc003024c
c0025de7:	e8 12 14 00 00       	call   c00271fe <printf>
c0025dec:	83 c4 10             	add    $0x10,%esp
      print_human_readable_size (capacity * 512);
c0025def:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025df2:	c1 e0 09             	shl    $0x9,%eax
c0025df5:	ba 00 00 00 00       	mov    $0x0,%edx
c0025dfa:	83 ec 08             	sub    $0x8,%esp
c0025dfd:	52                   	push   %edx
c0025dfe:	50                   	push   %eax
c0025dff:	e8 1f 21 00 00       	call   c0027f23 <print_human_readable_size>
c0025e04:	83 c4 10             	add    $0x10,%esp
      printf ("disk for safety\n");
c0025e07:	83 ec 0c             	sub    $0xc,%esp
c0025e0a:	68 5a 02 03 c0       	push   $0xc003025a
c0025e0f:	e8 d0 59 00 00       	call   c002b7e4 <puts>
c0025e14:	83 c4 10             	add    $0x10,%esp
      d->is_ata = false;
c0025e17:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e1a:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0025e1e:	eb 34                	jmp    c0025e54 <identify_ata_device+0x18d>
    }

  /* Register. */
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c0025e20:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e23:	83 ec 08             	sub    $0x8,%esp
c0025e26:	ff 75 08             	pushl  0x8(%ebp)
c0025e29:	68 a0 80 03 c0       	push   $0xc00380a0
c0025e2e:	ff 75 f0             	pushl  -0x10(%ebp)
c0025e31:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c0025e37:	52                   	push   %edx
c0025e38:	6a 04                	push   $0x4
c0025e3a:	50                   	push   %eax
c0025e3b:	e8 51 f2 ff ff       	call   c0025091 <block_register>
c0025e40:	83 c4 20             	add    $0x20,%esp
c0025e43:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                          &ide_operations, d);
  partition_scan (block);
c0025e46:	83 ec 0c             	sub    $0xc,%esp
c0025e49:	ff 75 e4             	pushl  -0x1c(%ebp)
c0025e4c:	e8 88 f3 ff ff       	call   c00251d9 <partition_scan>
c0025e51:	83 c4 10             	add    $0x10,%esp
}
c0025e54:	c9                   	leave  
c0025e55:	c3                   	ret    

c0025e56 <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0025e56:	55                   	push   %ebp
c0025e57:	89 e5                	mov    %esp,%ebp
c0025e59:	83 ec 10             	sub    $0x10,%esp
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0025e5c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0025e63:	eb 3b                	jmp    c0025ea0 <descramble_ata_string+0x4a>
    {
      char tmp = string[i];
c0025e65:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0025e68:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e6b:	01 d0                	add    %edx,%eax
c0025e6d:	0f b6 00             	movzbl (%eax),%eax
c0025e70:	88 45 fb             	mov    %al,-0x5(%ebp)
      string[i] = string[i + 1];
c0025e73:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0025e76:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e79:	01 c2                	add    %eax,%edx
c0025e7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025e7e:	8d 48 01             	lea    0x1(%eax),%ecx
c0025e81:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e84:	01 c8                	add    %ecx,%eax
c0025e86:	0f b6 00             	movzbl (%eax),%eax
c0025e89:	88 02                	mov    %al,(%edx)
      string[i + 1] = tmp;
c0025e8b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025e8e:	8d 50 01             	lea    0x1(%eax),%edx
c0025e91:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e94:	01 c2                	add    %eax,%edx
c0025e96:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0025e9a:	88 02                	mov    %al,(%edx)
descramble_ata_string (char *string, int size) 
{
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0025e9c:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
c0025ea0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025ea3:	83 c0 01             	add    $0x1,%eax
c0025ea6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0025ea9:	7c ba                	jl     c0025e65 <descramble_ata_string+0xf>
      string[i] = string[i + 1];
      string[i + 1] = tmp;
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0025eab:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0025eaf:	eb 2d                	jmp    c0025ede <descramble_ata_string+0x88>
    {
      int c = string[size - 1];
c0025eb1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025eb4:	8d 50 ff             	lea    -0x1(%eax),%edx
c0025eb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0025eba:	01 d0                	add    %edx,%eax
c0025ebc:	0f b6 00             	movzbl (%eax),%eax
c0025ebf:	0f be c0             	movsbl %al,%eax
c0025ec2:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (c != '\0' && !isspace (c))
c0025ec5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0025ec9:	74 0f                	je     c0025eda <descramble_ata_string+0x84>
c0025ecb:	ff 75 f4             	pushl  -0xc(%ebp)
c0025ece:	e8 c7 f7 ff ff       	call   c002569a <isspace>
c0025ed3:	83 c4 04             	add    $0x4,%esp
c0025ed6:	85 c0                	test   %eax,%eax
c0025ed8:	74 0c                	je     c0025ee6 <descramble_ata_string+0x90>
      string[i] = string[i + 1];
      string[i + 1] = tmp;
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0025eda:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0025ede:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0025ee2:	7f cd                	jg     c0025eb1 <descramble_ata_string+0x5b>
c0025ee4:	eb 01                	jmp    c0025ee7 <descramble_ata_string+0x91>
    {
      int c = string[size - 1];
      if (c != '\0' && !isspace (c))
        break; 
c0025ee6:	90                   	nop
    }
  string[size] = '\0';
c0025ee7:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025eea:	8b 45 08             	mov    0x8(%ebp),%eax
c0025eed:	01 d0                	add    %edx,%eax
c0025eef:	c6 00 00             	movb   $0x0,(%eax)

  return string;
c0025ef2:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0025ef5:	c9                   	leave  
c0025ef6:	c3                   	ret    

c0025ef7 <ide_read>:
   room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_read (void *d_, block_sector_t sec_no, void *buffer)
{
c0025ef7:	55                   	push   %ebp
c0025ef8:	89 e5                	mov    %esp,%ebp
c0025efa:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c0025efd:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f00:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0025f03:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025f06:	8b 40 08             	mov    0x8(%eax),%eax
c0025f09:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0025f0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025f0f:	83 c0 0c             	add    $0xc,%eax
c0025f12:	83 ec 0c             	sub    $0xc,%esp
c0025f15:	50                   	push   %eax
c0025f16:	e8 a7 cb ff ff       	call   c0022ac2 <lock_acquire>
c0025f1b:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c0025f1e:	83 ec 08             	sub    $0x8,%esp
c0025f21:	ff 75 0c             	pushl  0xc(%ebp)
c0025f24:	ff 75 f4             	pushl  -0xc(%ebp)
c0025f27:	e8 3b 01 00 00       	call   c0026067 <select_sector>
c0025f2c:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c0025f2f:	83 ec 08             	sub    $0x8,%esp
c0025f32:	6a 20                	push   $0x20
c0025f34:	ff 75 f0             	pushl  -0x10(%ebp)
c0025f37:	e8 32 02 00 00       	call   c002616e <issue_pio_command>
c0025f3c:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0025f3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025f42:	83 c0 28             	add    $0x28,%eax
c0025f45:	83 ec 0c             	sub    $0xc,%esp
c0025f48:	50                   	push   %eax
c0025f49:	e8 b3 c8 ff ff       	call   c0022801 <sema_down>
c0025f4e:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025f51:	83 ec 0c             	sub    $0xc,%esp
c0025f54:	ff 75 f4             	pushl  -0xc(%ebp)
c0025f57:	e8 1c 03 00 00       	call   c0026278 <wait_while_busy>
c0025f5c:	83 c4 10             	add    $0x10,%esp
c0025f5f:	83 f0 01             	xor    $0x1,%eax
c0025f62:	84 c0                	test   %al,%al
c0025f64:	74 23                	je     c0025f89 <ide_read+0x92>
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c0025f66:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025f69:	83 ec 08             	sub    $0x8,%esp
c0025f6c:	ff 75 0c             	pushl  0xc(%ebp)
c0025f6f:	50                   	push   %eax
c0025f70:	68 6c 02 03 c0       	push   $0xc003026c
c0025f75:	68 4c 03 03 c0       	push   $0xc003034c
c0025f7a:	68 62 01 00 00       	push   $0x162
c0025f7f:	68 fa 01 03 c0       	push   $0xc00301fa
c0025f84:	e8 a8 36 00 00       	call   c0029631 <debug_panic>
  input_sector (c, buffer);
c0025f89:	83 ec 08             	sub    $0x8,%esp
c0025f8c:	ff 75 10             	pushl  0x10(%ebp)
c0025f8f:	ff 75 f0             	pushl  -0x10(%ebp)
c0025f92:	e8 36 02 00 00       	call   c00261cd <input_sector>
c0025f97:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c0025f9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025f9d:	83 c0 0c             	add    $0xc,%eax
c0025fa0:	83 ec 0c             	sub    $0xc,%esp
c0025fa3:	50                   	push   %eax
c0025fa4:	e8 5a cc ff ff       	call   c0022c03 <lock_release>
c0025fa9:	83 c4 10             	add    $0x10,%esp
}
c0025fac:	90                   	nop
c0025fad:	c9                   	leave  
c0025fae:	c3                   	ret    

c0025faf <ide_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_write (void *d_, block_sector_t sec_no, const void *buffer)
{
c0025faf:	55                   	push   %ebp
c0025fb0:	89 e5                	mov    %esp,%ebp
c0025fb2:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c0025fb5:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fb8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0025fbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025fbe:	8b 40 08             	mov    0x8(%eax),%eax
c0025fc1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0025fc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025fc7:	83 c0 0c             	add    $0xc,%eax
c0025fca:	83 ec 0c             	sub    $0xc,%esp
c0025fcd:	50                   	push   %eax
c0025fce:	e8 ef ca ff ff       	call   c0022ac2 <lock_acquire>
c0025fd3:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c0025fd6:	83 ec 08             	sub    $0x8,%esp
c0025fd9:	ff 75 0c             	pushl  0xc(%ebp)
c0025fdc:	ff 75 f4             	pushl  -0xc(%ebp)
c0025fdf:	e8 83 00 00 00       	call   c0026067 <select_sector>
c0025fe4:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c0025fe7:	83 ec 08             	sub    $0x8,%esp
c0025fea:	6a 30                	push   $0x30
c0025fec:	ff 75 f0             	pushl  -0x10(%ebp)
c0025fef:	e8 7a 01 00 00       	call   c002616e <issue_pio_command>
c0025ff4:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025ff7:	83 ec 0c             	sub    $0xc,%esp
c0025ffa:	ff 75 f4             	pushl  -0xc(%ebp)
c0025ffd:	e8 76 02 00 00       	call   c0026278 <wait_while_busy>
c0026002:	83 c4 10             	add    $0x10,%esp
c0026005:	83 f0 01             	xor    $0x1,%eax
c0026008:	84 c0                	test   %al,%al
c002600a:	74 23                	je     c002602f <ide_write+0x80>
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c002600c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002600f:	83 ec 08             	sub    $0x8,%esp
c0026012:	ff 75 0c             	pushl  0xc(%ebp)
c0026015:	50                   	push   %eax
c0026016:	68 8c 02 03 c0       	push   $0xc003028c
c002601b:	68 58 03 03 c0       	push   $0xc0030358
c0026020:	68 75 01 00 00       	push   $0x175
c0026025:	68 fa 01 03 c0       	push   $0xc00301fa
c002602a:	e8 02 36 00 00       	call   c0029631 <debug_panic>
  output_sector (c, buffer);
c002602f:	83 ec 08             	sub    $0x8,%esp
c0026032:	ff 75 10             	pushl  0x10(%ebp)
c0026035:	ff 75 f0             	pushl  -0x10(%ebp)
c0026038:	e8 b1 01 00 00       	call   c00261ee <output_sector>
c002603d:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026040:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026043:	83 c0 28             	add    $0x28,%eax
c0026046:	83 ec 0c             	sub    $0xc,%esp
c0026049:	50                   	push   %eax
c002604a:	e8 b2 c7 ff ff       	call   c0022801 <sema_down>
c002604f:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c0026052:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026055:	83 c0 0c             	add    $0xc,%eax
c0026058:	83 ec 0c             	sub    $0xc,%esp
c002605b:	50                   	push   %eax
c002605c:	e8 a2 cb ff ff       	call   c0022c03 <lock_release>
c0026061:	83 c4 10             	add    $0x10,%esp
}
c0026064:	90                   	nop
c0026065:	c9                   	leave  
c0026066:	c3                   	ret    

c0026067 <select_sector>:
/* Selects device D, waiting for it to become ready, and then
   writes SEC_NO to the disk's sector selection registers.  (We
   use LBA mode.) */
static void
select_sector (struct ata_disk *d, block_sector_t sec_no)
{
c0026067:	55                   	push   %ebp
c0026068:	89 e5                	mov    %esp,%ebp
c002606a:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c002606d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026070:	8b 40 08             	mov    0x8(%eax),%eax
c0026073:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sec_no < (1UL << 28));
c0026076:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
c002607d:	76 21                	jbe    c00260a0 <select_sector+0x39>
c002607f:	83 ec 0c             	sub    $0xc,%esp
c0026082:	68 ad 02 03 c0       	push   $0xc00302ad
c0026087:	68 1d 02 03 c0       	push   $0xc003021d
c002608c:	68 64 03 03 c0       	push   $0xc0030364
c0026091:	68 89 01 00 00       	push   $0x189
c0026096:	68 fa 01 03 c0       	push   $0xc00301fa
c002609b:	e8 91 35 00 00       	call   c0029631 <debug_panic>
  
  select_device_wait (d);
c00260a0:	83 ec 0c             	sub    $0xc,%esp
c00260a3:	ff 75 08             	pushl  0x8(%ebp)
c00260a6:	e8 03 03 00 00       	call   c00263ae <select_device_wait>
c00260ab:	83 c4 10             	add    $0x10,%esp
  outb (reg_nsect (c), 1);
c00260ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00260b1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00260b5:	83 c0 02             	add    $0x2,%eax
c00260b8:	0f b7 c0             	movzwl %ax,%eax
c00260bb:	83 ec 08             	sub    $0x8,%esp
c00260be:	6a 01                	push   $0x1
c00260c0:	50                   	push   %eax
c00260c1:	e8 5a f6 ff ff       	call   c0025720 <outb>
c00260c6:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbal (c), sec_no);
c00260c9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00260cc:	0f b6 d0             	movzbl %al,%edx
c00260cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00260d2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00260d6:	83 c0 03             	add    $0x3,%eax
c00260d9:	0f b7 c0             	movzwl %ax,%eax
c00260dc:	83 ec 08             	sub    $0x8,%esp
c00260df:	52                   	push   %edx
c00260e0:	50                   	push   %eax
c00260e1:	e8 3a f6 ff ff       	call   c0025720 <outb>
c00260e6:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbam (c), sec_no >> 8);
c00260e9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00260ec:	c1 e8 08             	shr    $0x8,%eax
c00260ef:	0f b6 d0             	movzbl %al,%edx
c00260f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00260f5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00260f9:	83 c0 04             	add    $0x4,%eax
c00260fc:	0f b7 c0             	movzwl %ax,%eax
c00260ff:	83 ec 08             	sub    $0x8,%esp
c0026102:	52                   	push   %edx
c0026103:	50                   	push   %eax
c0026104:	e8 17 f6 ff ff       	call   c0025720 <outb>
c0026109:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbah (c), (sec_no >> 16));
c002610c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002610f:	c1 e8 10             	shr    $0x10,%eax
c0026112:	0f b6 d0             	movzbl %al,%edx
c0026115:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026118:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002611c:	83 c0 05             	add    $0x5,%eax
c002611f:	0f b7 c0             	movzwl %ax,%eax
c0026122:	83 ec 08             	sub    $0x8,%esp
c0026125:	52                   	push   %edx
c0026126:	50                   	push   %eax
c0026127:	e8 f4 f5 ff ff       	call   c0025720 <outb>
c002612c:	83 c4 10             	add    $0x10,%esp
  outb (reg_device (c),
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c002612f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026132:	8b 40 0c             	mov    0xc(%eax),%eax
  select_device_wait (d);
  outb (reg_nsect (c), 1);
  outb (reg_lbal (c), sec_no);
  outb (reg_lbam (c), sec_no >> 8);
  outb (reg_lbah (c), (sec_no >> 16));
  outb (reg_device (c),
c0026135:	83 f8 01             	cmp    $0x1,%eax
c0026138:	75 07                	jne    c0026141 <select_sector+0xda>
c002613a:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
c002613f:	eb 05                	jmp    c0026146 <select_sector+0xdf>
c0026141:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0026146:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026149:	c1 e8 18             	shr    $0x18,%eax
  select_device_wait (d);
  outb (reg_nsect (c), 1);
  outb (reg_lbal (c), sec_no);
  outb (reg_lbam (c), sec_no >> 8);
  outb (reg_lbah (c), (sec_no >> 16));
  outb (reg_device (c),
c002614c:	09 d0                	or     %edx,%eax
c002614e:	0f b6 d0             	movzbl %al,%edx
c0026151:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026154:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026158:	83 c0 06             	add    $0x6,%eax
c002615b:	0f b7 c0             	movzwl %ax,%eax
c002615e:	83 ec 08             	sub    $0x8,%esp
c0026161:	52                   	push   %edx
c0026162:	50                   	push   %eax
c0026163:	e8 b8 f5 ff ff       	call   c0025720 <outb>
c0026168:	83 c4 10             	add    $0x10,%esp
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
}
c002616b:	90                   	nop
c002616c:	c9                   	leave  
c002616d:	c3                   	ret    

c002616e <issue_pio_command>:

/* Writes COMMAND to channel C and prepares for receiving a
   completion interrupt. */
static void
issue_pio_command (struct channel *c, uint8_t command) 
{
c002616e:	55                   	push   %ebp
c002616f:	89 e5                	mov    %esp,%ebp
c0026171:	83 ec 18             	sub    $0x18,%esp
c0026174:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026177:	88 45 f4             	mov    %al,-0xc(%ebp)
  /* Interrupts must be enabled or our semaphore will never be
     up'd by the completion handler. */
  ASSERT (intr_get_level () == INTR_ON);
c002617a:	e8 ba b1 ff ff       	call   c0021339 <intr_get_level>
c002617f:	83 f8 01             	cmp    $0x1,%eax
c0026182:	74 21                	je     c00261a5 <issue_pio_command+0x37>
c0026184:	83 ec 0c             	sub    $0xc,%esp
c0026187:	68 c2 02 03 c0       	push   $0xc00302c2
c002618c:	68 1d 02 03 c0       	push   $0xc003021d
c0026191:	68 74 03 03 c0       	push   $0xc0030374
c0026196:	68 9b 01 00 00       	push   $0x19b
c002619b:	68 fa 01 03 c0       	push   $0xc00301fa
c00261a0:	e8 8c 34 00 00       	call   c0029631 <debug_panic>

  c->expecting_interrupt = true;
c00261a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00261a8:	c6 40 24 01          	movb   $0x1,0x24(%eax)
  outb (reg_command (c), command);
c00261ac:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c00261b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00261b3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00261b7:	83 c0 07             	add    $0x7,%eax
c00261ba:	0f b7 c0             	movzwl %ax,%eax
c00261bd:	83 ec 08             	sub    $0x8,%esp
c00261c0:	52                   	push   %edx
c00261c1:	50                   	push   %eax
c00261c2:	e8 59 f5 ff ff       	call   c0025720 <outb>
c00261c7:	83 c4 10             	add    $0x10,%esp
}
c00261ca:	90                   	nop
c00261cb:	c9                   	leave  
c00261cc:	c3                   	ret    

c00261cd <input_sector>:

/* Reads a sector from channel C's data register in PIO mode into
   SECTOR, which must have room for BLOCK_SECTOR_SIZE bytes. */
static void
input_sector (struct channel *c, void *sector) 
{
c00261cd:	55                   	push   %ebp
c00261ce:	89 e5                	mov    %esp,%ebp
  insw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c00261d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00261d3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00261d7:	0f b7 c0             	movzwl %ax,%eax
c00261da:	68 00 01 00 00       	push   $0x100
c00261df:	ff 75 0c             	pushl  0xc(%ebp)
c00261e2:	50                   	push   %eax
c00261e3:	e8 04 f5 ff ff       	call   c00256ec <insw>
c00261e8:	83 c4 0c             	add    $0xc,%esp
}
c00261eb:	90                   	nop
c00261ec:	c9                   	leave  
c00261ed:	c3                   	ret    

c00261ee <output_sector>:

/* Writes SECTOR to channel C's data register in PIO mode.
   SECTOR must contain BLOCK_SECTOR_SIZE bytes. */
static void
output_sector (struct channel *c, const void *sector) 
{
c00261ee:	55                   	push   %ebp
c00261ef:	89 e5                	mov    %esp,%ebp
  outsw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c00261f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00261f4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00261f8:	0f b7 c0             	movzwl %ax,%eax
c00261fb:	68 00 01 00 00       	push   $0x100
c0026200:	ff 75 0c             	pushl  0xc(%ebp)
c0026203:	50                   	push   %eax
c0026204:	e8 36 f5 ff ff       	call   c002573f <outsw>
c0026209:	83 c4 0c             	add    $0xc,%esp
}
c002620c:	90                   	nop
c002620d:	c9                   	leave  
c002620e:	c3                   	ret    

c002620f <wait_until_idle>:

   As a side effect, reading the status register clears any
   pending interrupt. */
static void
wait_until_idle (const struct ata_disk *d) 
{
c002620f:	55                   	push   %ebp
c0026210:	89 e5                	mov    %esp,%ebp
c0026212:	83 ec 18             	sub    $0x18,%esp
  int i;

  for (i = 0; i < 1000; i++) 
c0026215:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002621c:	eb 38                	jmp    c0026256 <wait_until_idle+0x47>
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c002621e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026221:	8b 40 08             	mov    0x8(%eax),%eax
c0026224:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026228:	83 c0 07             	add    $0x7,%eax
c002622b:	0f b7 c0             	movzwl %ax,%eax
c002622e:	50                   	push   %eax
c002622f:	e8 9b f4 ff ff       	call   c00256cf <inb>
c0026234:	83 c4 04             	add    $0x4,%esp
c0026237:	0f b6 c0             	movzbl %al,%eax
c002623a:	25 88 00 00 00       	and    $0x88,%eax
c002623f:	85 c0                	test   %eax,%eax
c0026241:	74 32                	je     c0026275 <wait_until_idle+0x66>
        return;
      timer_usleep (10);
c0026243:	83 ec 08             	sub    $0x8,%esp
c0026246:	6a 00                	push   $0x0
c0026248:	6a 0a                	push   $0xa
c002624a:	e8 6d db ff ff       	call   c0023dbc <timer_usleep>
c002624f:	83 c4 10             	add    $0x10,%esp
static void
wait_until_idle (const struct ata_disk *d) 
{
  int i;

  for (i = 0; i < 1000; i++) 
c0026252:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0026256:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c002625d:	7e bf                	jle    c002621e <wait_until_idle+0xf>
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
        return;
      timer_usleep (10);
    }

  printf ("%s: idle timeout\n", d->name);
c002625f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026262:	83 ec 08             	sub    $0x8,%esp
c0026265:	50                   	push   %eax
c0026266:	68 df 02 03 c0       	push   $0xc00302df
c002626b:	e8 8e 0f 00 00       	call   c00271fe <printf>
c0026270:	83 c4 10             	add    $0x10,%esp
c0026273:	eb 01                	jmp    c0026276 <wait_until_idle+0x67>
  int i;

  for (i = 0; i < 1000; i++) 
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
        return;
c0026275:	90                   	nop
      timer_usleep (10);
    }

  printf ("%s: idle timeout\n", d->name);
}
c0026276:	c9                   	leave  
c0026277:	c3                   	ret    

c0026278 <wait_while_busy>:
   and then return the status of the DRQ bit.
   The ATA standards say that a disk may take as long as that to
   complete its reset. */
static bool
wait_while_busy (const struct ata_disk *d) 
{
c0026278:	55                   	push   %ebp
c0026279:	89 e5                	mov    %esp,%ebp
c002627b:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c002627e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026281:	8b 40 08             	mov    0x8(%eax),%eax
c0026284:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < 3000; i++)
c0026287:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002628e:	e9 8e 00 00 00       	jmp    c0026321 <wait_while_busy+0xa9>
    {
      if (i == 700)
c0026293:	81 7d f4 bc 02 00 00 	cmpl   $0x2bc,-0xc(%ebp)
c002629a:	75 14                	jne    c00262b0 <wait_while_busy+0x38>
        printf ("%s: busy, waiting...", d->name);
c002629c:	8b 45 08             	mov    0x8(%ebp),%eax
c002629f:	83 ec 08             	sub    $0x8,%esp
c00262a2:	50                   	push   %eax
c00262a3:	68 f1 02 03 c0       	push   $0xc00302f1
c00262a8:	e8 51 0f 00 00       	call   c00271fe <printf>
c00262ad:	83 c4 10             	add    $0x10,%esp
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c00262b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00262b3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00262b7:	66 05 06 02          	add    $0x206,%ax
c00262bb:	0f b7 c0             	movzwl %ax,%eax
c00262be:	83 ec 0c             	sub    $0xc,%esp
c00262c1:	50                   	push   %eax
c00262c2:	e8 08 f4 ff ff       	call   c00256cf <inb>
c00262c7:	83 c4 10             	add    $0x10,%esp
c00262ca:	84 c0                	test   %al,%al
c00262cc:	78 40                	js     c002630e <wait_while_busy+0x96>
        {
          if (i >= 700)
c00262ce:	81 7d f4 bb 02 00 00 	cmpl   $0x2bb,-0xc(%ebp)
c00262d5:	7e 10                	jle    c00262e7 <wait_while_busy+0x6f>
            printf ("ok\n");
c00262d7:	83 ec 0c             	sub    $0xc,%esp
c00262da:	68 06 03 03 c0       	push   $0xc0030306
c00262df:	e8 00 55 00 00       	call   c002b7e4 <puts>
c00262e4:	83 c4 10             	add    $0x10,%esp
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c00262e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00262ea:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00262ee:	66 05 06 02          	add    $0x206,%ax
c00262f2:	0f b7 c0             	movzwl %ax,%eax
c00262f5:	83 ec 0c             	sub    $0xc,%esp
c00262f8:	50                   	push   %eax
c00262f9:	e8 d1 f3 ff ff       	call   c00256cf <inb>
c00262fe:	83 c4 10             	add    $0x10,%esp
c0026301:	0f b6 c0             	movzbl %al,%eax
c0026304:	83 e0 08             	and    $0x8,%eax
c0026307:	85 c0                	test   %eax,%eax
c0026309:	0f 95 c0             	setne  %al
c002630c:	eb 35                	jmp    c0026343 <wait_while_busy+0xcb>
        }
      timer_msleep (10);
c002630e:	83 ec 08             	sub    $0x8,%esp
c0026311:	6a 00                	push   $0x0
c0026313:	6a 0a                	push   $0xa
c0026315:	e8 77 da ff ff       	call   c0023d91 <timer_msleep>
c002631a:	83 c4 10             	add    $0x10,%esp
wait_while_busy (const struct ata_disk *d) 
{
  struct channel *c = d->channel;
  int i;
  
  for (i = 0; i < 3000; i++)
c002631d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0026321:	81 7d f4 b7 0b 00 00 	cmpl   $0xbb7,-0xc(%ebp)
c0026328:	0f 8e 65 ff ff ff    	jle    c0026293 <wait_while_busy+0x1b>
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
        }
      timer_msleep (10);
    }

  printf ("failed\n");
c002632e:	83 ec 0c             	sub    $0xc,%esp
c0026331:	68 09 03 03 c0       	push   $0xc0030309
c0026336:	e8 a9 54 00 00       	call   c002b7e4 <puts>
c002633b:	83 c4 10             	add    $0x10,%esp
  return false;
c002633e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0026343:	c9                   	leave  
c0026344:	c3                   	ret    

c0026345 <select_device>:

/* Program D's channel so that D is now the selected disk. */
static void
select_device (const struct ata_disk *d)
{
c0026345:	55                   	push   %ebp
c0026346:	89 e5                	mov    %esp,%ebp
c0026348:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c002634b:	8b 45 08             	mov    0x8(%ebp),%eax
c002634e:	8b 40 08             	mov    0x8(%eax),%eax
c0026351:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t dev = DEV_MBS;
c0026354:	c6 45 f7 a0          	movb   $0xa0,-0x9(%ebp)
  if (d->dev_no == 1)
c0026358:	8b 45 08             	mov    0x8(%ebp),%eax
c002635b:	8b 40 0c             	mov    0xc(%eax),%eax
c002635e:	83 f8 01             	cmp    $0x1,%eax
c0026361:	75 04                	jne    c0026367 <select_device+0x22>
    dev |= DEV_DEV;
c0026363:	80 4d f7 10          	orb    $0x10,-0x9(%ebp)
  outb (reg_device (c), dev);
c0026367:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c002636b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002636e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026372:	83 c0 06             	add    $0x6,%eax
c0026375:	0f b7 c0             	movzwl %ax,%eax
c0026378:	52                   	push   %edx
c0026379:	50                   	push   %eax
c002637a:	e8 a1 f3 ff ff       	call   c0025720 <outb>
c002637f:	83 c4 08             	add    $0x8,%esp
  inb (reg_alt_status (c));
c0026382:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026385:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026389:	66 05 06 02          	add    $0x206,%ax
c002638d:	0f b7 c0             	movzwl %ax,%eax
c0026390:	50                   	push   %eax
c0026391:	e8 39 f3 ff ff       	call   c00256cf <inb>
c0026396:	83 c4 04             	add    $0x4,%esp
  timer_nsleep (400);
c0026399:	83 ec 08             	sub    $0x8,%esp
c002639c:	6a 00                	push   $0x0
c002639e:	68 90 01 00 00       	push   $0x190
c00263a3:	e8 3f da ff ff       	call   c0023de7 <timer_nsleep>
c00263a8:	83 c4 10             	add    $0x10,%esp
}
c00263ab:	90                   	nop
c00263ac:	c9                   	leave  
c00263ad:	c3                   	ret    

c00263ae <select_device_wait>:

/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
c00263ae:	55                   	push   %ebp
c00263af:	89 e5                	mov    %esp,%ebp
c00263b1:	83 ec 08             	sub    $0x8,%esp
  wait_until_idle (d);
c00263b4:	83 ec 0c             	sub    $0xc,%esp
c00263b7:	ff 75 08             	pushl  0x8(%ebp)
c00263ba:	e8 50 fe ff ff       	call   c002620f <wait_until_idle>
c00263bf:	83 c4 10             	add    $0x10,%esp
  select_device (d);
c00263c2:	83 ec 0c             	sub    $0xc,%esp
c00263c5:	ff 75 08             	pushl  0x8(%ebp)
c00263c8:	e8 78 ff ff ff       	call   c0026345 <select_device>
c00263cd:	83 c4 10             	add    $0x10,%esp
  wait_until_idle (d);
c00263d0:	83 ec 0c             	sub    $0xc,%esp
c00263d3:	ff 75 08             	pushl  0x8(%ebp)
c00263d6:	e8 34 fe ff ff       	call   c002620f <wait_until_idle>
c00263db:	83 c4 10             	add    $0x10,%esp
}
c00263de:	90                   	nop
c00263df:	c9                   	leave  
c00263e0:	c3                   	ret    

c00263e1 <interrupt_handler>:

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c00263e1:	55                   	push   %ebp
c00263e2:	89 e5                	mov    %esp,%ebp
c00263e4:	83 ec 18             	sub    $0x18,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c00263e7:	c7 45 f4 80 99 03 c0 	movl   $0xc0039980,-0xc(%ebp)
c00263ee:	eb 63                	jmp    c0026453 <interrupt_handler+0x72>
    if (f->vec_no == c->irq)
c00263f0:	8b 45 08             	mov    0x8(%ebp),%eax
c00263f3:	8b 50 30             	mov    0x30(%eax),%edx
c00263f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00263f9:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c00263fd:	0f b6 c0             	movzbl %al,%eax
c0026400:	39 c2                	cmp    %eax,%edx
c0026402:	75 4b                	jne    c002644f <interrupt_handler+0x6e>
      {
        if (c->expecting_interrupt) 
c0026404:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026407:	0f b6 40 24          	movzbl 0x24(%eax),%eax
c002640b:	84 c0                	test   %al,%al
c002640d:	74 2a                	je     c0026439 <interrupt_handler+0x58>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
c002640f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026412:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026416:	83 c0 07             	add    $0x7,%eax
c0026419:	0f b7 c0             	movzwl %ax,%eax
c002641c:	50                   	push   %eax
c002641d:	e8 ad f2 ff ff       	call   c00256cf <inb>
c0026422:	83 c4 04             	add    $0x4,%esp
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c0026425:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026428:	83 c0 28             	add    $0x28,%eax
c002642b:	83 ec 0c             	sub    $0xc,%esp
c002642e:	50                   	push   %eax
c002642f:	e8 d8 c4 ff ff       	call   c002290c <sema_up>
c0026434:	83 c4 10             	add    $0x10,%esp
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
c0026437:	eb 3d                	jmp    c0026476 <interrupt_handler+0x95>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
            sema_up (&c->completion_wait);      /* Wake up waiter. */
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
c0026439:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002643c:	83 ec 08             	sub    $0x8,%esp
c002643f:	50                   	push   %eax
c0026440:	68 10 03 03 c0       	push   $0xc0030310
c0026445:	e8 b4 0d 00 00       	call   c00271fe <printf>
c002644a:	83 c4 10             	add    $0x10,%esp
        return;
c002644d:	eb 27                	jmp    c0026476 <interrupt_handler+0x95>
static void
interrupt_handler (struct intr_frame *f) 
{
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c002644f:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
c0026453:	b8 48 9a 03 c0       	mov    $0xc0039a48,%eax
c0026458:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002645b:	72 93                	jb     c00263f0 <interrupt_handler+0xf>
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
      }

  NOT_REACHED ();
c002645d:	68 d8 01 03 c0       	push   $0xc00301d8
c0026462:	68 88 03 03 c0       	push   $0xc0030388
c0026467:	68 0c 02 00 00       	push   $0x20c
c002646c:	68 fa 01 03 c0       	push   $0xc00301fa
c0026471:	e8 bb 31 00 00       	call   c0029631 <debug_panic>
}
c0026476:	c9                   	leave  
c0026477:	c3                   	ret    

c0026478 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c0026478:	55                   	push   %ebp
c0026479:	89 e5                	mov    %esp,%ebp
c002647b:	83 ec 08             	sub    $0x8,%esp
  intq_init (&buffer);
c002647e:	83 ec 0c             	sub    $0xc,%esp
c0026481:	68 60 9a 03 c0       	push   $0xc0039a60
c0026486:	e8 04 01 00 00       	call   c002658f <intq_init>
c002648b:	83 c4 10             	add    $0x10,%esp
}
c002648e:	90                   	nop
c002648f:	c9                   	leave  
c0026490:	c3                   	ret    

c0026491 <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c0026491:	55                   	push   %ebp
c0026492:	89 e5                	mov    %esp,%ebp
c0026494:	83 ec 18             	sub    $0x18,%esp
c0026497:	8b 45 08             	mov    0x8(%ebp),%eax
c002649a:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c002649d:	e8 97 ae ff ff       	call   c0021339 <intr_get_level>
c00264a2:	85 c0                	test   %eax,%eax
c00264a4:	74 1e                	je     c00264c4 <input_putc+0x33>
c00264a6:	83 ec 0c             	sub    $0xc,%esp
c00264a9:	68 9c 03 03 c0       	push   $0xc003039c
c00264ae:	68 ba 03 03 c0       	push   $0xc00303ba
c00264b3:	68 fc 03 03 c0       	push   $0xc00303fc
c00264b8:	6a 15                	push   $0x15
c00264ba:	68 d1 03 03 c0       	push   $0xc00303d1
c00264bf:	e8 6d 31 00 00       	call   c0029631 <debug_panic>
  ASSERT (!intq_full (&buffer));
c00264c4:	83 ec 0c             	sub    $0xc,%esp
c00264c7:	68 60 9a 03 c0       	push   $0xc0039a60
c00264cc:	e8 42 01 00 00       	call   c0026613 <intq_full>
c00264d1:	83 c4 10             	add    $0x10,%esp
c00264d4:	83 f0 01             	xor    $0x1,%eax
c00264d7:	84 c0                	test   %al,%al
c00264d9:	75 1e                	jne    c00264f9 <input_putc+0x68>
c00264db:	83 ec 0c             	sub    $0xc,%esp
c00264de:	68 e7 03 03 c0       	push   $0xc00303e7
c00264e3:	68 ba 03 03 c0       	push   $0xc00303ba
c00264e8:	68 fc 03 03 c0       	push   $0xc00303fc
c00264ed:	6a 16                	push   $0x16
c00264ef:	68 d1 03 03 c0       	push   $0xc00303d1
c00264f4:	e8 38 31 00 00       	call   c0029631 <debug_panic>

  intq_putc (&buffer, key);
c00264f9:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00264fd:	83 ec 08             	sub    $0x8,%esp
c0026500:	50                   	push   %eax
c0026501:	68 60 9a 03 c0       	push   $0xc0039a60
c0026506:	e8 38 02 00 00       	call   c0026743 <intq_putc>
c002650b:	83 c4 10             	add    $0x10,%esp
  serial_notify ();
c002650e:	e8 e6 e5 ff ff       	call   c0024af9 <serial_notify>
}
c0026513:	90                   	nop
c0026514:	c9                   	leave  
c0026515:	c3                   	ret    

c0026516 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c0026516:	55                   	push   %ebp
c0026517:	89 e5                	mov    %esp,%ebp
c0026519:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c002651c:	e8 8d ae ff ff       	call   c00213ae <intr_disable>
c0026521:	89 45 f4             	mov    %eax,-0xc(%ebp)
  key = intq_getc (&buffer);
c0026524:	83 ec 0c             	sub    $0xc,%esp
c0026527:	68 60 9a 03 c0       	push   $0xc0039a60
c002652c:	e8 30 01 00 00       	call   c0026661 <intq_getc>
c0026531:	83 c4 10             	add    $0x10,%esp
c0026534:	88 45 f3             	mov    %al,-0xd(%ebp)
  serial_notify ();
c0026537:	e8 bd e5 ff ff       	call   c0024af9 <serial_notify>
  intr_set_level (old_level);
c002653c:	83 ec 0c             	sub    $0xc,%esp
c002653f:	ff 75 f4             	pushl  -0xc(%ebp)
c0026542:	e8 0f ae ff ff       	call   c0021356 <intr_set_level>
c0026547:	83 c4 10             	add    $0x10,%esp
  
  return key;
c002654a:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
}
c002654e:	c9                   	leave  
c002654f:	c3                   	ret    

c0026550 <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c0026550:	55                   	push   %ebp
c0026551:	89 e5                	mov    %esp,%ebp
c0026553:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026556:	e8 de ad ff ff       	call   c0021339 <intr_get_level>
c002655b:	85 c0                	test   %eax,%eax
c002655d:	74 1e                	je     c002657d <input_full+0x2d>
c002655f:	83 ec 0c             	sub    $0xc,%esp
c0026562:	68 9c 03 03 c0       	push   $0xc003039c
c0026567:	68 ba 03 03 c0       	push   $0xc00303ba
c002656c:	68 08 04 03 c0       	push   $0xc0030408
c0026571:	6a 32                	push   $0x32
c0026573:	68 d1 03 03 c0       	push   $0xc00303d1
c0026578:	e8 b4 30 00 00       	call   c0029631 <debug_panic>
  return intq_full (&buffer);
c002657d:	83 ec 0c             	sub    $0xc,%esp
c0026580:	68 60 9a 03 c0       	push   $0xc0039a60
c0026585:	e8 89 00 00 00       	call   c0026613 <intq_full>
c002658a:	83 c4 10             	add    $0x10,%esp
}
c002658d:	c9                   	leave  
c002658e:	c3                   	ret    

c002658f <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c002658f:	55                   	push   %ebp
c0026590:	89 e5                	mov    %esp,%ebp
c0026592:	83 ec 08             	sub    $0x8,%esp
  lock_init (&q->lock);
c0026595:	8b 45 08             	mov    0x8(%ebp),%eax
c0026598:	83 ec 0c             	sub    $0xc,%esp
c002659b:	50                   	push   %eax
c002659c:	e8 d4 c4 ff ff       	call   c0022a75 <lock_init>
c00265a1:	83 c4 10             	add    $0x10,%esp
  q->not_full = q->not_empty = NULL;
c00265a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00265a7:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
c00265ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00265b1:	8b 50 1c             	mov    0x1c(%eax),%edx
c00265b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00265b7:	89 50 18             	mov    %edx,0x18(%eax)
  q->head = q->tail = 0;
c00265ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00265bd:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
c00265c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00265c7:	8b 50 64             	mov    0x64(%eax),%edx
c00265ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00265cd:	89 50 60             	mov    %edx,0x60(%eax)
}
c00265d0:	90                   	nop
c00265d1:	c9                   	leave  
c00265d2:	c3                   	ret    

c00265d3 <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c00265d3:	55                   	push   %ebp
c00265d4:	89 e5                	mov    %esp,%ebp
c00265d6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00265d9:	e8 5b ad ff ff       	call   c0021339 <intr_get_level>
c00265de:	85 c0                	test   %eax,%eax
c00265e0:	74 1e                	je     c0026600 <intq_empty+0x2d>
c00265e2:	83 ec 0c             	sub    $0xc,%esp
c00265e5:	68 14 04 03 c0       	push   $0xc0030414
c00265ea:	68 32 04 03 c0       	push   $0xc0030432
c00265ef:	68 28 05 03 c0       	push   $0xc0030528
c00265f4:	6a 16                	push   $0x16
c00265f6:	68 49 04 03 c0       	push   $0xc0030449
c00265fb:	e8 31 30 00 00       	call   c0029631 <debug_panic>
  return q->head == q->tail;
c0026600:	8b 45 08             	mov    0x8(%ebp),%eax
c0026603:	8b 50 60             	mov    0x60(%eax),%edx
c0026606:	8b 45 08             	mov    0x8(%ebp),%eax
c0026609:	8b 40 64             	mov    0x64(%eax),%eax
c002660c:	39 c2                	cmp    %eax,%edx
c002660e:	0f 94 c0             	sete   %al
}
c0026611:	c9                   	leave  
c0026612:	c3                   	ret    

c0026613 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c0026613:	55                   	push   %ebp
c0026614:	89 e5                	mov    %esp,%ebp
c0026616:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026619:	e8 1b ad ff ff       	call   c0021339 <intr_get_level>
c002661e:	85 c0                	test   %eax,%eax
c0026620:	74 1e                	je     c0026640 <intq_full+0x2d>
c0026622:	83 ec 0c             	sub    $0xc,%esp
c0026625:	68 14 04 03 c0       	push   $0xc0030414
c002662a:	68 32 04 03 c0       	push   $0xc0030432
c002662f:	68 34 05 03 c0       	push   $0xc0030534
c0026634:	6a 1e                	push   $0x1e
c0026636:	68 49 04 03 c0       	push   $0xc0030449
c002663b:	e8 f1 2f 00 00       	call   c0029631 <debug_panic>
  return next (q->head) == q->tail;
c0026640:	8b 45 08             	mov    0x8(%ebp),%eax
c0026643:	8b 40 60             	mov    0x60(%eax),%eax
c0026646:	83 ec 0c             	sub    $0xc,%esp
c0026649:	50                   	push   %eax
c002664a:	e8 d9 01 00 00       	call   c0026828 <next>
c002664f:	83 c4 10             	add    $0x10,%esp
c0026652:	89 c2                	mov    %eax,%edx
c0026654:	8b 45 08             	mov    0x8(%ebp),%eax
c0026657:	8b 40 64             	mov    0x64(%eax),%eax
c002665a:	39 c2                	cmp    %eax,%edx
c002665c:	0f 94 c0             	sete   %al
}
c002665f:	c9                   	leave  
c0026660:	c3                   	ret    

c0026661 <intq_getc>:
/* Removes a byte from Q and returns it.
   If Q is empty, sleeps until a byte is added.
   When called from an interrupt handler, Q must not be empty. */
uint8_t
intq_getc (struct intq *q) 
{
c0026661:	55                   	push   %ebp
c0026662:	89 e5                	mov    %esp,%ebp
c0026664:	83 ec 18             	sub    $0x18,%esp
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
c0026667:	e8 cd ac ff ff       	call   c0021339 <intr_get_level>
c002666c:	85 c0                	test   %eax,%eax
c002666e:	74 7b                	je     c00266eb <intq_getc+0x8a>
c0026670:	83 ec 0c             	sub    $0xc,%esp
c0026673:	68 14 04 03 c0       	push   $0xc0030414
c0026678:	68 32 04 03 c0       	push   $0xc0030432
c002667d:	68 40 05 03 c0       	push   $0xc0030540
c0026682:	6a 2a                	push   $0x2a
c0026684:	68 49 04 03 c0       	push   $0xc0030449
c0026689:	e8 a3 2f 00 00       	call   c0029631 <debug_panic>
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
c002668e:	e8 ea af ff ff       	call   c002167d <intr_context>
c0026693:	83 f0 01             	xor    $0x1,%eax
c0026696:	84 c0                	test   %al,%al
c0026698:	75 1e                	jne    c00266b8 <intq_getc+0x57>
c002669a:	83 ec 0c             	sub    $0xc,%esp
c002669d:	68 5e 04 03 c0       	push   $0xc003045e
c00266a2:	68 32 04 03 c0       	push   $0xc0030432
c00266a7:	68 40 05 03 c0       	push   $0xc0030540
c00266ac:	6a 2d                	push   $0x2d
c00266ae:	68 49 04 03 c0       	push   $0xc0030449
c00266b3:	e8 79 2f 00 00       	call   c0029631 <debug_panic>
      lock_acquire (&q->lock);
c00266b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00266bb:	83 ec 0c             	sub    $0xc,%esp
c00266be:	50                   	push   %eax
c00266bf:	e8 fe c3 ff ff       	call   c0022ac2 <lock_acquire>
c00266c4:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_empty);
c00266c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00266ca:	83 c0 1c             	add    $0x1c,%eax
c00266cd:	83 ec 08             	sub    $0x8,%esp
c00266d0:	50                   	push   %eax
c00266d1:	ff 75 08             	pushl  0x8(%ebp)
c00266d4:	e8 6b 01 00 00       	call   c0026844 <wait>
c00266d9:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c00266dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00266df:	83 ec 0c             	sub    $0xc,%esp
c00266e2:	50                   	push   %eax
c00266e3:	e8 1b c5 ff ff       	call   c0022c03 <lock_release>
c00266e8:	83 c4 10             	add    $0x10,%esp
intq_getc (struct intq *q) 
{
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
  while (intq_empty (q)) 
c00266eb:	83 ec 0c             	sub    $0xc,%esp
c00266ee:	ff 75 08             	pushl  0x8(%ebp)
c00266f1:	e8 dd fe ff ff       	call   c00265d3 <intq_empty>
c00266f6:	83 c4 10             	add    $0x10,%esp
c00266f9:	84 c0                	test   %al,%al
c00266fb:	75 91                	jne    c002668e <intq_getc+0x2d>
      lock_acquire (&q->lock);
      wait (q, &q->not_empty);
      lock_release (&q->lock);
    }
  
  byte = q->buf[q->tail];
c00266fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0026700:	8b 40 64             	mov    0x64(%eax),%eax
c0026703:	8b 55 08             	mov    0x8(%ebp),%edx
c0026706:	0f b6 44 02 20       	movzbl 0x20(%edx,%eax,1),%eax
c002670b:	88 45 f7             	mov    %al,-0x9(%ebp)
  q->tail = next (q->tail);
c002670e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026711:	8b 40 64             	mov    0x64(%eax),%eax
c0026714:	83 ec 0c             	sub    $0xc,%esp
c0026717:	50                   	push   %eax
c0026718:	e8 0b 01 00 00       	call   c0026828 <next>
c002671d:	83 c4 10             	add    $0x10,%esp
c0026720:	89 c2                	mov    %eax,%edx
c0026722:	8b 45 08             	mov    0x8(%ebp),%eax
c0026725:	89 50 64             	mov    %edx,0x64(%eax)
  signal (q, &q->not_full);
c0026728:	8b 45 08             	mov    0x8(%ebp),%eax
c002672b:	83 c0 18             	add    $0x18,%eax
c002672e:	83 ec 08             	sub    $0x8,%esp
c0026731:	50                   	push   %eax
c0026732:	ff 75 08             	pushl  0x8(%ebp)
c0026735:	e8 cd 01 00 00       	call   c0026907 <signal>
c002673a:	83 c4 10             	add    $0x10,%esp
  return byte;
c002673d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c0026741:	c9                   	leave  
c0026742:	c3                   	ret    

c0026743 <intq_putc>:
/* Adds BYTE to the end of Q.
   If Q is full, sleeps until a byte is removed.
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
c0026743:	55                   	push   %ebp
c0026744:	89 e5                	mov    %esp,%ebp
c0026746:	83 ec 18             	sub    $0x18,%esp
c0026749:	8b 45 0c             	mov    0xc(%ebp),%eax
c002674c:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c002674f:	e8 e5 ab ff ff       	call   c0021339 <intr_get_level>
c0026754:	85 c0                	test   %eax,%eax
c0026756:	74 7b                	je     c00267d3 <intq_putc+0x90>
c0026758:	83 ec 0c             	sub    $0xc,%esp
c002675b:	68 14 04 03 c0       	push   $0xc0030414
c0026760:	68 32 04 03 c0       	push   $0xc0030432
c0026765:	68 4c 05 03 c0       	push   $0xc003054c
c002676a:	6a 3f                	push   $0x3f
c002676c:	68 49 04 03 c0       	push   $0xc0030449
c0026771:	e8 bb 2e 00 00       	call   c0029631 <debug_panic>
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
c0026776:	e8 02 af ff ff       	call   c002167d <intr_context>
c002677b:	83 f0 01             	xor    $0x1,%eax
c002677e:	84 c0                	test   %al,%al
c0026780:	75 1e                	jne    c00267a0 <intq_putc+0x5d>
c0026782:	83 ec 0c             	sub    $0xc,%esp
c0026785:	68 5e 04 03 c0       	push   $0xc003045e
c002678a:	68 32 04 03 c0       	push   $0xc0030432
c002678f:	68 4c 05 03 c0       	push   $0xc003054c
c0026794:	6a 42                	push   $0x42
c0026796:	68 49 04 03 c0       	push   $0xc0030449
c002679b:	e8 91 2e 00 00       	call   c0029631 <debug_panic>
      lock_acquire (&q->lock);
c00267a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00267a3:	83 ec 0c             	sub    $0xc,%esp
c00267a6:	50                   	push   %eax
c00267a7:	e8 16 c3 ff ff       	call   c0022ac2 <lock_acquire>
c00267ac:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_full);
c00267af:	8b 45 08             	mov    0x8(%ebp),%eax
c00267b2:	83 c0 18             	add    $0x18,%eax
c00267b5:	83 ec 08             	sub    $0x8,%esp
c00267b8:	50                   	push   %eax
c00267b9:	ff 75 08             	pushl  0x8(%ebp)
c00267bc:	e8 83 00 00 00       	call   c0026844 <wait>
c00267c1:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c00267c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00267c7:	83 ec 0c             	sub    $0xc,%esp
c00267ca:	50                   	push   %eax
c00267cb:	e8 33 c4 ff ff       	call   c0022c03 <lock_release>
c00267d0:	83 c4 10             	add    $0x10,%esp
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
  ASSERT (intr_get_level () == INTR_OFF);
  while (intq_full (q))
c00267d3:	83 ec 0c             	sub    $0xc,%esp
c00267d6:	ff 75 08             	pushl  0x8(%ebp)
c00267d9:	e8 35 fe ff ff       	call   c0026613 <intq_full>
c00267de:	83 c4 10             	add    $0x10,%esp
c00267e1:	84 c0                	test   %al,%al
c00267e3:	75 91                	jne    c0026776 <intq_putc+0x33>
      lock_acquire (&q->lock);
      wait (q, &q->not_full);
      lock_release (&q->lock);
    }

  q->buf[q->head] = byte;
c00267e5:	8b 45 08             	mov    0x8(%ebp),%eax
c00267e8:	8b 40 60             	mov    0x60(%eax),%eax
c00267eb:	8b 55 08             	mov    0x8(%ebp),%edx
c00267ee:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c00267f2:	88 4c 02 20          	mov    %cl,0x20(%edx,%eax,1)
  q->head = next (q->head);
c00267f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00267f9:	8b 40 60             	mov    0x60(%eax),%eax
c00267fc:	83 ec 0c             	sub    $0xc,%esp
c00267ff:	50                   	push   %eax
c0026800:	e8 23 00 00 00       	call   c0026828 <next>
c0026805:	83 c4 10             	add    $0x10,%esp
c0026808:	89 c2                	mov    %eax,%edx
c002680a:	8b 45 08             	mov    0x8(%ebp),%eax
c002680d:	89 50 60             	mov    %edx,0x60(%eax)
  signal (q, &q->not_empty);
c0026810:	8b 45 08             	mov    0x8(%ebp),%eax
c0026813:	83 c0 1c             	add    $0x1c,%eax
c0026816:	83 ec 08             	sub    $0x8,%esp
c0026819:	50                   	push   %eax
c002681a:	ff 75 08             	pushl  0x8(%ebp)
c002681d:	e8 e5 00 00 00       	call   c0026907 <signal>
c0026822:	83 c4 10             	add    $0x10,%esp
}
c0026825:	90                   	nop
c0026826:	c9                   	leave  
c0026827:	c3                   	ret    

c0026828 <next>:

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
c0026828:	55                   	push   %ebp
c0026829:	89 e5                	mov    %esp,%ebp
  return (pos + 1) % INTQ_BUFSIZE;
c002682b:	8b 45 08             	mov    0x8(%ebp),%eax
c002682e:	8d 50 01             	lea    0x1(%eax),%edx
c0026831:	89 d0                	mov    %edx,%eax
c0026833:	c1 f8 1f             	sar    $0x1f,%eax
c0026836:	c1 e8 1a             	shr    $0x1a,%eax
c0026839:	01 c2                	add    %eax,%edx
c002683b:	83 e2 3f             	and    $0x3f,%edx
c002683e:	29 c2                	sub    %eax,%edx
c0026840:	89 d0                	mov    %edx,%eax
}
c0026842:	5d                   	pop    %ebp
c0026843:	c3                   	ret    

c0026844 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c0026844:	55                   	push   %ebp
c0026845:	89 e5                	mov    %esp,%ebp
c0026847:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c002684a:	e8 2e ae ff ff       	call   c002167d <intr_context>
c002684f:	83 f0 01             	xor    $0x1,%eax
c0026852:	84 c0                	test   %al,%al
c0026854:	75 1e                	jne    c0026874 <wait+0x30>
c0026856:	83 ec 0c             	sub    $0xc,%esp
c0026859:	68 5e 04 03 c0       	push   $0xc003045e
c002685e:	68 32 04 03 c0       	push   $0xc0030432
c0026863:	68 58 05 03 c0       	push   $0xc0030558
c0026868:	6a 59                	push   $0x59
c002686a:	68 49 04 03 c0       	push   $0xc0030449
c002686f:	e8 bd 2d 00 00       	call   c0029631 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0026874:	e8 c0 aa ff ff       	call   c0021339 <intr_get_level>
c0026879:	85 c0                	test   %eax,%eax
c002687b:	74 1e                	je     c002689b <wait+0x57>
c002687d:	83 ec 0c             	sub    $0xc,%esp
c0026880:	68 14 04 03 c0       	push   $0xc0030414
c0026885:	68 32 04 03 c0       	push   $0xc0030432
c002688a:	68 58 05 03 c0       	push   $0xc0030558
c002688f:	6a 5a                	push   $0x5a
c0026891:	68 49 04 03 c0       	push   $0xc0030449
c0026896:	e8 96 2d 00 00       	call   c0029631 <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c002689b:	8b 45 08             	mov    0x8(%ebp),%eax
c002689e:	83 c0 1c             	add    $0x1c,%eax
c00268a1:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00268a4:	75 12                	jne    c00268b8 <wait+0x74>
c00268a6:	83 ec 0c             	sub    $0xc,%esp
c00268a9:	ff 75 08             	pushl  0x8(%ebp)
c00268ac:	e8 22 fd ff ff       	call   c00265d3 <intq_empty>
c00268b1:	83 c4 10             	add    $0x10,%esp
c00268b4:	84 c0                	test   %al,%al
c00268b6:	75 3b                	jne    c00268f3 <wait+0xaf>
c00268b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00268bb:	83 c0 18             	add    $0x18,%eax
c00268be:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00268c1:	75 12                	jne    c00268d5 <wait+0x91>
c00268c3:	83 ec 0c             	sub    $0xc,%esp
c00268c6:	ff 75 08             	pushl  0x8(%ebp)
c00268c9:	e8 45 fd ff ff       	call   c0026613 <intq_full>
c00268ce:	83 c4 10             	add    $0x10,%esp
c00268d1:	84 c0                	test   %al,%al
c00268d3:	75 1e                	jne    c00268f3 <wait+0xaf>
c00268d5:	83 ec 0c             	sub    $0xc,%esp
c00268d8:	68 70 04 03 c0       	push   $0xc0030470
c00268dd:	68 32 04 03 c0       	push   $0xc0030432
c00268e2:	68 58 05 03 c0       	push   $0xc0030558
c00268e7:	6a 5c                	push   $0x5c
c00268e9:	68 49 04 03 c0       	push   $0xc0030449
c00268ee:	e8 3e 2d 00 00       	call   c0029631 <debug_panic>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c00268f3:	e8 89 a3 ff ff       	call   c0020c81 <thread_current>
c00268f8:	89 c2                	mov    %eax,%edx
c00268fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c00268fd:	89 10                	mov    %edx,(%eax)
  thread_block ();
c00268ff:	e8 5d a2 ff ff       	call   c0020b61 <thread_block>
}
c0026904:	90                   	nop
c0026905:	c9                   	leave  
c0026906:	c3                   	ret    

c0026907 <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c0026907:	55                   	push   %ebp
c0026908:	89 e5                	mov    %esp,%ebp
c002690a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c002690d:	e8 27 aa ff ff       	call   c0021339 <intr_get_level>
c0026912:	85 c0                	test   %eax,%eax
c0026914:	74 1e                	je     c0026934 <signal+0x2d>
c0026916:	83 ec 0c             	sub    $0xc,%esp
c0026919:	68 14 04 03 c0       	push   $0xc0030414
c002691e:	68 32 04 03 c0       	push   $0xc0030432
c0026923:	68 60 05 03 c0       	push   $0xc0030560
c0026928:	6a 69                	push   $0x69
c002692a:	68 49 04 03 c0       	push   $0xc0030449
c002692f:	e8 fd 2c 00 00       	call   c0029631 <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0026934:	8b 45 08             	mov    0x8(%ebp),%eax
c0026937:	83 c0 1c             	add    $0x1c,%eax
c002693a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002693d:	75 15                	jne    c0026954 <signal+0x4d>
c002693f:	83 ec 0c             	sub    $0xc,%esp
c0026942:	ff 75 08             	pushl  0x8(%ebp)
c0026945:	e8 89 fc ff ff       	call   c00265d3 <intq_empty>
c002694a:	83 c4 10             	add    $0x10,%esp
c002694d:	83 f0 01             	xor    $0x1,%eax
c0026950:	84 c0                	test   %al,%al
c0026952:	75 3e                	jne    c0026992 <signal+0x8b>
c0026954:	8b 45 08             	mov    0x8(%ebp),%eax
c0026957:	83 c0 18             	add    $0x18,%eax
c002695a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002695d:	75 15                	jne    c0026974 <signal+0x6d>
c002695f:	83 ec 0c             	sub    $0xc,%esp
c0026962:	ff 75 08             	pushl  0x8(%ebp)
c0026965:	e8 a9 fc ff ff       	call   c0026613 <intq_full>
c002696a:	83 c4 10             	add    $0x10,%esp
c002696d:	83 f0 01             	xor    $0x1,%eax
c0026970:	84 c0                	test   %al,%al
c0026972:	75 1e                	jne    c0026992 <signal+0x8b>
c0026974:	83 ec 0c             	sub    $0xc,%esp
c0026977:	68 cc 04 03 c0       	push   $0xc00304cc
c002697c:	68 32 04 03 c0       	push   $0xc0030432
c0026981:	68 60 05 03 c0       	push   $0xc0030560
c0026986:	6a 6b                	push   $0x6b
c0026988:	68 49 04 03 c0       	push   $0xc0030449
c002698d:	e8 9f 2c 00 00       	call   c0029631 <debug_panic>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c0026992:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026995:	8b 00                	mov    (%eax),%eax
c0026997:	85 c0                	test   %eax,%eax
c0026999:	74 1a                	je     c00269b5 <signal+0xae>
    {
      thread_unblock (*waiter);
c002699b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002699e:	8b 00                	mov    (%eax),%eax
c00269a0:	83 ec 0c             	sub    $0xc,%esp
c00269a3:	50                   	push   %eax
c00269a4:	e8 29 a2 ff ff       	call   c0020bd2 <thread_unblock>
c00269a9:	83 c4 10             	add    $0x10,%esp
      *waiter = NULL;
c00269ac:	8b 45 0c             	mov    0xc(%ebp),%eax
c00269af:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c00269b5:	90                   	nop
c00269b6:	c9                   	leave  
c00269b7:	c3                   	ret    

c00269b8 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c00269b8:	55                   	push   %ebp
c00269b9:	89 e5                	mov    %esp,%ebp
c00269bb:	83 ec 14             	sub    $0x14,%esp
c00269be:	8b 45 08             	mov    0x8(%ebp),%eax
c00269c1:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00269c5:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00269c9:	89 c2                	mov    %eax,%edx
c00269cb:	ec                   	in     (%dx),%al
c00269cc:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00269cf:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c00269d3:	c9                   	leave  
c00269d4:	c3                   	ret    

c00269d5 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c00269d5:	55                   	push   %ebp
c00269d6:	89 e5                	mov    %esp,%ebp
c00269d8:	83 ec 08             	sub    $0x8,%esp
c00269db:	8b 55 08             	mov    0x8(%ebp),%edx
c00269de:	8b 45 0c             	mov    0xc(%ebp),%eax
c00269e1:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00269e5:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00269e8:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00269ec:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00269f0:	ee                   	out    %al,(%dx)
}
c00269f1:	90                   	nop
c00269f2:	c9                   	leave  
c00269f3:	c3                   	ret    

c00269f4 <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c00269f4:	55                   	push   %ebp
c00269f5:	89 e5                	mov    %esp,%ebp
c00269f7:	83 ec 28             	sub    $0x28,%esp
     but for historical reasons everyone always uses BCD format
     except on obscure non-PC platforms, so we don't bother
     trying to detect the format in use. */
  do
    {
      sec = bcd_to_bin (cmos_read (RTC_REG_SEC));
c00269fa:	83 ec 0c             	sub    $0xc,%esp
c00269fd:	6a 00                	push   $0x0
c00269ff:	e8 ae 01 00 00       	call   c0026bb2 <cmos_read>
c0026a04:	83 c4 10             	add    $0x10,%esp
c0026a07:	0f b6 c0             	movzbl %al,%eax
c0026a0a:	83 ec 0c             	sub    $0xc,%esp
c0026a0d:	50                   	push   %eax
c0026a0e:	e8 73 01 00 00       	call   c0026b86 <bcd_to_bin>
c0026a13:	83 c4 10             	add    $0x10,%esp
c0026a16:	89 45 e8             	mov    %eax,-0x18(%ebp)
      min = bcd_to_bin (cmos_read (RTC_REG_MIN));
c0026a19:	83 ec 0c             	sub    $0xc,%esp
c0026a1c:	6a 02                	push   $0x2
c0026a1e:	e8 8f 01 00 00       	call   c0026bb2 <cmos_read>
c0026a23:	83 c4 10             	add    $0x10,%esp
c0026a26:	0f b6 c0             	movzbl %al,%eax
c0026a29:	83 ec 0c             	sub    $0xc,%esp
c0026a2c:	50                   	push   %eax
c0026a2d:	e8 54 01 00 00       	call   c0026b86 <bcd_to_bin>
c0026a32:	83 c4 10             	add    $0x10,%esp
c0026a35:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      hour = bcd_to_bin (cmos_read (RTC_REG_HOUR));
c0026a38:	83 ec 0c             	sub    $0xc,%esp
c0026a3b:	6a 04                	push   $0x4
c0026a3d:	e8 70 01 00 00       	call   c0026bb2 <cmos_read>
c0026a42:	83 c4 10             	add    $0x10,%esp
c0026a45:	0f b6 c0             	movzbl %al,%eax
c0026a48:	83 ec 0c             	sub    $0xc,%esp
c0026a4b:	50                   	push   %eax
c0026a4c:	e8 35 01 00 00       	call   c0026b86 <bcd_to_bin>
c0026a51:	83 c4 10             	add    $0x10,%esp
c0026a54:	89 45 e0             	mov    %eax,-0x20(%ebp)
      mday = bcd_to_bin (cmos_read (RTC_REG_MDAY));
c0026a57:	83 ec 0c             	sub    $0xc,%esp
c0026a5a:	6a 07                	push   $0x7
c0026a5c:	e8 51 01 00 00       	call   c0026bb2 <cmos_read>
c0026a61:	83 c4 10             	add    $0x10,%esp
c0026a64:	0f b6 c0             	movzbl %al,%eax
c0026a67:	83 ec 0c             	sub    $0xc,%esp
c0026a6a:	50                   	push   %eax
c0026a6b:	e8 16 01 00 00       	call   c0026b86 <bcd_to_bin>
c0026a70:	83 c4 10             	add    $0x10,%esp
c0026a73:	89 45 dc             	mov    %eax,-0x24(%ebp)
      mon = bcd_to_bin (cmos_read (RTC_REG_MON));
c0026a76:	83 ec 0c             	sub    $0xc,%esp
c0026a79:	6a 08                	push   $0x8
c0026a7b:	e8 32 01 00 00       	call   c0026bb2 <cmos_read>
c0026a80:	83 c4 10             	add    $0x10,%esp
c0026a83:	0f b6 c0             	movzbl %al,%eax
c0026a86:	83 ec 0c             	sub    $0xc,%esp
c0026a89:	50                   	push   %eax
c0026a8a:	e8 f7 00 00 00       	call   c0026b86 <bcd_to_bin>
c0026a8f:	83 c4 10             	add    $0x10,%esp
c0026a92:	89 45 d8             	mov    %eax,-0x28(%ebp)
      year = bcd_to_bin (cmos_read (RTC_REG_YEAR));
c0026a95:	83 ec 0c             	sub    $0xc,%esp
c0026a98:	6a 09                	push   $0x9
c0026a9a:	e8 13 01 00 00       	call   c0026bb2 <cmos_read>
c0026a9f:	83 c4 10             	add    $0x10,%esp
c0026aa2:	0f b6 c0             	movzbl %al,%eax
c0026aa5:	83 ec 0c             	sub    $0xc,%esp
c0026aa8:	50                   	push   %eax
c0026aa9:	e8 d8 00 00 00       	call   c0026b86 <bcd_to_bin>
c0026aae:	83 c4 10             	add    $0x10,%esp
c0026ab1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c0026ab4:	83 ec 0c             	sub    $0xc,%esp
c0026ab7:	6a 00                	push   $0x0
c0026ab9:	e8 f4 00 00 00       	call   c0026bb2 <cmos_read>
c0026abe:	83 c4 10             	add    $0x10,%esp
c0026ac1:	0f b6 c0             	movzbl %al,%eax
c0026ac4:	83 ec 0c             	sub    $0xc,%esp
c0026ac7:	50                   	push   %eax
c0026ac8:	e8 b9 00 00 00       	call   c0026b86 <bcd_to_bin>
c0026acd:	83 c4 10             	add    $0x10,%esp
c0026ad0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0026ad3:	0f 85 21 ff ff ff    	jne    c00269fa <rtc_get_time+0x6>

  /* Translate years-since-1900 into years-since-1970.
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
c0026ad9:	83 7d f4 45          	cmpl   $0x45,-0xc(%ebp)
c0026add:	7f 04                	jg     c0026ae3 <rtc_get_time+0xef>
    year += 100;
c0026adf:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
  year -= 70;
c0026ae3:	83 6d f4 46          	subl   $0x46,-0xc(%ebp)

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0026ae7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026aea:	69 d0 6d 01 00 00    	imul   $0x16d,%eax,%edx
c0026af0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026af3:	83 e8 01             	sub    $0x1,%eax
c0026af6:	8d 48 03             	lea    0x3(%eax),%ecx
c0026af9:	85 c0                	test   %eax,%eax
c0026afb:	0f 48 c1             	cmovs  %ecx,%eax
c0026afe:	c1 f8 02             	sar    $0x2,%eax
c0026b01:	01 d0                	add    %edx,%eax
c0026b03:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c0026b09:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c0026b0c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c0026b13:	eb 1a                	jmp    c0026b2f <rtc_get_time+0x13b>
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0026b15:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026b18:	83 e8 01             	sub    $0x1,%eax
c0026b1b:	8b 04 85 80 05 03 c0 	mov    -0x3ffcfa80(,%eax,4),%eax
c0026b22:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c0026b28:	01 45 f0             	add    %eax,-0x10(%ebp)
    year += 100;
  year -= 70;

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
  for (i = 1; i <= mon; i++)
c0026b2b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0026b2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026b32:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0026b35:	7e de                	jle    c0026b15 <rtc_get_time+0x121>
    time += days_per_month[i - 1] * 24 * 60 * 60;
  if (mon > 2 && year % 4 == 0)
c0026b37:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
c0026b3b:	7e 11                	jle    c0026b4e <rtc_get_time+0x15a>
c0026b3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026b40:	83 e0 03             	and    $0x3,%eax
c0026b43:	85 c0                	test   %eax,%eax
c0026b45:	75 07                	jne    c0026b4e <rtc_get_time+0x15a>
    time += 24 * 60 * 60;
c0026b47:	81 45 f0 80 51 01 00 	addl   $0x15180,-0x10(%ebp)
  time += (mday - 1) * 24 * 60 * 60;
c0026b4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0026b51:	83 e8 01             	sub    $0x1,%eax
c0026b54:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c0026b5a:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += hour * 60 * 60;
c0026b5d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0026b60:	69 c0 10 0e 00 00    	imul   $0xe10,%eax,%eax
c0026b66:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += min * 60;
c0026b69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0026b6c:	c1 e0 02             	shl    $0x2,%eax
c0026b6f:	89 c2                	mov    %eax,%edx
c0026b71:	c1 e2 04             	shl    $0x4,%edx
c0026b74:	29 c2                	sub    %eax,%edx
c0026b76:	89 d0                	mov    %edx,%eax
c0026b78:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += sec;
c0026b7b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0026b7e:	01 45 f0             	add    %eax,-0x10(%ebp)

  return time;
c0026b81:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0026b84:	c9                   	leave  
c0026b85:	c3                   	ret    

c0026b86 <bcd_to_bin>:

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
c0026b86:	55                   	push   %ebp
c0026b87:	89 e5                	mov    %esp,%ebp
c0026b89:	83 ec 04             	sub    $0x4,%esp
c0026b8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b8f:	88 45 fc             	mov    %al,-0x4(%ebp)
  return (x & 0x0f) + ((x >> 4) * 10);
c0026b92:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026b96:	83 e0 0f             	and    $0xf,%eax
c0026b99:	89 c1                	mov    %eax,%ecx
c0026b9b:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026b9f:	c0 e8 04             	shr    $0x4,%al
c0026ba2:	0f b6 d0             	movzbl %al,%edx
c0026ba5:	89 d0                	mov    %edx,%eax
c0026ba7:	c1 e0 02             	shl    $0x2,%eax
c0026baa:	01 d0                	add    %edx,%eax
c0026bac:	01 c0                	add    %eax,%eax
c0026bae:	01 c8                	add    %ecx,%eax
}
c0026bb0:	c9                   	leave  
c0026bb1:	c3                   	ret    

c0026bb2 <cmos_read>:

/* Reads a byte from the CMOS register with the given INDEX and
   returns the byte read. */
static uint8_t
cmos_read (uint8_t index)
{
c0026bb2:	55                   	push   %ebp
c0026bb3:	89 e5                	mov    %esp,%ebp
c0026bb5:	83 ec 04             	sub    $0x4,%esp
c0026bb8:	8b 45 08             	mov    0x8(%ebp),%eax
c0026bbb:	88 45 fc             	mov    %al,-0x4(%ebp)
  outb (CMOS_REG_SET, index);
c0026bbe:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026bc2:	50                   	push   %eax
c0026bc3:	6a 70                	push   $0x70
c0026bc5:	e8 0b fe ff ff       	call   c00269d5 <outb>
c0026bca:	83 c4 08             	add    $0x8,%esp
  return inb (CMOS_REG_IO);
c0026bcd:	6a 71                	push   $0x71
c0026bcf:	e8 e4 fd ff ff       	call   c00269b8 <inb>
c0026bd4:	83 c4 04             	add    $0x4,%esp
}
c0026bd7:	c9                   	leave  
c0026bd8:	c3                   	ret    

c0026bd9 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0026bd9:	55                   	push   %ebp
c0026bda:	89 e5                	mov    %esp,%ebp
c0026bdc:	83 ec 14             	sub    $0x14,%esp
c0026bdf:	8b 45 08             	mov    0x8(%ebp),%eax
c0026be2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026be6:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0026bea:	89 c2                	mov    %eax,%edx
c0026bec:	ec                   	in     (%dx),%al
c0026bed:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026bf0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0026bf4:	c9                   	leave  
c0026bf5:	c3                   	ret    

c0026bf6 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0026bf6:	55                   	push   %ebp
c0026bf7:	89 e5                	mov    %esp,%ebp
c0026bf9:	83 ec 08             	sub    $0x8,%esp
c0026bfc:	8b 55 08             	mov    0x8(%ebp),%edx
c0026bff:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026c02:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026c06:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026c09:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0026c0d:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0026c11:	ee                   	out    %al,(%dx)
}
c0026c12:	90                   	nop
c0026c13:	c9                   	leave  
c0026c14:	c3                   	ret    

c0026c15 <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c0026c15:	55                   	push   %ebp
c0026c16:	89 e5                	mov    %esp,%ebp
c0026c18:	83 ec 08             	sub    $0x8,%esp
c0026c1b:	8b 55 08             	mov    0x8(%ebp),%edx
c0026c1e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026c21:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026c25:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026c29:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c0026c2d:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0026c31:	66 ef                	out    %ax,(%dx)
}
c0026c33:	90                   	nop
c0026c34:	c9                   	leave  
c0026c35:	c3                   	ret    

c0026c36 <shutdown>:
/* Shuts down the machine in the way configured by
   shutdown_configure().  If the shutdown type is SHUTDOWN_NONE
   (which is the default), returns without doing anything. */
void
shutdown (void)
{
c0026c36:	55                   	push   %ebp
c0026c37:	89 e5                	mov    %esp,%ebp
c0026c39:	83 ec 08             	sub    $0x8,%esp
  switch (how)
c0026c3c:	a1 c8 9a 03 c0       	mov    0xc0039ac8,%eax
c0026c41:	83 f8 01             	cmp    $0x1,%eax
c0026c44:	74 07                	je     c0026c4d <shutdown+0x17>
c0026c46:	83 f8 02             	cmp    $0x2,%eax
c0026c49:	74 07                	je     c0026c52 <shutdown+0x1c>
      shutdown_reboot ();
      break;

    default:
      /* Nothing to do. */
      break;
c0026c4b:	eb 0a                	jmp    c0026c57 <shutdown+0x21>
shutdown (void)
{
  switch (how)
    {
    case SHUTDOWN_POWER_OFF:
      shutdown_power_off ();
c0026c4d:	e8 9d 00 00 00       	call   c0026cef <shutdown_power_off>
      break;

    case SHUTDOWN_REBOOT:
      shutdown_reboot ();
c0026c52:	e8 11 00 00 00       	call   c0026c68 <shutdown_reboot>

    default:
      /* Nothing to do. */
      break;
    }
}
c0026c57:	90                   	nop
c0026c58:	c9                   	leave  
c0026c59:	c3                   	ret    

c0026c5a <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c0026c5a:	55                   	push   %ebp
c0026c5b:	89 e5                	mov    %esp,%ebp
  how = type;
c0026c5d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026c60:	a3 c8 9a 03 c0       	mov    %eax,0xc0039ac8
}
c0026c65:	90                   	nop
c0026c66:	5d                   	pop    %ebp
c0026c67:	c3                   	ret    

c0026c68 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c0026c68:	55                   	push   %ebp
c0026c69:	89 e5                	mov    %esp,%ebp
c0026c6b:	83 ec 18             	sub    $0x18,%esp
  printf ("Rebooting...\n");
c0026c6e:	83 ec 0c             	sub    $0xc,%esp
c0026c71:	68 b0 05 03 c0       	push   $0xc00305b0
c0026c76:	e8 69 4b 00 00       	call   c002b7e4 <puts>
c0026c7b:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c0026c7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026c85:	eb 2a                	jmp    c0026cb1 <shutdown_reboot+0x49>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026c87:	83 ec 0c             	sub    $0xc,%esp
c0026c8a:	6a 64                	push   $0x64
c0026c8c:	e8 48 ff ff ff       	call   c0026bd9 <inb>
c0026c91:	83 c4 10             	add    $0x10,%esp
c0026c94:	0f b6 c0             	movzbl %al,%eax
c0026c97:	83 e0 02             	and    $0x2,%eax
c0026c9a:	85 c0                	test   %eax,%eax
c0026c9c:	74 1e                	je     c0026cbc <shutdown_reboot+0x54>
            break;
          timer_udelay (2);
c0026c9e:	83 ec 08             	sub    $0x8,%esp
c0026ca1:	6a 00                	push   $0x0
c0026ca3:	6a 02                	push   $0x2
c0026ca5:	e8 93 d1 ff ff       	call   c0023e3d <timer_udelay>
c0026caa:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c0026cad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0026cb1:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
c0026cb8:	7e cd                	jle    c0026c87 <shutdown_reboot+0x1f>
c0026cba:	eb 01                	jmp    c0026cbd <shutdown_reboot+0x55>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
            break;
c0026cbc:	90                   	nop
          timer_udelay (2);
        }

      timer_udelay (50);
c0026cbd:	83 ec 08             	sub    $0x8,%esp
c0026cc0:	6a 00                	push   $0x0
c0026cc2:	6a 32                	push   $0x32
c0026cc4:	e8 74 d1 ff ff       	call   c0023e3d <timer_udelay>
c0026cc9:	83 c4 10             	add    $0x10,%esp

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
c0026ccc:	83 ec 08             	sub    $0x8,%esp
c0026ccf:	68 fe 00 00 00       	push   $0xfe
c0026cd4:	6a 64                	push   $0x64
c0026cd6:	e8 1b ff ff ff       	call   c0026bf6 <outb>
c0026cdb:	83 c4 10             	add    $0x10,%esp
      timer_udelay (50);
c0026cde:	83 ec 08             	sub    $0x8,%esp
c0026ce1:	6a 00                	push   $0x0
c0026ce3:	6a 32                	push   $0x32
c0026ce5:	e8 53 d1 ff ff       	call   c0023e3d <timer_udelay>
c0026cea:	83 c4 10             	add    $0x10,%esp
    }
c0026ced:	eb 8f                	jmp    c0026c7e <shutdown_reboot+0x16>

c0026cef <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c0026cef:	55                   	push   %ebp
c0026cf0:	89 e5                	mov    %esp,%ebp
c0026cf2:	83 ec 18             	sub    $0x18,%esp
  const char s[] = "Shutdown";
c0026cf5:	c7 45 eb 53 68 75 74 	movl   $0x74756853,-0x15(%ebp)
c0026cfc:	c7 45 ef 64 6f 77 6e 	movl   $0x6e776f64,-0x11(%ebp)
c0026d03:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)

#ifdef FILESYS
  filesys_done ();
#endif

  print_stats ();
c0026d07:	e8 80 00 00 00       	call   c0026d8c <print_stats>

  printf ("Powering off...\n");
c0026d0c:	83 ec 0c             	sub    $0xc,%esp
c0026d0f:	68 bd 05 03 c0       	push   $0xc00305bd
c0026d14:	e8 cb 4a 00 00       	call   c002b7e4 <puts>
c0026d19:	83 c4 10             	add    $0x10,%esp
  serial_flush ();
c0026d1c:	e8 81 dd ff ff       	call   c0024aa2 <serial_flush>

  /* ACPI power-off */
  outw (0xB004, 0x2000);
c0026d21:	83 ec 08             	sub    $0x8,%esp
c0026d24:	68 00 20 00 00       	push   $0x2000
c0026d29:	68 04 b0 00 00       	push   $0xb004
c0026d2e:	e8 e2 fe ff ff       	call   c0026c15 <outw>
c0026d33:	83 c4 10             	add    $0x10,%esp

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c0026d36:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0026d39:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0026d3c:	eb 1e                	jmp    c0026d5c <shutdown_power_off+0x6d>
    outb (0x8900, *p);
c0026d3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026d41:	0f b6 00             	movzbl (%eax),%eax
c0026d44:	0f b6 c0             	movzbl %al,%eax
c0026d47:	83 ec 08             	sub    $0x8,%esp
c0026d4a:	50                   	push   %eax
c0026d4b:	68 00 89 00 00       	push   $0x8900
c0026d50:	e8 a1 fe ff ff       	call   c0026bf6 <outb>
c0026d55:	83 c4 10             	add    $0x10,%esp
  /* ACPI power-off */
  outw (0xB004, 0x2000);

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c0026d58:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0026d5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026d5f:	0f b6 00             	movzbl (%eax),%eax
c0026d62:	84 c0                	test   %al,%al
c0026d64:	75 d8                	jne    c0026d3e <shutdown_power_off+0x4f>
  /* For newer versions of qemu, you must run with -device
   * isa-debug-exit, which exits on any write to an IO port (by
   * default 0x501).  Qemu's exit code is double the value plus one,
   * so there is no way to exit cleanly.  We use 0x31 which should
   * result in a qemu exit code of 0x63.  */
  outb (0x501, 0x31);
c0026d66:	83 ec 08             	sub    $0x8,%esp
c0026d69:	6a 31                	push   $0x31
c0026d6b:	68 01 05 00 00       	push   $0x501
c0026d70:	e8 81 fe ff ff       	call   c0026bf6 <outb>
c0026d75:	83 c4 10             	add    $0x10,%esp

  /* This will power off a VMware VM if "gui.exitOnCLIHLT = TRUE"
     is set in its configuration file.  (The "pintos" script does
     that automatically.)  */
  asm volatile ("cli; hlt" : : : "memory");
c0026d78:	fa                   	cli    
c0026d79:	f4                   	hlt    

  /* None of those worked. */
  printf ("still running...\n");
c0026d7a:	83 ec 0c             	sub    $0xc,%esp
c0026d7d:	68 cd 05 03 c0       	push   $0xc00305cd
c0026d82:	e8 5d 4a 00 00       	call   c002b7e4 <puts>
c0026d87:	83 c4 10             	add    $0x10,%esp
  for (;;);
c0026d8a:	eb fe                	jmp    c0026d8a <shutdown_power_off+0x9b>

c0026d8c <print_stats>:
}

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
c0026d8c:	55                   	push   %ebp
c0026d8d:	89 e5                	mov    %esp,%ebp
c0026d8f:	83 ec 08             	sub    $0x8,%esp
  timer_print_stats ();
c0026d92:	e8 fc d0 ff ff       	call   c0023e93 <timer_print_stats>
  thread_print_stats ();
c0026d97:	e8 81 9c ff ff       	call   c0020a1d <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
#endif
  console_print_stats ();
c0026d9c:	e8 0d 49 00 00       	call   c002b6ae <console_print_stats>
  kbd_print_stats ();
c0026da1:	e8 04 d4 ff ff       	call   c00241aa <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
#endif
}
c0026da6:	90                   	nop
c0026da7:	c9                   	leave  
c0026da8:	c3                   	ret    

c0026da9 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0026da9:	55                   	push   %ebp
c0026daa:	89 e5                	mov    %esp,%ebp
c0026dac:	83 ec 14             	sub    $0x14,%esp
c0026daf:	8b 45 08             	mov    0x8(%ebp),%eax
c0026db2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026db6:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0026dba:	89 c2                	mov    %eax,%edx
c0026dbc:	ec                   	in     (%dx),%al
c0026dbd:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026dc0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0026dc4:	c9                   	leave  
c0026dc5:	c3                   	ret    

c0026dc6 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0026dc6:	55                   	push   %ebp
c0026dc7:	89 e5                	mov    %esp,%ebp
c0026dc9:	83 ec 08             	sub    $0x8,%esp
c0026dcc:	8b 55 08             	mov    0x8(%ebp),%edx
c0026dcf:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026dd2:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026dd6:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026dd9:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0026ddd:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0026de1:	ee                   	out    %al,(%dx)
}
c0026de2:	90                   	nop
c0026de3:	c9                   	leave  
c0026de4:	c3                   	ret    

c0026de5 <speaker_on>:

/* Sets the PC speaker to emit a tone at the given FREQUENCY, in
   Hz. */
void
speaker_on (int frequency)
{
c0026de5:	55                   	push   %ebp
c0026de6:	89 e5                	mov    %esp,%ebp
c0026de8:	83 ec 18             	sub    $0x18,%esp
  if (frequency >= 20 && frequency <= 20000)
c0026deb:	83 7d 08 13          	cmpl   $0x13,0x8(%ebp)
c0026def:	7e 54                	jle    c0026e45 <speaker_on+0x60>
c0026df1:	81 7d 08 20 4e 00 00 	cmpl   $0x4e20,0x8(%ebp)
c0026df8:	7f 4b                	jg     c0026e45 <speaker_on+0x60>
    {
      /* Set the timer channel that's connected to the speaker to
         output a square wave at the given FREQUENCY, then
         connect the timer channel output to the speaker. */
      enum intr_level old_level = intr_disable ();
c0026dfa:	e8 af a5 ff ff       	call   c00213ae <intr_disable>
c0026dff:	89 45 f4             	mov    %eax,-0xc(%ebp)
      pit_configure_channel (2, 3, frequency);
c0026e02:	83 ec 04             	sub    $0x4,%esp
c0026e05:	ff 75 08             	pushl  0x8(%ebp)
c0026e08:	6a 03                	push   $0x3
c0026e0a:	6a 02                	push   $0x2
c0026e0c:	e8 6f cc ff ff       	call   c0023a80 <pit_configure_channel>
c0026e11:	83 c4 10             	add    $0x10,%esp
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026e14:	83 ec 0c             	sub    $0xc,%esp
c0026e17:	6a 61                	push   $0x61
c0026e19:	e8 8b ff ff ff       	call   c0026da9 <inb>
c0026e1e:	83 c4 10             	add    $0x10,%esp
c0026e21:	83 c8 03             	or     $0x3,%eax
c0026e24:	0f b6 c0             	movzbl %al,%eax
c0026e27:	83 ec 08             	sub    $0x8,%esp
c0026e2a:	50                   	push   %eax
c0026e2b:	6a 61                	push   $0x61
c0026e2d:	e8 94 ff ff ff       	call   c0026dc6 <outb>
c0026e32:	83 c4 10             	add    $0x10,%esp
      intr_set_level (old_level);
c0026e35:	83 ec 0c             	sub    $0xc,%esp
c0026e38:	ff 75 f4             	pushl  -0xc(%ebp)
c0026e3b:	e8 16 a5 ff ff       	call   c0021356 <intr_set_level>
c0026e40:	83 c4 10             	add    $0x10,%esp
   Hz. */
void
speaker_on (int frequency)
{
  if (frequency >= 20 && frequency <= 20000)
    {
c0026e43:	eb 05                	jmp    c0026e4a <speaker_on+0x65>
    }
  else
    {
      /* FREQUENCY is outside the range of normal human hearing.
         Just turn off the speaker. */
      speaker_off ();
c0026e45:	e8 03 00 00 00       	call   c0026e4d <speaker_off>
    }
}
c0026e4a:	90                   	nop
c0026e4b:	c9                   	leave  
c0026e4c:	c3                   	ret    

c0026e4d <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0026e4d:	55                   	push   %ebp
c0026e4e:	89 e5                	mov    %esp,%ebp
c0026e50:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0026e53:	e8 56 a5 ff ff       	call   c00213ae <intr_disable>
c0026e58:	89 45 f4             	mov    %eax,-0xc(%ebp)
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
c0026e5b:	83 ec 0c             	sub    $0xc,%esp
c0026e5e:	6a 61                	push   $0x61
c0026e60:	e8 44 ff ff ff       	call   c0026da9 <inb>
c0026e65:	83 c4 10             	add    $0x10,%esp
c0026e68:	0f b6 c0             	movzbl %al,%eax
c0026e6b:	25 fc 00 00 00       	and    $0xfc,%eax
c0026e70:	83 ec 08             	sub    $0x8,%esp
c0026e73:	50                   	push   %eax
c0026e74:	6a 61                	push   $0x61
c0026e76:	e8 4b ff ff ff       	call   c0026dc6 <outb>
c0026e7b:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0026e7e:	83 ec 0c             	sub    $0xc,%esp
c0026e81:	ff 75 f4             	pushl  -0xc(%ebp)
c0026e84:	e8 cd a4 ff ff       	call   c0021356 <intr_set_level>
c0026e89:	83 c4 10             	add    $0x10,%esp
}
c0026e8c:	90                   	nop
c0026e8d:	c9                   	leave  
c0026e8e:	c3                   	ret    

c0026e8f <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0026e8f:	55                   	push   %ebp
c0026e90:	89 e5                	mov    %esp,%ebp
c0026e92:	83 ec 08             	sub    $0x8,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0026e95:	e8 9f a4 ff ff       	call   c0021339 <intr_get_level>
c0026e9a:	83 f8 01             	cmp    $0x1,%eax
c0026e9d:	75 27                	jne    c0026ec6 <speaker_beep+0x37>
    {
      speaker_on (440);
c0026e9f:	83 ec 0c             	sub    $0xc,%esp
c0026ea2:	68 b8 01 00 00       	push   $0x1b8
c0026ea7:	e8 39 ff ff ff       	call   c0026de5 <speaker_on>
c0026eac:	83 c4 10             	add    $0x10,%esp
      timer_msleep (250);
c0026eaf:	83 ec 08             	sub    $0x8,%esp
c0026eb2:	6a 00                	push   $0x0
c0026eb4:	68 fa 00 00 00       	push   $0xfa
c0026eb9:	e8 d3 ce ff ff       	call   c0023d91 <timer_msleep>
c0026ebe:	83 c4 10             	add    $0x10,%esp
      speaker_off ();
c0026ec1:	e8 87 ff ff ff       	call   c0026e4d <speaker_off>
    }
}
c0026ec6:	90                   	nop
c0026ec7:	c9                   	leave  
c0026ec8:	c3                   	ret    

c0026ec9 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0026ec9:	55                   	push   %ebp
c0026eca:	89 e5                	mov    %esp,%ebp
c0026ecc:	83 ec 18             	sub    $0x18,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0026ecf:	8b 45 04             	mov    0x4(%ebp),%eax
c0026ed2:	83 ec 08             	sub    $0x8,%esp
c0026ed5:	50                   	push   %eax
c0026ed6:	68 e0 05 03 c0       	push   $0xc00305e0
c0026edb:	e8 1e 03 00 00       	call   c00271fe <printf>
c0026ee0:	83 c4 10             	add    $0x10,%esp
  for (frame = __builtin_frame_address (1);
c0026ee3:	8b 45 00             	mov    0x0(%ebp),%eax
c0026ee6:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0026ee9:	eb 21                	jmp    c0026f0c <debug_backtrace+0x43>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0026eeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026eee:	83 c0 04             	add    $0x4,%eax
c0026ef1:	8b 00                	mov    (%eax),%eax
c0026ef3:	83 ec 08             	sub    $0x8,%esp
c0026ef6:	50                   	push   %eax
c0026ef7:	68 ef 05 03 c0       	push   $0xc00305ef
c0026efc:	e8 fd 02 00 00       	call   c00271fe <printf>
c0026f01:	83 c4 10             	add    $0x10,%esp
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
c0026f04:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026f07:	8b 00                	mov    (%eax),%eax
c0026f09:	89 45 f4             	mov    %eax,-0xc(%ebp)
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026f0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
{
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
c0026f0f:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c0026f14:	76 09                	jbe    c0026f1f <debug_backtrace+0x56>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026f16:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026f19:	8b 00                	mov    (%eax),%eax
c0026f1b:	85 c0                	test   %eax,%eax
c0026f1d:	75 cc                	jne    c0026eeb <debug_backtrace+0x22>
       frame = frame[0]) 
    printf (" %p", frame[1]);
  printf (".\n");
c0026f1f:	83 ec 0c             	sub    $0xc,%esp
c0026f22:	68 f3 05 03 c0       	push   $0xc00305f3
c0026f27:	e8 b8 48 00 00       	call   c002b7e4 <puts>
c0026f2c:	83 c4 10             	add    $0x10,%esp

  if (!explained) 
c0026f2f:	0f b6 05 cc 9a 03 c0 	movzbl 0xc0039acc,%eax
c0026f36:	83 f0 01             	xor    $0x1,%eax
c0026f39:	84 c0                	test   %al,%al
c0026f3b:	74 17                	je     c0026f54 <debug_backtrace+0x8b>
    {
      explained = true;
c0026f3d:	c6 05 cc 9a 03 c0 01 	movb   $0x1,0xc0039acc
      printf ("The `backtrace' program can make call stacks useful.\n"
c0026f44:	83 ec 0c             	sub    $0xc,%esp
c0026f47:	68 f8 05 03 c0       	push   $0xc00305f8
c0026f4c:	e8 93 48 00 00       	call   c002b7e4 <puts>
c0026f51:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c0026f54:	90                   	nop
c0026f55:	c9                   	leave  
c0026f56:	c3                   	ret    

c0026f57 <swap_byte>:
static bool inited;     

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
c0026f57:	55                   	push   %ebp
c0026f58:	89 e5                	mov    %esp,%ebp
c0026f5a:	83 ec 10             	sub    $0x10,%esp
  uint8_t t = *a;
c0026f5d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f60:	0f b6 00             	movzbl (%eax),%eax
c0026f63:	88 45 ff             	mov    %al,-0x1(%ebp)
  *a = *b;
c0026f66:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f69:	0f b6 10             	movzbl (%eax),%edx
c0026f6c:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f6f:	88 10                	mov    %dl,(%eax)
  *b = t;
c0026f71:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f74:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0026f78:	88 10                	mov    %dl,(%eax)
}
c0026f7a:	90                   	nop
c0026f7b:	c9                   	leave  
c0026f7c:	c3                   	ret    

c0026f7d <random_init>:

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0026f7d:	55                   	push   %ebp
c0026f7e:	89 e5                	mov    %esp,%ebp
c0026f80:	83 ec 10             	sub    $0x10,%esp
  uint8_t *seedp = (uint8_t *) &seed;
c0026f83:	8d 45 08             	lea    0x8(%ebp),%eax
c0026f86:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0026f89:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0026f90:	eb 13                	jmp    c0026fa5 <random_init+0x28>
    s[i] = i;
c0026f92:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f95:	89 c2                	mov    %eax,%edx
c0026f97:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f9a:	05 e0 9a 03 c0       	add    $0xc0039ae0,%eax
c0026f9f:	88 10                	mov    %dl,(%eax)
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0026fa1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0026fa5:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0026fac:	7e e4                	jle    c0026f92 <random_init+0x15>
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
c0026fae:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
c0026fb2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0026fb9:	eb 40                	jmp    c0026ffb <random_init+0x7e>
    {
      j += s[i] + seedp[i % sizeof seed];
c0026fbb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026fbe:	05 e0 9a 03 c0       	add    $0xc0039ae0,%eax
c0026fc3:	0f b6 10             	movzbl (%eax),%edx
c0026fc6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026fc9:	83 e0 03             	and    $0x3,%eax
c0026fcc:	89 c1                	mov    %eax,%ecx
c0026fce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026fd1:	01 c8                	add    %ecx,%eax
c0026fd3:	0f b6 00             	movzbl (%eax),%eax
c0026fd6:	01 d0                	add    %edx,%eax
c0026fd8:	00 45 fb             	add    %al,-0x5(%ebp)
      swap_byte (s + i, s + j);
c0026fdb:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0026fdf:	8d 90 e0 9a 03 c0    	lea    -0x3ffc6520(%eax),%edx
c0026fe5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026fe8:	05 e0 9a 03 c0       	add    $0xc0039ae0,%eax
c0026fed:	52                   	push   %edx
c0026fee:	50                   	push   %eax
c0026fef:	e8 63 ff ff ff       	call   c0026f57 <swap_byte>
c0026ff4:	83 c4 08             	add    $0x8,%esp
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
c0026ff7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0026ffb:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0027002:	7e b7                	jle    c0026fbb <random_init+0x3e>
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
    }

  s_i = s_j = 0;
c0027004:	c6 05 e1 9b 03 c0 00 	movb   $0x0,0xc0039be1
c002700b:	0f b6 05 e1 9b 03 c0 	movzbl 0xc0039be1,%eax
c0027012:	a2 e0 9b 03 c0       	mov    %al,0xc0039be0
  inited = true;
c0027017:	c6 05 e2 9b 03 c0 01 	movb   $0x1,0xc0039be2
}
c002701e:	90                   	nop
c002701f:	c9                   	leave  
c0027020:	c3                   	ret    

c0027021 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0027021:	55                   	push   %ebp
c0027022:	89 e5                	mov    %esp,%ebp
c0027024:	83 ec 10             	sub    $0x10,%esp
  uint8_t *buf;

  if (!inited)
c0027027:	0f b6 05 e2 9b 03 c0 	movzbl 0xc0039be2,%eax
c002702e:	83 f0 01             	xor    $0x1,%eax
c0027031:	84 c0                	test   %al,%al
c0027033:	74 0a                	je     c002703f <random_bytes+0x1e>
    random_init (0);
c0027035:	6a 00                	push   $0x0
c0027037:	e8 41 ff ff ff       	call   c0026f7d <random_init>
c002703c:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
c002703f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027042:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0027045:	e9 92 00 00 00       	jmp    c00270dc <random_bytes+0xbb>
    {
      uint8_t s_k;
      
      s_i++;
c002704a:	0f b6 05 e0 9b 03 c0 	movzbl 0xc0039be0,%eax
c0027051:	83 c0 01             	add    $0x1,%eax
c0027054:	a2 e0 9b 03 c0       	mov    %al,0xc0039be0
      s_j += s[s_i];
c0027059:	0f b6 05 e0 9b 03 c0 	movzbl 0xc0039be0,%eax
c0027060:	0f b6 c0             	movzbl %al,%eax
c0027063:	0f b6 90 e0 9a 03 c0 	movzbl -0x3ffc6520(%eax),%edx
c002706a:	0f b6 05 e1 9b 03 c0 	movzbl 0xc0039be1,%eax
c0027071:	01 d0                	add    %edx,%eax
c0027073:	a2 e1 9b 03 c0       	mov    %al,0xc0039be1
      swap_byte (s + s_i, s + s_j);
c0027078:	0f b6 05 e1 9b 03 c0 	movzbl 0xc0039be1,%eax
c002707f:	0f b6 c0             	movzbl %al,%eax
c0027082:	8d 90 e0 9a 03 c0    	lea    -0x3ffc6520(%eax),%edx
c0027088:	0f b6 05 e0 9b 03 c0 	movzbl 0xc0039be0,%eax
c002708f:	0f b6 c0             	movzbl %al,%eax
c0027092:	05 e0 9a 03 c0       	add    $0xc0039ae0,%eax
c0027097:	52                   	push   %edx
c0027098:	50                   	push   %eax
c0027099:	e8 b9 fe ff ff       	call   c0026f57 <swap_byte>
c002709e:	83 c4 08             	add    $0x8,%esp

      s_k = s[s_i] + s[s_j];
c00270a1:	0f b6 05 e0 9b 03 c0 	movzbl 0xc0039be0,%eax
c00270a8:	0f b6 c0             	movzbl %al,%eax
c00270ab:	0f b6 90 e0 9a 03 c0 	movzbl -0x3ffc6520(%eax),%edx
c00270b2:	0f b6 05 e1 9b 03 c0 	movzbl 0xc0039be1,%eax
c00270b9:	0f b6 c0             	movzbl %al,%eax
c00270bc:	0f b6 80 e0 9a 03 c0 	movzbl -0x3ffc6520(%eax),%eax
c00270c3:	01 d0                	add    %edx,%eax
c00270c5:	88 45 fb             	mov    %al,-0x5(%ebp)
      *buf = s[s_k];
c00270c8:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c00270cc:	0f b6 90 e0 9a 03 c0 	movzbl -0x3ffc6520(%eax),%edx
c00270d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00270d6:	88 10                	mov    %dl,(%eax)
  uint8_t *buf;

  if (!inited)
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c00270d8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c00270dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00270df:	8d 50 ff             	lea    -0x1(%eax),%edx
c00270e2:	89 55 0c             	mov    %edx,0xc(%ebp)
c00270e5:	85 c0                	test   %eax,%eax
c00270e7:	0f 85 5d ff ff ff    	jne    c002704a <random_bytes+0x29>
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
    }
}
c00270ed:	90                   	nop
c00270ee:	c9                   	leave  
c00270ef:	c3                   	ret    

c00270f0 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c00270f0:	55                   	push   %ebp
c00270f1:	89 e5                	mov    %esp,%ebp
c00270f3:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c00270f6:	6a 04                	push   $0x4
c00270f8:	8d 45 fc             	lea    -0x4(%ebp),%eax
c00270fb:	50                   	push   %eax
c00270fc:	e8 20 ff ff ff       	call   c0027021 <random_bytes>
c0027101:	83 c4 08             	add    $0x8,%esp
  return ul;
c0027104:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0027107:	c9                   	leave  
c0027108:	c3                   	ret    

c0027109 <isdigit>:
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
static inline int isalpha (int c) { return islower (c) || isupper (c); }
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027109:	55                   	push   %ebp
c002710a:	89 e5                	mov    %esp,%ebp
c002710c:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0027110:	7e 0d                	jle    c002711f <isdigit+0x16>
c0027112:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0027116:	7f 07                	jg     c002711f <isdigit+0x16>
c0027118:	b8 01 00 00 00       	mov    $0x1,%eax
c002711d:	eb 05                	jmp    c0027124 <isdigit+0x1b>
c002711f:	b8 00 00 00 00       	mov    $0x0,%eax
c0027124:	5d                   	pop    %ebp
c0027125:	c3                   	ret    

c0027126 <isprint>:
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
}
static inline int isblank (int c) { return c == ' ' || c == '\t'; }
static inline int isgraph (int c) { return c > 32 && c < 127; }
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027126:	55                   	push   %ebp
c0027127:	89 e5                	mov    %esp,%ebp
c0027129:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c002712d:	7e 0d                	jle    c002713c <isprint+0x16>
c002712f:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c0027133:	7f 07                	jg     c002713c <isprint+0x16>
c0027135:	b8 01 00 00 00       	mov    $0x1,%eax
c002713a:	eb 05                	jmp    c0027141 <isprint+0x1b>
c002713c:	b8 00 00 00 00       	mov    $0x0,%eax
c0027141:	5d                   	pop    %ebp
c0027142:	c3                   	ret    

c0027143 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
c0027143:	55                   	push   %ebp
c0027144:	89 e5                	mov    %esp,%ebp
c0027146:	83 ec 18             	sub    $0x18,%esp
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
c0027149:	8b 45 08             	mov    0x8(%ebp),%eax
c002714c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  aux.length = 0;
c002714f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027156:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002715a:	74 08                	je     c0027164 <vsnprintf+0x21>
c002715c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002715f:	83 e8 01             	sub    $0x1,%eax
c0027162:	eb 05                	jmp    c0027169 <vsnprintf+0x26>
c0027164:	b8 00 00 00 00       	mov    $0x0,%eax
c0027169:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c002716c:	8d 45 ec             	lea    -0x14(%ebp),%eax
c002716f:	50                   	push   %eax
c0027170:	68 94 71 02 c0       	push   $0xc0027194
c0027175:	ff 75 14             	pushl  0x14(%ebp)
c0027178:	ff 75 10             	pushl  0x10(%ebp)
c002717b:	e8 a4 00 00 00       	call   c0027224 <__vprintf>
c0027180:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
c0027183:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0027187:	74 06                	je     c002718f <vsnprintf+0x4c>
    *aux.p = '\0';
c0027189:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002718c:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
c002718f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0027192:	c9                   	leave  
c0027193:	c3                   	ret    

c0027194 <vsnprintf_helper>:

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0027194:	55                   	push   %ebp
c0027195:	89 e5                	mov    %esp,%ebp
c0027197:	83 ec 14             	sub    $0x14,%esp
c002719a:	8b 45 08             	mov    0x8(%ebp),%eax
c002719d:	88 45 ec             	mov    %al,-0x14(%ebp)
  struct vsnprintf_aux *aux = aux_;
c00271a0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00271a3:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (aux->length++ < aux->max_length)
c00271a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00271a9:	8b 40 04             	mov    0x4(%eax),%eax
c00271ac:	8d 48 01             	lea    0x1(%eax),%ecx
c00271af:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00271b2:	89 4a 04             	mov    %ecx,0x4(%edx)
c00271b5:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00271b8:	8b 52 08             	mov    0x8(%edx),%edx
c00271bb:	39 d0                	cmp    %edx,%eax
c00271bd:	7d 13                	jge    c00271d2 <vsnprintf_helper+0x3e>
    *aux->p++ = ch;
c00271bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00271c2:	8b 00                	mov    (%eax),%eax
c00271c4:	8d 48 01             	lea    0x1(%eax),%ecx
c00271c7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00271ca:	89 0a                	mov    %ecx,(%edx)
c00271cc:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
c00271d0:	88 10                	mov    %dl,(%eax)
}
c00271d2:	90                   	nop
c00271d3:	c9                   	leave  
c00271d4:	c3                   	ret    

c00271d5 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
c00271d5:	55                   	push   %ebp
c00271d6:	89 e5                	mov    %esp,%ebp
c00271d8:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c00271db:	8d 45 14             	lea    0x14(%ebp),%eax
c00271de:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vsnprintf (buffer, buf_size, format, args);
c00271e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00271e4:	50                   	push   %eax
c00271e5:	ff 75 10             	pushl  0x10(%ebp)
c00271e8:	ff 75 0c             	pushl  0xc(%ebp)
c00271eb:	ff 75 08             	pushl  0x8(%ebp)
c00271ee:	e8 50 ff ff ff       	call   c0027143 <vsnprintf>
c00271f3:	83 c4 10             	add    $0x10,%esp
c00271f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c00271f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00271fc:	c9                   	leave  
c00271fd:	c3                   	ret    

c00271fe <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
c00271fe:	55                   	push   %ebp
c00271ff:	89 e5                	mov    %esp,%ebp
c0027201:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c0027204:	8d 45 0c             	lea    0xc(%ebp),%eax
c0027207:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vprintf (format, args);
c002720a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002720d:	83 ec 08             	sub    $0x8,%esp
c0027210:	50                   	push   %eax
c0027211:	ff 75 08             	pushl  0x8(%ebp)
c0027214:	e8 98 45 00 00       	call   c002b7b1 <vprintf>
c0027219:	83 c4 10             	add    $0x10,%esp
c002721c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c002721f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0027222:	c9                   	leave  
c0027223:	c3                   	ret    

c0027224 <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
c0027224:	55                   	push   %ebp
c0027225:	89 e5                	mov    %esp,%ebp
c0027227:	57                   	push   %edi
c0027228:	56                   	push   %esi
c0027229:	53                   	push   %ebx
c002722a:	83 ec 3c             	sub    $0x3c,%esp
  for (; *format != '\0'; format++)
c002722d:	e9 45 04 00 00       	jmp    c0027677 <__vprintf+0x453>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
c0027232:	8b 45 08             	mov    0x8(%ebp),%eax
c0027235:	0f b6 00             	movzbl (%eax),%eax
c0027238:	3c 25                	cmp    $0x25,%al
c002723a:	74 1d                	je     c0027259 <__vprintf+0x35>
        {
          output (*format, aux);
c002723c:	8b 45 08             	mov    0x8(%ebp),%eax
c002723f:	0f b6 00             	movzbl (%eax),%eax
c0027242:	0f be c0             	movsbl %al,%eax
c0027245:	83 ec 08             	sub    $0x8,%esp
c0027248:	ff 75 14             	pushl  0x14(%ebp)
c002724b:	50                   	push   %eax
c002724c:	8b 45 10             	mov    0x10(%ebp),%eax
c002724f:	ff d0                	call   *%eax
c0027251:	83 c4 10             	add    $0x10,%esp
          continue;
c0027254:	e9 1a 04 00 00       	jmp    c0027673 <__vprintf+0x44f>
        }
      format++;
c0027259:	83 45 08 01          	addl   $0x1,0x8(%ebp)

      /* %% => %. */
      if (*format == '%') 
c002725d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027260:	0f b6 00             	movzbl (%eax),%eax
c0027263:	3c 25                	cmp    $0x25,%al
c0027265:	75 15                	jne    c002727c <__vprintf+0x58>
        {
          output ('%', aux);
c0027267:	83 ec 08             	sub    $0x8,%esp
c002726a:	ff 75 14             	pushl  0x14(%ebp)
c002726d:	6a 25                	push   $0x25
c002726f:	8b 45 10             	mov    0x10(%ebp),%eax
c0027272:	ff d0                	call   *%eax
c0027274:	83 c4 10             	add    $0x10,%esp
          continue;
c0027277:	e9 f7 03 00 00       	jmp    c0027673 <__vprintf+0x44f>
        }

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);
c002727c:	83 ec 04             	sub    $0x4,%esp
c002727f:	8d 45 0c             	lea    0xc(%ebp),%eax
c0027282:	50                   	push   %eax
c0027283:	8d 45 bc             	lea    -0x44(%ebp),%eax
c0027286:	50                   	push   %eax
c0027287:	ff 75 08             	pushl  0x8(%ebp)
c002728a:	e8 ff 03 00 00       	call   c002768e <parse_conversion>
c002728f:	83 c4 10             	add    $0x10,%esp
c0027292:	89 45 08             	mov    %eax,0x8(%ebp)

      /* Do conversion. */
      switch (*format) 
c0027295:	8b 45 08             	mov    0x8(%ebp),%eax
c0027298:	0f b6 00             	movzbl (%eax),%eax
c002729b:	0f be c0             	movsbl %al,%eax
c002729e:	83 e8 45             	sub    $0x45,%eax
c00272a1:	83 f8 33             	cmp    $0x33,%eax
c00272a4:	0f 87 ab 03 00 00    	ja     c0027655 <__vprintf+0x431>
c00272aa:	8b 04 85 7c 07 03 c0 	mov    -0x3ffcf884(,%eax,4),%eax
c00272b1:	ff e0                	jmp    *%eax
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
c00272b3:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00272b6:	83 f8 08             	cmp    $0x8,%eax
c00272b9:	0f 87 dd 00 00 00    	ja     c002739c <__vprintf+0x178>
c00272bf:	8b 04 85 4c 08 03 c0 	mov    -0x3ffcf7b4(,%eax,4),%eax
c00272c6:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
c00272c8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272cb:	8d 50 04             	lea    0x4(%eax),%edx
c00272ce:	89 55 0c             	mov    %edx,0xc(%ebp)
c00272d1:	8b 00                	mov    (%eax),%eax
c00272d3:	0f be c0             	movsbl %al,%eax
c00272d6:	99                   	cltd   
c00272d7:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00272da:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c00272dd:	e9 d4 00 00 00       	jmp    c00273b6 <__vprintf+0x192>
              case SHORT:
                value = (short) va_arg (args, int);
c00272e2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272e5:	8d 50 04             	lea    0x4(%eax),%edx
c00272e8:	89 55 0c             	mov    %edx,0xc(%ebp)
c00272eb:	8b 00                	mov    (%eax),%eax
c00272ed:	98                   	cwtl   
c00272ee:	99                   	cltd   
c00272ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00272f2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c00272f5:	e9 bc 00 00 00       	jmp    c00273b6 <__vprintf+0x192>
              case INT:
                value = va_arg (args, int);
c00272fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272fd:	8d 50 04             	lea    0x4(%eax),%edx
c0027300:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027303:	8b 00                	mov    (%eax),%eax
c0027305:	99                   	cltd   
c0027306:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027309:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c002730c:	e9 a5 00 00 00       	jmp    c00273b6 <__vprintf+0x192>
              case INTMAX:
                value = va_arg (args, intmax_t);
c0027311:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027314:	8d 50 08             	lea    0x8(%eax),%edx
c0027317:	89 55 0c             	mov    %edx,0xc(%ebp)
c002731a:	8b 50 04             	mov    0x4(%eax),%edx
c002731d:	8b 00                	mov    (%eax),%eax
c002731f:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027322:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0027325:	e9 8c 00 00 00       	jmp    c00273b6 <__vprintf+0x192>
              case LONG:
                value = va_arg (args, long);
c002732a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002732d:	8d 50 04             	lea    0x4(%eax),%edx
c0027330:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027333:	8b 00                	mov    (%eax),%eax
c0027335:	99                   	cltd   
c0027336:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027339:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c002733c:	eb 78                	jmp    c00273b6 <__vprintf+0x192>
              case LONGLONG:
                value = va_arg (args, long long);
c002733e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027341:	8d 50 08             	lea    0x8(%eax),%edx
c0027344:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027347:	8b 50 04             	mov    0x4(%eax),%edx
c002734a:	8b 00                	mov    (%eax),%eax
c002734c:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002734f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0027352:	eb 62                	jmp    c00273b6 <__vprintf+0x192>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c0027354:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027357:	8d 50 04             	lea    0x4(%eax),%edx
c002735a:	89 55 0c             	mov    %edx,0xc(%ebp)
c002735d:	8b 00                	mov    (%eax),%eax
c002735f:	99                   	cltd   
c0027360:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027363:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0027366:	eb 4e                	jmp    c00273b6 <__vprintf+0x192>
              case SIZET:
                value = va_arg (args, size_t);
c0027368:	8b 45 0c             	mov    0xc(%ebp),%eax
c002736b:	8d 50 04             	lea    0x4(%eax),%edx
c002736e:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027371:	8b 00                	mov    (%eax),%eax
c0027373:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027376:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                if (value > SIZE_MAX / 2)
c002737d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0027381:	78 32                	js     c00273b5 <__vprintf+0x191>
c0027383:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0027387:	7f 09                	jg     c0027392 <__vprintf+0x16e>
c0027389:	81 7d e0 ff ff ff 7f 	cmpl   $0x7fffffff,-0x20(%ebp)
c0027390:	76 23                	jbe    c00273b5 <__vprintf+0x191>
                  value = value - SIZE_MAX - 1;
c0027392:	83 45 e0 00          	addl   $0x0,-0x20(%ebp)
c0027396:	83 55 e4 ff          	adcl   $0xffffffff,-0x1c(%ebp)
                break;
c002739a:	eb 19                	jmp    c00273b5 <__vprintf+0x191>
              default:
                NOT_REACHED ();
c002739c:	68 14 07 03 c0       	push   $0xc0030714
c00273a1:	68 48 09 03 c0       	push   $0xc0030948
c00273a6:	68 dc 00 00 00       	push   $0xdc
c00273ab:	68 36 07 03 c0       	push   $0xc0030736
c00273b0:	e8 7c 22 00 00       	call   c0029631 <debug_panic>
                break;
              case SIZET:
                value = va_arg (args, size_t);
                if (value > SIZE_MAX / 2)
                  value = value - SIZE_MAX - 1;
                break;
c00273b5:	90                   	nop
              default:
                NOT_REACHED ();
              }

            format_integer (value < 0 ? -value : value,
c00273b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00273b9:	c1 e8 1f             	shr    $0x1f,%eax
c00273bc:	0f b6 c8             	movzbl %al,%ecx
c00273bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00273c2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00273c5:	89 d2                	mov    %edx,%edx
c00273c7:	c1 fa 1f             	sar    $0x1f,%edx
c00273ca:	89 d0                	mov    %edx,%eax
c00273cc:	89 c7                	mov    %eax,%edi
c00273ce:	33 7d e0             	xor    -0x20(%ebp),%edi
c00273d1:	89 fb                	mov    %edi,%ebx
c00273d3:	89 d7                	mov    %edx,%edi
c00273d5:	33 7d e4             	xor    -0x1c(%ebp),%edi
c00273d8:	89 fe                	mov    %edi,%esi
c00273da:	29 c3                	sub    %eax,%ebx
c00273dc:	19 d6                	sbb    %edx,%esi
c00273de:	89 d8                	mov    %ebx,%eax
c00273e0:	89 f2                	mov    %esi,%edx
c00273e2:	ff 75 14             	pushl  0x14(%ebp)
c00273e5:	ff 75 10             	pushl  0x10(%ebp)
c00273e8:	8d 7d bc             	lea    -0x44(%ebp),%edi
c00273eb:	57                   	push   %edi
c00273ec:	68 a0 06 03 c0       	push   $0xc00306a0
c00273f1:	51                   	push   %ecx
c00273f2:	6a 01                	push   $0x1
c00273f4:	52                   	push   %edx
c00273f5:	50                   	push   %eax
c00273f6:	e8 5b 05 00 00       	call   c0027956 <format_integer>
c00273fb:	83 c4 20             	add    $0x20,%esp
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
c00273fe:	e9 70 02 00 00       	jmp    c0027673 <__vprintf+0x44f>
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
c0027403:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0027406:	83 f8 08             	cmp    $0x8,%eax
c0027409:	0f 87 d3 00 00 00    	ja     c00274e2 <__vprintf+0x2be>
c002740f:	8b 04 85 70 08 03 c0 	mov    -0x3ffcf790(,%eax,4),%eax
c0027416:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c0027418:	8b 45 0c             	mov    0xc(%ebp),%eax
c002741b:	8d 50 04             	lea    0x4(%eax),%edx
c002741e:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027421:	8b 00                	mov    (%eax),%eax
c0027423:	0f b6 c0             	movzbl %al,%eax
c0027426:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027429:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027430:	e9 c6 00 00 00       	jmp    c00274fb <__vprintf+0x2d7>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c0027435:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027438:	8d 50 04             	lea    0x4(%eax),%edx
c002743b:	89 55 0c             	mov    %edx,0xc(%ebp)
c002743e:	8b 00                	mov    (%eax),%eax
c0027440:	0f b7 c0             	movzwl %ax,%eax
c0027443:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027446:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c002744d:	e9 a9 00 00 00       	jmp    c00274fb <__vprintf+0x2d7>
              case INT:
                value = va_arg (args, unsigned);
c0027452:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027455:	8d 50 04             	lea    0x4(%eax),%edx
c0027458:	89 55 0c             	mov    %edx,0xc(%ebp)
c002745b:	8b 00                	mov    (%eax),%eax
c002745d:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027460:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027467:	e9 8f 00 00 00       	jmp    c00274fb <__vprintf+0x2d7>
              case INTMAX:
                value = va_arg (args, uintmax_t);
c002746c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002746f:	8d 50 08             	lea    0x8(%eax),%edx
c0027472:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027475:	8b 50 04             	mov    0x4(%eax),%edx
c0027478:	8b 00                	mov    (%eax),%eax
c002747a:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002747d:	89 55 dc             	mov    %edx,-0x24(%ebp)
                break;
c0027480:	eb 79                	jmp    c00274fb <__vprintf+0x2d7>
              case LONG:
                value = va_arg (args, unsigned long);
c0027482:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027485:	8d 50 04             	lea    0x4(%eax),%edx
c0027488:	89 55 0c             	mov    %edx,0xc(%ebp)
c002748b:	8b 00                	mov    (%eax),%eax
c002748d:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027490:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027497:	eb 62                	jmp    c00274fb <__vprintf+0x2d7>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c0027499:	8b 45 0c             	mov    0xc(%ebp),%eax
c002749c:	8d 50 08             	lea    0x8(%eax),%edx
c002749f:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274a2:	8b 50 04             	mov    0x4(%eax),%edx
c00274a5:	8b 00                	mov    (%eax),%eax
c00274a7:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00274aa:	89 55 dc             	mov    %edx,-0x24(%ebp)
                break;
c00274ad:	eb 4c                	jmp    c00274fb <__vprintf+0x2d7>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c00274af:	8b 45 0c             	mov    0xc(%ebp),%eax
c00274b2:	8d 50 04             	lea    0x4(%eax),%edx
c00274b5:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274b8:	8b 00                	mov    (%eax),%eax
c00274ba:	99                   	cltd   
c00274bb:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00274be:	89 55 dc             	mov    %edx,-0x24(%ebp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c00274c1:	83 65 d8 ff          	andl   $0xffffffff,-0x28(%ebp)
c00274c5:	83 65 dc 00          	andl   $0x0,-0x24(%ebp)
#endif
                break;
c00274c9:	eb 30                	jmp    c00274fb <__vprintf+0x2d7>
              case SIZET:
                value = va_arg (args, size_t);
c00274cb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00274ce:	8d 50 04             	lea    0x4(%eax),%edx
c00274d1:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274d4:	8b 00                	mov    (%eax),%eax
c00274d6:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00274d9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c00274e0:	eb 19                	jmp    c00274fb <__vprintf+0x2d7>
              default:
                NOT_REACHED ();
c00274e2:	68 14 07 03 c0       	push   $0xc0030714
c00274e7:	68 48 09 03 c0       	push   $0xc0030948
c00274ec:	68 0b 01 00 00       	push   $0x10b
c00274f1:	68 36 07 03 c0       	push   $0xc0030736
c00274f6:	e8 36 21 00 00       	call   c0029631 <debug_panic>
              }

            switch (*format) 
c00274fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00274fe:	0f b6 00             	movzbl (%eax),%eax
c0027501:	0f be c0             	movsbl %al,%eax
c0027504:	83 f8 6f             	cmp    $0x6f,%eax
c0027507:	74 18                	je     c0027521 <__vprintf+0x2fd>
c0027509:	83 f8 6f             	cmp    $0x6f,%eax
c002750c:	7f 07                	jg     c0027515 <__vprintf+0x2f1>
c002750e:	83 f8 58             	cmp    $0x58,%eax
c0027511:	74 29                	je     c002753c <__vprintf+0x318>
c0027513:	eb 30                	jmp    c0027545 <__vprintf+0x321>
c0027515:	83 f8 75             	cmp    $0x75,%eax
c0027518:	74 10                	je     c002752a <__vprintf+0x306>
c002751a:	83 f8 78             	cmp    $0x78,%eax
c002751d:	74 14                	je     c0027533 <__vprintf+0x30f>
c002751f:	eb 24                	jmp    c0027545 <__vprintf+0x321>
              {
              case 'o': b = &base_o; break;
c0027521:	c7 45 d4 bc 06 03 c0 	movl   $0xc00306bc,-0x2c(%ebp)
c0027528:	eb 34                	jmp    c002755e <__vprintf+0x33a>
              case 'u': b = &base_d; break;
c002752a:	c7 45 d4 a0 06 03 c0 	movl   $0xc00306a0,-0x2c(%ebp)
c0027531:	eb 2b                	jmp    c002755e <__vprintf+0x33a>
              case 'x': b = &base_x; break;
c0027533:	c7 45 d4 e0 06 03 c0 	movl   $0xc00306e0,-0x2c(%ebp)
c002753a:	eb 22                	jmp    c002755e <__vprintf+0x33a>
              case 'X': b = &base_X; break;
c002753c:	c7 45 d4 04 07 03 c0 	movl   $0xc0030704,-0x2c(%ebp)
c0027543:	eb 19                	jmp    c002755e <__vprintf+0x33a>
              default: NOT_REACHED ();
c0027545:	68 14 07 03 c0       	push   $0xc0030714
c002754a:	68 48 09 03 c0       	push   $0xc0030948
c002754f:	68 14 01 00 00       	push   $0x114
c0027554:	68 36 07 03 c0       	push   $0xc0030736
c0027559:	e8 d3 20 00 00       	call   c0029631 <debug_panic>
              }

            format_integer (value, false, false, b, &c, output, aux);
c002755e:	ff 75 14             	pushl  0x14(%ebp)
c0027561:	ff 75 10             	pushl  0x10(%ebp)
c0027564:	8d 45 bc             	lea    -0x44(%ebp),%eax
c0027567:	50                   	push   %eax
c0027568:	ff 75 d4             	pushl  -0x2c(%ebp)
c002756b:	6a 00                	push   $0x0
c002756d:	6a 00                	push   $0x0
c002756f:	ff 75 dc             	pushl  -0x24(%ebp)
c0027572:	ff 75 d8             	pushl  -0x28(%ebp)
c0027575:	e8 dc 03 00 00       	call   c0027956 <format_integer>
c002757a:	83 c4 20             	add    $0x20,%esp
          }
          break;
c002757d:	e9 f1 00 00 00       	jmp    c0027673 <__vprintf+0x44f>

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c0027582:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027585:	8d 50 04             	lea    0x4(%eax),%edx
c0027588:	89 55 0c             	mov    %edx,0xc(%ebp)
c002758b:	8b 00                	mov    (%eax),%eax
c002758d:	88 45 bb             	mov    %al,-0x45(%ebp)
            format_string (&ch, 1, &c, output, aux);
c0027590:	83 ec 0c             	sub    $0xc,%esp
c0027593:	ff 75 14             	pushl  0x14(%ebp)
c0027596:	ff 75 10             	pushl  0x10(%ebp)
c0027599:	8d 45 bc             	lea    -0x44(%ebp),%eax
c002759c:	50                   	push   %eax
c002759d:	6a 01                	push   $0x1
c002759f:	8d 45 bb             	lea    -0x45(%ebp),%eax
c00275a2:	50                   	push   %eax
c00275a3:	e8 d0 06 00 00       	call   c0027c78 <format_string>
c00275a8:	83 c4 20             	add    $0x20,%esp
          }
          break;
c00275ab:	e9 c3 00 00 00       	jmp    c0027673 <__vprintf+0x44f>

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c00275b0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275b3:	8d 50 04             	lea    0x4(%eax),%edx
c00275b6:	89 55 0c             	mov    %edx,0xc(%ebp)
c00275b9:	8b 00                	mov    (%eax),%eax
c00275bb:	89 45 d0             	mov    %eax,-0x30(%ebp)
            if (s == NULL)
c00275be:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
c00275c2:	75 07                	jne    c00275cb <__vprintf+0x3a7>
              s = "(null)";
c00275c4:	c7 45 d0 48 07 03 c0 	movl   $0xc0030748,-0x30(%ebp)

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c00275cb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c00275ce:	83 ec 08             	sub    $0x8,%esp
c00275d1:	50                   	push   %eax
c00275d2:	ff 75 d0             	pushl  -0x30(%ebp)
c00275d5:	e8 f3 14 00 00       	call   c0028acd <strnlen>
c00275da:	83 c4 10             	add    $0x10,%esp
c00275dd:	89 c2                	mov    %eax,%edx
c00275df:	83 ec 0c             	sub    $0xc,%esp
c00275e2:	ff 75 14             	pushl  0x14(%ebp)
c00275e5:	ff 75 10             	pushl  0x10(%ebp)
c00275e8:	8d 45 bc             	lea    -0x44(%ebp),%eax
c00275eb:	50                   	push   %eax
c00275ec:	52                   	push   %edx
c00275ed:	ff 75 d0             	pushl  -0x30(%ebp)
c00275f0:	e8 83 06 00 00       	call   c0027c78 <format_string>
c00275f5:	83 c4 20             	add    $0x20,%esp
          }
          break;
c00275f8:	eb 79                	jmp    c0027673 <__vprintf+0x44f>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c00275fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275fd:	8d 50 04             	lea    0x4(%eax),%edx
c0027600:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027603:	8b 00                	mov    (%eax),%eax
c0027605:	89 45 cc             	mov    %eax,-0x34(%ebp)

            c.flags = POUND;
c0027608:	c7 45 bc 08 00 00 00 	movl   $0x8,-0x44(%ebp)
            format_integer ((uintptr_t) p, false, false,
c002760f:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0027612:	ba 00 00 00 00       	mov    $0x0,%edx
c0027617:	ff 75 14             	pushl  0x14(%ebp)
c002761a:	ff 75 10             	pushl  0x10(%ebp)
c002761d:	8d 4d bc             	lea    -0x44(%ebp),%ecx
c0027620:	51                   	push   %ecx
c0027621:	68 e0 06 03 c0       	push   $0xc00306e0
c0027626:	6a 00                	push   $0x0
c0027628:	6a 00                	push   $0x0
c002762a:	52                   	push   %edx
c002762b:	50                   	push   %eax
c002762c:	e8 25 03 00 00       	call   c0027956 <format_integer>
c0027631:	83 c4 20             	add    $0x20,%esp
                            &base_x, &c, output, aux);
          }
          break;
c0027634:	eb 3d                	jmp    c0027673 <__vprintf+0x44f>
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0027636:	8b 45 08             	mov    0x8(%ebp),%eax
c0027639:	0f b6 00             	movzbl (%eax),%eax
c002763c:	0f be c0             	movsbl %al,%eax
c002763f:	50                   	push   %eax
c0027640:	ff 75 14             	pushl  0x14(%ebp)
c0027643:	ff 75 10             	pushl  0x10(%ebp)
c0027646:	68 4f 07 03 c0       	push   $0xc003074f
c002764b:	e8 c5 06 00 00       	call   c0027d15 <__printf>
c0027650:	83 c4 10             	add    $0x10,%esp
          break;
c0027653:	eb 1e                	jmp    c0027673 <__vprintf+0x44f>

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c0027655:	8b 45 08             	mov    0x8(%ebp),%eax
c0027658:	0f b6 00             	movzbl (%eax),%eax
c002765b:	0f be c0             	movsbl %al,%eax
c002765e:	50                   	push   %eax
c002765f:	ff 75 14             	pushl  0x14(%ebp)
c0027662:	ff 75 10             	pushl  0x10(%ebp)
c0027665:	68 65 07 03 c0       	push   $0xc0030765
c002766a:	e8 a6 06 00 00       	call   c0027d15 <__printf>
c002766f:	83 c4 10             	add    $0x10,%esp
          break;
c0027672:	90                   	nop

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
  for (; *format != '\0'; format++)
c0027673:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0027677:	8b 45 08             	mov    0x8(%ebp),%eax
c002767a:	0f b6 00             	movzbl (%eax),%eax
c002767d:	84 c0                	test   %al,%al
c002767f:	0f 85 ad fb ff ff    	jne    c0027232 <__vprintf+0xe>
        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
          break;
        }
    }
}
c0027685:	90                   	nop
c0027686:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0027689:	5b                   	pop    %ebx
c002768a:	5e                   	pop    %esi
c002768b:	5f                   	pop    %edi
c002768c:	5d                   	pop    %ebp
c002768d:	c3                   	ret    

c002768e <parse_conversion>:
   that indicates the conversion (e.g. the `d' in `%d').  Uses
   *ARGS for `*' field widths and precisions. */
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
c002768e:	55                   	push   %ebp
c002768f:	89 e5                	mov    %esp,%ebp
  /* Parse flag characters. */
  c->flags = 0;
c0027691:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027694:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (;;) 
    {
      switch (*format++) 
c002769a:	8b 45 08             	mov    0x8(%ebp),%eax
c002769d:	8d 50 01             	lea    0x1(%eax),%edx
c00276a0:	89 55 08             	mov    %edx,0x8(%ebp)
c00276a3:	0f b6 00             	movzbl (%eax),%eax
c00276a6:	0f be c0             	movsbl %al,%eax
c00276a9:	83 e8 20             	sub    $0x20,%eax
c00276ac:	83 f8 10             	cmp    $0x10,%eax
c00276af:	77 6f                	ja     c0027720 <parse_conversion+0x92>
c00276b1:	8b 04 85 94 08 03 c0 	mov    -0x3ffcf76c(,%eax,4),%eax
c00276b8:	ff e0                	jmp    *%eax
        {
        case '-':
          c->flags |= MINUS;
c00276ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276bd:	8b 00                	mov    (%eax),%eax
c00276bf:	83 c8 01             	or     $0x1,%eax
c00276c2:	89 c2                	mov    %eax,%edx
c00276c4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276c7:	89 10                	mov    %edx,(%eax)
          break;
c00276c9:	eb 68                	jmp    c0027733 <parse_conversion+0xa5>
        case '+':
          c->flags |= PLUS;
c00276cb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276ce:	8b 00                	mov    (%eax),%eax
c00276d0:	83 c8 02             	or     $0x2,%eax
c00276d3:	89 c2                	mov    %eax,%edx
c00276d5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276d8:	89 10                	mov    %edx,(%eax)
          break;
c00276da:	eb 57                	jmp    c0027733 <parse_conversion+0xa5>
        case ' ':
          c->flags |= SPACE;
c00276dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276df:	8b 00                	mov    (%eax),%eax
c00276e1:	83 c8 04             	or     $0x4,%eax
c00276e4:	89 c2                	mov    %eax,%edx
c00276e6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276e9:	89 10                	mov    %edx,(%eax)
          break;
c00276eb:	eb 46                	jmp    c0027733 <parse_conversion+0xa5>
        case '#':
          c->flags |= POUND;
c00276ed:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276f0:	8b 00                	mov    (%eax),%eax
c00276f2:	83 c8 08             	or     $0x8,%eax
c00276f5:	89 c2                	mov    %eax,%edx
c00276f7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276fa:	89 10                	mov    %edx,(%eax)
          break;
c00276fc:	eb 35                	jmp    c0027733 <parse_conversion+0xa5>
        case '0':
          c->flags |= ZERO;
c00276fe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027701:	8b 00                	mov    (%eax),%eax
c0027703:	83 c8 10             	or     $0x10,%eax
c0027706:	89 c2                	mov    %eax,%edx
c0027708:	8b 45 0c             	mov    0xc(%ebp),%eax
c002770b:	89 10                	mov    %edx,(%eax)
          break;
c002770d:	eb 24                	jmp    c0027733 <parse_conversion+0xa5>
        case '\'':
          c->flags |= GROUP;
c002770f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027712:	8b 00                	mov    (%eax),%eax
c0027714:	83 c8 20             	or     $0x20,%eax
c0027717:	89 c2                	mov    %eax,%edx
c0027719:	8b 45 0c             	mov    0xc(%ebp),%eax
c002771c:	89 10                	mov    %edx,(%eax)
          break;
c002771e:	eb 13                	jmp    c0027733 <parse_conversion+0xa5>
        default:
          format--;
c0027720:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
          goto not_a_flag;
c0027724:	90                   	nop
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
c0027725:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027728:	8b 00                	mov    (%eax),%eax
c002772a:	83 e0 01             	and    $0x1,%eax
c002772d:	85 c0                	test   %eax,%eax
c002772f:	74 16                	je     c0027747 <parse_conversion+0xb9>
c0027731:	eb 05                	jmp    c0027738 <parse_conversion+0xaa>
          break;
        default:
          format--;
          goto not_a_flag;
        }
    }
c0027733:	e9 62 ff ff ff       	jmp    c002769a <parse_conversion+0xc>
 not_a_flag:
  if (c->flags & MINUS)
    c->flags &= ~ZERO;
c0027738:	8b 45 0c             	mov    0xc(%ebp),%eax
c002773b:	8b 00                	mov    (%eax),%eax
c002773d:	83 e0 ef             	and    $0xffffffef,%eax
c0027740:	89 c2                	mov    %eax,%edx
c0027742:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027745:	89 10                	mov    %edx,(%eax)
  if (c->flags & PLUS)
c0027747:	8b 45 0c             	mov    0xc(%ebp),%eax
c002774a:	8b 00                	mov    (%eax),%eax
c002774c:	83 e0 02             	and    $0x2,%eax
c002774f:	85 c0                	test   %eax,%eax
c0027751:	74 0f                	je     c0027762 <parse_conversion+0xd4>
    c->flags &= ~SPACE;
c0027753:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027756:	8b 00                	mov    (%eax),%eax
c0027758:	83 e0 fb             	and    $0xfffffffb,%eax
c002775b:	89 c2                	mov    %eax,%edx
c002775d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027760:	89 10                	mov    %edx,(%eax)

  /* Parse field width. */
  c->width = 0;
c0027762:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027765:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (*format == '*')
c002776c:	8b 45 08             	mov    0x8(%ebp),%eax
c002776f:	0f b6 00             	movzbl (%eax),%eax
c0027772:	3c 2a                	cmp    $0x2a,%al
c0027774:	75 44                	jne    c00277ba <parse_conversion+0x12c>
    {
      format++;
c0027776:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      c->width = va_arg (*args, int);
c002777a:	8b 45 10             	mov    0x10(%ebp),%eax
c002777d:	8b 00                	mov    (%eax),%eax
c002777f:	8d 48 04             	lea    0x4(%eax),%ecx
c0027782:	8b 55 10             	mov    0x10(%ebp),%edx
c0027785:	89 0a                	mov    %ecx,(%edx)
c0027787:	8b 10                	mov    (%eax),%edx
c0027789:	8b 45 0c             	mov    0xc(%ebp),%eax
c002778c:	89 50 04             	mov    %edx,0x4(%eax)
c002778f:	eb 3f                	jmp    c00277d0 <parse_conversion+0x142>
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
c0027791:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027794:	8b 50 04             	mov    0x4(%eax),%edx
c0027797:	89 d0                	mov    %edx,%eax
c0027799:	c1 e0 02             	shl    $0x2,%eax
c002779c:	01 d0                	add    %edx,%eax
c002779e:	01 c0                	add    %eax,%eax
c00277a0:	89 c2                	mov    %eax,%edx
c00277a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00277a5:	0f b6 00             	movzbl (%eax),%eax
c00277a8:	0f be c0             	movsbl %al,%eax
c00277ab:	01 d0                	add    %edx,%eax
c00277ad:	8d 50 d0             	lea    -0x30(%eax),%edx
c00277b0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277b3:	89 50 04             	mov    %edx,0x4(%eax)
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
c00277b6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c00277ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00277bd:	0f b6 00             	movzbl (%eax),%eax
c00277c0:	0f be c0             	movsbl %al,%eax
c00277c3:	50                   	push   %eax
c00277c4:	e8 40 f9 ff ff       	call   c0027109 <isdigit>
c00277c9:	83 c4 04             	add    $0x4,%esp
c00277cc:	85 c0                	test   %eax,%eax
c00277ce:	75 c1                	jne    c0027791 <parse_conversion+0x103>
        c->width = c->width * 10 + *format - '0';
    }
  if (c->width < 0) 
c00277d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277d3:	8b 40 04             	mov    0x4(%eax),%eax
c00277d6:	85 c0                	test   %eax,%eax
c00277d8:	79 1f                	jns    c00277f9 <parse_conversion+0x16b>
    {
      c->width = -c->width;
c00277da:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277dd:	8b 40 04             	mov    0x4(%eax),%eax
c00277e0:	f7 d8                	neg    %eax
c00277e2:	89 c2                	mov    %eax,%edx
c00277e4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277e7:	89 50 04             	mov    %edx,0x4(%eax)
      c->flags |= MINUS;
c00277ea:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277ed:	8b 00                	mov    (%eax),%eax
c00277ef:	83 c8 01             	or     $0x1,%eax
c00277f2:	89 c2                	mov    %eax,%edx
c00277f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277f7:	89 10                	mov    %edx,(%eax)
    }
      
  /* Parse precision. */
  c->precision = -1;
c00277f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277fc:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  if (*format == '.') 
c0027803:	8b 45 08             	mov    0x8(%ebp),%eax
c0027806:	0f b6 00             	movzbl (%eax),%eax
c0027809:	3c 2e                	cmp    $0x2e,%al
c002780b:	0f 85 88 00 00 00    	jne    c0027899 <parse_conversion+0x20b>
    {
      format++;
c0027811:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      if (*format == '*') 
c0027815:	8b 45 08             	mov    0x8(%ebp),%eax
c0027818:	0f b6 00             	movzbl (%eax),%eax
c002781b:	3c 2a                	cmp    $0x2a,%al
c002781d:	75 1b                	jne    c002783a <parse_conversion+0x1ac>
        {
          format++;
c002781f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->precision = va_arg (*args, int);
c0027823:	8b 45 10             	mov    0x10(%ebp),%eax
c0027826:	8b 00                	mov    (%eax),%eax
c0027828:	8d 48 04             	lea    0x4(%eax),%ecx
c002782b:	8b 55 10             	mov    0x10(%ebp),%edx
c002782e:	89 0a                	mov    %ecx,(%edx)
c0027830:	8b 10                	mov    (%eax),%edx
c0027832:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027835:	89 50 08             	mov    %edx,0x8(%eax)
c0027838:	eb 4b                	jmp    c0027885 <parse_conversion+0x1f7>
        }
      else 
        {
          c->precision = 0;
c002783a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002783d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          for (; isdigit (*format); format++)
c0027844:	eb 29                	jmp    c002786f <parse_conversion+0x1e1>
            c->precision = c->precision * 10 + *format - '0';
c0027846:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027849:	8b 50 08             	mov    0x8(%eax),%edx
c002784c:	89 d0                	mov    %edx,%eax
c002784e:	c1 e0 02             	shl    $0x2,%eax
c0027851:	01 d0                	add    %edx,%eax
c0027853:	01 c0                	add    %eax,%eax
c0027855:	89 c2                	mov    %eax,%edx
c0027857:	8b 45 08             	mov    0x8(%ebp),%eax
c002785a:	0f b6 00             	movzbl (%eax),%eax
c002785d:	0f be c0             	movsbl %al,%eax
c0027860:	01 d0                	add    %edx,%eax
c0027862:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027865:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027868:	89 50 08             	mov    %edx,0x8(%eax)
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
          for (; isdigit (*format); format++)
c002786b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c002786f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027872:	0f b6 00             	movzbl (%eax),%eax
c0027875:	0f be c0             	movsbl %al,%eax
c0027878:	50                   	push   %eax
c0027879:	e8 8b f8 ff ff       	call   c0027109 <isdigit>
c002787e:	83 c4 04             	add    $0x4,%esp
c0027881:	85 c0                	test   %eax,%eax
c0027883:	75 c1                	jne    c0027846 <parse_conversion+0x1b8>
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
c0027885:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027888:	8b 40 08             	mov    0x8(%eax),%eax
c002788b:	85 c0                	test   %eax,%eax
c002788d:	79 0a                	jns    c0027899 <parse_conversion+0x20b>
        c->precision = -1;
c002788f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027892:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    }
  if (c->precision >= 0)
c0027899:	8b 45 0c             	mov    0xc(%ebp),%eax
c002789c:	8b 40 08             	mov    0x8(%eax),%eax
c002789f:	85 c0                	test   %eax,%eax
c00278a1:	78 0f                	js     c00278b2 <parse_conversion+0x224>
    c->flags &= ~ZERO;
c00278a3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278a6:	8b 00                	mov    (%eax),%eax
c00278a8:	83 e0 ef             	and    $0xffffffef,%eax
c00278ab:	89 c2                	mov    %eax,%edx
c00278ad:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278b0:	89 10                	mov    %edx,(%eax)

  /* Parse type. */
  c->type = INT;
c00278b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278b5:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  switch (*format++) 
c00278bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00278bf:	8d 50 01             	lea    0x1(%eax),%edx
c00278c2:	89 55 08             	mov    %edx,0x8(%ebp)
c00278c5:	0f b6 00             	movzbl (%eax),%eax
c00278c8:	0f be c0             	movsbl %al,%eax
c00278cb:	83 e8 68             	sub    $0x68,%eax
c00278ce:	83 f8 12             	cmp    $0x12,%eax
c00278d1:	77 79                	ja     c002794c <parse_conversion+0x2be>
c00278d3:	8b 04 85 d8 08 03 c0 	mov    -0x3ffcf728(,%eax,4),%eax
c00278da:	ff e0                	jmp    *%eax
    {
    case 'h':
      if (*format == 'h') 
c00278dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00278df:	0f b6 00             	movzbl (%eax),%eax
c00278e2:	3c 68                	cmp    $0x68,%al
c00278e4:	75 10                	jne    c00278f6 <parse_conversion+0x268>
        {
          format++;
c00278e6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->type = CHAR;
c00278ea:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278ed:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
        }
      else
        c->type = SHORT;
      break;
c00278f4:	eb 5b                	jmp    c0027951 <parse_conversion+0x2c3>
        {
          format++;
          c->type = CHAR;
        }
      else
        c->type = SHORT;
c00278f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278f9:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
      break;
c0027900:	eb 4f                	jmp    c0027951 <parse_conversion+0x2c3>
      
    case 'j':
      c->type = INTMAX;
c0027902:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027905:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      break;
c002790c:	eb 43                	jmp    c0027951 <parse_conversion+0x2c3>

    case 'l':
      if (*format == 'l')
c002790e:	8b 45 08             	mov    0x8(%ebp),%eax
c0027911:	0f b6 00             	movzbl (%eax),%eax
c0027914:	3c 6c                	cmp    $0x6c,%al
c0027916:	75 10                	jne    c0027928 <parse_conversion+0x29a>
        {
          format++;
c0027918:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->type = LONGLONG;
c002791c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002791f:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
        }
      else
        c->type = LONG;
      break;
c0027926:	eb 29                	jmp    c0027951 <parse_conversion+0x2c3>
        {
          format++;
          c->type = LONGLONG;
        }
      else
        c->type = LONG;
c0027928:	8b 45 0c             	mov    0xc(%ebp),%eax
c002792b:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
      break;
c0027932:	eb 1d                	jmp    c0027951 <parse_conversion+0x2c3>

    case 't':
      c->type = PTRDIFFT;
c0027934:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027937:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
      break;
c002793e:	eb 11                	jmp    c0027951 <parse_conversion+0x2c3>

    case 'z':
      c->type = SIZET;
c0027940:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027943:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)
      break;
c002794a:	eb 05                	jmp    c0027951 <parse_conversion+0x2c3>

    default:
      format--;
c002794c:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
      break;
c0027950:	90                   	nop
    }

  return format;
c0027951:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0027954:	c9                   	leave  
c0027955:	c3                   	ret    

c0027956 <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
c0027956:	55                   	push   %ebp
c0027957:	89 e5                	mov    %esp,%ebp
c0027959:	57                   	push   %edi
c002795a:	56                   	push   %esi
c002795b:	53                   	push   %ebx
c002795c:	83 ec 7c             	sub    $0x7c,%esp
c002795f:	8b 55 10             	mov    0x10(%ebp),%edx
c0027962:	8b 45 14             	mov    0x14(%ebp),%eax
c0027965:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0027968:	89 4d 80             	mov    %ecx,-0x80(%ebp)
c002796b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002796e:	89 4d 84             	mov    %ecx,-0x7c(%ebp)
c0027971:	88 95 7c ff ff ff    	mov    %dl,-0x84(%ebp)
c0027977:	88 85 78 ff ff ff    	mov    %al,-0x88(%ebp)
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
c002797d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  if (is_signed) 
c0027984:	80 bd 7c ff ff ff 00 	cmpb   $0x0,-0x84(%ebp)
c002798b:	74 5c                	je     c00279e9 <format_integer+0x93>
    {
      if (c->flags & PLUS)
c002798d:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027990:	8b 00                	mov    (%eax),%eax
c0027992:	83 e0 02             	and    $0x2,%eax
c0027995:	85 c0                	test   %eax,%eax
c0027997:	74 1a                	je     c00279b3 <format_integer+0x5d>
        sign = negative ? '-' : '+';
c0027999:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c00279a0:	74 07                	je     c00279a9 <format_integer+0x53>
c00279a2:	b8 2d 00 00 00       	mov    $0x2d,%eax
c00279a7:	eb 05                	jmp    c00279ae <format_integer+0x58>
c00279a9:	b8 2b 00 00 00       	mov    $0x2b,%eax
c00279ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00279b1:	eb 36                	jmp    c00279e9 <format_integer+0x93>
      else if (c->flags & SPACE)
c00279b3:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00279b6:	8b 00                	mov    (%eax),%eax
c00279b8:	83 e0 04             	and    $0x4,%eax
c00279bb:	85 c0                	test   %eax,%eax
c00279bd:	74 1a                	je     c00279d9 <format_integer+0x83>
        sign = negative ? '-' : ' ';
c00279bf:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c00279c6:	74 07                	je     c00279cf <format_integer+0x79>
c00279c8:	b8 2d 00 00 00       	mov    $0x2d,%eax
c00279cd:	eb 05                	jmp    c00279d4 <format_integer+0x7e>
c00279cf:	b8 20 00 00 00       	mov    $0x20,%eax
c00279d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00279d7:	eb 10                	jmp    c00279e9 <format_integer+0x93>
      else if (negative)
c00279d9:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c00279e0:	74 07                	je     c00279e9 <format_integer+0x93>
        sign = '-';
c00279e2:	c7 45 e0 2d 00 00 00 	movl   $0x2d,-0x20(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c00279e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00279ec:	8b 00                	mov    (%eax),%eax
c00279ee:	83 e0 08             	and    $0x8,%eax
c00279f1:	85 c0                	test   %eax,%eax
c00279f3:	74 12                	je     c0027a07 <format_integer+0xb1>
c00279f5:	8b 45 84             	mov    -0x7c(%ebp),%eax
c00279f8:	0b 45 80             	or     -0x80(%ebp),%eax
c00279fb:	85 c0                	test   %eax,%eax
c00279fd:	74 08                	je     c0027a07 <format_integer+0xb1>
c00279ff:	8b 45 18             	mov    0x18(%ebp),%eax
c0027a02:	8b 40 08             	mov    0x8(%eax),%eax
c0027a05:	eb 05                	jmp    c0027a0c <format_integer+0xb6>
c0027a07:	b8 00 00 00 00       	mov    $0x0,%eax
c0027a0c:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
c0027a0f:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027a12:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  digit_cnt = 0;
c0027a15:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  while (value > 0) 
c0027a1c:	e9 84 00 00 00       	jmp    c0027aa5 <format_integer+0x14f>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0027a21:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027a24:	8b 00                	mov    (%eax),%eax
c0027a26:	83 e0 20             	and    $0x20,%eax
c0027a29:	85 c0                	test   %eax,%eax
c0027a2b:	74 24                	je     c0027a51 <format_integer+0xfb>
c0027a2d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0027a31:	7e 1e                	jle    c0027a51 <format_integer+0xfb>
c0027a33:	8b 45 18             	mov    0x18(%ebp),%eax
c0027a36:	8b 48 0c             	mov    0xc(%eax),%ecx
c0027a39:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0027a3c:	99                   	cltd   
c0027a3d:	f7 f9                	idiv   %ecx
c0027a3f:	89 d0                	mov    %edx,%eax
c0027a41:	85 c0                	test   %eax,%eax
c0027a43:	75 0c                	jne    c0027a51 <format_integer+0xfb>
        *cp++ = ',';
c0027a45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027a48:	8d 50 01             	lea    0x1(%eax),%edx
c0027a4b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027a4e:	c6 00 2c             	movb   $0x2c,(%eax)
      *cp++ = b->digits[value % b->base];
c0027a51:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0027a54:	8d 46 01             	lea    0x1(%esi),%eax
c0027a57:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0027a5a:	8b 45 18             	mov    0x18(%ebp),%eax
c0027a5d:	8b 78 04             	mov    0x4(%eax),%edi
c0027a60:	8b 45 18             	mov    0x18(%ebp),%eax
c0027a63:	8b 00                	mov    (%eax),%eax
c0027a65:	89 c1                	mov    %eax,%ecx
c0027a67:	89 c3                	mov    %eax,%ebx
c0027a69:	c1 fb 1f             	sar    $0x1f,%ebx
c0027a6c:	8b 45 80             	mov    -0x80(%ebp),%eax
c0027a6f:	8b 55 84             	mov    -0x7c(%ebp),%edx
c0027a72:	53                   	push   %ebx
c0027a73:	51                   	push   %ecx
c0027a74:	52                   	push   %edx
c0027a75:	50                   	push   %eax
c0027a76:	e8 2d 16 00 00       	call   c00290a8 <__umoddi3>
c0027a7b:	83 c4 10             	add    $0x10,%esp
c0027a7e:	01 f8                	add    %edi,%eax
c0027a80:	0f b6 00             	movzbl (%eax),%eax
c0027a83:	88 06                	mov    %al,(%esi)
      value /= b->base;
c0027a85:	8b 45 18             	mov    0x18(%ebp),%eax
c0027a88:	8b 00                	mov    (%eax),%eax
c0027a8a:	99                   	cltd   
c0027a8b:	52                   	push   %edx
c0027a8c:	50                   	push   %eax
c0027a8d:	ff 75 84             	pushl  -0x7c(%ebp)
c0027a90:	ff 75 80             	pushl  -0x80(%ebp)
c0027a93:	e8 dc 15 00 00       	call   c0029074 <__udivdi3>
c0027a98:	83 c4 10             	add    $0x10,%esp
c0027a9b:	89 45 80             	mov    %eax,-0x80(%ebp)
c0027a9e:	89 55 84             	mov    %edx,-0x7c(%ebp)
      digit_cnt++;
c0027aa1:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
c0027aa5:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027aa8:	0b 45 80             	or     -0x80(%ebp),%eax
c0027aab:	85 c0                	test   %eax,%eax
c0027aad:	0f 85 6e ff ff ff    	jne    c0027a21 <format_integer+0xcb>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
c0027ab3:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027ab6:	8b 40 08             	mov    0x8(%eax),%eax
c0027ab9:	85 c0                	test   %eax,%eax
c0027abb:	78 08                	js     c0027ac5 <format_integer+0x16f>
c0027abd:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027ac0:	8b 40 08             	mov    0x8(%eax),%eax
c0027ac3:	eb 05                	jmp    c0027aca <format_integer+0x174>
c0027ac5:	b8 01 00 00 00       	mov    $0x1,%eax
c0027aca:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027acd:	eb 0c                	jmp    c0027adb <format_integer+0x185>
    *cp++ = '0';
c0027acf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027ad2:	8d 50 01             	lea    0x1(%eax),%edx
c0027ad5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027ad8:	c6 00 30             	movb   $0x30,(%eax)
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027adb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027ade:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027ae1:	29 c2                	sub    %eax,%edx
c0027ae3:	89 d0                	mov    %edx,%eax
c0027ae5:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0027ae8:	7d 0b                	jge    c0027af5 <format_integer+0x19f>
c0027aea:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027aed:	83 c0 3f             	add    $0x3f,%eax
c0027af0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027af3:	77 da                	ja     c0027acf <format_integer+0x179>
    *cp++ = '0';
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0027af5:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027af8:	8b 00                	mov    (%eax),%eax
c0027afa:	83 e0 08             	and    $0x8,%eax
c0027afd:	85 c0                	test   %eax,%eax
c0027aff:	74 2b                	je     c0027b2c <format_integer+0x1d6>
c0027b01:	8b 45 18             	mov    0x18(%ebp),%eax
c0027b04:	8b 00                	mov    (%eax),%eax
c0027b06:	83 f8 08             	cmp    $0x8,%eax
c0027b09:	75 21                	jne    c0027b2c <format_integer+0x1d6>
c0027b0b:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027b0e:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027b11:	74 0d                	je     c0027b20 <format_integer+0x1ca>
c0027b13:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027b16:	83 e8 01             	sub    $0x1,%eax
c0027b19:	0f b6 00             	movzbl (%eax),%eax
c0027b1c:	3c 30                	cmp    $0x30,%al
c0027b1e:	74 0c                	je     c0027b2c <format_integer+0x1d6>
    *cp++ = '0';
c0027b20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027b23:	8d 50 01             	lea    0x1(%eax),%edx
c0027b26:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027b29:	c6 00 30             	movb   $0x30,(%eax)

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0027b2c:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b2f:	8b 40 04             	mov    0x4(%eax),%eax
c0027b32:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0027b35:	8d 55 90             	lea    -0x70(%ebp),%edx
c0027b38:	29 d1                	sub    %edx,%ecx
c0027b3a:	89 ca                	mov    %ecx,%edx
c0027b3c:	29 d0                	sub    %edx,%eax
c0027b3e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0027b42:	74 07                	je     c0027b4b <format_integer+0x1f5>
c0027b44:	ba 02 00 00 00       	mov    $0x2,%edx
c0027b49:	eb 05                	jmp    c0027b50 <format_integer+0x1fa>
c0027b4b:	ba 00 00 00 00       	mov    $0x0,%edx
c0027b50:	29 d0                	sub    %edx,%eax
c0027b52:	89 c2                	mov    %eax,%edx
c0027b54:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027b58:	0f 95 c0             	setne  %al
c0027b5b:	0f b6 c0             	movzbl %al,%eax
c0027b5e:	29 c2                	sub    %eax,%edx
c0027b60:	89 d0                	mov    %edx,%eax
c0027b62:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (pad_cnt < 0)
c0027b65:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0027b69:	79 07                	jns    c0027b72 <format_integer+0x21c>
    pad_cnt = 0;
c0027b6b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
c0027b72:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b75:	8b 00                	mov    (%eax),%eax
c0027b77:	83 e0 11             	and    $0x11,%eax
c0027b7a:	85 c0                	test   %eax,%eax
c0027b7c:	75 14                	jne    c0027b92 <format_integer+0x23c>
    output_dup (' ', pad_cnt, output, aux);
c0027b7e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027b81:	ff 75 24             	pushl  0x24(%ebp)
c0027b84:	ff 75 20             	pushl  0x20(%ebp)
c0027b87:	50                   	push   %eax
c0027b88:	6a 20                	push   $0x20
c0027b8a:	e8 b8 00 00 00       	call   c0027c47 <output_dup>
c0027b8f:	83 c4 10             	add    $0x10,%esp
  if (sign)
c0027b92:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027b96:	74 15                	je     c0027bad <format_integer+0x257>
    output (sign, aux);
c0027b98:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027b9b:	0f be c0             	movsbl %al,%eax
c0027b9e:	83 ec 08             	sub    $0x8,%esp
c0027ba1:	ff 75 24             	pushl  0x24(%ebp)
c0027ba4:	50                   	push   %eax
c0027ba5:	8b 45 20             	mov    0x20(%ebp),%eax
c0027ba8:	ff d0                	call   *%eax
c0027baa:	83 c4 10             	add    $0x10,%esp
  if (x) 
c0027bad:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0027bb1:	74 25                	je     c0027bd8 <format_integer+0x282>
    {
      output ('0', aux);
c0027bb3:	83 ec 08             	sub    $0x8,%esp
c0027bb6:	ff 75 24             	pushl  0x24(%ebp)
c0027bb9:	6a 30                	push   $0x30
c0027bbb:	8b 45 20             	mov    0x20(%ebp),%eax
c0027bbe:	ff d0                	call   *%eax
c0027bc0:	83 c4 10             	add    $0x10,%esp
      output (x, aux); 
c0027bc3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0027bc6:	0f be c0             	movsbl %al,%eax
c0027bc9:	83 ec 08             	sub    $0x8,%esp
c0027bcc:	ff 75 24             	pushl  0x24(%ebp)
c0027bcf:	50                   	push   %eax
c0027bd0:	8b 45 20             	mov    0x20(%ebp),%eax
c0027bd3:	ff d0                	call   *%eax
c0027bd5:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
c0027bd8:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027bdb:	8b 00                	mov    (%eax),%eax
c0027bdd:	83 e0 10             	and    $0x10,%eax
c0027be0:	85 c0                	test   %eax,%eax
c0027be2:	74 32                	je     c0027c16 <format_integer+0x2c0>
    output_dup ('0', pad_cnt, output, aux);
c0027be4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027be7:	ff 75 24             	pushl  0x24(%ebp)
c0027bea:	ff 75 20             	pushl  0x20(%ebp)
c0027bed:	50                   	push   %eax
c0027bee:	6a 30                	push   $0x30
c0027bf0:	e8 52 00 00 00       	call   c0027c47 <output_dup>
c0027bf5:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c0027bf8:	eb 1c                	jmp    c0027c16 <format_integer+0x2c0>
    output (*--cp, aux);
c0027bfa:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
c0027bfe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027c01:	0f b6 00             	movzbl (%eax),%eax
c0027c04:	0f be c0             	movsbl %al,%eax
c0027c07:	83 ec 08             	sub    $0x8,%esp
c0027c0a:	ff 75 24             	pushl  0x24(%ebp)
c0027c0d:	50                   	push   %eax
c0027c0e:	8b 45 20             	mov    0x20(%ebp),%eax
c0027c11:	ff d0                	call   *%eax
c0027c13:	83 c4 10             	add    $0x10,%esp
      output ('0', aux);
      output (x, aux); 
    }
  if (c->flags & ZERO)
    output_dup ('0', pad_cnt, output, aux);
  while (cp > buf)
c0027c16:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027c19:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027c1c:	77 dc                	ja     c0027bfa <format_integer+0x2a4>
    output (*--cp, aux);
  if (c->flags & MINUS)
c0027c1e:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027c21:	8b 00                	mov    (%eax),%eax
c0027c23:	83 e0 01             	and    $0x1,%eax
c0027c26:	85 c0                	test   %eax,%eax
c0027c28:	74 14                	je     c0027c3e <format_integer+0x2e8>
    output_dup (' ', pad_cnt, output, aux);
c0027c2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027c2d:	ff 75 24             	pushl  0x24(%ebp)
c0027c30:	ff 75 20             	pushl  0x20(%ebp)
c0027c33:	50                   	push   %eax
c0027c34:	6a 20                	push   $0x20
c0027c36:	e8 0c 00 00 00       	call   c0027c47 <output_dup>
c0027c3b:	83 c4 10             	add    $0x10,%esp
}
c0027c3e:	90                   	nop
c0027c3f:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0027c42:	5b                   	pop    %ebx
c0027c43:	5e                   	pop    %esi
c0027c44:	5f                   	pop    %edi
c0027c45:	5d                   	pop    %ebp
c0027c46:	c3                   	ret    

c0027c47 <output_dup>:

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0027c47:	55                   	push   %ebp
c0027c48:	89 e5                	mov    %esp,%ebp
c0027c4a:	83 ec 18             	sub    $0x18,%esp
c0027c4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c50:	88 45 f4             	mov    %al,-0xc(%ebp)
  while (cnt-- > 0)
c0027c53:	eb 13                	jmp    c0027c68 <output_dup+0x21>
    output (ch, aux);
c0027c55:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0027c59:	83 ec 08             	sub    $0x8,%esp
c0027c5c:	ff 75 14             	pushl  0x14(%ebp)
c0027c5f:	50                   	push   %eax
c0027c60:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c63:	ff d0                	call   *%eax
c0027c65:	83 c4 10             	add    $0x10,%esp

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
  while (cnt-- > 0)
c0027c68:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c6b:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027c6e:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027c71:	85 c0                	test   %eax,%eax
c0027c73:	75 e0                	jne    c0027c55 <output_dup+0xe>
    output (ch, aux);
}
c0027c75:	90                   	nop
c0027c76:	c9                   	leave  
c0027c77:	c3                   	ret    

c0027c78 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0027c78:	55                   	push   %ebp
c0027c79:	89 e5                	mov    %esp,%ebp
c0027c7b:	83 ec 18             	sub    $0x18,%esp
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0027c7e:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c81:	8b 40 04             	mov    0x4(%eax),%eax
c0027c84:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027c87:	7e 26                	jle    c0027caf <format_string+0x37>
c0027c89:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c8c:	8b 00                	mov    (%eax),%eax
c0027c8e:	83 e0 01             	and    $0x1,%eax
c0027c91:	85 c0                	test   %eax,%eax
c0027c93:	75 1a                	jne    c0027caf <format_string+0x37>
    output_dup (' ', c->width - length, output, aux);
c0027c95:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c98:	8b 40 04             	mov    0x4(%eax),%eax
c0027c9b:	2b 45 0c             	sub    0xc(%ebp),%eax
c0027c9e:	ff 75 18             	pushl  0x18(%ebp)
c0027ca1:	ff 75 14             	pushl  0x14(%ebp)
c0027ca4:	50                   	push   %eax
c0027ca5:	6a 20                	push   $0x20
c0027ca7:	e8 9b ff ff ff       	call   c0027c47 <output_dup>
c0027cac:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0027caf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0027cb6:	eb 21                	jmp    c0027cd9 <format_string+0x61>
    output (string[i], aux);
c0027cb8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027cbb:	8b 45 08             	mov    0x8(%ebp),%eax
c0027cbe:	01 d0                	add    %edx,%eax
c0027cc0:	0f b6 00             	movzbl (%eax),%eax
c0027cc3:	0f be c0             	movsbl %al,%eax
c0027cc6:	83 ec 08             	sub    $0x8,%esp
c0027cc9:	ff 75 18             	pushl  0x18(%ebp)
c0027ccc:	50                   	push   %eax
c0027ccd:	8b 45 14             	mov    0x14(%ebp),%eax
c0027cd0:	ff d0                	call   *%eax
c0027cd2:	83 c4 10             	add    $0x10,%esp
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c0027cd5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0027cd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027cdc:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027cdf:	7c d7                	jl     c0027cb8 <format_string+0x40>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
c0027ce1:	8b 45 10             	mov    0x10(%ebp),%eax
c0027ce4:	8b 40 04             	mov    0x4(%eax),%eax
c0027ce7:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027cea:	7e 26                	jle    c0027d12 <format_string+0x9a>
c0027cec:	8b 45 10             	mov    0x10(%ebp),%eax
c0027cef:	8b 00                	mov    (%eax),%eax
c0027cf1:	83 e0 01             	and    $0x1,%eax
c0027cf4:	85 c0                	test   %eax,%eax
c0027cf6:	74 1a                	je     c0027d12 <format_string+0x9a>
    output_dup (' ', c->width - length, output, aux);
c0027cf8:	8b 45 10             	mov    0x10(%ebp),%eax
c0027cfb:	8b 40 04             	mov    0x4(%eax),%eax
c0027cfe:	2b 45 0c             	sub    0xc(%ebp),%eax
c0027d01:	ff 75 18             	pushl  0x18(%ebp)
c0027d04:	ff 75 14             	pushl  0x14(%ebp)
c0027d07:	50                   	push   %eax
c0027d08:	6a 20                	push   $0x20
c0027d0a:	e8 38 ff ff ff       	call   c0027c47 <output_dup>
c0027d0f:	83 c4 10             	add    $0x10,%esp
}
c0027d12:	90                   	nop
c0027d13:	c9                   	leave  
c0027d14:	c3                   	ret    

c0027d15 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0027d15:	55                   	push   %ebp
c0027d16:	89 e5                	mov    %esp,%ebp
c0027d18:	83 ec 18             	sub    $0x18,%esp
  va_list args;

  va_start (args, aux);
c0027d1b:	8d 45 14             	lea    0x14(%ebp),%eax
c0027d1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  __vprintf (format, args, output, aux);
c0027d21:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027d24:	ff 75 10             	pushl  0x10(%ebp)
c0027d27:	ff 75 0c             	pushl  0xc(%ebp)
c0027d2a:	50                   	push   %eax
c0027d2b:	ff 75 08             	pushl  0x8(%ebp)
c0027d2e:	e8 f1 f4 ff ff       	call   c0027224 <__vprintf>
c0027d33:	83 c4 10             	add    $0x10,%esp
  va_end (args);
}
c0027d36:	90                   	nop
c0027d37:	c9                   	leave  
c0027d38:	c3                   	ret    

c0027d39 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027d39:	55                   	push   %ebp
c0027d3a:	89 e5                	mov    %esp,%ebp
c0027d3c:	83 ec 38             	sub    $0x38,%esp
c0027d3f:	8b 45 14             	mov    0x14(%ebp),%eax
c0027d42:	88 45 d4             	mov    %al,-0x2c(%ebp)
  const uint8_t *buf = buf_;
c0027d45:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d48:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const size_t per_line = 16; /* Maximum bytes per line. */
c0027d4b:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)

  while (size > 0)
c0027d52:	e9 bf 01 00 00       	jmp    c0027f16 <hex_dump+0x1dd>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
c0027d57:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d5a:	ba 00 00 00 00       	mov    $0x0,%edx
c0027d5f:	f7 75 e8             	divl   -0x18(%ebp)
c0027d62:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      end = per_line;
c0027d65:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027d68:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (end - start > size)
c0027d6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027d6e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027d71:	3b 45 10             	cmp    0x10(%ebp),%eax
c0027d74:	76 0b                	jbe    c0027d81 <hex_dump+0x48>
        end = start + size;
c0027d76:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027d79:	8b 45 10             	mov    0x10(%ebp),%eax
c0027d7c:	01 d0                	add    %edx,%eax
c0027d7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      n = end - start;
c0027d81:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027d84:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027d87:	89 45 e0             	mov    %eax,-0x20(%ebp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027d8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d8d:	ba 00 00 00 00       	mov    $0x0,%edx
c0027d92:	f7 75 e8             	divl   -0x18(%ebp)
c0027d95:	0f af 45 e8          	imul   -0x18(%ebp),%eax
c0027d99:	ba 00 00 00 00       	mov    $0x0,%edx
c0027d9e:	83 ec 04             	sub    $0x4,%esp
c0027da1:	52                   	push   %edx
c0027da2:	50                   	push   %eax
c0027da3:	68 24 09 03 c0       	push   $0xc0030924
c0027da8:	e8 51 f4 ff ff       	call   c00271fe <printf>
c0027dad:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0027db0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0027db7:	eb 14                	jmp    c0027dcd <hex_dump+0x94>
        printf ("   ");
c0027db9:	83 ec 0c             	sub    $0xc,%esp
c0027dbc:	68 2c 09 03 c0       	push   $0xc003092c
c0027dc1:	e8 38 f4 ff ff       	call   c00271fe <printf>
c0027dc6:	83 c4 10             	add    $0x10,%esp
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
c0027dc9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027dcd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027dd0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027dd3:	72 e4                	jb     c0027db9 <hex_dump+0x80>
        printf ("   ");
      for (; i < end; i++) 
c0027dd5:	eb 42                	jmp    c0027e19 <hex_dump+0xe0>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027dd7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027dda:	d1 e8                	shr    %eax
c0027ddc:	83 e8 01             	sub    $0x1,%eax
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
c0027ddf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0027de2:	75 07                	jne    c0027deb <hex_dump+0xb2>
c0027de4:	b9 2d 00 00 00       	mov    $0x2d,%ecx
c0027de9:	eb 05                	jmp    c0027df0 <hex_dump+0xb7>
c0027deb:	b9 20 00 00 00       	mov    $0x20,%ecx
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027df0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027df3:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027df6:	89 c2                	mov    %eax,%edx
c0027df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027dfb:	01 d0                	add    %edx,%eax
c0027dfd:	0f b6 00             	movzbl (%eax),%eax
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
c0027e00:	0f b6 c0             	movzbl %al,%eax
c0027e03:	83 ec 04             	sub    $0x4,%esp
c0027e06:	51                   	push   %ecx
c0027e07:	50                   	push   %eax
c0027e08:	68 30 09 03 c0       	push   $0xc0030930
c0027e0d:	e8 ec f3 ff ff       	call   c00271fe <printf>
c0027e12:	83 c4 10             	add    $0x10,%esp

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
c0027e15:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027e19:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027e1c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0027e1f:	72 b6                	jb     c0027dd7 <hex_dump+0x9e>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
c0027e21:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
c0027e25:	0f 84 cc 00 00 00    	je     c0027ef7 <hex_dump+0x1be>
        {
          for (; i < per_line; i++)
c0027e2b:	eb 14                	jmp    c0027e41 <hex_dump+0x108>
            printf ("   ");
c0027e2d:	83 ec 0c             	sub    $0xc,%esp
c0027e30:	68 2c 09 03 c0       	push   $0xc003092c
c0027e35:	e8 c4 f3 ff ff       	call   c00271fe <printf>
c0027e3a:	83 c4 10             	add    $0x10,%esp
      for (; i < end; i++) 
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
        {
          for (; i < per_line; i++)
c0027e3d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027e41:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027e44:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0027e47:	72 e4                	jb     c0027e2d <hex_dump+0xf4>
            printf ("   ");
          printf ("|");
c0027e49:	83 ec 0c             	sub    $0xc,%esp
c0027e4c:	6a 7c                	push   $0x7c
c0027e4e:	e8 19 3a 00 00       	call   c002b86c <putchar>
c0027e53:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0027e56:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0027e5d:	eb 11                	jmp    c0027e70 <hex_dump+0x137>
            printf (" ");
c0027e5f:	83 ec 0c             	sub    $0xc,%esp
c0027e62:	6a 20                	push   $0x20
c0027e64:	e8 03 3a 00 00       	call   c002b86c <putchar>
c0027e69:	83 c4 10             	add    $0x10,%esp
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c0027e6c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027e70:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027e73:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027e76:	72 e7                	jb     c0027e5f <hex_dump+0x126>
            printf (" ");
          for (; i < end; i++)
c0027e78:	eb 4d                	jmp    c0027ec7 <hex_dump+0x18e>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027e7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027e7d:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027e80:	89 c2                	mov    %eax,%edx
c0027e82:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e85:	01 d0                	add    %edx,%eax
c0027e87:	0f b6 00             	movzbl (%eax),%eax
c0027e8a:	0f b6 c0             	movzbl %al,%eax
c0027e8d:	83 ec 0c             	sub    $0xc,%esp
c0027e90:	50                   	push   %eax
c0027e91:	e8 90 f2 ff ff       	call   c0027126 <isprint>
c0027e96:	83 c4 10             	add    $0x10,%esp
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c0027e99:	85 c0                	test   %eax,%eax
c0027e9b:	74 15                	je     c0027eb2 <hex_dump+0x179>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027e9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027ea0:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027ea3:	89 c2                	mov    %eax,%edx
c0027ea5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027ea8:	01 d0                	add    %edx,%eax
c0027eaa:	0f b6 00             	movzbl (%eax),%eax
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c0027ead:	0f b6 c0             	movzbl %al,%eax
c0027eb0:	eb 05                	jmp    c0027eb7 <hex_dump+0x17e>
c0027eb2:	b8 2e 00 00 00       	mov    $0x2e,%eax
c0027eb7:	83 ec 0c             	sub    $0xc,%esp
c0027eba:	50                   	push   %eax
c0027ebb:	e8 ac 39 00 00       	call   c002b86c <putchar>
c0027ec0:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
c0027ec3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027ec7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027eca:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0027ecd:	72 ab                	jb     c0027e7a <hex_dump+0x141>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
c0027ecf:	eb 11                	jmp    c0027ee2 <hex_dump+0x1a9>
            printf (" ");
c0027ed1:	83 ec 0c             	sub    $0xc,%esp
c0027ed4:	6a 20                	push   $0x20
c0027ed6:	e8 91 39 00 00       	call   c002b86c <putchar>
c0027edb:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
c0027ede:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027ee2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027ee5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0027ee8:	72 e7                	jb     c0027ed1 <hex_dump+0x198>
            printf (" ");
          printf ("|");
c0027eea:	83 ec 0c             	sub    $0xc,%esp
c0027eed:	6a 7c                	push   $0x7c
c0027eef:	e8 78 39 00 00       	call   c002b86c <putchar>
c0027ef4:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0027ef7:	83 ec 0c             	sub    $0xc,%esp
c0027efa:	6a 0a                	push   $0xa
c0027efc:	e8 6b 39 00 00       	call   c002b86c <putchar>
c0027f01:	83 c4 10             	add    $0x10,%esp

      ofs += n;
c0027f04:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027f07:	01 45 08             	add    %eax,0x8(%ebp)
      buf += n;
c0027f0a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027f0d:	01 45 f4             	add    %eax,-0xc(%ebp)
      size -= n;
c0027f10:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027f13:	29 45 10             	sub    %eax,0x10(%ebp)
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0027f16:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0027f1a:	0f 85 37 fe ff ff    	jne    c0027d57 <hex_dump+0x1e>

      ofs += n;
      buf += n;
      size -= n;
    }
}
c0027f20:	90                   	nop
c0027f21:	c9                   	leave  
c0027f22:	c3                   	ret    

c0027f23 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0027f23:	55                   	push   %ebp
c0027f24:	89 e5                	mov    %esp,%ebp
c0027f26:	83 ec 28             	sub    $0x28,%esp
c0027f29:	8b 45 08             	mov    0x8(%ebp),%eax
c0027f2c:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027f2f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027f32:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (size == 1)
c0027f35:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027f38:	83 f0 01             	xor    $0x1,%eax
c0027f3b:	0b 45 e4             	or     -0x1c(%ebp),%eax
c0027f3e:	85 c0                	test   %eax,%eax
c0027f40:	75 12                	jne    c0027f54 <print_human_readable_size+0x31>
    printf ("1 byte");
c0027f42:	83 ec 0c             	sub    $0xc,%esp
c0027f45:	68 39 09 03 c0       	push   $0xc0030939
c0027f4a:	e8 af f2 ff ff       	call   c00271fe <printf>
c0027f4f:	83 c4 10             	add    $0x10,%esp

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
    }
}
c0027f52:	eb 5a                	jmp    c0027fae <print_human_readable_size+0x8b>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027f54:	c7 45 f4 a8 80 03 c0 	movl   $0xc00380a8,-0xc(%ebp)
c0027f5b:	eb 17                	jmp    c0027f74 <print_human_readable_size+0x51>
        size /= 1024;
c0027f5d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027f60:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027f63:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0027f67:	c1 ea 0a             	shr    $0xa,%edx
c0027f6a:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027f6d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027f70:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c0027f74:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0027f78:	72 1b                	jb     c0027f95 <print_human_readable_size+0x72>
c0027f7a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0027f7e:	77 09                	ja     c0027f89 <print_human_readable_size+0x66>
c0027f80:	81 7d e0 ff 03 00 00 	cmpl   $0x3ff,-0x20(%ebp)
c0027f87:	76 0c                	jbe    c0027f95 <print_human_readable_size+0x72>
c0027f89:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027f8c:	83 c0 04             	add    $0x4,%eax
c0027f8f:	8b 00                	mov    (%eax),%eax
c0027f91:	85 c0                	test   %eax,%eax
c0027f93:	75 c8                	jne    c0027f5d <print_human_readable_size+0x3a>
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
c0027f95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027f98:	8b 00                	mov    (%eax),%eax
c0027f9a:	50                   	push   %eax
c0027f9b:	ff 75 e4             	pushl  -0x1c(%ebp)
c0027f9e:	ff 75 e0             	pushl  -0x20(%ebp)
c0027fa1:	68 40 09 03 c0       	push   $0xc0030940
c0027fa6:	e8 53 f2 ff ff       	call   c00271fe <printf>
c0027fab:	83 c4 10             	add    $0x10,%esp
    }
}
c0027fae:	90                   	nop
c0027faf:	c9                   	leave  
c0027fb0:	c3                   	ret    

c0027fb1 <isdigit>:
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
static inline int isalpha (int c) { return islower (c) || isupper (c); }
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027fb1:	55                   	push   %ebp
c0027fb2:	89 e5                	mov    %esp,%ebp
c0027fb4:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0027fb8:	7e 0d                	jle    c0027fc7 <isdigit+0x16>
c0027fba:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0027fbe:	7f 07                	jg     c0027fc7 <isdigit+0x16>
c0027fc0:	b8 01 00 00 00       	mov    $0x1,%eax
c0027fc5:	eb 05                	jmp    c0027fcc <isdigit+0x1b>
c0027fc7:	b8 00 00 00 00       	mov    $0x0,%eax
c0027fcc:	5d                   	pop    %ebp
c0027fcd:	c3                   	ret    

c0027fce <isspace>:
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
c0027fce:	55                   	push   %ebp
c0027fcf:	89 e5                	mov    %esp,%ebp
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
c0027fd1:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0027fd5:	74 1e                	je     c0027ff5 <isspace+0x27>
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
  return (c == ' ' || c == '\f' || c == '\n'
c0027fd7:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0027fdb:	74 18                	je     c0027ff5 <isspace+0x27>
c0027fdd:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0027fe1:	74 12                	je     c0027ff5 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c0027fe3:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0027fe7:	74 0c                	je     c0027ff5 <isspace+0x27>
c0027fe9:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0027fed:	74 06                	je     c0027ff5 <isspace+0x27>
c0027fef:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0027ff3:	75 07                	jne    c0027ffc <isspace+0x2e>
c0027ff5:	b8 01 00 00 00       	mov    $0x1,%eax
c0027ffa:	eb 05                	jmp    c0028001 <isspace+0x33>
c0027ffc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028001:	5d                   	pop    %ebp
c0028002:	c3                   	ret    

c0028003 <atoi>:

/* Converts a string representation of a signed decimal integer
   in S into an `int', which is returned. */
int
atoi (const char *s) 
{
c0028003:	55                   	push   %ebp
c0028004:	89 e5                	mov    %esp,%ebp
c0028006:	83 ec 18             	sub    $0x18,%esp
  bool negative;
  int value;

  ASSERT (s != NULL);
c0028009:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002800d:	75 22                	jne    c0028031 <atoi+0x2e>
c002800f:	83 ec 0c             	sub    $0xc,%esp
c0028012:	68 64 09 03 c0       	push   $0xc0030964
c0028017:	68 6e 09 03 c0       	push   $0xc003096e
c002801c:	68 cc 09 03 c0       	push   $0xc00309cc
c0028021:	6a 0f                	push   $0xf
c0028023:	68 85 09 03 c0       	push   $0xc0030985
c0028028:	e8 04 16 00 00       	call   c0029631 <debug_panic>

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
    s++;
c002802d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  int value;

  ASSERT (s != NULL);

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
c0028031:	8b 45 08             	mov    0x8(%ebp),%eax
c0028034:	0f b6 00             	movzbl (%eax),%eax
c0028037:	0f b6 c0             	movzbl %al,%eax
c002803a:	83 ec 0c             	sub    $0xc,%esp
c002803d:	50                   	push   %eax
c002803e:	e8 8b ff ff ff       	call   c0027fce <isspace>
c0028043:	83 c4 10             	add    $0x10,%esp
c0028046:	85 c0                	test   %eax,%eax
c0028048:	75 e3                	jne    c002802d <atoi+0x2a>
    s++;

  /* Parse sign. */
  negative = false;
c002804a:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (*s == '+')
c002804e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028051:	0f b6 00             	movzbl (%eax),%eax
c0028054:	3c 2b                	cmp    $0x2b,%al
c0028056:	75 06                	jne    c002805e <atoi+0x5b>
    s++;
c0028058:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c002805c:	eb 12                	jmp    c0028070 <atoi+0x6d>
  else if (*s == '-')
c002805e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028061:	0f b6 00             	movzbl (%eax),%eax
c0028064:	3c 2d                	cmp    $0x2d,%al
c0028066:	75 08                	jne    c0028070 <atoi+0x6d>
    {
      negative = true;
c0028068:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
      s++;
c002806c:	83 45 08 01          	addl   $0x1,0x8(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0028070:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0028077:	eb 25                	jmp    c002809e <atoi+0x9b>
    value = value * 10 - (*s - '0');
c0028079:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002807c:	89 d0                	mov    %edx,%eax
c002807e:	c1 e0 02             	shl    $0x2,%eax
c0028081:	01 d0                	add    %edx,%eax
c0028083:	01 c0                	add    %eax,%eax
c0028085:	89 c2                	mov    %eax,%edx
c0028087:	8b 45 08             	mov    0x8(%ebp),%eax
c002808a:	0f b6 00             	movzbl (%eax),%eax
c002808d:	0f be c0             	movsbl %al,%eax
c0028090:	83 e8 30             	sub    $0x30,%eax
c0028093:	29 c2                	sub    %eax,%edx
c0028095:	89 d0                	mov    %edx,%eax
c0028097:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c002809a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c002809e:	8b 45 08             	mov    0x8(%ebp),%eax
c00280a1:	0f b6 00             	movzbl (%eax),%eax
c00280a4:	0f be c0             	movsbl %al,%eax
c00280a7:	83 ec 0c             	sub    $0xc,%esp
c00280aa:	50                   	push   %eax
c00280ab:	e8 01 ff ff ff       	call   c0027fb1 <isdigit>
c00280b0:	83 c4 10             	add    $0x10,%esp
c00280b3:	85 c0                	test   %eax,%eax
c00280b5:	75 c2                	jne    c0028079 <atoi+0x76>
    value = value * 10 - (*s - '0');
  if (!negative)
c00280b7:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00280bb:	83 f0 01             	xor    $0x1,%eax
c00280be:	84 c0                	test   %al,%al
c00280c0:	74 03                	je     c00280c5 <atoi+0xc2>
    value = -value;
c00280c2:	f7 5d f0             	negl   -0x10(%ebp)

  return value;
c00280c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c00280c8:	c9                   	leave  
c00280c9:	c3                   	ret    

c00280ca <compare_thunk>:

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c00280ca:	55                   	push   %ebp
c00280cb:	89 e5                	mov    %esp,%ebp
c00280cd:	83 ec 18             	sub    $0x18,%esp
  int (**compare) (const void *, const void *) = aux;
c00280d0:	8b 45 10             	mov    0x10(%ebp),%eax
c00280d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return (*compare) (a, b);
c00280d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00280d9:	8b 00                	mov    (%eax),%eax
c00280db:	83 ec 08             	sub    $0x8,%esp
c00280de:	ff 75 0c             	pushl  0xc(%ebp)
c00280e1:	ff 75 08             	pushl  0x8(%ebp)
c00280e4:	ff d0                	call   *%eax
c00280e6:	83 c4 10             	add    $0x10,%esp
}
c00280e9:	c9                   	leave  
c00280ea:	c3                   	ret    

c00280eb <qsort>:
   zero if A > B.  Runs in O(n lg n) time and O(1) space in
   CNT. */
void
qsort (void *array, size_t cnt, size_t size,
       int (*compare) (const void *, const void *)) 
{
c00280eb:	55                   	push   %ebp
c00280ec:	89 e5                	mov    %esp,%ebp
c00280ee:	83 ec 08             	sub    $0x8,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c00280f1:	83 ec 0c             	sub    $0xc,%esp
c00280f4:	8d 45 14             	lea    0x14(%ebp),%eax
c00280f7:	50                   	push   %eax
c00280f8:	68 ca 80 02 c0       	push   $0xc00280ca
c00280fd:	ff 75 10             	pushl  0x10(%ebp)
c0028100:	ff 75 0c             	pushl  0xc(%ebp)
c0028103:	ff 75 08             	pushl  0x8(%ebp)
c0028106:	e8 5f 01 00 00       	call   c002826a <sort>
c002810b:	83 c4 20             	add    $0x20,%esp
}
c002810e:	90                   	nop
c002810f:	c9                   	leave  
c0028110:	c3                   	ret    

c0028111 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0028111:	55                   	push   %ebp
c0028112:	89 e5                	mov    %esp,%ebp
c0028114:	83 ec 10             	sub    $0x10,%esp
  unsigned char *a = array + (a_idx - 1) * size;
c0028117:	8b 45 0c             	mov    0xc(%ebp),%eax
c002811a:	83 e8 01             	sub    $0x1,%eax
c002811d:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028121:	89 c2                	mov    %eax,%edx
c0028123:	8b 45 08             	mov    0x8(%ebp),%eax
c0028126:	01 d0                	add    %edx,%eax
c0028128:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned char *b = array + (b_idx - 1) * size;
c002812b:	8b 45 10             	mov    0x10(%ebp),%eax
c002812e:	83 e8 01             	sub    $0x1,%eax
c0028131:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028135:	89 c2                	mov    %eax,%edx
c0028137:	8b 45 08             	mov    0x8(%ebp),%eax
c002813a:	01 d0                	add    %edx,%eax
c002813c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t i;

  for (i = 0; i < size; i++)
c002813f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0028146:	eb 35                	jmp    c002817d <do_swap+0x6c>
    {
      unsigned char t = a[i];
c0028148:	8b 55 f8             	mov    -0x8(%ebp),%edx
c002814b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002814e:	01 d0                	add    %edx,%eax
c0028150:	0f b6 00             	movzbl (%eax),%eax
c0028153:	88 45 f3             	mov    %al,-0xd(%ebp)
      a[i] = b[i];
c0028156:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0028159:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002815c:	01 c2                	add    %eax,%edx
c002815e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0028161:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028164:	01 c8                	add    %ecx,%eax
c0028166:	0f b6 00             	movzbl (%eax),%eax
c0028169:	88 02                	mov    %al,(%edx)
      b[i] = t;
c002816b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002816e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028171:	01 c2                	add    %eax,%edx
c0028173:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c0028177:	88 02                	mov    %al,(%edx)
{
  unsigned char *a = array + (a_idx - 1) * size;
  unsigned char *b = array + (b_idx - 1) * size;
  size_t i;

  for (i = 0; i < size; i++)
c0028179:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c002817d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028180:	3b 45 14             	cmp    0x14(%ebp),%eax
c0028183:	72 c3                	jb     c0028148 <do_swap+0x37>
    {
      unsigned char t = a[i];
      a[i] = b[i];
      b[i] = t;
    }
}
c0028185:	90                   	nop
c0028186:	c9                   	leave  
c0028187:	c3                   	ret    

c0028188 <do_compare>:
   strcmp()-type result. */
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
c0028188:	55                   	push   %ebp
c0028189:	89 e5                	mov    %esp,%ebp
c002818b:	83 ec 08             	sub    $0x8,%esp
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c002818e:	8b 45 10             	mov    0x10(%ebp),%eax
c0028191:	83 e8 01             	sub    $0x1,%eax
c0028194:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028198:	89 c2                	mov    %eax,%edx
c002819a:	8b 45 08             	mov    0x8(%ebp),%eax
c002819d:	01 c2                	add    %eax,%edx
c002819f:	8b 45 0c             	mov    0xc(%ebp),%eax
c00281a2:	83 e8 01             	sub    $0x1,%eax
c00281a5:	0f af 45 14          	imul   0x14(%ebp),%eax
c00281a9:	89 c1                	mov    %eax,%ecx
c00281ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00281ae:	01 c8                	add    %ecx,%eax
c00281b0:	83 ec 04             	sub    $0x4,%esp
c00281b3:	ff 75 1c             	pushl  0x1c(%ebp)
c00281b6:	52                   	push   %edx
c00281b7:	50                   	push   %eax
c00281b8:	8b 45 18             	mov    0x18(%ebp),%eax
c00281bb:	ff d0                	call   *%eax
c00281bd:	83 c4 10             	add    $0x10,%esp
}
c00281c0:	c9                   	leave  
c00281c1:	c3                   	ret    

c00281c2 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c00281c2:	55                   	push   %ebp
c00281c3:	89 e5                	mov    %esp,%ebp
c00281c5:	83 ec 18             	sub    $0x18,%esp
  for (;;) 
    {
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
c00281c8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00281cb:	01 c0                	add    %eax,%eax
c00281cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t right = 2 * i + 1;
c00281d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00281d3:	01 c0                	add    %eax,%eax
c00281d5:	83 c0 01             	add    $0x1,%eax
c00281d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
      size_t max = i;
c00281db:	8b 45 0c             	mov    0xc(%ebp),%eax
c00281de:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c00281e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00281e4:	3b 45 10             	cmp    0x10(%ebp),%eax
c00281e7:	77 27                	ja     c0028210 <heapify+0x4e>
c00281e9:	83 ec 08             	sub    $0x8,%esp
c00281ec:	ff 75 1c             	pushl  0x1c(%ebp)
c00281ef:	ff 75 18             	pushl  0x18(%ebp)
c00281f2:	ff 75 14             	pushl  0x14(%ebp)
c00281f5:	ff 75 f4             	pushl  -0xc(%ebp)
c00281f8:	ff 75 f0             	pushl  -0x10(%ebp)
c00281fb:	ff 75 08             	pushl  0x8(%ebp)
c00281fe:	e8 85 ff ff ff       	call   c0028188 <do_compare>
c0028203:	83 c4 20             	add    $0x20,%esp
c0028206:	85 c0                	test   %eax,%eax
c0028208:	7e 06                	jle    c0028210 <heapify+0x4e>
        max = left;
c002820a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002820d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (right <= cnt
c0028210:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028213:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028216:	77 27                	ja     c002823f <heapify+0x7d>
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0028218:	83 ec 08             	sub    $0x8,%esp
c002821b:	ff 75 1c             	pushl  0x1c(%ebp)
c002821e:	ff 75 18             	pushl  0x18(%ebp)
c0028221:	ff 75 14             	pushl  0x14(%ebp)
c0028224:	ff 75 f4             	pushl  -0xc(%ebp)
c0028227:	ff 75 ec             	pushl  -0x14(%ebp)
c002822a:	ff 75 08             	pushl  0x8(%ebp)
c002822d:	e8 56 ff ff ff       	call   c0028188 <do_compare>
c0028232:	83 c4 20             	add    $0x20,%esp
c0028235:	85 c0                	test   %eax,%eax
c0028237:	7e 06                	jle    c002823f <heapify+0x7d>
        max = right;
c0028239:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002823c:	89 45 f4             	mov    %eax,-0xc(%ebp)

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c002823f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028242:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028245:	74 1f                	je     c0028266 <heapify+0xa4>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0028247:	ff 75 14             	pushl  0x14(%ebp)
c002824a:	ff 75 f4             	pushl  -0xc(%ebp)
c002824d:	ff 75 0c             	pushl  0xc(%ebp)
c0028250:	ff 75 08             	pushl  0x8(%ebp)
c0028253:	e8 b9 fe ff ff       	call   c0028111 <do_swap>
c0028258:	83 c4 10             	add    $0x10,%esp
      i = max;
c002825b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002825e:	89 45 0c             	mov    %eax,0xc(%ebp)
    }
c0028261:	e9 62 ff ff ff       	jmp    c00281c8 <heapify+0x6>
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
        break;
c0028266:	90                   	nop

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
      i = max;
    }
}
c0028267:	90                   	nop
c0028268:	c9                   	leave  
c0028269:	c3                   	ret    

c002826a <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c002826a:	55                   	push   %ebp
c002826b:	89 e5                	mov    %esp,%ebp
c002826d:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c0028270:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028274:	75 27                	jne    c002829d <sort+0x33>
c0028276:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002827a:	74 21                	je     c002829d <sort+0x33>
c002827c:	83 ec 0c             	sub    $0xc,%esp
c002827f:	68 98 09 03 c0       	push   $0xc0030998
c0028284:	68 6e 09 03 c0       	push   $0xc003096e
c0028289:	68 d4 09 03 c0       	push   $0xc00309d4
c002828e:	68 8a 00 00 00       	push   $0x8a
c0028293:	68 85 09 03 c0       	push   $0xc0030985
c0028298:	e8 94 13 00 00       	call   c0029631 <debug_panic>
  ASSERT (compare != NULL);
c002829d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c00282a1:	75 21                	jne    c00282c4 <sort+0x5a>
c00282a3:	83 ec 0c             	sub    $0xc,%esp
c00282a6:	68 b2 09 03 c0       	push   $0xc00309b2
c00282ab:	68 6e 09 03 c0       	push   $0xc003096e
c00282b0:	68 d4 09 03 c0       	push   $0xc00309d4
c00282b5:	68 8b 00 00 00       	push   $0x8b
c00282ba:	68 85 09 03 c0       	push   $0xc0030985
c00282bf:	e8 6d 13 00 00       	call   c0029631 <debug_panic>
  ASSERT (size > 0);
c00282c4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00282c8:	75 21                	jne    c00282eb <sort+0x81>
c00282ca:	83 ec 0c             	sub    $0xc,%esp
c00282cd:	68 c2 09 03 c0       	push   $0xc00309c2
c00282d2:	68 6e 09 03 c0       	push   $0xc003096e
c00282d7:	68 d4 09 03 c0       	push   $0xc00309d4
c00282dc:	68 8c 00 00 00       	push   $0x8c
c00282e1:	68 85 09 03 c0       	push   $0xc0030985
c00282e6:	e8 46 13 00 00       	call   c0029631 <debug_panic>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c00282eb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00282ee:	d1 e8                	shr    %eax
c00282f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00282f3:	eb 21                	jmp    c0028316 <sort+0xac>
    heapify (array, i, cnt, size, compare, aux);
c00282f5:	83 ec 08             	sub    $0x8,%esp
c00282f8:	ff 75 18             	pushl  0x18(%ebp)
c00282fb:	ff 75 14             	pushl  0x14(%ebp)
c00282fe:	ff 75 10             	pushl  0x10(%ebp)
c0028301:	ff 75 0c             	pushl  0xc(%ebp)
c0028304:	ff 75 f4             	pushl  -0xc(%ebp)
c0028307:	ff 75 08             	pushl  0x8(%ebp)
c002830a:	e8 b3 fe ff ff       	call   c00281c2 <heapify>
c002830f:	83 c4 20             	add    $0x20,%esp
  ASSERT (array != NULL || cnt == 0);
  ASSERT (compare != NULL);
  ASSERT (size > 0);

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0028312:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c0028316:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002831a:	75 d9                	jne    c00282f5 <sort+0x8b>
    heapify (array, i, cnt, size, compare, aux);

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c002831c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002831f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028322:	eb 37                	jmp    c002835b <sort+0xf1>
    {
      do_swap (array, 1, i, size);
c0028324:	ff 75 10             	pushl  0x10(%ebp)
c0028327:	ff 75 f4             	pushl  -0xc(%ebp)
c002832a:	6a 01                	push   $0x1
c002832c:	ff 75 08             	pushl  0x8(%ebp)
c002832f:	e8 dd fd ff ff       	call   c0028111 <do_swap>
c0028334:	83 c4 10             	add    $0x10,%esp
      heapify (array, 1, i - 1, size, compare, aux); 
c0028337:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002833a:	83 e8 01             	sub    $0x1,%eax
c002833d:	83 ec 08             	sub    $0x8,%esp
c0028340:	ff 75 18             	pushl  0x18(%ebp)
c0028343:	ff 75 14             	pushl  0x14(%ebp)
c0028346:	ff 75 10             	pushl  0x10(%ebp)
c0028349:	50                   	push   %eax
c002834a:	6a 01                	push   $0x1
c002834c:	ff 75 08             	pushl  0x8(%ebp)
c002834f:	e8 6e fe ff ff       	call   c00281c2 <heapify>
c0028354:	83 c4 20             	add    $0x20,%esp
  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
    heapify (array, i, cnt, size, compare, aux);

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0028357:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c002835b:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002835f:	77 c3                	ja     c0028324 <sort+0xba>
    {
      do_swap (array, 1, i, size);
      heapify (array, 1, i - 1, size, compare, aux); 
    }
}
c0028361:	90                   	nop
c0028362:	c9                   	leave  
c0028363:	c3                   	ret    

c0028364 <bsearch>:
   strcmp()-type result, i.e. less than zero if A < B, zero if A
   == B, greater than zero if A > B. */
void *
bsearch (const void *key, const void *array, size_t cnt,
         size_t size, int (*compare) (const void *, const void *)) 
{
c0028364:	55                   	push   %ebp
c0028365:	89 e5                	mov    %esp,%ebp
c0028367:	83 ec 08             	sub    $0x8,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c002836a:	83 ec 08             	sub    $0x8,%esp
c002836d:	8d 45 18             	lea    0x18(%ebp),%eax
c0028370:	50                   	push   %eax
c0028371:	68 ca 80 02 c0       	push   $0xc00280ca
c0028376:	ff 75 14             	pushl  0x14(%ebp)
c0028379:	ff 75 10             	pushl  0x10(%ebp)
c002837c:	ff 75 0c             	pushl  0xc(%ebp)
c002837f:	ff 75 08             	pushl  0x8(%ebp)
c0028382:	e8 05 00 00 00       	call   c002838c <binary_search>
c0028387:	83 c4 20             	add    $0x20,%esp
}
c002838a:	c9                   	leave  
c002838b:	c3                   	ret    

c002838c <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c002838c:	55                   	push   %ebp
c002838d:	89 e5                	mov    %esp,%ebp
c002838f:	83 ec 28             	sub    $0x28,%esp
  const unsigned char *first = array;
c0028392:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028395:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *last = array + size * cnt;
c0028398:	8b 45 14             	mov    0x14(%ebp),%eax
c002839b:	0f af 45 10          	imul   0x10(%ebp),%eax
c002839f:	89 c2                	mov    %eax,%edx
c00283a1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00283a4:	01 d0                	add    %edx,%eax
c00283a6:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while (first < last) 
c00283a9:	eb 65                	jmp    c0028410 <binary_search+0x84>
    {
      size_t range = (last - first) / size;
c00283ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00283ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00283b1:	29 c2                	sub    %eax,%edx
c00283b3:	89 d0                	mov    %edx,%eax
c00283b5:	ba 00 00 00 00       	mov    $0x0,%edx
c00283ba:	f7 75 14             	divl   0x14(%ebp)
c00283bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
      const unsigned char *middle = first + (range / 2) * size;
c00283c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00283c3:	d1 e8                	shr    %eax
c00283c5:	0f af 45 14          	imul   0x14(%ebp),%eax
c00283c9:	89 c2                	mov    %eax,%edx
c00283cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00283ce:	01 d0                	add    %edx,%eax
c00283d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int cmp = compare (key, middle, aux);
c00283d3:	83 ec 04             	sub    $0x4,%esp
c00283d6:	ff 75 1c             	pushl  0x1c(%ebp)
c00283d9:	ff 75 e8             	pushl  -0x18(%ebp)
c00283dc:	ff 75 08             	pushl  0x8(%ebp)
c00283df:	8b 45 18             	mov    0x18(%ebp),%eax
c00283e2:	ff d0                	call   *%eax
c00283e4:	83 c4 10             	add    $0x10,%esp
c00283e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if (cmp < 0) 
c00283ea:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00283ee:	79 08                	jns    c00283f8 <binary_search+0x6c>
        last = middle;
c00283f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00283f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00283f6:	eb 18                	jmp    c0028410 <binary_search+0x84>
      else if (cmp > 0) 
c00283f8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00283fc:	7e 0d                	jle    c002840b <binary_search+0x7f>
        first = middle + size;
c00283fe:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0028401:	8b 45 14             	mov    0x14(%ebp),%eax
c0028404:	01 d0                	add    %edx,%eax
c0028406:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028409:	eb 05                	jmp    c0028410 <binary_search+0x84>
      else
        return (void *) middle;
c002840b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002840e:	eb 0d                	jmp    c002841d <binary_search+0x91>
               void *aux) 
{
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;

  while (first < last) 
c0028410:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028413:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028416:	72 93                	jb     c00283ab <binary_search+0x1f>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c0028418:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002841d:	c9                   	leave  
c002841e:	c3                   	ret    

c002841f <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c002841f:	55                   	push   %ebp
c0028420:	89 e5                	mov    %esp,%ebp
c0028422:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028425:	8b 45 08             	mov    0x8(%ebp),%eax
c0028428:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c002842b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002842e:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028431:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028435:	75 24                	jne    c002845b <memcpy+0x3c>
c0028437:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002843b:	74 1e                	je     c002845b <memcpy+0x3c>
c002843d:	83 ec 0c             	sub    $0xc,%esp
c0028440:	68 dc 09 03 c0       	push   $0xc00309dc
c0028445:	68 f5 09 03 c0       	push   $0xc00309f5
c002844a:	68 ec 0a 03 c0       	push   $0xc0030aec
c002844f:	6a 0c                	push   $0xc
c0028451:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028456:	e8 d6 11 00 00       	call   c0029631 <debug_panic>
  ASSERT (src != NULL || size == 0);
c002845b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002845f:	75 3b                	jne    c002849c <memcpy+0x7d>
c0028461:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028465:	74 35                	je     c002849c <memcpy+0x7d>
c0028467:	83 ec 0c             	sub    $0xc,%esp
c002846a:	68 1f 0a 03 c0       	push   $0xc0030a1f
c002846f:	68 f5 09 03 c0       	push   $0xc00309f5
c0028474:	68 ec 0a 03 c0       	push   $0xc0030aec
c0028479:	6a 0d                	push   $0xd
c002847b:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028480:	e8 ac 11 00 00       	call   c0029631 <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
c0028485:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028488:	8d 50 01             	lea    0x1(%eax),%edx
c002848b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002848e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028491:	8d 4a 01             	lea    0x1(%edx),%ecx
c0028494:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028497:	0f b6 12             	movzbl (%edx),%edx
c002849a:	88 10                	mov    %dl,(%eax)
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c002849c:	8b 45 10             	mov    0x10(%ebp),%eax
c002849f:	8d 50 ff             	lea    -0x1(%eax),%edx
c00284a2:	89 55 10             	mov    %edx,0x10(%ebp)
c00284a5:	85 c0                	test   %eax,%eax
c00284a7:	75 dc                	jne    c0028485 <memcpy+0x66>
    *dst++ = *src++;

  return dst_;
c00284a9:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00284ac:	c9                   	leave  
c00284ad:	c3                   	ret    

c00284ae <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c00284ae:	55                   	push   %ebp
c00284af:	89 e5                	mov    %esp,%ebp
c00284b1:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c00284b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00284b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c00284ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00284bd:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c00284c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00284c4:	75 24                	jne    c00284ea <memmove+0x3c>
c00284c6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00284ca:	74 1e                	je     c00284ea <memmove+0x3c>
c00284cc:	83 ec 0c             	sub    $0xc,%esp
c00284cf:	68 dc 09 03 c0       	push   $0xc00309dc
c00284d4:	68 f5 09 03 c0       	push   $0xc00309f5
c00284d9:	68 f4 0a 03 c0       	push   $0xc0030af4
c00284de:	6a 1d                	push   $0x1d
c00284e0:	68 0c 0a 03 c0       	push   $0xc0030a0c
c00284e5:	e8 47 11 00 00       	call   c0029631 <debug_panic>
  ASSERT (src != NULL || size == 0);
c00284ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00284ee:	75 24                	jne    c0028514 <memmove+0x66>
c00284f0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00284f4:	74 1e                	je     c0028514 <memmove+0x66>
c00284f6:	83 ec 0c             	sub    $0xc,%esp
c00284f9:	68 1f 0a 03 c0       	push   $0xc0030a1f
c00284fe:	68 f5 09 03 c0       	push   $0xc00309f5
c0028503:	68 f4 0a 03 c0       	push   $0xc0030af4
c0028508:	6a 1e                	push   $0x1e
c002850a:	68 0c 0a 03 c0       	push   $0xc0030a0c
c002850f:	e8 1d 11 00 00       	call   c0029631 <debug_panic>

  if (dst < src) 
c0028514:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028517:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002851a:	73 28                	jae    c0028544 <memmove+0x96>
    {
      while (size-- > 0)
c002851c:	eb 17                	jmp    c0028535 <memmove+0x87>
        *dst++ = *src++;
c002851e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028521:	8d 50 01             	lea    0x1(%eax),%edx
c0028524:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028527:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002852a:	8d 4a 01             	lea    0x1(%edx),%ecx
c002852d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028530:	0f b6 12             	movzbl (%edx),%edx
c0028533:	88 10                	mov    %dl,(%eax)
  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
    {
      while (size-- > 0)
c0028535:	8b 45 10             	mov    0x10(%ebp),%eax
c0028538:	8d 50 ff             	lea    -0x1(%eax),%edx
c002853b:	89 55 10             	mov    %edx,0x10(%ebp)
c002853e:	85 c0                	test   %eax,%eax
c0028540:	75 dc                	jne    c002851e <memmove+0x70>
c0028542:	eb 2e                	jmp    c0028572 <memmove+0xc4>
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
c0028544:	8b 45 10             	mov    0x10(%ebp),%eax
c0028547:	01 45 f4             	add    %eax,-0xc(%ebp)
      src += size;
c002854a:	8b 45 10             	mov    0x10(%ebp),%eax
c002854d:	01 45 f0             	add    %eax,-0x10(%ebp)
      while (size-- > 0)
c0028550:	eb 13                	jmp    c0028565 <memmove+0xb7>
        *--dst = *--src;
c0028552:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c0028556:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c002855a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002855d:	0f b6 10             	movzbl (%eax),%edx
c0028560:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028563:	88 10                	mov    %dl,(%eax)
    }
  else 
    {
      dst += size;
      src += size;
      while (size-- > 0)
c0028565:	8b 45 10             	mov    0x10(%ebp),%eax
c0028568:	8d 50 ff             	lea    -0x1(%eax),%edx
c002856b:	89 55 10             	mov    %edx,0x10(%ebp)
c002856e:	85 c0                	test   %eax,%eax
c0028570:	75 e0                	jne    c0028552 <memmove+0xa4>
        *--dst = *--src;
    }

  return dst;
c0028572:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028575:	c9                   	leave  
c0028576:	c3                   	ret    

c0028577 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0028577:	55                   	push   %ebp
c0028578:	89 e5                	mov    %esp,%ebp
c002857a:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = a_;
c002857d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028580:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = b_;
c0028583:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028586:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL || size == 0);
c0028589:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002858d:	75 24                	jne    c00285b3 <memcmp+0x3c>
c002858f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028593:	74 1e                	je     c00285b3 <memcmp+0x3c>
c0028595:	83 ec 0c             	sub    $0xc,%esp
c0028598:	68 38 0a 03 c0       	push   $0xc0030a38
c002859d:	68 f5 09 03 c0       	push   $0xc00309f5
c00285a2:	68 fc 0a 03 c0       	push   $0xc0030afc
c00285a7:	6a 3a                	push   $0x3a
c00285a9:	68 0c 0a 03 c0       	push   $0xc0030a0c
c00285ae:	e8 7e 10 00 00       	call   c0029631 <debug_panic>
  ASSERT (b != NULL || size == 0);
c00285b3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00285b7:	75 5a                	jne    c0028613 <memcmp+0x9c>
c00285b9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00285bd:	74 54                	je     c0028613 <memcmp+0x9c>
c00285bf:	83 ec 0c             	sub    $0xc,%esp
c00285c2:	68 4f 0a 03 c0       	push   $0xc0030a4f
c00285c7:	68 f5 09 03 c0       	push   $0xc00309f5
c00285cc:	68 fc 0a 03 c0       	push   $0xc0030afc
c00285d1:	6a 3b                	push   $0x3b
c00285d3:	68 0c 0a 03 c0       	push   $0xc0030a0c
c00285d8:	e8 54 10 00 00       	call   c0029631 <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
c00285dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285e0:	0f b6 10             	movzbl (%eax),%edx
c00285e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00285e6:	0f b6 00             	movzbl (%eax),%eax
c00285e9:	38 c2                	cmp    %al,%dl
c00285eb:	74 1e                	je     c002860b <memcmp+0x94>
      return *a > *b ? +1 : -1;
c00285ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285f0:	0f b6 10             	movzbl (%eax),%edx
c00285f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00285f6:	0f b6 00             	movzbl (%eax),%eax
c00285f9:	38 c2                	cmp    %al,%dl
c00285fb:	76 07                	jbe    c0028604 <memcmp+0x8d>
c00285fd:	b8 01 00 00 00       	mov    $0x1,%eax
c0028602:	eb 21                	jmp    c0028625 <memcmp+0xae>
c0028604:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0028609:	eb 1a                	jmp    c0028625 <memcmp+0xae>
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c002860b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002860f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0028613:	8b 45 10             	mov    0x10(%ebp),%eax
c0028616:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028619:	89 55 10             	mov    %edx,0x10(%ebp)
c002861c:	85 c0                	test   %eax,%eax
c002861e:	75 bd                	jne    c00285dd <memcmp+0x66>
    if (*a != *b)
      return *a > *b ? +1 : -1;
  return 0;
c0028620:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028625:	c9                   	leave  
c0028626:	c3                   	ret    

c0028627 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c0028627:	55                   	push   %ebp
c0028628:	89 e5                	mov    %esp,%ebp
c002862a:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = (const unsigned char *) a_;
c002862d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028630:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = (const unsigned char *) b_;
c0028633:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028636:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL);
c0028639:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002863d:	75 1e                	jne    c002865d <strcmp+0x36>
c002863f:	83 ec 0c             	sub    $0xc,%esp
c0028642:	68 66 0a 03 c0       	push   $0xc0030a66
c0028647:	68 f5 09 03 c0       	push   $0xc00309f5
c002864c:	68 04 0b 03 c0       	push   $0xc0030b04
c0028651:	6a 4e                	push   $0x4e
c0028653:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028658:	e8 d4 0f 00 00       	call   c0029631 <debug_panic>
  ASSERT (b != NULL);
c002865d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028661:	75 26                	jne    c0028689 <strcmp+0x62>
c0028663:	83 ec 0c             	sub    $0xc,%esp
c0028666:	68 70 0a 03 c0       	push   $0xc0030a70
c002866b:	68 f5 09 03 c0       	push   $0xc00309f5
c0028670:	68 04 0b 03 c0       	push   $0xc0030b04
c0028675:	6a 4f                	push   $0x4f
c0028677:	68 0c 0a 03 c0       	push   $0xc0030a0c
c002867c:	e8 b0 0f 00 00       	call   c0029631 <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
c0028681:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      b++;
c0028685:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c0028689:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002868c:	0f b6 00             	movzbl (%eax),%eax
c002868f:	84 c0                	test   %al,%al
c0028691:	74 10                	je     c00286a3 <strcmp+0x7c>
c0028693:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028696:	0f b6 10             	movzbl (%eax),%edx
c0028699:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002869c:	0f b6 00             	movzbl (%eax),%eax
c002869f:	38 c2                	cmp    %al,%dl
c00286a1:	74 de                	je     c0028681 <strcmp+0x5a>
    {
      a++;
      b++;
    }

  return *a < *b ? -1 : *a > *b;
c00286a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286a6:	0f b6 10             	movzbl (%eax),%edx
c00286a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00286ac:	0f b6 00             	movzbl (%eax),%eax
c00286af:	38 c2                	cmp    %al,%dl
c00286b1:	72 16                	jb     c00286c9 <strcmp+0xa2>
c00286b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286b6:	0f b6 10             	movzbl (%eax),%edx
c00286b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00286bc:	0f b6 00             	movzbl (%eax),%eax
c00286bf:	38 c2                	cmp    %al,%dl
c00286c1:	0f 97 c0             	seta   %al
c00286c4:	0f b6 c0             	movzbl %al,%eax
c00286c7:	eb 05                	jmp    c00286ce <strcmp+0xa7>
c00286c9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c00286ce:	c9                   	leave  
c00286cf:	c3                   	ret    

c00286d0 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c00286d0:	55                   	push   %ebp
c00286d1:	89 e5                	mov    %esp,%ebp
c00286d3:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *block = block_;
c00286d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00286d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned char ch = ch_;
c00286dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00286df:	88 45 f3             	mov    %al,-0xd(%ebp)

  ASSERT (block != NULL || size == 0);
c00286e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00286e6:	75 38                	jne    c0028720 <memchr+0x50>
c00286e8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00286ec:	74 32                	je     c0028720 <memchr+0x50>
c00286ee:	83 ec 0c             	sub    $0xc,%esp
c00286f1:	68 7a 0a 03 c0       	push   $0xc0030a7a
c00286f6:	68 f5 09 03 c0       	push   $0xc00309f5
c00286fb:	68 0c 0b 03 c0       	push   $0xc0030b0c
c0028700:	6a 63                	push   $0x63
c0028702:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028707:	e8 25 0f 00 00       	call   c0029631 <debug_panic>

  for (; size-- > 0; block++)
    if (*block == ch)
c002870c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002870f:	0f b6 00             	movzbl (%eax),%eax
c0028712:	3a 45 f3             	cmp    -0xd(%ebp),%al
c0028715:	75 05                	jne    c002871c <memchr+0x4c>
      return (void *) block;
c0028717:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002871a:	eb 16                	jmp    c0028732 <memchr+0x62>
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c002871c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028720:	8b 45 10             	mov    0x10(%ebp),%eax
c0028723:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028726:	89 55 10             	mov    %edx,0x10(%ebp)
c0028729:	85 c0                	test   %eax,%eax
c002872b:	75 df                	jne    c002870c <memchr+0x3c>
    if (*block == ch)
      return (void *) block;

  return NULL;
c002872d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028732:	c9                   	leave  
c0028733:	c3                   	ret    

c0028734 <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c0028734:	55                   	push   %ebp
c0028735:	89 e5                	mov    %esp,%ebp
c0028737:	83 ec 18             	sub    $0x18,%esp
  char c = c_;
c002873a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002873d:	88 45 f7             	mov    %al,-0x9(%ebp)

  ASSERT (string != NULL);
c0028740:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028744:	75 1e                	jne    c0028764 <strchr+0x30>
c0028746:	83 ec 0c             	sub    $0xc,%esp
c0028749:	68 95 0a 03 c0       	push   $0xc0030a95
c002874e:	68 f5 09 03 c0       	push   $0xc00309f5
c0028753:	68 14 0b 03 c0       	push   $0xc0030b14
c0028758:	6a 75                	push   $0x75
c002875a:	68 0c 0a 03 c0       	push   $0xc0030a0c
c002875f:	e8 cd 0e 00 00       	call   c0029631 <debug_panic>

  for (;;) 
    if (*string == c)
c0028764:	8b 45 08             	mov    0x8(%ebp),%eax
c0028767:	0f b6 00             	movzbl (%eax),%eax
c002876a:	3a 45 f7             	cmp    -0x9(%ebp),%al
c002876d:	75 05                	jne    c0028774 <strchr+0x40>
      return (char *) string;
c002876f:	8b 45 08             	mov    0x8(%ebp),%eax
c0028772:	eb 17                	jmp    c002878b <strchr+0x57>
    else if (*string == '\0')
c0028774:	8b 45 08             	mov    0x8(%ebp),%eax
c0028777:	0f b6 00             	movzbl (%eax),%eax
c002877a:	84 c0                	test   %al,%al
c002877c:	75 07                	jne    c0028785 <strchr+0x51>
      return NULL;
c002877e:	b8 00 00 00 00       	mov    $0x0,%eax
c0028783:	eb 06                	jmp    c002878b <strchr+0x57>
    else
      string++;
c0028785:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0028789:	eb d9                	jmp    c0028764 <strchr+0x30>
}
c002878b:	c9                   	leave  
c002878c:	c3                   	ret    

c002878d <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c002878d:	55                   	push   %ebp
c002878e:	89 e5                	mov    %esp,%ebp
c0028790:	83 ec 18             	sub    $0x18,%esp
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0028793:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002879a:	eb 25                	jmp    c00287c1 <strcspn+0x34>
    if (strchr (stop, string[length]) != NULL)
c002879c:	8b 55 08             	mov    0x8(%ebp),%edx
c002879f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287a2:	01 d0                	add    %edx,%eax
c00287a4:	0f b6 00             	movzbl (%eax),%eax
c00287a7:	0f be c0             	movsbl %al,%eax
c00287aa:	83 ec 08             	sub    $0x8,%esp
c00287ad:	50                   	push   %eax
c00287ae:	ff 75 0c             	pushl  0xc(%ebp)
c00287b1:	e8 7e ff ff ff       	call   c0028734 <strchr>
c00287b6:	83 c4 10             	add    $0x10,%esp
c00287b9:	85 c0                	test   %eax,%eax
c00287bb:	75 15                	jne    c00287d2 <strcspn+0x45>
size_t
strcspn (const char *string, const char *stop) 
{
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c00287bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00287c1:	8b 55 08             	mov    0x8(%ebp),%edx
c00287c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287c7:	01 d0                	add    %edx,%eax
c00287c9:	0f b6 00             	movzbl (%eax),%eax
c00287cc:	84 c0                	test   %al,%al
c00287ce:	75 cc                	jne    c002879c <strcspn+0xf>
c00287d0:	eb 01                	jmp    c00287d3 <strcspn+0x46>
    if (strchr (stop, string[length]) != NULL)
      break;
c00287d2:	90                   	nop
  return length;
c00287d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00287d6:	c9                   	leave  
c00287d7:	c3                   	ret    

c00287d8 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c00287d8:	55                   	push   %ebp
c00287d9:	89 e5                	mov    %esp,%ebp
c00287db:	83 ec 08             	sub    $0x8,%esp
  for (; *string != '\0'; string++)
c00287de:	eb 25                	jmp    c0028805 <strpbrk+0x2d>
    if (strchr (stop, *string) != NULL)
c00287e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00287e3:	0f b6 00             	movzbl (%eax),%eax
c00287e6:	0f be c0             	movsbl %al,%eax
c00287e9:	83 ec 08             	sub    $0x8,%esp
c00287ec:	50                   	push   %eax
c00287ed:	ff 75 0c             	pushl  0xc(%ebp)
c00287f0:	e8 3f ff ff ff       	call   c0028734 <strchr>
c00287f5:	83 c4 10             	add    $0x10,%esp
c00287f8:	85 c0                	test   %eax,%eax
c00287fa:	74 05                	je     c0028801 <strpbrk+0x29>
      return (char *) string;
c00287fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00287ff:	eb 13                	jmp    c0028814 <strpbrk+0x3c>
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
  for (; *string != '\0'; string++)
c0028801:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0028805:	8b 45 08             	mov    0x8(%ebp),%eax
c0028808:	0f b6 00             	movzbl (%eax),%eax
c002880b:	84 c0                	test   %al,%al
c002880d:	75 d1                	jne    c00287e0 <strpbrk+0x8>
    if (strchr (stop, *string) != NULL)
      return (char *) string;
  return NULL;
c002880f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028814:	c9                   	leave  
c0028815:	c3                   	ret    

c0028816 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0028816:	55                   	push   %ebp
c0028817:	89 e5                	mov    %esp,%ebp
c0028819:	83 ec 10             	sub    $0x10,%esp
  char c = c_;
c002881c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002881f:	88 45 fb             	mov    %al,-0x5(%ebp)
  const char *p = NULL;
c0028822:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (; *string != '\0'; string++)
c0028829:	eb 15                	jmp    c0028840 <strrchr+0x2a>
    if (*string == c)
c002882b:	8b 45 08             	mov    0x8(%ebp),%eax
c002882e:	0f b6 00             	movzbl (%eax),%eax
c0028831:	3a 45 fb             	cmp    -0x5(%ebp),%al
c0028834:	75 06                	jne    c002883c <strrchr+0x26>
      p = string;
c0028836:	8b 45 08             	mov    0x8(%ebp),%eax
c0028839:	89 45 fc             	mov    %eax,-0x4(%ebp)
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;

  for (; *string != '\0'; string++)
c002883c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0028840:	8b 45 08             	mov    0x8(%ebp),%eax
c0028843:	0f b6 00             	movzbl (%eax),%eax
c0028846:	84 c0                	test   %al,%al
c0028848:	75 e1                	jne    c002882b <strrchr+0x15>
    if (*string == c)
      p = string;
  return (char *) p;
c002884a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002884d:	c9                   	leave  
c002884e:	c3                   	ret    

c002884f <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c002884f:	55                   	push   %ebp
c0028850:	89 e5                	mov    %esp,%ebp
c0028852:	83 ec 18             	sub    $0x18,%esp
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c0028855:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002885c:	eb 25                	jmp    c0028883 <strspn+0x34>
    if (strchr (skip, string[length]) == NULL)
c002885e:	8b 55 08             	mov    0x8(%ebp),%edx
c0028861:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028864:	01 d0                	add    %edx,%eax
c0028866:	0f b6 00             	movzbl (%eax),%eax
c0028869:	0f be c0             	movsbl %al,%eax
c002886c:	83 ec 08             	sub    $0x8,%esp
c002886f:	50                   	push   %eax
c0028870:	ff 75 0c             	pushl  0xc(%ebp)
c0028873:	e8 bc fe ff ff       	call   c0028734 <strchr>
c0028878:	83 c4 10             	add    $0x10,%esp
c002887b:	85 c0                	test   %eax,%eax
c002887d:	74 15                	je     c0028894 <strspn+0x45>
size_t
strspn (const char *string, const char *skip) 
{
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c002887f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028883:	8b 55 08             	mov    0x8(%ebp),%edx
c0028886:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028889:	01 d0                	add    %edx,%eax
c002888b:	0f b6 00             	movzbl (%eax),%eax
c002888e:	84 c0                	test   %al,%al
c0028890:	75 cc                	jne    c002885e <strspn+0xf>
c0028892:	eb 01                	jmp    c0028895 <strspn+0x46>
    if (strchr (skip, string[length]) == NULL)
      break;
c0028894:	90                   	nop
  return length;
c0028895:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028898:	c9                   	leave  
c0028899:	c3                   	ret    

c002889a <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
c002889a:	55                   	push   %ebp
c002889b:	89 e5                	mov    %esp,%ebp
c002889d:	83 ec 18             	sub    $0x18,%esp
  size_t haystack_len = strlen (haystack);
c00288a0:	83 ec 0c             	sub    $0xc,%esp
c00288a3:	ff 75 08             	pushl  0x8(%ebp)
c00288a6:	e8 d3 01 00 00       	call   c0028a7e <strlen>
c00288ab:	83 c4 10             	add    $0x10,%esp
c00288ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t needle_len = strlen (needle);
c00288b1:	83 ec 0c             	sub    $0xc,%esp
c00288b4:	ff 75 0c             	pushl  0xc(%ebp)
c00288b7:	e8 c2 01 00 00       	call   c0028a7e <strlen>
c00288bc:	83 c4 10             	add    $0x10,%esp
c00288bf:	89 45 ec             	mov    %eax,-0x14(%ebp)

  if (haystack_len >= needle_len) 
c00288c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00288c5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00288c8:	72 40                	jb     c002890a <strstr+0x70>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c00288ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00288d1:	eb 2c                	jmp    c00288ff <strstr+0x65>
        if (!memcmp (haystack + i, needle, needle_len))
c00288d3:	8b 55 08             	mov    0x8(%ebp),%edx
c00288d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00288d9:	01 d0                	add    %edx,%eax
c00288db:	83 ec 04             	sub    $0x4,%esp
c00288de:	ff 75 ec             	pushl  -0x14(%ebp)
c00288e1:	ff 75 0c             	pushl  0xc(%ebp)
c00288e4:	50                   	push   %eax
c00288e5:	e8 8d fc ff ff       	call   c0028577 <memcmp>
c00288ea:	83 c4 10             	add    $0x10,%esp
c00288ed:	85 c0                	test   %eax,%eax
c00288ef:	75 0a                	jne    c00288fb <strstr+0x61>
          return (char *) haystack + i;
c00288f1:	8b 55 08             	mov    0x8(%ebp),%edx
c00288f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00288f7:	01 d0                	add    %edx,%eax
c00288f9:	eb 14                	jmp    c002890f <strstr+0x75>

  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c00288fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00288ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028902:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028905:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028908:	73 c9                	jae    c00288d3 <strstr+0x39>
        if (!memcmp (haystack + i, needle, needle_len))
          return (char *) haystack + i;
    }

  return NULL;
c002890a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002890f:	c9                   	leave  
c0028910:	c3                   	ret    

c0028911 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c0028911:	55                   	push   %ebp
c0028912:	89 e5                	mov    %esp,%ebp
c0028914:	83 ec 18             	sub    $0x18,%esp
  char *token;
  
  ASSERT (delimiters != NULL);
c0028917:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002891b:	75 21                	jne    c002893e <strtok_r+0x2d>
c002891d:	83 ec 0c             	sub    $0xc,%esp
c0028920:	68 a4 0a 03 c0       	push   $0xc0030aa4
c0028925:	68 f5 09 03 c0       	push   $0xc00309f5
c002892a:	68 1c 0b 03 c0       	push   $0xc0030b1c
c002892f:	68 ef 00 00 00       	push   $0xef
c0028934:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028939:	e8 f3 0c 00 00       	call   c0029631 <debug_panic>
  ASSERT (save_ptr != NULL);
c002893e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028942:	75 21                	jne    c0028965 <strtok_r+0x54>
c0028944:	83 ec 0c             	sub    $0xc,%esp
c0028947:	68 b7 0a 03 c0       	push   $0xc0030ab7
c002894c:	68 f5 09 03 c0       	push   $0xc00309f5
c0028951:	68 1c 0b 03 c0       	push   $0xc0030b1c
c0028956:	68 f0 00 00 00       	push   $0xf0
c002895b:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028960:	e8 cc 0c 00 00       	call   c0029631 <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0028965:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028969:	75 08                	jne    c0028973 <strtok_r+0x62>
    s = *save_ptr;
c002896b:	8b 45 10             	mov    0x10(%ebp),%eax
c002896e:	8b 00                	mov    (%eax),%eax
c0028970:	89 45 08             	mov    %eax,0x8(%ebp)
  ASSERT (s != NULL);
c0028973:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028977:	75 3e                	jne    c00289b7 <strtok_r+0xa6>
c0028979:	83 ec 0c             	sub    $0xc,%esp
c002897c:	68 c8 0a 03 c0       	push   $0xc0030ac8
c0028981:	68 f5 09 03 c0       	push   $0xc00309f5
c0028986:	68 1c 0b 03 c0       	push   $0xc0030b1c
c002898b:	68 f6 00 00 00       	push   $0xf6
c0028990:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028995:	e8 97 0c 00 00       	call   c0029631 <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c002899a:	8b 45 08             	mov    0x8(%ebp),%eax
c002899d:	0f b6 00             	movzbl (%eax),%eax
c00289a0:	84 c0                	test   %al,%al
c00289a2:	75 0f                	jne    c00289b3 <strtok_r+0xa2>
        {
          *save_ptr = s;
c00289a4:	8b 45 10             	mov    0x10(%ebp),%eax
c00289a7:	8b 55 08             	mov    0x8(%ebp),%edx
c00289aa:	89 10                	mov    %edx,(%eax)
          return NULL;
c00289ac:	b8 00 00 00 00       	mov    $0x0,%eax
c00289b1:	eb 70                	jmp    c0028a23 <strtok_r+0x112>
        }

      s++;
c00289b3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  if (s == NULL)
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c00289b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00289ba:	0f b6 00             	movzbl (%eax),%eax
c00289bd:	0f be c0             	movsbl %al,%eax
c00289c0:	83 ec 08             	sub    $0x8,%esp
c00289c3:	50                   	push   %eax
c00289c4:	ff 75 0c             	pushl  0xc(%ebp)
c00289c7:	e8 68 fd ff ff       	call   c0028734 <strchr>
c00289cc:	83 c4 10             	add    $0x10,%esp
c00289cf:	85 c0                	test   %eax,%eax
c00289d1:	75 c7                	jne    c002899a <strtok_r+0x89>

      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
c00289d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00289d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (strchr (delimiters, *s) == NULL)
c00289d9:	eb 04                	jmp    c00289df <strtok_r+0xce>
    s++;
c00289db:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
c00289df:	8b 45 08             	mov    0x8(%ebp),%eax
c00289e2:	0f b6 00             	movzbl (%eax),%eax
c00289e5:	0f be c0             	movsbl %al,%eax
c00289e8:	83 ec 08             	sub    $0x8,%esp
c00289eb:	50                   	push   %eax
c00289ec:	ff 75 0c             	pushl  0xc(%ebp)
c00289ef:	e8 40 fd ff ff       	call   c0028734 <strchr>
c00289f4:	83 c4 10             	add    $0x10,%esp
c00289f7:	85 c0                	test   %eax,%eax
c00289f9:	74 e0                	je     c00289db <strtok_r+0xca>
    s++;
  if (*s != '\0') 
c00289fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00289fe:	0f b6 00             	movzbl (%eax),%eax
c0028a01:	84 c0                	test   %al,%al
c0028a03:	74 13                	je     c0028a18 <strtok_r+0x107>
    {
      *s = '\0';
c0028a05:	8b 45 08             	mov    0x8(%ebp),%eax
c0028a08:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c0028a0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0028a0e:	8d 50 01             	lea    0x1(%eax),%edx
c0028a11:	8b 45 10             	mov    0x10(%ebp),%eax
c0028a14:	89 10                	mov    %edx,(%eax)
c0028a16:	eb 08                	jmp    c0028a20 <strtok_r+0x10f>
    }
  else 
    *save_ptr = s;
c0028a18:	8b 45 10             	mov    0x10(%ebp),%eax
c0028a1b:	8b 55 08             	mov    0x8(%ebp),%edx
c0028a1e:	89 10                	mov    %edx,(%eax)
  return token;
c0028a20:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028a23:	c9                   	leave  
c0028a24:	c3                   	ret    

c0028a25 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0028a25:	55                   	push   %ebp
c0028a26:	89 e5                	mov    %esp,%ebp
c0028a28:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028a2b:	8b 45 08             	mov    0x8(%ebp),%eax
c0028a2e:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028a31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028a35:	75 35                	jne    c0028a6c <memset+0x47>
c0028a37:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028a3b:	74 2f                	je     c0028a6c <memset+0x47>
c0028a3d:	83 ec 0c             	sub    $0xc,%esp
c0028a40:	68 dc 09 03 c0       	push   $0xc00309dc
c0028a45:	68 f5 09 03 c0       	push   $0xc00309f5
c0028a4a:	68 28 0b 03 c0       	push   $0xc0030b28
c0028a4f:	68 1b 01 00 00       	push   $0x11b
c0028a54:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028a59:	e8 d3 0b 00 00       	call   c0029631 <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
c0028a5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028a61:	8d 50 01             	lea    0x1(%eax),%edx
c0028a64:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028a67:	8b 55 0c             	mov    0xc(%ebp),%edx
c0028a6a:	88 10                	mov    %dl,(%eax)
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c0028a6c:	8b 45 10             	mov    0x10(%ebp),%eax
c0028a6f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028a72:	89 55 10             	mov    %edx,0x10(%ebp)
c0028a75:	85 c0                	test   %eax,%eax
c0028a77:	75 e5                	jne    c0028a5e <memset+0x39>
    *dst++ = value;

  return dst_;
c0028a79:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0028a7c:	c9                   	leave  
c0028a7d:	c3                   	ret    

c0028a7e <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0028a7e:	55                   	push   %ebp
c0028a7f:	89 e5                	mov    %esp,%ebp
c0028a81:	83 ec 18             	sub    $0x18,%esp
  const char *p;

  ASSERT (string != NULL);
c0028a84:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028a88:	75 21                	jne    c0028aab <strlen+0x2d>
c0028a8a:	83 ec 0c             	sub    $0xc,%esp
c0028a8d:	68 95 0a 03 c0       	push   $0xc0030a95
c0028a92:	68 f5 09 03 c0       	push   $0xc00309f5
c0028a97:	68 30 0b 03 c0       	push   $0xc0030b30
c0028a9c:	68 29 01 00 00       	push   $0x129
c0028aa1:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028aa6:	e8 86 0b 00 00       	call   c0029631 <debug_panic>

  for (p = string; *p != '\0'; p++)
c0028aab:	8b 45 08             	mov    0x8(%ebp),%eax
c0028aae:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028ab1:	eb 04                	jmp    c0028ab7 <strlen+0x39>
c0028ab3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028ab7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028aba:	0f b6 00             	movzbl (%eax),%eax
c0028abd:	84 c0                	test   %al,%al
c0028abf:	75 f2                	jne    c0028ab3 <strlen+0x35>
    continue;
  return p - string;
c0028ac1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0028ac4:	8b 45 08             	mov    0x8(%ebp),%eax
c0028ac7:	29 c2                	sub    %eax,%edx
c0028ac9:	89 d0                	mov    %edx,%eax
}
c0028acb:	c9                   	leave  
c0028acc:	c3                   	ret    

c0028acd <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c0028acd:	55                   	push   %ebp
c0028ace:	89 e5                	mov    %esp,%ebp
c0028ad0:	83 ec 10             	sub    $0x10,%esp
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0028ad3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0028ada:	eb 04                	jmp    c0028ae0 <strnlen+0x13>
c0028adc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0028ae0:	8b 55 08             	mov    0x8(%ebp),%edx
c0028ae3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028ae6:	01 d0                	add    %edx,%eax
c0028ae8:	0f b6 00             	movzbl (%eax),%eax
c0028aeb:	84 c0                	test   %al,%al
c0028aed:	74 08                	je     c0028af7 <strnlen+0x2a>
c0028aef:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028af2:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028af5:	72 e5                	jb     c0028adc <strnlen+0xf>
    continue;
  return length;
c0028af7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028afa:	c9                   	leave  
c0028afb:	c3                   	ret    

c0028afc <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c0028afc:	55                   	push   %ebp
c0028afd:	89 e5                	mov    %esp,%ebp
c0028aff:	83 ec 18             	sub    $0x18,%esp
  size_t src_len;

  ASSERT (dst != NULL);
c0028b02:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028b06:	75 21                	jne    c0028b29 <strlcpy+0x2d>
c0028b08:	83 ec 0c             	sub    $0xc,%esp
c0028b0b:	68 d2 0a 03 c0       	push   $0xc0030ad2
c0028b10:	68 f5 09 03 c0       	push   $0xc00309f5
c0028b15:	68 38 0b 03 c0       	push   $0xc0030b38
c0028b1a:	68 4a 01 00 00       	push   $0x14a
c0028b1f:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028b24:	e8 08 0b 00 00       	call   c0029631 <debug_panic>
  ASSERT (src != NULL);
c0028b29:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028b2d:	75 21                	jne    c0028b50 <strlcpy+0x54>
c0028b2f:	83 ec 0c             	sub    $0xc,%esp
c0028b32:	68 de 0a 03 c0       	push   $0xc0030ade
c0028b37:	68 f5 09 03 c0       	push   $0xc00309f5
c0028b3c:	68 38 0b 03 c0       	push   $0xc0030b38
c0028b41:	68 4b 01 00 00       	push   $0x14b
c0028b46:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028b4b:	e8 e1 0a 00 00       	call   c0029631 <debug_panic>

  src_len = strlen (src);
c0028b50:	83 ec 0c             	sub    $0xc,%esp
c0028b53:	ff 75 0c             	pushl  0xc(%ebp)
c0028b56:	e8 23 ff ff ff       	call   c0028a7e <strlen>
c0028b5b:	83 c4 10             	add    $0x10,%esp
c0028b5e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (size > 0) 
c0028b61:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028b65:	74 36                	je     c0028b9d <strlcpy+0xa1>
    {
      size_t dst_len = size - 1;
c0028b67:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b6a:	83 e8 01             	sub    $0x1,%eax
c0028b6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < dst_len)
c0028b70:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b73:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028b76:	73 06                	jae    c0028b7e <strlcpy+0x82>
        dst_len = src_len;
c0028b78:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst, src, dst_len);
c0028b7e:	83 ec 04             	sub    $0x4,%esp
c0028b81:	ff 75 f4             	pushl  -0xc(%ebp)
c0028b84:	ff 75 0c             	pushl  0xc(%ebp)
c0028b87:	ff 75 08             	pushl  0x8(%ebp)
c0028b8a:	e8 90 f8 ff ff       	call   c002841f <memcpy>
c0028b8f:	83 c4 10             	add    $0x10,%esp
      dst[dst_len] = '\0';
c0028b92:	8b 55 08             	mov    0x8(%ebp),%edx
c0028b95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b98:	01 d0                	add    %edx,%eax
c0028b9a:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len;
c0028b9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028ba0:	c9                   	leave  
c0028ba1:	c3                   	ret    

c0028ba2 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c0028ba2:	55                   	push   %ebp
c0028ba3:	89 e5                	mov    %esp,%ebp
c0028ba5:	83 ec 18             	sub    $0x18,%esp
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0028ba8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028bac:	75 21                	jne    c0028bcf <strlcat+0x2d>
c0028bae:	83 ec 0c             	sub    $0xc,%esp
c0028bb1:	68 d2 0a 03 c0       	push   $0xc0030ad2
c0028bb6:	68 f5 09 03 c0       	push   $0xc00309f5
c0028bbb:	68 40 0b 03 c0       	push   $0xc0030b40
c0028bc0:	68 68 01 00 00       	push   $0x168
c0028bc5:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028bca:	e8 62 0a 00 00       	call   c0029631 <debug_panic>
  ASSERT (src != NULL);
c0028bcf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028bd3:	75 21                	jne    c0028bf6 <strlcat+0x54>
c0028bd5:	83 ec 0c             	sub    $0xc,%esp
c0028bd8:	68 de 0a 03 c0       	push   $0xc0030ade
c0028bdd:	68 f5 09 03 c0       	push   $0xc00309f5
c0028be2:	68 40 0b 03 c0       	push   $0xc0030b40
c0028be7:	68 69 01 00 00       	push   $0x169
c0028bec:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028bf1:	e8 3b 0a 00 00       	call   c0029631 <debug_panic>

  src_len = strlen (src);
c0028bf6:	83 ec 0c             	sub    $0xc,%esp
c0028bf9:	ff 75 0c             	pushl  0xc(%ebp)
c0028bfc:	e8 7d fe ff ff       	call   c0028a7e <strlen>
c0028c01:	83 c4 10             	add    $0x10,%esp
c0028c04:	89 45 f0             	mov    %eax,-0x10(%ebp)
  dst_len = strlen (dst);
c0028c07:	83 ec 0c             	sub    $0xc,%esp
c0028c0a:	ff 75 08             	pushl  0x8(%ebp)
c0028c0d:	e8 6c fe ff ff       	call   c0028a7e <strlen>
c0028c12:	83 c4 10             	add    $0x10,%esp
c0028c15:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (size > 0 && dst_len < size) 
c0028c18:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028c1c:	74 4c                	je     c0028c6a <strlcat+0xc8>
c0028c1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028c21:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028c24:	73 44                	jae    c0028c6a <strlcat+0xc8>
    {
      size_t copy_cnt = size - dst_len - 1;
c0028c26:	8b 45 10             	mov    0x10(%ebp),%eax
c0028c29:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028c2c:	83 e8 01             	sub    $0x1,%eax
c0028c2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < copy_cnt)
c0028c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028c35:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028c38:	73 06                	jae    c0028c40 <strlcat+0x9e>
        copy_cnt = src_len;
c0028c3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028c3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst + dst_len, src, copy_cnt);
c0028c40:	8b 55 08             	mov    0x8(%ebp),%edx
c0028c43:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028c46:	01 d0                	add    %edx,%eax
c0028c48:	83 ec 04             	sub    $0x4,%esp
c0028c4b:	ff 75 f4             	pushl  -0xc(%ebp)
c0028c4e:	ff 75 0c             	pushl  0xc(%ebp)
c0028c51:	50                   	push   %eax
c0028c52:	e8 c8 f7 ff ff       	call   c002841f <memcpy>
c0028c57:	83 c4 10             	add    $0x10,%esp
      dst[dst_len + copy_cnt] = '\0';
c0028c5a:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028c5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c60:	01 c2                	add    %eax,%edx
c0028c62:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c65:	01 d0                	add    %edx,%eax
c0028c67:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len + dst_len;
c0028c6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028c6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028c70:	01 d0                	add    %edx,%eax
}
c0028c72:	c9                   	leave  
c0028c73:	c3                   	ret    

c0028c74 <divl>:
   yield a 32-bit quotient.  Returns the quotient.
   Traps with a divide error (#DE) if the quotient does not fit
   in 32 bits. */
static inline uint32_t
divl (uint64_t n, uint32_t d)
{
c0028c74:	55                   	push   %ebp
c0028c75:	89 e5                	mov    %esp,%ebp
c0028c77:	83 ec 18             	sub    $0x18,%esp
c0028c7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c7d:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028c80:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028c83:	89 45 ec             	mov    %eax,-0x14(%ebp)
  uint32_t n1 = n >> 32;
c0028c86:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028c89:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028c8c:	89 d0                	mov    %edx,%eax
c0028c8e:	31 d2                	xor    %edx,%edx
c0028c90:	89 45 fc             	mov    %eax,-0x4(%ebp)
  uint32_t n0 = n;
c0028c93:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028c96:	89 45 f8             	mov    %eax,-0x8(%ebp)
  uint32_t q, r;

  asm ("divl %4"
c0028c99:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0028c9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0028c9f:	f7 75 10             	divl   0x10(%ebp)
c0028ca2:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028ca5:	89 45 f0             	mov    %eax,-0x10(%ebp)
       : "=d" (r), "=a" (q)
       : "0" (n1), "1" (n0), "rm" (d));

  return q;
c0028ca8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028cab:	c9                   	leave  
c0028cac:	c3                   	ret    

c0028cad <nlz>:

/* Returns the number of leading zero bits in X,
   which must be nonzero. */
static int
nlz (uint32_t x) 
{
c0028cad:	55                   	push   %ebp
c0028cae:	89 e5                	mov    %esp,%ebp
c0028cb0:	83 ec 10             	sub    $0x10,%esp
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
c0028cb3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if (x <= 0x0000FFFF)
c0028cba:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
c0028cc1:	77 08                	ja     c0028ccb <nlz+0x1e>
    {
      n += 16;
c0028cc3:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
      x <<= 16; 
c0028cc7:	c1 65 08 10          	shll   $0x10,0x8(%ebp)
    }
  if (x <= 0x00FFFFFF)
c0028ccb:	81 7d 08 ff ff ff 00 	cmpl   $0xffffff,0x8(%ebp)
c0028cd2:	77 08                	ja     c0028cdc <nlz+0x2f>
    {
      n += 8;
c0028cd4:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
      x <<= 8; 
c0028cd8:	c1 65 08 08          	shll   $0x8,0x8(%ebp)
    }
  if (x <= 0x0FFFFFFF)
c0028cdc:	81 7d 08 ff ff ff 0f 	cmpl   $0xfffffff,0x8(%ebp)
c0028ce3:	77 08                	ja     c0028ced <nlz+0x40>
    {
      n += 4;
c0028ce5:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
      x <<= 4;
c0028ce9:	c1 65 08 04          	shll   $0x4,0x8(%ebp)
    }
  if (x <= 0x3FFFFFFF)
c0028ced:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
c0028cf4:	77 08                	ja     c0028cfe <nlz+0x51>
    {
      n += 2;
c0028cf6:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
      x <<= 2; 
c0028cfa:	c1 65 08 02          	shll   $0x2,0x8(%ebp)
    }
  if (x <= 0x7FFFFFFF)
c0028cfe:	8b 45 08             	mov    0x8(%ebp),%eax
c0028d01:	85 c0                	test   %eax,%eax
c0028d03:	78 04                	js     c0028d09 <nlz+0x5c>
    n++;
c0028d05:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return n;
c0028d09:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028d0c:	c9                   	leave  
c0028d0d:	c3                   	ret    

c0028d0e <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0028d0e:	55                   	push   %ebp
c0028d0f:	89 e5                	mov    %esp,%ebp
c0028d11:	57                   	push   %edi
c0028d12:	56                   	push   %esi
c0028d13:	53                   	push   %ebx
c0028d14:	83 ec 44             	sub    $0x44,%esp
c0028d17:	8b 45 08             	mov    0x8(%ebp),%eax
c0028d1a:	89 45 b8             	mov    %eax,-0x48(%ebp)
c0028d1d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028d20:	89 45 bc             	mov    %eax,-0x44(%ebp)
c0028d23:	8b 45 10             	mov    0x10(%ebp),%eax
c0028d26:	89 45 b0             	mov    %eax,-0x50(%ebp)
c0028d29:	8b 45 14             	mov    0x14(%ebp),%eax
c0028d2c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if ((d >> 32) == 0) 
c0028d2f:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028d32:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028d35:	89 d0                	mov    %edx,%eax
c0028d37:	31 d2                	xor    %edx,%edx
c0028d39:	09 d0                	or     %edx,%eax
c0028d3b:	85 c0                	test   %eax,%eax
c0028d3d:	0f 85 a3 00 00 00    	jne    c0028de6 <udiv64+0xd8>
             <=> [(bd - 1)/d] < b
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
c0028d43:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0028d4a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      uint32_t n1 = n >> 32;
c0028d51:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028d54:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028d57:	89 d0                	mov    %edx,%eax
c0028d59:	31 d2                	xor    %edx,%edx
c0028d5b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      uint32_t n0 = n; 
c0028d5e:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028d61:	89 45 e0             	mov    %eax,-0x20(%ebp)
      uint32_t d0 = d;
c0028d64:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028d67:	89 45 dc             	mov    %eax,-0x24(%ebp)

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0028d6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028d6d:	ba 00 00 00 00       	mov    $0x0,%edx
c0028d72:	f7 75 dc             	divl   -0x24(%ebp)
c0028d75:	89 d0                	mov    %edx,%eax
c0028d77:	ba 00 00 00 00       	mov    $0x0,%edx
c0028d7c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0028d7f:	89 cb                	mov    %ecx,%ebx
c0028d81:	0f af da             	imul   %edx,%ebx
c0028d84:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0028d87:	0f af c8             	imul   %eax,%ecx
c0028d8a:	01 d9                	add    %ebx,%ecx
c0028d8c:	f7 65 e8             	mull   -0x18(%ebp)
c0028d8f:	01 d1                	add    %edx,%ecx
c0028d91:	89 ca                	mov    %ecx,%edx
c0028d93:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c0028d96:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028d9b:	01 c8                	add    %ecx,%eax
c0028d9d:	11 da                	adc    %ebx,%edx
c0028d9f:	83 ec 04             	sub    $0x4,%esp
c0028da2:	ff 75 dc             	pushl  -0x24(%ebp)
c0028da5:	52                   	push   %edx
c0028da6:	50                   	push   %eax
c0028da7:	e8 c8 fe ff ff       	call   c0028c74 <divl>
c0028dac:	83 c4 10             	add    $0x10,%esp
c0028daf:	89 c6                	mov    %eax,%esi
c0028db1:	bf 00 00 00 00       	mov    $0x0,%edi
c0028db6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028db9:	ba 00 00 00 00       	mov    $0x0,%edx
c0028dbe:	f7 75 dc             	divl   -0x24(%ebp)
c0028dc1:	ba 00 00 00 00       	mov    $0x0,%edx
c0028dc6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0028dc9:	89 cb                	mov    %ecx,%ebx
c0028dcb:	0f af da             	imul   %edx,%ebx
c0028dce:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0028dd1:	0f af c8             	imul   %eax,%ecx
c0028dd4:	01 d9                	add    %ebx,%ecx
c0028dd6:	f7 65 e8             	mull   -0x18(%ebp)
c0028dd9:	01 d1                	add    %edx,%ecx
c0028ddb:	89 ca                	mov    %ecx,%edx
c0028ddd:	01 f0                	add    %esi,%eax
c0028ddf:	11 fa                	adc    %edi,%edx
c0028de1:	e9 e8 00 00 00       	jmp    c0028ece <udiv64+0x1c0>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0028de6:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028de9:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028dec:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028def:	77 19                	ja     c0028e0a <udiv64+0xfc>
c0028df1:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028df4:	72 05                	jb     c0028dfb <udiv64+0xed>
c0028df6:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0028df9:	73 0f                	jae    c0028e0a <udiv64+0xfc>
        return 0;
c0028dfb:	b8 00 00 00 00       	mov    $0x0,%eax
c0028e00:	ba 00 00 00 00       	mov    $0x0,%edx
c0028e05:	e9 c4 00 00 00       	jmp    c0028ece <udiv64+0x1c0>
      else 
        {
          uint32_t d1 = d >> 32;
c0028e0a:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028e0d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028e10:	89 d0                	mov    %edx,%eax
c0028e12:	31 d2                	xor    %edx,%edx
c0028e14:	89 45 d8             	mov    %eax,-0x28(%ebp)
          int s = nlz (d1);
c0028e17:	83 ec 04             	sub    $0x4,%esp
c0028e1a:	ff 75 d8             	pushl  -0x28(%ebp)
c0028e1d:	e8 8b fe ff ff       	call   c0028cad <nlz>
c0028e22:	83 c4 08             	add    $0x8,%esp
c0028e25:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028e28:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c0028e2b:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028e2e:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028e31:	0f a5 c2             	shld   %cl,%eax,%edx
c0028e34:	d3 e0                	shl    %cl,%eax
c0028e36:	f6 c1 20             	test   $0x20,%cl
c0028e39:	74 04                	je     c0028e3f <udiv64+0x131>
c0028e3b:	89 c2                	mov    %eax,%edx
c0028e3d:	31 c0                	xor    %eax,%eax
c0028e3f:	89 d0                	mov    %edx,%eax
c0028e41:	31 d2                	xor    %edx,%edx
c0028e43:	89 c1                	mov    %eax,%ecx
c0028e45:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028e48:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028e4b:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c0028e4f:	d1 ea                	shr    %edx
c0028e51:	83 ec 04             	sub    $0x4,%esp
c0028e54:	51                   	push   %ecx
c0028e55:	52                   	push   %edx
c0028e56:	50                   	push   %eax
c0028e57:	e8 18 fe ff ff       	call   c0028c74 <divl>
c0028e5c:	83 c4 10             	add    $0x10,%esp
c0028e5f:	89 c2                	mov    %eax,%edx
c0028e61:	b8 1f 00 00 00       	mov    $0x1f,%eax
c0028e66:	2b 45 d4             	sub    -0x2c(%ebp),%eax
c0028e69:	89 c1                	mov    %eax,%ecx
c0028e6b:	d3 ea                	shr    %cl,%edx
c0028e6d:	89 d0                	mov    %edx,%eax
c0028e6f:	89 45 c8             	mov    %eax,-0x38(%ebp)
c0028e72:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0028e79:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0028e7c:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0028e7f:	83 c0 ff             	add    $0xffffffff,%eax
c0028e82:	83 d2 ff             	adc    $0xffffffff,%edx
c0028e85:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c0028e88:	89 cb                	mov    %ecx,%ebx
c0028e8a:	0f af da             	imul   %edx,%ebx
c0028e8d:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
c0028e90:	0f af c8             	imul   %eax,%ecx
c0028e93:	01 d9                	add    %ebx,%ecx
c0028e95:	f7 65 b0             	mull   -0x50(%ebp)
c0028e98:	01 d1                	add    %edx,%ecx
c0028e9a:	89 ca                	mov    %ecx,%edx
c0028e9c:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c0028e9f:	8b 5d bc             	mov    -0x44(%ebp),%ebx
c0028ea2:	29 c1                	sub    %eax,%ecx
c0028ea4:	19 d3                	sbb    %edx,%ebx
c0028ea6:	89 c8                	mov    %ecx,%eax
c0028ea8:	89 da                	mov    %ebx,%edx
c0028eaa:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028ead:	77 18                	ja     c0028ec7 <udiv64+0x1b9>
c0028eaf:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028eb2:	72 05                	jb     c0028eb9 <udiv64+0x1ab>
c0028eb4:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0028eb7:	73 0e                	jae    c0028ec7 <udiv64+0x1b9>
c0028eb9:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0028ebc:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0028ebf:	83 c0 ff             	add    $0xffffffff,%eax
c0028ec2:	83 d2 ff             	adc    $0xffffffff,%edx
c0028ec5:	eb 06                	jmp    c0028ecd <udiv64+0x1bf>
c0028ec7:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0028eca:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0028ecd:	90                   	nop
        }
    }
}
c0028ece:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0028ed1:	5b                   	pop    %ebx
c0028ed2:	5e                   	pop    %esi
c0028ed3:	5f                   	pop    %edi
c0028ed4:	5d                   	pop    %ebp
c0028ed5:	c3                   	ret    

c0028ed6 <umod64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
c0028ed6:	55                   	push   %ebp
c0028ed7:	89 e5                	mov    %esp,%ebp
c0028ed9:	53                   	push   %ebx
c0028eda:	83 ec 14             	sub    $0x14,%esp
c0028edd:	8b 45 08             	mov    0x8(%ebp),%eax
c0028ee0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028ee3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028ee6:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028ee9:	8b 45 10             	mov    0x10(%ebp),%eax
c0028eec:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028eef:	8b 45 14             	mov    0x14(%ebp),%eax
c0028ef2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * udiv64 (n, d);
c0028ef5:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0028ef8:	ff 75 ec             	pushl  -0x14(%ebp)
c0028efb:	ff 75 e8             	pushl  -0x18(%ebp)
c0028efe:	ff 75 f4             	pushl  -0xc(%ebp)
c0028f01:	ff 75 f0             	pushl  -0x10(%ebp)
c0028f04:	e8 05 fe ff ff       	call   c0028d0e <udiv64>
c0028f09:	83 c4 10             	add    $0x10,%esp
c0028f0c:	89 c2                	mov    %eax,%edx
c0028f0e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028f11:	0f af c2             	imul   %edx,%eax
c0028f14:	29 c3                	sub    %eax,%ebx
c0028f16:	89 d8                	mov    %ebx,%eax
}
c0028f18:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028f1b:	c9                   	leave  
c0028f1c:	c3                   	ret    

c0028f1d <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0028f1d:	55                   	push   %ebp
c0028f1e:	89 e5                	mov    %esp,%ebp
c0028f20:	83 ec 30             	sub    $0x30,%esp
c0028f23:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f26:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0028f29:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028f2c:	89 45 dc             	mov    %eax,-0x24(%ebp)
c0028f2f:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f32:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0028f35:	8b 45 14             	mov    0x14(%ebp),%eax
c0028f38:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028f3b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0028f3f:	79 0f                	jns    c0028f50 <sdiv64+0x33>
c0028f41:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0028f44:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0028f47:	f7 d8                	neg    %eax
c0028f49:	83 d2 00             	adc    $0x0,%edx
c0028f4c:	f7 da                	neg    %edx
c0028f4e:	eb 06                	jmp    c0028f56 <sdiv64+0x39>
c0028f50:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0028f53:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0028f56:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028f59:	89 55 fc             	mov    %edx,-0x4(%ebp)
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028f5c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0028f60:	79 0f                	jns    c0028f71 <sdiv64+0x54>
c0028f62:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0028f65:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0028f68:	f7 d8                	neg    %eax
c0028f6a:	83 d2 00             	adc    $0x0,%edx
c0028f6d:	f7 da                	neg    %edx
c0028f6f:	eb 06                	jmp    c0028f77 <sdiv64+0x5a>
c0028f71:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0028f74:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0028f77:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028f7a:	89 55 f4             	mov    %edx,-0xc(%ebp)
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0028f7d:	ff 75 f4             	pushl  -0xc(%ebp)
c0028f80:	ff 75 f0             	pushl  -0x10(%ebp)
c0028f83:	ff 75 fc             	pushl  -0x4(%ebp)
c0028f86:	ff 75 f8             	pushl  -0x8(%ebp)
c0028f89:	e8 80 fd ff ff       	call   c0028d0e <udiv64>
c0028f8e:	83 c4 10             	add    $0x10,%esp
c0028f91:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028f94:	89 55 ec             	mov    %edx,-0x14(%ebp)
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028f97:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0028f9a:	f7 d0                	not    %eax
c0028f9c:	c1 e8 1f             	shr    $0x1f,%eax
c0028f9f:	89 c2                	mov    %eax,%edx
c0028fa1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0028fa4:	c1 e8 1f             	shr    $0x1f,%eax
c0028fa7:	31 d0                	xor    %edx,%eax
c0028fa9:	84 c0                	test   %al,%al
c0028fab:	74 08                	je     c0028fb5 <sdiv64+0x98>
c0028fad:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028fb0:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028fb3:	eb 0d                	jmp    c0028fc2 <sdiv64+0xa5>
c0028fb5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028fb8:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028fbb:	f7 d8                	neg    %eax
c0028fbd:	83 d2 00             	adc    $0x0,%edx
c0028fc0:	f7 da                	neg    %edx
}
c0028fc2:	c9                   	leave  
c0028fc3:	c3                   	ret    

c0028fc4 <smod64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
c0028fc4:	55                   	push   %ebp
c0028fc5:	89 e5                	mov    %esp,%ebp
c0028fc7:	53                   	push   %ebx
c0028fc8:	83 ec 14             	sub    $0x14,%esp
c0028fcb:	8b 45 08             	mov    0x8(%ebp),%eax
c0028fce:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028fd1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028fd4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028fd7:	8b 45 10             	mov    0x10(%ebp),%eax
c0028fda:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028fdd:	8b 45 14             	mov    0x14(%ebp),%eax
c0028fe0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * sdiv64 (n, d);
c0028fe3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0028fe6:	ff 75 ec             	pushl  -0x14(%ebp)
c0028fe9:	ff 75 e8             	pushl  -0x18(%ebp)
c0028fec:	ff 75 f4             	pushl  -0xc(%ebp)
c0028fef:	ff 75 f0             	pushl  -0x10(%ebp)
c0028ff2:	e8 26 ff ff ff       	call   c0028f1d <sdiv64>
c0028ff7:	83 c4 10             	add    $0x10,%esp
c0028ffa:	89 c2                	mov    %eax,%edx
c0028ffc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028fff:	0f af c2             	imul   %edx,%eax
c0029002:	29 c3                	sub    %eax,%ebx
c0029004:	89 d8                	mov    %ebx,%eax
}
c0029006:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029009:	c9                   	leave  
c002900a:	c3                   	ret    

c002900b <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c002900b:	55                   	push   %ebp
c002900c:	89 e5                	mov    %esp,%ebp
c002900e:	83 ec 10             	sub    $0x10,%esp
c0029011:	8b 45 08             	mov    0x8(%ebp),%eax
c0029014:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029017:	8b 45 0c             	mov    0xc(%ebp),%eax
c002901a:	89 45 fc             	mov    %eax,-0x4(%ebp)
c002901d:	8b 45 10             	mov    0x10(%ebp),%eax
c0029020:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029023:	8b 45 14             	mov    0x14(%ebp),%eax
c0029026:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return sdiv64 (n, d);
c0029029:	ff 75 f4             	pushl  -0xc(%ebp)
c002902c:	ff 75 f0             	pushl  -0x10(%ebp)
c002902f:	ff 75 fc             	pushl  -0x4(%ebp)
c0029032:	ff 75 f8             	pushl  -0x8(%ebp)
c0029035:	e8 e3 fe ff ff       	call   c0028f1d <sdiv64>
c002903a:	83 c4 10             	add    $0x10,%esp
}
c002903d:	c9                   	leave  
c002903e:	c3                   	ret    

c002903f <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c002903f:	55                   	push   %ebp
c0029040:	89 e5                	mov    %esp,%ebp
c0029042:	83 ec 10             	sub    $0x10,%esp
c0029045:	8b 45 08             	mov    0x8(%ebp),%eax
c0029048:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002904b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002904e:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029051:	8b 45 10             	mov    0x10(%ebp),%eax
c0029054:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029057:	8b 45 14             	mov    0x14(%ebp),%eax
c002905a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return smod64 (n, d);
c002905d:	ff 75 f4             	pushl  -0xc(%ebp)
c0029060:	ff 75 f0             	pushl  -0x10(%ebp)
c0029063:	ff 75 fc             	pushl  -0x4(%ebp)
c0029066:	ff 75 f8             	pushl  -0x8(%ebp)
c0029069:	e8 56 ff ff ff       	call   c0028fc4 <smod64>
c002906e:	83 c4 10             	add    $0x10,%esp
c0029071:	99                   	cltd   
}
c0029072:	c9                   	leave  
c0029073:	c3                   	ret    

c0029074 <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c0029074:	55                   	push   %ebp
c0029075:	89 e5                	mov    %esp,%ebp
c0029077:	83 ec 10             	sub    $0x10,%esp
c002907a:	8b 45 08             	mov    0x8(%ebp),%eax
c002907d:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029080:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029083:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029086:	8b 45 10             	mov    0x10(%ebp),%eax
c0029089:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002908c:	8b 45 14             	mov    0x14(%ebp),%eax
c002908f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return udiv64 (n, d);
c0029092:	ff 75 f4             	pushl  -0xc(%ebp)
c0029095:	ff 75 f0             	pushl  -0x10(%ebp)
c0029098:	ff 75 fc             	pushl  -0x4(%ebp)
c002909b:	ff 75 f8             	pushl  -0x8(%ebp)
c002909e:	e8 6b fc ff ff       	call   c0028d0e <udiv64>
c00290a3:	83 c4 10             	add    $0x10,%esp
}
c00290a6:	c9                   	leave  
c00290a7:	c3                   	ret    

c00290a8 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c00290a8:	55                   	push   %ebp
c00290a9:	89 e5                	mov    %esp,%ebp
c00290ab:	83 ec 10             	sub    $0x10,%esp
c00290ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00290b1:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00290b4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00290b7:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00290ba:	8b 45 10             	mov    0x10(%ebp),%eax
c00290bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00290c0:	8b 45 14             	mov    0x14(%ebp),%eax
c00290c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return umod64 (n, d);
c00290c6:	ff 75 f4             	pushl  -0xc(%ebp)
c00290c9:	ff 75 f0             	pushl  -0x10(%ebp)
c00290cc:	ff 75 fc             	pushl  -0x4(%ebp)
c00290cf:	ff 75 f8             	pushl  -0x8(%ebp)
c00290d2:	e8 ff fd ff ff       	call   c0028ed6 <umod64>
c00290d7:	83 c4 10             	add    $0x10,%esp
c00290da:	ba 00 00 00 00       	mov    $0x0,%edx
}
c00290df:	c9                   	leave  
c00290e0:	c3                   	ret    

c00290e1 <calculate_chksum>:
PACKED;

/* Returns the checksum for the given ustar format HEADER. */
static unsigned int
calculate_chksum (const struct ustar_header *h)
{
c00290e1:	55                   	push   %ebp
c00290e2:	89 e5                	mov    %esp,%ebp
c00290e4:	83 ec 20             	sub    $0x20,%esp
  const uint8_t *header = (const uint8_t *) h;
c00290e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00290ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int chksum;
  size_t i;

  chksum = 0;
c00290ed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c00290f4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c00290fb:	eb 5a                	jmp    c0029157 <calculate_chksum+0x76>
    {
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
c00290fd:	c7 45 f0 94 00 00 00 	movl   $0x94,-0x10(%ebp)
      const size_t chksum_end = chksum_start + sizeof h->chksum;
c0029104:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029107:	83 c0 08             	add    $0x8,%eax
c002910a:	89 45 ec             	mov    %eax,-0x14(%ebp)
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
c002910d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029110:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0029113:	72 0f                	jb     c0029124 <calculate_chksum+0x43>
c0029115:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029118:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002911b:	73 07                	jae    c0029124 <calculate_chksum+0x43>
c002911d:	b8 01 00 00 00       	mov    $0x1,%eax
c0029122:	eb 05                	jmp    c0029129 <calculate_chksum+0x48>
c0029124:	b8 00 00 00 00       	mov    $0x0,%eax
c0029129:	88 45 eb             	mov    %al,-0x15(%ebp)
c002912c:	80 65 eb 01          	andb   $0x1,-0x15(%ebp)
      chksum += in_chksum_field ? ' ' : header[i];
c0029130:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0029134:	83 f0 01             	xor    $0x1,%eax
c0029137:	84 c0                	test   %al,%al
c0029139:	74 10                	je     c002914b <calculate_chksum+0x6a>
c002913b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002913e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029141:	01 d0                	add    %edx,%eax
c0029143:	0f b6 00             	movzbl (%eax),%eax
c0029146:	0f b6 c0             	movzbl %al,%eax
c0029149:	eb 05                	jmp    c0029150 <calculate_chksum+0x6f>
c002914b:	b8 20 00 00 00       	mov    $0x20,%eax
c0029150:	01 45 fc             	add    %eax,-0x4(%ebp)
  const uint8_t *header = (const uint8_t *) h;
  unsigned int chksum;
  size_t i;

  chksum = 0;
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0029153:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0029157:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
c002915e:	76 9d                	jbe    c00290fd <calculate_chksum+0x1c>
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
      const size_t chksum_end = chksum_start + sizeof h->chksum;
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
      chksum += in_chksum_field ? ' ' : header[i];
    }
  return chksum;
c0029160:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0029163:	c9                   	leave  
c0029164:	c3                   	ret    

c0029165 <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
c0029165:	55                   	push   %ebp
c0029166:	89 e5                	mov    %esp,%ebp
c0029168:	83 ec 08             	sub    $0x8,%esp
  while (*file_name == '/'
c002916b:	eb 16                	jmp    c0029183 <strip_antisocial_prefixes+0x1e>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
c002916d:	83 ec 08             	sub    $0x8,%esp
c0029170:	6a 2f                	push   $0x2f
c0029172:	ff 75 08             	pushl  0x8(%ebp)
c0029175:	e8 ba f5 ff ff       	call   c0028734 <strchr>
c002917a:	83 c4 10             	add    $0x10,%esp
c002917d:	83 c0 01             	add    $0x1,%eax
c0029180:	89 45 08             	mov    %eax,0x8(%ebp)
   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
  while (*file_name == '/'
c0029183:	8b 45 08             	mov    0x8(%ebp),%eax
c0029186:	0f b6 00             	movzbl (%eax),%eax
c0029189:	3c 2f                	cmp    $0x2f,%al
c002918b:	74 e0                	je     c002916d <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "./", 2)
c002918d:	83 ec 04             	sub    $0x4,%esp
c0029190:	6a 02                	push   $0x2
c0029192:	68 48 0b 03 c0       	push   $0xc0030b48
c0029197:	ff 75 08             	pushl  0x8(%ebp)
c002919a:	e8 d8 f3 ff ff       	call   c0028577 <memcmp>
c002919f:	83 c4 10             	add    $0x10,%esp
c00291a2:	85 c0                	test   %eax,%eax
c00291a4:	74 c7                	je     c002916d <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "../", 3))
c00291a6:	83 ec 04             	sub    $0x4,%esp
c00291a9:	6a 03                	push   $0x3
c00291ab:	68 4b 0b 03 c0       	push   $0xc0030b4b
c00291b0:	ff 75 08             	pushl  0x8(%ebp)
c00291b3:	e8 bf f3 ff ff       	call   c0028577 <memcmp>
c00291b8:	83 c4 10             	add    $0x10,%esp
c00291bb:	85 c0                	test   %eax,%eax
c00291bd:	74 ae                	je     c002916d <strip_antisocial_prefixes+0x8>
    file_name = strchr (file_name, '/') + 1;
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c00291bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00291c2:	0f b6 00             	movzbl (%eax),%eax
c00291c5:	84 c0                	test   %al,%al
c00291c7:	74 1c                	je     c00291e5 <strip_antisocial_prefixes+0x80>
c00291c9:	83 ec 08             	sub    $0x8,%esp
c00291cc:	68 4f 0b 03 c0       	push   $0xc0030b4f
c00291d1:	ff 75 08             	pushl  0x8(%ebp)
c00291d4:	e8 4e f4 ff ff       	call   c0028627 <strcmp>
c00291d9:	83 c4 10             	add    $0x10,%esp
c00291dc:	85 c0                	test   %eax,%eax
c00291de:	74 05                	je     c00291e5 <strip_antisocial_prefixes+0x80>
c00291e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00291e3:	eb 05                	jmp    c00291ea <strip_antisocial_prefixes+0x85>
c00291e5:	b8 52 0b 03 c0       	mov    $0xc0030b52,%eax
}
c00291ea:	c9                   	leave  
c00291eb:	c3                   	ret    

c00291ec <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
c00291ec:	55                   	push   %ebp
c00291ed:	89 e5                	mov    %esp,%ebp
c00291ef:	83 ec 18             	sub    $0x18,%esp
  struct ustar_header *h = (struct ustar_header *) header;
c00291f2:	8b 45 14             	mov    0x14(%ebp),%eax
c00291f5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c00291f8:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c00291fc:	74 24                	je     c0029222 <ustar_make_header+0x36>
c00291fe:	83 7d 0c 35          	cmpl   $0x35,0xc(%ebp)
c0029202:	74 1e                	je     c0029222 <ustar_make_header+0x36>
c0029204:	83 ec 0c             	sub    $0xc,%esp
c0029207:	68 54 0b 03 c0       	push   $0xc0030b54
c002920c:	68 85 0b 03 c0       	push   $0xc0030b85
c0029211:	68 88 0c 03 c0       	push   $0xc0030c88
c0029216:	6a 59                	push   $0x59
c0029218:	68 9c 0b 03 c0       	push   $0xc0030b9c
c002921d:	e8 0f 04 00 00       	call   c0029631 <debug_panic>

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
c0029222:	83 ec 0c             	sub    $0xc,%esp
c0029225:	ff 75 08             	pushl  0x8(%ebp)
c0029228:	e8 38 ff ff ff       	call   c0029165 <strip_antisocial_prefixes>
c002922d:	83 c4 10             	add    $0x10,%esp
c0029230:	89 45 08             	mov    %eax,0x8(%ebp)
  if (strlen (file_name) > 99)
c0029233:	83 ec 0c             	sub    $0xc,%esp
c0029236:	ff 75 08             	pushl  0x8(%ebp)
c0029239:	e8 40 f8 ff ff       	call   c0028a7e <strlen>
c002923e:	83 c4 10             	add    $0x10,%esp
c0029241:	83 f8 63             	cmp    $0x63,%eax
c0029244:	76 1d                	jbe    c0029263 <ustar_make_header+0x77>
    {
      printf ("%s: file name too long\n", file_name);
c0029246:	83 ec 08             	sub    $0x8,%esp
c0029249:	ff 75 08             	pushl  0x8(%ebp)
c002924c:	68 ae 0b 03 c0       	push   $0xc0030bae
c0029251:	e8 a8 df ff ff       	call   c00271fe <printf>
c0029256:	83 c4 10             	add    $0x10,%esp
      return false;
c0029259:	b8 00 00 00 00       	mov    $0x0,%eax
c002925e:	e9 64 01 00 00       	jmp    c00293c7 <ustar_make_header+0x1db>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
c0029263:	83 ec 04             	sub    $0x4,%esp
c0029266:	68 00 02 00 00       	push   $0x200
c002926b:	6a 00                	push   $0x0
c002926d:	ff 75 f4             	pushl  -0xc(%ebp)
c0029270:	e8 b0 f7 ff ff       	call   c0028a25 <memset>
c0029275:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->name, file_name, sizeof h->name);
c0029278:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002927b:	83 ec 04             	sub    $0x4,%esp
c002927e:	6a 64                	push   $0x64
c0029280:	ff 75 08             	pushl  0x8(%ebp)
c0029283:	50                   	push   %eax
c0029284:	e8 73 f8 ff ff       	call   c0028afc <strlcpy>
c0029289:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c002928c:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c0029290:	75 07                	jne    c0029299 <ustar_make_header+0xad>
c0029292:	ba a4 01 00 00       	mov    $0x1a4,%edx
c0029297:	eb 05                	jmp    c002929e <ustar_make_header+0xb2>
c0029299:	ba ed 01 00 00       	mov    $0x1ed,%edx
c002929e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00292a1:	83 c0 64             	add    $0x64,%eax
c00292a4:	52                   	push   %edx
c00292a5:	68 c6 0b 03 c0       	push   $0xc0030bc6
c00292aa:	6a 08                	push   $0x8
c00292ac:	50                   	push   %eax
c00292ad:	e8 23 df ff ff       	call   c00271d5 <snprintf>
c00292b2:	83 c4 10             	add    $0x10,%esp
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
c00292b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00292b8:	83 c0 6c             	add    $0x6c,%eax
c00292bb:	83 ec 04             	sub    $0x4,%esp
c00292be:	6a 08                	push   $0x8
c00292c0:	68 cb 0b 03 c0       	push   $0xc0030bcb
c00292c5:	50                   	push   %eax
c00292c6:	e8 31 f8 ff ff       	call   c0028afc <strlcpy>
c00292cb:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->gid, "0000000", sizeof h->gid);
c00292ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00292d1:	83 c0 74             	add    $0x74,%eax
c00292d4:	83 ec 04             	sub    $0x4,%esp
c00292d7:	6a 08                	push   $0x8
c00292d9:	68 cb 0b 03 c0       	push   $0xc0030bcb
c00292de:	50                   	push   %eax
c00292df:	e8 18 f8 ff ff       	call   c0028afc <strlcpy>
c00292e4:	83 c4 10             	add    $0x10,%esp
  snprintf (h->size, sizeof h->size, "%011o", size);
c00292e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00292ea:	83 c0 7c             	add    $0x7c,%eax
c00292ed:	ff 75 10             	pushl  0x10(%ebp)
c00292f0:	68 d3 0b 03 c0       	push   $0xc0030bd3
c00292f5:	6a 0c                	push   $0xc
c00292f7:	50                   	push   %eax
c00292f8:	e8 d8 de ff ff       	call   c00271d5 <snprintf>
c00292fd:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0029300:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029303:	05 88 00 00 00       	add    $0x88,%eax
c0029308:	68 00 8c b7 43       	push   $0x43b78c00
c002930d:	68 d3 0b 03 c0       	push   $0xc0030bd3
c0029312:	6a 0c                	push   $0xc
c0029314:	50                   	push   %eax
c0029315:	e8 bb de ff ff       	call   c00271d5 <snprintf>
c002931a:	83 c4 10             	add    $0x10,%esp
  h->typeflag = type;
c002931d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029320:	89 c2                	mov    %eax,%edx
c0029322:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029325:	88 90 9c 00 00 00    	mov    %dl,0x9c(%eax)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c002932b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002932e:	05 01 01 00 00       	add    $0x101,%eax
c0029333:	83 ec 04             	sub    $0x4,%esp
c0029336:	6a 06                	push   $0x6
c0029338:	68 d9 0b 03 c0       	push   $0xc0030bd9
c002933d:	50                   	push   %eax
c002933e:	e8 b9 f7 ff ff       	call   c0028afc <strlcpy>
c0029343:	83 c4 10             	add    $0x10,%esp
  h->version[0] = h->version[1] = '0';
c0029346:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029349:	c6 80 08 01 00 00 30 	movb   $0x30,0x108(%eax)
c0029350:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029353:	0f b6 90 08 01 00 00 	movzbl 0x108(%eax),%edx
c002935a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002935d:	88 90 07 01 00 00    	mov    %dl,0x107(%eax)
  strlcpy (h->gname, "root", sizeof h->gname);
c0029363:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029366:	05 29 01 00 00       	add    $0x129,%eax
c002936b:	83 ec 04             	sub    $0x4,%esp
c002936e:	6a 20                	push   $0x20
c0029370:	68 df 0b 03 c0       	push   $0xc0030bdf
c0029375:	50                   	push   %eax
c0029376:	e8 81 f7 ff ff       	call   c0028afc <strlcpy>
c002937b:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->uname, "root", sizeof h->uname);
c002937e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029381:	05 09 01 00 00       	add    $0x109,%eax
c0029386:	83 ec 04             	sub    $0x4,%esp
c0029389:	6a 20                	push   $0x20
c002938b:	68 df 0b 03 c0       	push   $0xc0030bdf
c0029390:	50                   	push   %eax
c0029391:	e8 66 f7 ff ff       	call   c0028afc <strlcpy>
c0029396:	83 c4 10             	add    $0x10,%esp

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0029399:	83 ec 0c             	sub    $0xc,%esp
c002939c:	ff 75 f4             	pushl  -0xc(%ebp)
c002939f:	e8 3d fd ff ff       	call   c00290e1 <calculate_chksum>
c00293a4:	83 c4 10             	add    $0x10,%esp
c00293a7:	89 c2                	mov    %eax,%edx
c00293a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293ac:	05 94 00 00 00       	add    $0x94,%eax
c00293b1:	52                   	push   %edx
c00293b2:	68 c6 0b 03 c0       	push   $0xc0030bc6
c00293b7:	6a 08                	push   $0x8
c00293b9:	50                   	push   %eax
c00293ba:	e8 16 de ff ff       	call   c00271d5 <snprintf>
c00293bf:	83 c4 10             	add    $0x10,%esp

  return true;
c00293c2:	b8 01 00 00 00       	mov    $0x1,%eax
}
c00293c7:	c9                   	leave  
c00293c8:	c3                   	ret    

c00293c9 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c00293c9:	55                   	push   %ebp
c00293ca:	89 e5                	mov    %esp,%ebp
c00293cc:	83 ec 10             	sub    $0x10,%esp
  size_t ofs;

  *value = 0;
c00293cf:	8b 45 10             	mov    0x10(%ebp),%eax
c00293d2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c00293d8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00293df:	eb 65                	jmp    c0029446 <parse_octal_field+0x7d>
    {
      char c = s[ofs];
c00293e1:	8b 55 08             	mov    0x8(%ebp),%edx
c00293e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00293e7:	01 d0                	add    %edx,%eax
c00293e9:	0f b6 00             	movzbl (%eax),%eax
c00293ec:	88 45 fb             	mov    %al,-0x5(%ebp)
      if (c >= '0' && c <= '7')
c00293ef:	80 7d fb 2f          	cmpb   $0x2f,-0x5(%ebp)
c00293f3:	7e 35                	jle    c002942a <parse_octal_field+0x61>
c00293f5:	80 7d fb 37          	cmpb   $0x37,-0x5(%ebp)
c00293f9:	7f 2f                	jg     c002942a <parse_octal_field+0x61>
        {
          if (*value > ULONG_MAX / 8)
c00293fb:	8b 45 10             	mov    0x10(%ebp),%eax
c00293fe:	8b 00                	mov    (%eax),%eax
c0029400:	3d ff ff ff 1f       	cmp    $0x1fffffff,%eax
c0029405:	76 07                	jbe    c002940e <parse_octal_field+0x45>
            {
              /* Overflow. */
              return false;
c0029407:	b8 00 00 00 00       	mov    $0x0,%eax
c002940c:	eb 45                	jmp    c0029453 <parse_octal_field+0x8a>
            }
          *value = c - '0' + *value * 8;
c002940e:	0f be 55 fb          	movsbl -0x5(%ebp),%edx
c0029412:	8b 45 10             	mov    0x10(%ebp),%eax
c0029415:	8b 00                	mov    (%eax),%eax
c0029417:	c1 e0 03             	shl    $0x3,%eax
c002941a:	01 d0                	add    %edx,%eax
c002941c:	8d 50 d0             	lea    -0x30(%eax),%edx
c002941f:	8b 45 10             	mov    0x10(%ebp),%eax
c0029422:	89 10                	mov    %edx,(%eax)
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
c0029424:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0029428:	eb 1c                	jmp    c0029446 <parse_octal_field+0x7d>
              /* Overflow. */
              return false;
            }
          *value = c - '0' + *value * 8;
        }
      else if (c == ' ' || c == '\0')
c002942a:	80 7d fb 20          	cmpb   $0x20,-0x5(%ebp)
c002942e:	74 06                	je     c0029436 <parse_octal_field+0x6d>
c0029430:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c0029434:	75 09                	jne    c002943f <parse_octal_field+0x76>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
c0029436:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c002943a:	0f 95 c0             	setne  %al
c002943d:	eb 14                	jmp    c0029453 <parse_octal_field+0x8a>
        }
      else
        {
          /* Bad character. */
          return false;
c002943f:	b8 00 00 00 00       	mov    $0x0,%eax
c0029444:	eb 0d                	jmp    c0029453 <parse_octal_field+0x8a>
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
c0029446:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029449:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002944c:	72 93                	jb     c00293e1 <parse_octal_field+0x18>
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c002944e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029453:	c9                   	leave  
c0029454:	c3                   	ret    

c0029455 <is_all_zeros>:

/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
c0029455:	55                   	push   %ebp
c0029456:	89 e5                	mov    %esp,%ebp
  while (cnt-- > 0)
c0029458:	eb 17                	jmp    c0029471 <is_all_zeros+0x1c>
    if (*block++ != 0)
c002945a:	8b 45 08             	mov    0x8(%ebp),%eax
c002945d:	8d 50 01             	lea    0x1(%eax),%edx
c0029460:	89 55 08             	mov    %edx,0x8(%ebp)
c0029463:	0f b6 00             	movzbl (%eax),%eax
c0029466:	84 c0                	test   %al,%al
c0029468:	74 07                	je     c0029471 <is_all_zeros+0x1c>
      return false;
c002946a:	b8 00 00 00 00       	mov    $0x0,%eax
c002946f:	eb 12                	jmp    c0029483 <is_all_zeros+0x2e>
/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
  while (cnt-- > 0)
c0029471:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029474:	8d 50 ff             	lea    -0x1(%eax),%edx
c0029477:	89 55 0c             	mov    %edx,0xc(%ebp)
c002947a:	85 c0                	test   %eax,%eax
c002947c:	75 dc                	jne    c002945a <is_all_zeros+0x5>
    if (*block++ != 0)
      return false;
  return true;
c002947e:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0029483:	5d                   	pop    %ebp
c0029484:	c3                   	ret    

c0029485 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0029485:	55                   	push   %ebp
c0029486:	89 e5                	mov    %esp,%ebp
c0029488:	83 ec 18             	sub    $0x18,%esp
  const struct ustar_header *h = (const struct ustar_header *) header;
c002948b:	8b 45 08             	mov    0x8(%ebp),%eax
c002948e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned long int chksum, size_ul;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
c0029491:	68 00 02 00 00       	push   $0x200
c0029496:	ff 75 08             	pushl  0x8(%ebp)
c0029499:	e8 b7 ff ff ff       	call   c0029455 <is_all_zeros>
c002949e:	83 c4 08             	add    $0x8,%esp
c00294a1:	84 c0                	test   %al,%al
c00294a3:	74 25                	je     c00294ca <ustar_parse_header+0x45>
    {
      *file_name = NULL;
c00294a5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00294a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c00294ae:	8b 45 10             	mov    0x10(%ebp),%eax
c00294b1:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c00294b7:	8b 45 14             	mov    0x14(%ebp),%eax
c00294ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c00294c0:	b8 00 00 00 00       	mov    $0x0,%eax
c00294c5:	e9 65 01 00 00       	jmp    c002962f <ustar_parse_header+0x1aa>
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c00294ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294cd:	05 01 01 00 00       	add    $0x101,%eax
c00294d2:	83 ec 04             	sub    $0x4,%esp
c00294d5:	6a 06                	push   $0x6
c00294d7:	68 d9 0b 03 c0       	push   $0xc0030bd9
c00294dc:	50                   	push   %eax
c00294dd:	e8 95 f0 ff ff       	call   c0028577 <memcmp>
c00294e2:	83 c4 10             	add    $0x10,%esp
c00294e5:	85 c0                	test   %eax,%eax
c00294e7:	74 0a                	je     c00294f3 <ustar_parse_header+0x6e>
    return "not a ustar archive";
c00294e9:	b8 e4 0b 03 c0       	mov    $0xc0030be4,%eax
c00294ee:	e9 3c 01 00 00       	jmp    c002962f <ustar_parse_header+0x1aa>
  else if (h->version[0] != '0' || h->version[1] != '0')
c00294f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294f6:	0f b6 80 07 01 00 00 	movzbl 0x107(%eax),%eax
c00294fd:	3c 30                	cmp    $0x30,%al
c00294ff:	75 0e                	jne    c002950f <ustar_parse_header+0x8a>
c0029501:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029504:	0f b6 80 08 01 00 00 	movzbl 0x108(%eax),%eax
c002950b:	3c 30                	cmp    $0x30,%al
c002950d:	74 0a                	je     c0029519 <ustar_parse_header+0x94>
    return "invalid ustar version";
c002950f:	b8 f8 0b 03 c0       	mov    $0xc0030bf8,%eax
c0029514:	e9 16 01 00 00       	jmp    c002962f <ustar_parse_header+0x1aa>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0029519:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002951c:	8d 90 94 00 00 00    	lea    0x94(%eax),%edx
c0029522:	83 ec 04             	sub    $0x4,%esp
c0029525:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0029528:	50                   	push   %eax
c0029529:	6a 08                	push   $0x8
c002952b:	52                   	push   %edx
c002952c:	e8 98 fe ff ff       	call   c00293c9 <parse_octal_field>
c0029531:	83 c4 10             	add    $0x10,%esp
c0029534:	83 f0 01             	xor    $0x1,%eax
c0029537:	84 c0                	test   %al,%al
c0029539:	74 0a                	je     c0029545 <ustar_parse_header+0xc0>
    return "corrupt chksum field";
c002953b:	b8 0e 0c 03 c0       	mov    $0xc0030c0e,%eax
c0029540:	e9 ea 00 00 00       	jmp    c002962f <ustar_parse_header+0x1aa>
  else if (chksum != calculate_chksum (h))
c0029545:	83 ec 0c             	sub    $0xc,%esp
c0029548:	ff 75 f4             	pushl  -0xc(%ebp)
c002954b:	e8 91 fb ff ff       	call   c00290e1 <calculate_chksum>
c0029550:	83 c4 10             	add    $0x10,%esp
c0029553:	89 c2                	mov    %eax,%edx
c0029555:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029558:	39 c2                	cmp    %eax,%edx
c002955a:	74 0a                	je     c0029566 <ustar_parse_header+0xe1>
    return "checksum mismatch";
c002955c:	b8 23 0c 03 c0       	mov    $0xc0030c23,%eax
c0029561:	e9 c9 00 00 00       	jmp    c002962f <ustar_parse_header+0x1aa>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0029566:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029569:	0f b6 40 63          	movzbl 0x63(%eax),%eax
c002956d:	84 c0                	test   %al,%al
c002956f:	75 0e                	jne    c002957f <ustar_parse_header+0xfa>
c0029571:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029574:	0f b6 80 59 01 00 00 	movzbl 0x159(%eax),%eax
c002957b:	84 c0                	test   %al,%al
c002957d:	74 0a                	je     c0029589 <ustar_parse_header+0x104>
    return "file name too long";
c002957f:	b8 35 0c 03 c0       	mov    $0xc0030c35,%eax
c0029584:	e9 a6 00 00 00       	jmp    c002962f <ustar_parse_header+0x1aa>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0029589:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002958c:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c0029593:	3c 30                	cmp    $0x30,%al
c0029595:	74 18                	je     c00295af <ustar_parse_header+0x12a>
c0029597:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002959a:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c00295a1:	3c 35                	cmp    $0x35,%al
c00295a3:	74 0a                	je     c00295af <ustar_parse_header+0x12a>
    return "unimplemented file type";
c00295a5:	b8 48 0c 03 c0       	mov    $0xc0030c48,%eax
c00295aa:	e9 80 00 00 00       	jmp    c002962f <ustar_parse_header+0x1aa>
  if (h->typeflag == USTAR_REGULAR)
c00295af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00295b2:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c00295b9:	3c 30                	cmp    $0x30,%al
c00295bb:	75 34                	jne    c00295f1 <ustar_parse_header+0x16c>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c00295bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00295c0:	8d 50 7c             	lea    0x7c(%eax),%edx
c00295c3:	83 ec 04             	sub    $0x4,%esp
c00295c6:	8d 45 ec             	lea    -0x14(%ebp),%eax
c00295c9:	50                   	push   %eax
c00295ca:	6a 0c                	push   $0xc
c00295cc:	52                   	push   %edx
c00295cd:	e8 f7 fd ff ff       	call   c00293c9 <parse_octal_field>
c00295d2:	83 c4 10             	add    $0x10,%esp
c00295d5:	83 f0 01             	xor    $0x1,%eax
c00295d8:	84 c0                	test   %al,%al
c00295da:	74 07                	je     c00295e3 <ustar_parse_header+0x15e>
        return "corrupt file size field";
c00295dc:	b8 60 0c 03 c0       	mov    $0xc0030c60,%eax
c00295e1:	eb 4c                	jmp    c002962f <ustar_parse_header+0x1aa>
      else if (size_ul > INT_MAX)
c00295e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00295e6:	85 c0                	test   %eax,%eax
c00295e8:	79 0e                	jns    c00295f8 <ustar_parse_header+0x173>
        return "file too large";
c00295ea:	b8 78 0c 03 c0       	mov    $0xc0030c78,%eax
c00295ef:	eb 3e                	jmp    c002962f <ustar_parse_header+0x1aa>
    }
  else
    size_ul = 0;
c00295f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c00295f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00295fb:	83 ec 0c             	sub    $0xc,%esp
c00295fe:	50                   	push   %eax
c00295ff:	e8 61 fb ff ff       	call   c0029165 <strip_antisocial_prefixes>
c0029604:	83 c4 10             	add    $0x10,%esp
c0029607:	89 c2                	mov    %eax,%edx
c0029609:	8b 45 0c             	mov    0xc(%ebp),%eax
c002960c:	89 10                	mov    %edx,(%eax)
  *type = h->typeflag;
c002960e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029611:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c0029618:	0f be d0             	movsbl %al,%edx
c002961b:	8b 45 10             	mov    0x10(%ebp),%eax
c002961e:	89 10                	mov    %edx,(%eax)
  *size = size_ul;
c0029620:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029623:	89 c2                	mov    %eax,%edx
c0029625:	8b 45 14             	mov    0x14(%ebp),%eax
c0029628:	89 10                	mov    %edx,(%eax)
  return NULL;
c002962a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002962f:	c9                   	leave  
c0029630:	c3                   	ret    

c0029631 <debug_panic>:
/* Halts the OS, printing the source file name, line number, and
   function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
c0029631:	55                   	push   %ebp
c0029632:	89 e5                	mov    %esp,%ebp
c0029634:	83 ec 18             	sub    $0x18,%esp
  static int level;
  va_list args;

  intr_disable ();
c0029637:	e8 72 7d ff ff       	call   c00213ae <intr_disable>
  console_panic ();
c002963c:	e8 60 20 00 00       	call   c002b6a1 <console_panic>

  level++;
c0029641:	a1 e4 9b 03 c0       	mov    0xc0039be4,%eax
c0029646:	83 c0 01             	add    $0x1,%eax
c0029649:	a3 e4 9b 03 c0       	mov    %eax,0xc0039be4
  if (level == 1) 
c002964e:	a1 e4 9b 03 c0       	mov    0xc0039be4,%eax
c0029653:	83 f8 01             	cmp    $0x1,%eax
c0029656:	75 42                	jne    c002969a <debug_panic+0x69>
    {
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0029658:	ff 75 10             	pushl  0x10(%ebp)
c002965b:	ff 75 0c             	pushl  0xc(%ebp)
c002965e:	ff 75 08             	pushl  0x8(%ebp)
c0029661:	68 9c 0c 03 c0       	push   $0xc0030c9c
c0029666:	e8 93 db ff ff       	call   c00271fe <printf>
c002966b:	83 c4 10             	add    $0x10,%esp

      va_start (args, message);
c002966e:	8d 45 18             	lea    0x18(%ebp),%eax
c0029671:	89 45 f4             	mov    %eax,-0xc(%ebp)
      vprintf (message, args);
c0029674:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029677:	83 ec 08             	sub    $0x8,%esp
c002967a:	50                   	push   %eax
c002967b:	ff 75 14             	pushl  0x14(%ebp)
c002967e:	e8 2e 21 00 00       	call   c002b7b1 <vprintf>
c0029683:	83 c4 10             	add    $0x10,%esp
      printf ("\n");
c0029686:	83 ec 0c             	sub    $0xc,%esp
c0029689:	6a 0a                	push   $0xa
c002968b:	e8 dc 21 00 00       	call   c002b86c <putchar>
c0029690:	83 c4 10             	add    $0x10,%esp
      va_end (args);

      debug_backtrace ();
c0029693:	e8 31 d8 ff ff       	call   c0026ec9 <debug_backtrace>
c0029698:	eb 20                	jmp    c00296ba <debug_panic+0x89>
    }
  else if (level == 2)
c002969a:	a1 e4 9b 03 c0       	mov    0xc0039be4,%eax
c002969f:	83 f8 02             	cmp    $0x2,%eax
c00296a2:	75 16                	jne    c00296ba <debug_panic+0x89>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c00296a4:	ff 75 10             	pushl  0x10(%ebp)
c00296a7:	ff 75 0c             	pushl  0xc(%ebp)
c00296aa:	ff 75 08             	pushl  0x8(%ebp)
c00296ad:	68 bc 0c 03 c0       	push   $0xc0030cbc
c00296b2:	e8 47 db ff ff       	call   c00271fe <printf>
c00296b7:	83 c4 10             	add    $0x10,%esp
  else 
    {
      /* Don't print anything: that's probably why we recursed. */
    }

  serial_flush ();
c00296ba:	e8 e3 b3 ff ff       	call   c0024aa2 <serial_flush>
  shutdown ();
c00296bf:	e8 72 d5 ff ff       	call   c0026c36 <shutdown>
  for (;;);
c00296c4:	eb fe                	jmp    c00296c4 <debug_panic+0x93>

c00296c6 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c00296c6:	55                   	push   %ebp
c00296c7:	89 e5                	mov    %esp,%ebp
c00296c9:	83 ec 18             	sub    $0x18,%esp
  void *retaddr = NULL, **frame = NULL;
c00296cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00296d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  const char *status = "UNKNOWN";
c00296da:	c7 45 ec e6 0c 03 c0 	movl   $0xc0030ce6,-0x14(%ebp)

  switch (t->status) {
c00296e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00296e4:	8b 40 04             	mov    0x4(%eax),%eax
c00296e7:	83 f8 01             	cmp    $0x1,%eax
c00296ea:	74 15                	je     c0029701 <print_stacktrace+0x3b>
c00296ec:	83 f8 01             	cmp    $0x1,%eax
c00296ef:	72 07                	jb     c00296f8 <print_stacktrace+0x32>
c00296f1:	83 f8 02             	cmp    $0x2,%eax
c00296f4:	74 14                	je     c002970a <print_stacktrace+0x44>
    case THREAD_BLOCKED:  
      status = "BLOCKED";
      break;

    default:
      break;
c00296f6:	eb 1a                	jmp    c0029712 <print_stacktrace+0x4c>
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
    case THREAD_RUNNING:  
      status = "RUNNING";
c00296f8:	c7 45 ec ee 0c 03 c0 	movl   $0xc0030cee,-0x14(%ebp)
      break;
c00296ff:	eb 11                	jmp    c0029712 <print_stacktrace+0x4c>

    case THREAD_READY:  
      status = "READY";
c0029701:	c7 45 ec f6 0c 03 c0 	movl   $0xc0030cf6,-0x14(%ebp)
      break;
c0029708:	eb 08                	jmp    c0029712 <print_stacktrace+0x4c>

    case THREAD_BLOCKED:  
      status = "BLOCKED";
c002970a:	c7 45 ec fc 0c 03 c0 	movl   $0xc0030cfc,-0x14(%ebp)
      break;
c0029711:	90                   	nop

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0029712:	8b 45 08             	mov    0x8(%ebp),%eax
c0029715:	83 c0 08             	add    $0x8,%eax
c0029718:	83 ec 04             	sub    $0x4,%esp
c002971b:	ff 75 ec             	pushl  -0x14(%ebp)
c002971e:	50                   	push   %eax
c002971f:	68 04 0d 03 c0       	push   $0xc0030d04
c0029724:	e8 d5 da ff ff       	call   c00271fe <printf>
c0029729:	83 c4 10             	add    $0x10,%esp

  if (t == thread_current()) 
c002972c:	e8 50 75 ff ff       	call   c0020c81 <thread_current>
c0029731:	3b 45 08             	cmp    0x8(%ebp),%eax
c0029734:	75 0e                	jne    c0029744 <print_stacktrace+0x7e>
    {
      frame = __builtin_frame_address (1);
c0029736:	8b 45 00             	mov    0x0(%ebp),%eax
c0029739:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = __builtin_return_address (0);
c002973c:	8b 45 04             	mov    0x4(%ebp),%eax
c002973f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029742:	eb 4d                	jmp    c0029791 <print_stacktrace+0xcb>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0029744:	8b 45 08             	mov    0x8(%ebp),%eax
c0029747:	8b 40 18             	mov    0x18(%eax),%eax
c002974a:	89 45 e8             	mov    %eax,-0x18(%ebp)
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c002974d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029750:	8b 40 18             	mov    0x18(%eax),%eax
c0029753:	8b 55 08             	mov    0x8(%ebp),%edx
c0029756:	81 c2 00 10 00 00    	add    $0x1000,%edx
c002975c:	39 d0                	cmp    %edx,%eax
c002975e:	74 0d                	je     c002976d <print_stacktrace+0xa7>
c0029760:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029763:	8b 40 10             	mov    0x10(%eax),%eax
c0029766:	3d 0d 13 02 c0       	cmp    $0xc002130d,%eax
c002976b:	75 12                	jne    c002977f <print_stacktrace+0xb9>
        {
          printf (" thread was never scheduled.\n");
c002976d:	83 ec 0c             	sub    $0xc,%esp
c0029770:	68 2b 0d 03 c0       	push   $0xc0030d2b
c0029775:	e8 6a 20 00 00       	call   c002b7e4 <puts>
c002977a:	83 c4 10             	add    $0x10,%esp
          return;
c002977d:	eb 6b                	jmp    c00297ea <print_stacktrace+0x124>
        }

      frame = (void **) saved_frame->ebp;
c002977f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029782:	8b 40 08             	mov    0x8(%eax),%eax
c0029785:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = (void *) saved_frame->eip;
c0029788:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002978b:	8b 40 10             	mov    0x10(%eax),%eax
c002978e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

  printf (" %p", retaddr);
c0029791:	83 ec 08             	sub    $0x8,%esp
c0029794:	ff 75 f4             	pushl  -0xc(%ebp)
c0029797:	68 48 0d 03 c0       	push   $0xc0030d48
c002979c:	e8 5d da ff ff       	call   c00271fe <printf>
c00297a1:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00297a4:	eb 21                	jmp    c00297c7 <print_stacktrace+0x101>
    printf (" %p", frame[1]);
c00297a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00297a9:	83 c0 04             	add    $0x4,%eax
c00297ac:	8b 00                	mov    (%eax),%eax
c00297ae:	83 ec 08             	sub    $0x8,%esp
c00297b1:	50                   	push   %eax
c00297b2:	68 48 0d 03 c0       	push   $0xc0030d48
c00297b7:	e8 42 da ff ff       	call   c00271fe <printf>
c00297bc:	83 c4 10             	add    $0x10,%esp
      frame = (void **) saved_frame->ebp;
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00297bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00297c2:	8b 00                	mov    (%eax),%eax
c00297c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00297c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00297ca:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c00297cf:	76 09                	jbe    c00297da <print_stacktrace+0x114>
c00297d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00297d4:	8b 00                	mov    (%eax),%eax
c00297d6:	85 c0                	test   %eax,%eax
c00297d8:	75 cc                	jne    c00297a6 <print_stacktrace+0xe0>
    printf (" %p", frame[1]);
  printf (".\n");
c00297da:	83 ec 0c             	sub    $0xc,%esp
c00297dd:	68 4c 0d 03 c0       	push   $0xc0030d4c
c00297e2:	e8 fd 1f 00 00       	call   c002b7e4 <puts>
c00297e7:	83 c4 10             	add    $0x10,%esp
}
c00297ea:	c9                   	leave  
c00297eb:	c3                   	ret    

c00297ec <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c00297ec:	55                   	push   %ebp
c00297ed:	89 e5                	mov    %esp,%ebp
c00297ef:	83 ec 18             	sub    $0x18,%esp
  enum intr_level oldlevel = intr_disable ();
c00297f2:	e8 b7 7b ff ff       	call   c00213ae <intr_disable>
c00297f7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  thread_foreach (print_stacktrace, 0);
c00297fa:	83 ec 08             	sub    $0x8,%esp
c00297fd:	6a 00                	push   $0x0
c00297ff:	68 c6 96 02 c0       	push   $0xc00296c6
c0029804:	e8 f2 75 ff ff       	call   c0020dfb <thread_foreach>
c0029809:	83 c4 10             	add    $0x10,%esp
  intr_set_level (oldlevel);
c002980c:	83 ec 0c             	sub    $0xc,%esp
c002980f:	ff 75 f4             	pushl  -0xc(%ebp)
c0029812:	e8 3f 7b ff ff       	call   c0021356 <intr_set_level>
c0029817:	83 c4 10             	add    $0x10,%esp
}
c002981a:	90                   	nop
c002981b:	c9                   	leave  
c002981c:	c3                   	ret    

c002981d <is_head>:
                       list_less_func *less, void *aux) UNUSED;

/* Returns true if ELEM is a head, false otherwise. */
static inline bool
is_head (struct list_elem *elem)
{
c002981d:	55                   	push   %ebp
c002981e:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029820:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029824:	74 1a                	je     c0029840 <is_head+0x23>
c0029826:	8b 45 08             	mov    0x8(%ebp),%eax
c0029829:	8b 00                	mov    (%eax),%eax
c002982b:	85 c0                	test   %eax,%eax
c002982d:	75 11                	jne    c0029840 <is_head+0x23>
c002982f:	8b 45 08             	mov    0x8(%ebp),%eax
c0029832:	8b 40 04             	mov    0x4(%eax),%eax
c0029835:	85 c0                	test   %eax,%eax
c0029837:	74 07                	je     c0029840 <is_head+0x23>
c0029839:	b8 01 00 00 00       	mov    $0x1,%eax
c002983e:	eb 05                	jmp    c0029845 <is_head+0x28>
c0029840:	b8 00 00 00 00       	mov    $0x0,%eax
c0029845:	83 e0 01             	and    $0x1,%eax
}
c0029848:	5d                   	pop    %ebp
c0029849:	c3                   	ret    

c002984a <is_interior>:

/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
c002984a:	55                   	push   %ebp
c002984b:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002984d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029851:	74 1a                	je     c002986d <is_interior+0x23>
c0029853:	8b 45 08             	mov    0x8(%ebp),%eax
c0029856:	8b 00                	mov    (%eax),%eax
c0029858:	85 c0                	test   %eax,%eax
c002985a:	74 11                	je     c002986d <is_interior+0x23>
c002985c:	8b 45 08             	mov    0x8(%ebp),%eax
c002985f:	8b 40 04             	mov    0x4(%eax),%eax
c0029862:	85 c0                	test   %eax,%eax
c0029864:	74 07                	je     c002986d <is_interior+0x23>
c0029866:	b8 01 00 00 00       	mov    $0x1,%eax
c002986b:	eb 05                	jmp    c0029872 <is_interior+0x28>
c002986d:	b8 00 00 00 00       	mov    $0x0,%eax
c0029872:	83 e0 01             	and    $0x1,%eax
}
c0029875:	5d                   	pop    %ebp
c0029876:	c3                   	ret    

c0029877 <is_tail>:

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
c0029877:	55                   	push   %ebp
c0029878:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002987a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002987e:	74 1a                	je     c002989a <is_tail+0x23>
c0029880:	8b 45 08             	mov    0x8(%ebp),%eax
c0029883:	8b 00                	mov    (%eax),%eax
c0029885:	85 c0                	test   %eax,%eax
c0029887:	74 11                	je     c002989a <is_tail+0x23>
c0029889:	8b 45 08             	mov    0x8(%ebp),%eax
c002988c:	8b 40 04             	mov    0x4(%eax),%eax
c002988f:	85 c0                	test   %eax,%eax
c0029891:	75 07                	jne    c002989a <is_tail+0x23>
c0029893:	b8 01 00 00 00       	mov    $0x1,%eax
c0029898:	eb 05                	jmp    c002989f <is_tail+0x28>
c002989a:	b8 00 00 00 00       	mov    $0x0,%eax
c002989f:	83 e0 01             	and    $0x1,%eax
}
c00298a2:	5d                   	pop    %ebp
c00298a3:	c3                   	ret    

c00298a4 <list_init>:

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c00298a4:	55                   	push   %ebp
c00298a5:	89 e5                	mov    %esp,%ebp
c00298a7:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c00298aa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00298ae:	75 1e                	jne    c00298ce <list_init+0x2a>
c00298b0:	83 ec 0c             	sub    $0xc,%esp
c00298b3:	68 50 0d 03 c0       	push   $0xc0030d50
c00298b8:	68 5d 0d 03 c0       	push   $0xc0030d5d
c00298bd:	68 28 0f 03 c0       	push   $0xc0030f28
c00298c2:	6a 3f                	push   $0x3f
c00298c4:	68 74 0d 03 c0       	push   $0xc0030d74
c00298c9:	e8 63 fd ff ff       	call   c0029631 <debug_panic>
  list->head.prev = NULL;
c00298ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00298d1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c00298d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00298da:	8d 50 08             	lea    0x8(%eax),%edx
c00298dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00298e0:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c00298e3:	8b 55 08             	mov    0x8(%ebp),%edx
c00298e6:	8b 45 08             	mov    0x8(%ebp),%eax
c00298e9:	89 50 08             	mov    %edx,0x8(%eax)
  list->tail.next = NULL;
c00298ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00298ef:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c00298f6:	90                   	nop
c00298f7:	c9                   	leave  
c00298f8:	c3                   	ret    

c00298f9 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c00298f9:	55                   	push   %ebp
c00298fa:	89 e5                	mov    %esp,%ebp
c00298fc:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c00298ff:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029903:	75 1e                	jne    c0029923 <list_begin+0x2a>
c0029905:	83 ec 0c             	sub    $0xc,%esp
c0029908:	68 50 0d 03 c0       	push   $0xc0030d50
c002990d:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029912:	68 34 0f 03 c0       	push   $0xc0030f34
c0029917:	6a 4a                	push   $0x4a
c0029919:	68 74 0d 03 c0       	push   $0xc0030d74
c002991e:	e8 0e fd ff ff       	call   c0029631 <debug_panic>
  return list->head.next;
c0029923:	8b 45 08             	mov    0x8(%ebp),%eax
c0029926:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029929:	c9                   	leave  
c002992a:	c3                   	ret    

c002992b <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c002992b:	55                   	push   %ebp
c002992c:	89 e5                	mov    %esp,%ebp
c002992e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_head (elem) || is_interior (elem));
c0029931:	ff 75 08             	pushl  0x8(%ebp)
c0029934:	e8 e4 fe ff ff       	call   c002981d <is_head>
c0029939:	83 c4 04             	add    $0x4,%esp
c002993c:	84 c0                	test   %al,%al
c002993e:	75 2d                	jne    c002996d <list_next+0x42>
c0029940:	ff 75 08             	pushl  0x8(%ebp)
c0029943:	e8 02 ff ff ff       	call   c002984a <is_interior>
c0029948:	83 c4 04             	add    $0x4,%esp
c002994b:	84 c0                	test   %al,%al
c002994d:	75 1e                	jne    c002996d <list_next+0x42>
c002994f:	83 ec 0c             	sub    $0xc,%esp
c0029952:	68 8c 0d 03 c0       	push   $0xc0030d8c
c0029957:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002995c:	68 40 0f 03 c0       	push   $0xc0030f40
c0029961:	6a 54                	push   $0x54
c0029963:	68 74 0d 03 c0       	push   $0xc0030d74
c0029968:	e8 c4 fc ff ff       	call   c0029631 <debug_panic>
  return elem->next;
c002996d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029970:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029973:	c9                   	leave  
c0029974:	c3                   	ret    

c0029975 <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c0029975:	55                   	push   %ebp
c0029976:	89 e5                	mov    %esp,%ebp
c0029978:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002997b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002997f:	75 1e                	jne    c002999f <list_end+0x2a>
c0029981:	83 ec 0c             	sub    $0xc,%esp
c0029984:	68 50 0d 03 c0       	push   $0xc0030d50
c0029989:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002998e:	68 4c 0f 03 c0       	push   $0xc0030f4c
c0029993:	6a 60                	push   $0x60
c0029995:	68 74 0d 03 c0       	push   $0xc0030d74
c002999a:	e8 92 fc ff ff       	call   c0029631 <debug_panic>
  return &list->tail;
c002999f:	8b 45 08             	mov    0x8(%ebp),%eax
c00299a2:	83 c0 08             	add    $0x8,%eax
}
c00299a5:	c9                   	leave  
c00299a6:	c3                   	ret    

c00299a7 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c00299a7:	55                   	push   %ebp
c00299a8:	89 e5                	mov    %esp,%ebp
c00299aa:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c00299ad:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00299b1:	75 1e                	jne    c00299d1 <list_rbegin+0x2a>
c00299b3:	83 ec 0c             	sub    $0xc,%esp
c00299b6:	68 50 0d 03 c0       	push   $0xc0030d50
c00299bb:	68 5d 0d 03 c0       	push   $0xc0030d5d
c00299c0:	68 58 0f 03 c0       	push   $0xc0030f58
c00299c5:	6a 69                	push   $0x69
c00299c7:	68 74 0d 03 c0       	push   $0xc0030d74
c00299cc:	e8 60 fc ff ff       	call   c0029631 <debug_panic>
  return list->tail.prev;
c00299d1:	8b 45 08             	mov    0x8(%ebp),%eax
c00299d4:	8b 40 08             	mov    0x8(%eax),%eax
}
c00299d7:	c9                   	leave  
c00299d8:	c3                   	ret    

c00299d9 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c00299d9:	55                   	push   %ebp
c00299da:	89 e5                	mov    %esp,%ebp
c00299dc:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem) || is_tail (elem));
c00299df:	ff 75 08             	pushl  0x8(%ebp)
c00299e2:	e8 63 fe ff ff       	call   c002984a <is_interior>
c00299e7:	83 c4 04             	add    $0x4,%esp
c00299ea:	84 c0                	test   %al,%al
c00299ec:	75 2d                	jne    c0029a1b <list_prev+0x42>
c00299ee:	ff 75 08             	pushl  0x8(%ebp)
c00299f1:	e8 81 fe ff ff       	call   c0029877 <is_tail>
c00299f6:	83 c4 04             	add    $0x4,%esp
c00299f9:	84 c0                	test   %al,%al
c00299fb:	75 1e                	jne    c0029a1b <list_prev+0x42>
c00299fd:	83 ec 0c             	sub    $0xc,%esp
c0029a00:	68 b4 0d 03 c0       	push   $0xc0030db4
c0029a05:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029a0a:	68 64 0f 03 c0       	push   $0xc0030f64
c0029a0f:	6a 73                	push   $0x73
c0029a11:	68 74 0d 03 c0       	push   $0xc0030d74
c0029a16:	e8 16 fc ff ff       	call   c0029631 <debug_panic>
  return elem->prev;
c0029a1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a1e:	8b 00                	mov    (%eax),%eax
}
c0029a20:	c9                   	leave  
c0029a21:	c3                   	ret    

c0029a22 <list_rend>:
          ...do something with f...
        }
*/
struct list_elem *
list_rend (struct list *list) 
{
c0029a22:	55                   	push   %ebp
c0029a23:	89 e5                	mov    %esp,%ebp
c0029a25:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029a28:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029a2c:	75 21                	jne    c0029a4f <list_rend+0x2d>
c0029a2e:	83 ec 0c             	sub    $0xc,%esp
c0029a31:	68 50 0d 03 c0       	push   $0xc0030d50
c0029a36:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029a3b:	68 70 0f 03 c0       	push   $0xc0030f70
c0029a40:	68 87 00 00 00       	push   $0x87
c0029a45:	68 74 0d 03 c0       	push   $0xc0030d74
c0029a4a:	e8 e2 fb ff ff       	call   c0029631 <debug_panic>
  return &list->head;
c0029a4f:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029a52:	c9                   	leave  
c0029a53:	c3                   	ret    

c0029a54 <list_head>:
          ...
        }
*/
struct list_elem *
list_head (struct list *list) 
{
c0029a54:	55                   	push   %ebp
c0029a55:	89 e5                	mov    %esp,%ebp
c0029a57:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029a5a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029a5e:	75 21                	jne    c0029a81 <list_head+0x2d>
c0029a60:	83 ec 0c             	sub    $0xc,%esp
c0029a63:	68 50 0d 03 c0       	push   $0xc0030d50
c0029a68:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029a6d:	68 7c 0f 03 c0       	push   $0xc0030f7c
c0029a72:	68 99 00 00 00       	push   $0x99
c0029a77:	68 74 0d 03 c0       	push   $0xc0030d74
c0029a7c:	e8 b0 fb ff ff       	call   c0029631 <debug_panic>
  return &list->head;
c0029a81:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029a84:	c9                   	leave  
c0029a85:	c3                   	ret    

c0029a86 <list_tail>:

/* Return's LIST's tail. */
struct list_elem *
list_tail (struct list *list) 
{
c0029a86:	55                   	push   %ebp
c0029a87:	89 e5                	mov    %esp,%ebp
c0029a89:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029a8c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029a90:	75 21                	jne    c0029ab3 <list_tail+0x2d>
c0029a92:	83 ec 0c             	sub    $0xc,%esp
c0029a95:	68 50 0d 03 c0       	push   $0xc0030d50
c0029a9a:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029a9f:	68 88 0f 03 c0       	push   $0xc0030f88
c0029aa4:	68 a1 00 00 00       	push   $0xa1
c0029aa9:	68 74 0d 03 c0       	push   $0xc0030d74
c0029aae:	e8 7e fb ff ff       	call   c0029631 <debug_panic>
  return &list->tail;
c0029ab3:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ab6:	83 c0 08             	add    $0x8,%eax
}
c0029ab9:	c9                   	leave  
c0029aba:	c3                   	ret    

c0029abb <list_insert>:
/* Inserts ELEM just before BEFORE, which may be either an
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
c0029abb:	55                   	push   %ebp
c0029abc:	89 e5                	mov    %esp,%ebp
c0029abe:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c0029ac1:	ff 75 08             	pushl  0x8(%ebp)
c0029ac4:	e8 81 fd ff ff       	call   c002984a <is_interior>
c0029ac9:	83 c4 04             	add    $0x4,%esp
c0029acc:	84 c0                	test   %al,%al
c0029ace:	75 30                	jne    c0029b00 <list_insert+0x45>
c0029ad0:	ff 75 08             	pushl  0x8(%ebp)
c0029ad3:	e8 9f fd ff ff       	call   c0029877 <is_tail>
c0029ad8:	83 c4 04             	add    $0x4,%esp
c0029adb:	84 c0                	test   %al,%al
c0029add:	75 21                	jne    c0029b00 <list_insert+0x45>
c0029adf:	83 ec 0c             	sub    $0xc,%esp
c0029ae2:	68 dc 0d 03 c0       	push   $0xc0030ddc
c0029ae7:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029aec:	68 94 0f 03 c0       	push   $0xc0030f94
c0029af1:	68 ab 00 00 00       	push   $0xab
c0029af6:	68 74 0d 03 c0       	push   $0xc0030d74
c0029afb:	e8 31 fb ff ff       	call   c0029631 <debug_panic>
  ASSERT (elem != NULL);
c0029b00:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0029b04:	75 21                	jne    c0029b27 <list_insert+0x6c>
c0029b06:	83 ec 0c             	sub    $0xc,%esp
c0029b09:	68 05 0e 03 c0       	push   $0xc0030e05
c0029b0e:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029b13:	68 94 0f 03 c0       	push   $0xc0030f94
c0029b18:	68 ac 00 00 00       	push   $0xac
c0029b1d:	68 74 0d 03 c0       	push   $0xc0030d74
c0029b22:	e8 0a fb ff ff       	call   c0029631 <debug_panic>

  elem->prev = before->prev;
c0029b27:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b2a:	8b 10                	mov    (%eax),%edx
c0029b2c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029b2f:	89 10                	mov    %edx,(%eax)
  elem->next = before;
c0029b31:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029b34:	8b 55 08             	mov    0x8(%ebp),%edx
c0029b37:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = elem;
c0029b3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b3d:	8b 00                	mov    (%eax),%eax
c0029b3f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029b42:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = elem;
c0029b45:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b48:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029b4b:	89 10                	mov    %edx,(%eax)
}
c0029b4d:	90                   	nop
c0029b4e:	c9                   	leave  
c0029b4f:	c3                   	ret    

c0029b50 <list_splice>:
   current list, then inserts them just before BEFORE, which may
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
c0029b50:	55                   	push   %ebp
c0029b51:	89 e5                	mov    %esp,%ebp
c0029b53:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c0029b56:	ff 75 08             	pushl  0x8(%ebp)
c0029b59:	e8 ec fc ff ff       	call   c002984a <is_interior>
c0029b5e:	83 c4 04             	add    $0x4,%esp
c0029b61:	84 c0                	test   %al,%al
c0029b63:	75 30                	jne    c0029b95 <list_splice+0x45>
c0029b65:	ff 75 08             	pushl  0x8(%ebp)
c0029b68:	e8 0a fd ff ff       	call   c0029877 <is_tail>
c0029b6d:	83 c4 04             	add    $0x4,%esp
c0029b70:	84 c0                	test   %al,%al
c0029b72:	75 21                	jne    c0029b95 <list_splice+0x45>
c0029b74:	83 ec 0c             	sub    $0xc,%esp
c0029b77:	68 dc 0d 03 c0       	push   $0xc0030ddc
c0029b7c:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029b81:	68 a0 0f 03 c0       	push   $0xc0030fa0
c0029b86:	68 bb 00 00 00       	push   $0xbb
c0029b8b:	68 74 0d 03 c0       	push   $0xc0030d74
c0029b90:	e8 9c fa ff ff       	call   c0029631 <debug_panic>
  if (first == last)
c0029b95:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029b98:	3b 45 10             	cmp    0x10(%ebp),%eax
c0029b9b:	0f 84 ba 00 00 00    	je     c0029c5b <list_splice+0x10b>
    return;
  last = list_prev (last);
c0029ba1:	83 ec 0c             	sub    $0xc,%esp
c0029ba4:	ff 75 10             	pushl  0x10(%ebp)
c0029ba7:	e8 2d fe ff ff       	call   c00299d9 <list_prev>
c0029bac:	83 c4 10             	add    $0x10,%esp
c0029baf:	89 45 10             	mov    %eax,0x10(%ebp)

  ASSERT (is_interior (first));
c0029bb2:	83 ec 0c             	sub    $0xc,%esp
c0029bb5:	ff 75 0c             	pushl  0xc(%ebp)
c0029bb8:	e8 8d fc ff ff       	call   c002984a <is_interior>
c0029bbd:	83 c4 10             	add    $0x10,%esp
c0029bc0:	84 c0                	test   %al,%al
c0029bc2:	75 21                	jne    c0029be5 <list_splice+0x95>
c0029bc4:	83 ec 0c             	sub    $0xc,%esp
c0029bc7:	68 12 0e 03 c0       	push   $0xc0030e12
c0029bcc:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029bd1:	68 a0 0f 03 c0       	push   $0xc0030fa0
c0029bd6:	68 c0 00 00 00       	push   $0xc0
c0029bdb:	68 74 0d 03 c0       	push   $0xc0030d74
c0029be0:	e8 4c fa ff ff       	call   c0029631 <debug_panic>
  ASSERT (is_interior (last));
c0029be5:	83 ec 0c             	sub    $0xc,%esp
c0029be8:	ff 75 10             	pushl  0x10(%ebp)
c0029beb:	e8 5a fc ff ff       	call   c002984a <is_interior>
c0029bf0:	83 c4 10             	add    $0x10,%esp
c0029bf3:	84 c0                	test   %al,%al
c0029bf5:	75 21                	jne    c0029c18 <list_splice+0xc8>
c0029bf7:	83 ec 0c             	sub    $0xc,%esp
c0029bfa:	68 26 0e 03 c0       	push   $0xc0030e26
c0029bff:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029c04:	68 a0 0f 03 c0       	push   $0xc0030fa0
c0029c09:	68 c1 00 00 00       	push   $0xc1
c0029c0e:	68 74 0d 03 c0       	push   $0xc0030d74
c0029c13:	e8 19 fa ff ff       	call   c0029631 <debug_panic>

  /* Cleanly remove FIRST...LAST from its current list. */
  first->prev->next = last->next;
c0029c18:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029c1b:	8b 00                	mov    (%eax),%eax
c0029c1d:	8b 55 10             	mov    0x10(%ebp),%edx
c0029c20:	8b 52 04             	mov    0x4(%edx),%edx
c0029c23:	89 50 04             	mov    %edx,0x4(%eax)
  last->next->prev = first->prev;
c0029c26:	8b 45 10             	mov    0x10(%ebp),%eax
c0029c29:	8b 40 04             	mov    0x4(%eax),%eax
c0029c2c:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029c2f:	8b 12                	mov    (%edx),%edx
c0029c31:	89 10                	mov    %edx,(%eax)

  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
c0029c33:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c36:	8b 10                	mov    (%eax),%edx
c0029c38:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029c3b:	89 10                	mov    %edx,(%eax)
  last->next = before;
c0029c3d:	8b 45 10             	mov    0x10(%ebp),%eax
c0029c40:	8b 55 08             	mov    0x8(%ebp),%edx
c0029c43:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = first;
c0029c46:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c49:	8b 00                	mov    (%eax),%eax
c0029c4b:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029c4e:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = last;
c0029c51:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c54:	8b 55 10             	mov    0x10(%ebp),%edx
c0029c57:	89 10                	mov    %edx,(%eax)
c0029c59:	eb 01                	jmp    c0029c5c <list_splice+0x10c>
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
  ASSERT (is_interior (before) || is_tail (before));
  if (first == last)
    return;
c0029c5b:	90                   	nop
  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
  last->next = before;
  before->prev->next = first;
  before->prev = last;
}
c0029c5c:	c9                   	leave  
c0029c5d:	c3                   	ret    

c0029c5e <list_push_front>:

/* Inserts ELEM at the beginning of LIST, so that it becomes the
   front in LIST. */
void
list_push_front (struct list *list, struct list_elem *elem)
{
c0029c5e:	55                   	push   %ebp
c0029c5f:	89 e5                	mov    %esp,%ebp
c0029c61:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_begin (list), elem);
c0029c64:	83 ec 0c             	sub    $0xc,%esp
c0029c67:	ff 75 08             	pushl  0x8(%ebp)
c0029c6a:	e8 8a fc ff ff       	call   c00298f9 <list_begin>
c0029c6f:	83 c4 10             	add    $0x10,%esp
c0029c72:	83 ec 08             	sub    $0x8,%esp
c0029c75:	ff 75 0c             	pushl  0xc(%ebp)
c0029c78:	50                   	push   %eax
c0029c79:	e8 3d fe ff ff       	call   c0029abb <list_insert>
c0029c7e:	83 c4 10             	add    $0x10,%esp
}
c0029c81:	90                   	nop
c0029c82:	c9                   	leave  
c0029c83:	c3                   	ret    

c0029c84 <list_push_back>:

/* Inserts ELEM at the end of LIST, so that it becomes the
   back in LIST. */
void
list_push_back (struct list *list, struct list_elem *elem)
{
c0029c84:	55                   	push   %ebp
c0029c85:	89 e5                	mov    %esp,%ebp
c0029c87:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_end (list), elem);
c0029c8a:	83 ec 0c             	sub    $0xc,%esp
c0029c8d:	ff 75 08             	pushl  0x8(%ebp)
c0029c90:	e8 e0 fc ff ff       	call   c0029975 <list_end>
c0029c95:	83 c4 10             	add    $0x10,%esp
c0029c98:	83 ec 08             	sub    $0x8,%esp
c0029c9b:	ff 75 0c             	pushl  0xc(%ebp)
c0029c9e:	50                   	push   %eax
c0029c9f:	e8 17 fe ff ff       	call   c0029abb <list_insert>
c0029ca4:	83 c4 10             	add    $0x10,%esp
}
c0029ca7:	90                   	nop
c0029ca8:	c9                   	leave  
c0029ca9:	c3                   	ret    

c0029caa <list_remove>:
       ...do something with e...
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
c0029caa:	55                   	push   %ebp
c0029cab:	89 e5                	mov    %esp,%ebp
c0029cad:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem));
c0029cb0:	ff 75 08             	pushl  0x8(%ebp)
c0029cb3:	e8 92 fb ff ff       	call   c002984a <is_interior>
c0029cb8:	83 c4 04             	add    $0x4,%esp
c0029cbb:	84 c0                	test   %al,%al
c0029cbd:	75 21                	jne    c0029ce0 <list_remove+0x36>
c0029cbf:	83 ec 0c             	sub    $0xc,%esp
c0029cc2:	68 39 0e 03 c0       	push   $0xc0030e39
c0029cc7:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029ccc:	68 ac 0f 03 c0       	push   $0xc0030fac
c0029cd1:	68 fb 00 00 00       	push   $0xfb
c0029cd6:	68 74 0d 03 c0       	push   $0xc0030d74
c0029cdb:	e8 51 f9 ff ff       	call   c0029631 <debug_panic>
  elem->prev->next = elem->next;
c0029ce0:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ce3:	8b 00                	mov    (%eax),%eax
c0029ce5:	8b 55 08             	mov    0x8(%ebp),%edx
c0029ce8:	8b 52 04             	mov    0x4(%edx),%edx
c0029ceb:	89 50 04             	mov    %edx,0x4(%eax)
  elem->next->prev = elem->prev;
c0029cee:	8b 45 08             	mov    0x8(%ebp),%eax
c0029cf1:	8b 40 04             	mov    0x4(%eax),%eax
c0029cf4:	8b 55 08             	mov    0x8(%ebp),%edx
c0029cf7:	8b 12                	mov    (%edx),%edx
c0029cf9:	89 10                	mov    %edx,(%eax)
  return elem->next;
c0029cfb:	8b 45 08             	mov    0x8(%ebp),%eax
c0029cfe:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029d01:	c9                   	leave  
c0029d02:	c3                   	ret    

c0029d03 <list_pop_front>:

/* Removes the front element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_front (struct list *list)
{
c0029d03:	55                   	push   %ebp
c0029d04:	89 e5                	mov    %esp,%ebp
c0029d06:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *front = list_front (list);
c0029d09:	83 ec 0c             	sub    $0xc,%esp
c0029d0c:	ff 75 08             	pushl  0x8(%ebp)
c0029d0f:	e8 43 00 00 00       	call   c0029d57 <list_front>
c0029d14:	83 c4 10             	add    $0x10,%esp
c0029d17:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (front);
c0029d1a:	83 ec 0c             	sub    $0xc,%esp
c0029d1d:	ff 75 f4             	pushl  -0xc(%ebp)
c0029d20:	e8 85 ff ff ff       	call   c0029caa <list_remove>
c0029d25:	83 c4 10             	add    $0x10,%esp
  return front;
c0029d28:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029d2b:	c9                   	leave  
c0029d2c:	c3                   	ret    

c0029d2d <list_pop_back>:

/* Removes the back element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_back (struct list *list)
{
c0029d2d:	55                   	push   %ebp
c0029d2e:	89 e5                	mov    %esp,%ebp
c0029d30:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *back = list_back (list);
c0029d33:	83 ec 0c             	sub    $0xc,%esp
c0029d36:	ff 75 08             	pushl  0x8(%ebp)
c0029d39:	e8 5d 00 00 00       	call   c0029d9b <list_back>
c0029d3e:	83 c4 10             	add    $0x10,%esp
c0029d41:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (back);
c0029d44:	83 ec 0c             	sub    $0xc,%esp
c0029d47:	ff 75 f4             	pushl  -0xc(%ebp)
c0029d4a:	e8 5b ff ff ff       	call   c0029caa <list_remove>
c0029d4f:	83 c4 10             	add    $0x10,%esp
  return back;
c0029d52:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029d55:	c9                   	leave  
c0029d56:	c3                   	ret    

c0029d57 <list_front>:

/* Returns the front element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_front (struct list *list)
{
c0029d57:	55                   	push   %ebp
c0029d58:	89 e5                	mov    %esp,%ebp
c0029d5a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c0029d5d:	83 ec 0c             	sub    $0xc,%esp
c0029d60:	ff 75 08             	pushl  0x8(%ebp)
c0029d63:	e8 c4 00 00 00       	call   c0029e2c <list_empty>
c0029d68:	83 c4 10             	add    $0x10,%esp
c0029d6b:	83 f0 01             	xor    $0x1,%eax
c0029d6e:	84 c0                	test   %al,%al
c0029d70:	75 21                	jne    c0029d93 <list_front+0x3c>
c0029d72:	83 ec 0c             	sub    $0xc,%esp
c0029d75:	68 4c 0e 03 c0       	push   $0xc0030e4c
c0029d7a:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029d7f:	68 b8 0f 03 c0       	push   $0xc0030fb8
c0029d84:	68 1a 01 00 00       	push   $0x11a
c0029d89:	68 74 0d 03 c0       	push   $0xc0030d74
c0029d8e:	e8 9e f8 ff ff       	call   c0029631 <debug_panic>
  return list->head.next;
c0029d93:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d96:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029d99:	c9                   	leave  
c0029d9a:	c3                   	ret    

c0029d9b <list_back>:

/* Returns the back element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_back (struct list *list)
{
c0029d9b:	55                   	push   %ebp
c0029d9c:	89 e5                	mov    %esp,%ebp
c0029d9e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c0029da1:	83 ec 0c             	sub    $0xc,%esp
c0029da4:	ff 75 08             	pushl  0x8(%ebp)
c0029da7:	e8 80 00 00 00       	call   c0029e2c <list_empty>
c0029dac:	83 c4 10             	add    $0x10,%esp
c0029daf:	83 f0 01             	xor    $0x1,%eax
c0029db2:	84 c0                	test   %al,%al
c0029db4:	75 21                	jne    c0029dd7 <list_back+0x3c>
c0029db6:	83 ec 0c             	sub    $0xc,%esp
c0029db9:	68 4c 0e 03 c0       	push   $0xc0030e4c
c0029dbe:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029dc3:	68 c4 0f 03 c0       	push   $0xc0030fc4
c0029dc8:	68 23 01 00 00       	push   $0x123
c0029dcd:	68 74 0d 03 c0       	push   $0xc0030d74
c0029dd2:	e8 5a f8 ff ff       	call   c0029631 <debug_panic>
  return list->tail.prev;
c0029dd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0029dda:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029ddd:	c9                   	leave  
c0029dde:	c3                   	ret    

c0029ddf <list_size>:

/* Returns the number of elements in LIST.
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
c0029ddf:	55                   	push   %ebp
c0029de0:	89 e5                	mov    %esp,%ebp
c0029de2:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;
  size_t cnt = 0;
c0029de5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029dec:	83 ec 0c             	sub    $0xc,%esp
c0029def:	ff 75 08             	pushl  0x8(%ebp)
c0029df2:	e8 02 fb ff ff       	call   c00298f9 <list_begin>
c0029df7:	83 c4 10             	add    $0x10,%esp
c0029dfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029dfd:	eb 15                	jmp    c0029e14 <list_size+0x35>
    cnt++;
c0029dff:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
list_size (struct list *list)
{
  struct list_elem *e;
  size_t cnt = 0;

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029e03:	83 ec 0c             	sub    $0xc,%esp
c0029e06:	ff 75 f4             	pushl  -0xc(%ebp)
c0029e09:	e8 1d fb ff ff       	call   c002992b <list_next>
c0029e0e:	83 c4 10             	add    $0x10,%esp
c0029e11:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029e14:	83 ec 0c             	sub    $0xc,%esp
c0029e17:	ff 75 08             	pushl  0x8(%ebp)
c0029e1a:	e8 56 fb ff ff       	call   c0029975 <list_end>
c0029e1f:	83 c4 10             	add    $0x10,%esp
c0029e22:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029e25:	75 d8                	jne    c0029dff <list_size+0x20>
    cnt++;
  return cnt;
c0029e27:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0029e2a:	c9                   	leave  
c0029e2b:	c3                   	ret    

c0029e2c <list_empty>:

/* Returns true if LIST is empty, false otherwise. */
bool
list_empty (struct list *list)
{
c0029e2c:	55                   	push   %ebp
c0029e2d:	89 e5                	mov    %esp,%ebp
c0029e2f:	53                   	push   %ebx
c0029e30:	83 ec 04             	sub    $0x4,%esp
  return list_begin (list) == list_end (list);
c0029e33:	83 ec 0c             	sub    $0xc,%esp
c0029e36:	ff 75 08             	pushl  0x8(%ebp)
c0029e39:	e8 bb fa ff ff       	call   c00298f9 <list_begin>
c0029e3e:	83 c4 10             	add    $0x10,%esp
c0029e41:	89 c3                	mov    %eax,%ebx
c0029e43:	83 ec 0c             	sub    $0xc,%esp
c0029e46:	ff 75 08             	pushl  0x8(%ebp)
c0029e49:	e8 27 fb ff ff       	call   c0029975 <list_end>
c0029e4e:	83 c4 10             	add    $0x10,%esp
c0029e51:	39 c3                	cmp    %eax,%ebx
c0029e53:	0f 94 c0             	sete   %al
}
c0029e56:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029e59:	c9                   	leave  
c0029e5a:	c3                   	ret    

c0029e5b <swap>:

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
c0029e5b:	55                   	push   %ebp
c0029e5c:	89 e5                	mov    %esp,%ebp
c0029e5e:	83 ec 10             	sub    $0x10,%esp
  struct list_elem *t = *a;
c0029e61:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e64:	8b 00                	mov    (%eax),%eax
c0029e66:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *a = *b;
c0029e69:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029e6c:	8b 10                	mov    (%eax),%edx
c0029e6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e71:	89 10                	mov    %edx,(%eax)
  *b = t;
c0029e73:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029e76:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0029e79:	89 10                	mov    %edx,(%eax)
}
c0029e7b:	90                   	nop
c0029e7c:	c9                   	leave  
c0029e7d:	c3                   	ret    

c0029e7e <list_reverse>:

/* Reverses the order of LIST. */
void
list_reverse (struct list *list)
{
c0029e7e:	55                   	push   %ebp
c0029e7f:	89 e5                	mov    %esp,%ebp
c0029e81:	83 ec 18             	sub    $0x18,%esp
  if (!list_empty (list)) 
c0029e84:	83 ec 0c             	sub    $0xc,%esp
c0029e87:	ff 75 08             	pushl  0x8(%ebp)
c0029e8a:	e8 9d ff ff ff       	call   c0029e2c <list_empty>
c0029e8f:	83 c4 10             	add    $0x10,%esp
c0029e92:	83 f0 01             	xor    $0x1,%eax
c0029e95:	84 c0                	test   %al,%al
c0029e97:	74 79                	je     c0029f12 <list_reverse+0x94>
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029e99:	83 ec 0c             	sub    $0xc,%esp
c0029e9c:	ff 75 08             	pushl  0x8(%ebp)
c0029e9f:	e8 55 fa ff ff       	call   c00298f9 <list_begin>
c0029ea4:	83 c4 10             	add    $0x10,%esp
c0029ea7:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029eaa:	eb 1e                	jmp    c0029eca <list_reverse+0x4c>
        swap (&e->prev, &e->next);
c0029eac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029eaf:	8d 50 04             	lea    0x4(%eax),%edx
c0029eb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029eb5:	83 ec 08             	sub    $0x8,%esp
c0029eb8:	52                   	push   %edx
c0029eb9:	50                   	push   %eax
c0029eba:	e8 9c ff ff ff       	call   c0029e5b <swap>
c0029ebf:	83 c4 10             	add    $0x10,%esp
{
  if (!list_empty (list)) 
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029ec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ec5:	8b 00                	mov    (%eax),%eax
c0029ec7:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029eca:	83 ec 0c             	sub    $0xc,%esp
c0029ecd:	ff 75 08             	pushl  0x8(%ebp)
c0029ed0:	e8 a0 fa ff ff       	call   c0029975 <list_end>
c0029ed5:	83 c4 10             	add    $0x10,%esp
c0029ed8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029edb:	75 cf                	jne    c0029eac <list_reverse+0x2e>
        swap (&e->prev, &e->next);
      swap (&list->head.next, &list->tail.prev);
c0029edd:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ee0:	8d 50 08             	lea    0x8(%eax),%edx
c0029ee3:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ee6:	83 c0 04             	add    $0x4,%eax
c0029ee9:	83 ec 08             	sub    $0x8,%esp
c0029eec:	52                   	push   %edx
c0029eed:	50                   	push   %eax
c0029eee:	e8 68 ff ff ff       	call   c0029e5b <swap>
c0029ef3:	83 c4 10             	add    $0x10,%esp
      swap (&list->head.next->prev, &list->tail.prev->next);
c0029ef6:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ef9:	8b 40 08             	mov    0x8(%eax),%eax
c0029efc:	8d 50 04             	lea    0x4(%eax),%edx
c0029eff:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f02:	8b 40 04             	mov    0x4(%eax),%eax
c0029f05:	83 ec 08             	sub    $0x8,%esp
c0029f08:	52                   	push   %edx
c0029f09:	50                   	push   %eax
c0029f0a:	e8 4c ff ff ff       	call   c0029e5b <swap>
c0029f0f:	83 c4 10             	add    $0x10,%esp
    }
}
c0029f12:	90                   	nop
c0029f13:	c9                   	leave  
c0029f14:	c3                   	ret    

c0029f15 <is_sorted>:
/* Returns true only if the list elements A through B (exclusive)
   are in order according to LESS given auxiliary data AUX. */
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
c0029f15:	55                   	push   %ebp
c0029f16:	89 e5                	mov    %esp,%ebp
c0029f18:	83 ec 08             	sub    $0x8,%esp
  if (a != b)
c0029f1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f1e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029f21:	74 46                	je     c0029f69 <is_sorted+0x54>
    while ((a = list_next (a)) != b) 
c0029f23:	eb 2b                	jmp    c0029f50 <is_sorted+0x3b>
      if (less (a, list_prev (a), aux))
c0029f25:	83 ec 0c             	sub    $0xc,%esp
c0029f28:	ff 75 08             	pushl  0x8(%ebp)
c0029f2b:	e8 a9 fa ff ff       	call   c00299d9 <list_prev>
c0029f30:	83 c4 10             	add    $0x10,%esp
c0029f33:	83 ec 04             	sub    $0x4,%esp
c0029f36:	ff 75 14             	pushl  0x14(%ebp)
c0029f39:	50                   	push   %eax
c0029f3a:	ff 75 08             	pushl  0x8(%ebp)
c0029f3d:	8b 45 10             	mov    0x10(%ebp),%eax
c0029f40:	ff d0                	call   *%eax
c0029f42:	83 c4 10             	add    $0x10,%esp
c0029f45:	84 c0                	test   %al,%al
c0029f47:	74 07                	je     c0029f50 <is_sorted+0x3b>
        return false;
c0029f49:	b8 00 00 00 00       	mov    $0x0,%eax
c0029f4e:	eb 1e                	jmp    c0029f6e <is_sorted+0x59>
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
  if (a != b)
    while ((a = list_next (a)) != b) 
c0029f50:	83 ec 0c             	sub    $0xc,%esp
c0029f53:	ff 75 08             	pushl  0x8(%ebp)
c0029f56:	e8 d0 f9 ff ff       	call   c002992b <list_next>
c0029f5b:	83 c4 10             	add    $0x10,%esp
c0029f5e:	89 45 08             	mov    %eax,0x8(%ebp)
c0029f61:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f64:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029f67:	75 bc                	jne    c0029f25 <is_sorted+0x10>
      if (less (a, list_prev (a), aux))
        return false;
  return true;
c0029f69:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0029f6e:	c9                   	leave  
c0029f6f:	c3                   	ret    

c0029f70 <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c0029f70:	55                   	push   %ebp
c0029f71:	89 e5                	mov    %esp,%ebp
c0029f73:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c0029f76:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029f7a:	75 21                	jne    c0029f9d <find_end_of_run+0x2d>
c0029f7c:	83 ec 0c             	sub    $0xc,%esp
c0029f7f:	68 5f 0e 03 c0       	push   $0xc0030e5f
c0029f84:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029f89:	68 d0 0f 03 c0       	push   $0xc0030fd0
c0029f8e:	68 69 01 00 00       	push   $0x169
c0029f93:	68 74 0d 03 c0       	push   $0xc0030d74
c0029f98:	e8 94 f6 ff ff       	call   c0029631 <debug_panic>
  ASSERT (b != NULL);
c0029f9d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0029fa1:	75 21                	jne    c0029fc4 <find_end_of_run+0x54>
c0029fa3:	83 ec 0c             	sub    $0xc,%esp
c0029fa6:	68 69 0e 03 c0       	push   $0xc0030e69
c0029fab:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029fb0:	68 d0 0f 03 c0       	push   $0xc0030fd0
c0029fb5:	68 6a 01 00 00       	push   $0x16a
c0029fba:	68 74 0d 03 c0       	push   $0xc0030d74
c0029fbf:	e8 6d f6 ff ff       	call   c0029631 <debug_panic>
  ASSERT (less != NULL);
c0029fc4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029fc8:	75 21                	jne    c0029feb <find_end_of_run+0x7b>
c0029fca:	83 ec 0c             	sub    $0xc,%esp
c0029fcd:	68 73 0e 03 c0       	push   $0xc0030e73
c0029fd2:	68 5d 0d 03 c0       	push   $0xc0030d5d
c0029fd7:	68 d0 0f 03 c0       	push   $0xc0030fd0
c0029fdc:	68 6b 01 00 00       	push   $0x16b
c0029fe1:	68 74 0d 03 c0       	push   $0xc0030d74
c0029fe6:	e8 46 f6 ff ff       	call   c0029631 <debug_panic>
  ASSERT (a != b);
c0029feb:	8b 45 08             	mov    0x8(%ebp),%eax
c0029fee:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029ff1:	75 21                	jne    c002a014 <find_end_of_run+0xa4>
c0029ff3:	83 ec 0c             	sub    $0xc,%esp
c0029ff6:	68 80 0e 03 c0       	push   $0xc0030e80
c0029ffb:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a000:	68 d0 0f 03 c0       	push   $0xc0030fd0
c002a005:	68 6c 01 00 00       	push   $0x16c
c002a00a:	68 74 0d 03 c0       	push   $0xc0030d74
c002a00f:	e8 1d f6 ff ff       	call   c0029631 <debug_panic>
  
  do 
    {
      a = list_next (a);
c002a014:	83 ec 0c             	sub    $0xc,%esp
c002a017:	ff 75 08             	pushl  0x8(%ebp)
c002a01a:	e8 0c f9 ff ff       	call   c002992b <list_next>
c002a01f:	83 c4 10             	add    $0x10,%esp
c002a022:	89 45 08             	mov    %eax,0x8(%ebp)
    }
  while (a != b && !less (a, list_prev (a), aux));
c002a025:	8b 45 08             	mov    0x8(%ebp),%eax
c002a028:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a02b:	74 27                	je     c002a054 <find_end_of_run+0xe4>
c002a02d:	83 ec 0c             	sub    $0xc,%esp
c002a030:	ff 75 08             	pushl  0x8(%ebp)
c002a033:	e8 a1 f9 ff ff       	call   c00299d9 <list_prev>
c002a038:	83 c4 10             	add    $0x10,%esp
c002a03b:	83 ec 04             	sub    $0x4,%esp
c002a03e:	ff 75 14             	pushl  0x14(%ebp)
c002a041:	50                   	push   %eax
c002a042:	ff 75 08             	pushl  0x8(%ebp)
c002a045:	8b 45 10             	mov    0x10(%ebp),%eax
c002a048:	ff d0                	call   *%eax
c002a04a:	83 c4 10             	add    $0x10,%esp
c002a04d:	83 f0 01             	xor    $0x1,%eax
c002a050:	84 c0                	test   %al,%al
c002a052:	75 c0                	jne    c002a014 <find_end_of_run+0xa4>
  return a;
c002a054:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002a057:	c9                   	leave  
c002a058:	c3                   	ret    

c002a059 <inplace_merge>:
   AUX.  The output range will be sorted the same way. */
static void
inplace_merge (struct list_elem *a0, struct list_elem *a1b0,
               struct list_elem *b1,
               list_less_func *less, void *aux)
{
c002a059:	55                   	push   %ebp
c002a05a:	89 e5                	mov    %esp,%ebp
c002a05c:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a0 != NULL);
c002a05f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a063:	75 21                	jne    c002a086 <inplace_merge+0x2d>
c002a065:	83 ec 0c             	sub    $0xc,%esp
c002a068:	68 87 0e 03 c0       	push   $0xc0030e87
c002a06d:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a072:	68 e0 0f 03 c0       	push   $0xc0030fe0
c002a077:	68 80 01 00 00       	push   $0x180
c002a07c:	68 74 0d 03 c0       	push   $0xc0030d74
c002a081:	e8 ab f5 ff ff       	call   c0029631 <debug_panic>
  ASSERT (a1b0 != NULL);
c002a086:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a08a:	75 21                	jne    c002a0ad <inplace_merge+0x54>
c002a08c:	83 ec 0c             	sub    $0xc,%esp
c002a08f:	68 92 0e 03 c0       	push   $0xc0030e92
c002a094:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a099:	68 e0 0f 03 c0       	push   $0xc0030fe0
c002a09e:	68 81 01 00 00       	push   $0x181
c002a0a3:	68 74 0d 03 c0       	push   $0xc0030d74
c002a0a8:	e8 84 f5 ff ff       	call   c0029631 <debug_panic>
  ASSERT (b1 != NULL);
c002a0ad:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a0b1:	75 21                	jne    c002a0d4 <inplace_merge+0x7b>
c002a0b3:	83 ec 0c             	sub    $0xc,%esp
c002a0b6:	68 9f 0e 03 c0       	push   $0xc0030e9f
c002a0bb:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a0c0:	68 e0 0f 03 c0       	push   $0xc0030fe0
c002a0c5:	68 82 01 00 00       	push   $0x182
c002a0ca:	68 74 0d 03 c0       	push   $0xc0030d74
c002a0cf:	e8 5d f5 ff ff       	call   c0029631 <debug_panic>
  ASSERT (less != NULL);
c002a0d4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002a0d8:	75 21                	jne    c002a0fb <inplace_merge+0xa2>
c002a0da:	83 ec 0c             	sub    $0xc,%esp
c002a0dd:	68 73 0e 03 c0       	push   $0xc0030e73
c002a0e2:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a0e7:	68 e0 0f 03 c0       	push   $0xc0030fe0
c002a0ec:	68 83 01 00 00       	push   $0x183
c002a0f1:	68 74 0d 03 c0       	push   $0xc0030d74
c002a0f6:	e8 36 f5 ff ff       	call   c0029631 <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c002a0fb:	ff 75 18             	pushl  0x18(%ebp)
c002a0fe:	ff 75 14             	pushl  0x14(%ebp)
c002a101:	ff 75 0c             	pushl  0xc(%ebp)
c002a104:	ff 75 08             	pushl  0x8(%ebp)
c002a107:	e8 09 fe ff ff       	call   c0029f15 <is_sorted>
c002a10c:	83 c4 10             	add    $0x10,%esp
c002a10f:	84 c0                	test   %al,%al
c002a111:	75 21                	jne    c002a134 <inplace_merge+0xdb>
c002a113:	83 ec 0c             	sub    $0xc,%esp
c002a116:	68 ac 0e 03 c0       	push   $0xc0030eac
c002a11b:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a120:	68 e0 0f 03 c0       	push   $0xc0030fe0
c002a125:	68 84 01 00 00       	push   $0x184
c002a12a:	68 74 0d 03 c0       	push   $0xc0030d74
c002a12f:	e8 fd f4 ff ff       	call   c0029631 <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c002a134:	ff 75 18             	pushl  0x18(%ebp)
c002a137:	ff 75 14             	pushl  0x14(%ebp)
c002a13a:	ff 75 10             	pushl  0x10(%ebp)
c002a13d:	ff 75 0c             	pushl  0xc(%ebp)
c002a140:	e8 d0 fd ff ff       	call   c0029f15 <is_sorted>
c002a145:	83 c4 10             	add    $0x10,%esp
c002a148:	84 c0                	test   %al,%al
c002a14a:	0f 85 80 00 00 00    	jne    c002a1d0 <inplace_merge+0x177>
c002a150:	83 ec 0c             	sub    $0xc,%esp
c002a153:	68 cc 0e 03 c0       	push   $0xc0030ecc
c002a158:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a15d:	68 e0 0f 03 c0       	push   $0xc0030fe0
c002a162:	68 85 01 00 00       	push   $0x185
c002a167:	68 74 0d 03 c0       	push   $0xc0030d74
c002a16c:	e8 c0 f4 ff ff       	call   c0029631 <debug_panic>

  while (a0 != a1b0 && a1b0 != b1)
    if (!less (a1b0, a0, aux)) 
c002a171:	83 ec 04             	sub    $0x4,%esp
c002a174:	ff 75 18             	pushl  0x18(%ebp)
c002a177:	ff 75 08             	pushl  0x8(%ebp)
c002a17a:	ff 75 0c             	pushl  0xc(%ebp)
c002a17d:	8b 45 14             	mov    0x14(%ebp),%eax
c002a180:	ff d0                	call   *%eax
c002a182:	83 c4 10             	add    $0x10,%esp
c002a185:	83 f0 01             	xor    $0x1,%eax
c002a188:	84 c0                	test   %al,%al
c002a18a:	74 13                	je     c002a19f <inplace_merge+0x146>
      a0 = list_next (a0);
c002a18c:	83 ec 0c             	sub    $0xc,%esp
c002a18f:	ff 75 08             	pushl  0x8(%ebp)
c002a192:	e8 94 f7 ff ff       	call   c002992b <list_next>
c002a197:	83 c4 10             	add    $0x10,%esp
c002a19a:	89 45 08             	mov    %eax,0x8(%ebp)
c002a19d:	eb 31                	jmp    c002a1d0 <inplace_merge+0x177>
    else 
      {
        a1b0 = list_next (a1b0);
c002a19f:	83 ec 0c             	sub    $0xc,%esp
c002a1a2:	ff 75 0c             	pushl  0xc(%ebp)
c002a1a5:	e8 81 f7 ff ff       	call   c002992b <list_next>
c002a1aa:	83 c4 10             	add    $0x10,%esp
c002a1ad:	89 45 0c             	mov    %eax,0xc(%ebp)
        list_splice (a0, list_prev (a1b0), a1b0);
c002a1b0:	83 ec 0c             	sub    $0xc,%esp
c002a1b3:	ff 75 0c             	pushl  0xc(%ebp)
c002a1b6:	e8 1e f8 ff ff       	call   c00299d9 <list_prev>
c002a1bb:	83 c4 10             	add    $0x10,%esp
c002a1be:	83 ec 04             	sub    $0x4,%esp
c002a1c1:	ff 75 0c             	pushl  0xc(%ebp)
c002a1c4:	50                   	push   %eax
c002a1c5:	ff 75 08             	pushl  0x8(%ebp)
c002a1c8:	e8 83 f9 ff ff       	call   c0029b50 <list_splice>
c002a1cd:	83 c4 10             	add    $0x10,%esp
  ASSERT (b1 != NULL);
  ASSERT (less != NULL);
  ASSERT (is_sorted (a0, a1b0, less, aux));
  ASSERT (is_sorted (a1b0, b1, less, aux));

  while (a0 != a1b0 && a1b0 != b1)
c002a1d0:	8b 45 08             	mov    0x8(%ebp),%eax
c002a1d3:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a1d6:	74 08                	je     c002a1e0 <inplace_merge+0x187>
c002a1d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a1db:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a1de:	75 91                	jne    c002a171 <inplace_merge+0x118>
    else 
      {
        a1b0 = list_next (a1b0);
        list_splice (a0, list_prev (a1b0), a1b0);
      }
}
c002a1e0:	90                   	nop
c002a1e1:	c9                   	leave  
c002a1e2:	c3                   	ret    

c002a1e3 <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c002a1e3:	55                   	push   %ebp
c002a1e4:	89 e5                	mov    %esp,%ebp
c002a1e6:	53                   	push   %ebx
c002a1e7:	83 ec 14             	sub    $0x14,%esp
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c002a1ea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a1ee:	75 21                	jne    c002a211 <list_sort+0x2e>
c002a1f0:	83 ec 0c             	sub    $0xc,%esp
c002a1f3:	68 50 0d 03 c0       	push   $0xc0030d50
c002a1f8:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a1fd:	68 f0 0f 03 c0       	push   $0xc0030ff0
c002a202:	68 99 01 00 00       	push   $0x199
c002a207:	68 74 0d 03 c0       	push   $0xc0030d74
c002a20c:	e8 20 f4 ff ff       	call   c0029631 <debug_panic>
  ASSERT (less != NULL);
c002a211:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a215:	75 21                	jne    c002a238 <list_sort+0x55>
c002a217:	83 ec 0c             	sub    $0xc,%esp
c002a21a:	68 73 0e 03 c0       	push   $0xc0030e73
c002a21f:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a224:	68 f0 0f 03 c0       	push   $0xc0030ff0
c002a229:	68 9a 01 00 00       	push   $0x19a
c002a22e:	68 74 0d 03 c0       	push   $0xc0030d74
c002a233:	e8 f9 f3 ff ff       	call   c0029631 <debug_panic>
    {
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
c002a238:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a23f:	83 ec 0c             	sub    $0xc,%esp
c002a242:	ff 75 08             	pushl  0x8(%ebp)
c002a245:	e8 af f6 ff ff       	call   c00298f9 <list_begin>
c002a24a:	83 c4 10             	add    $0x10,%esp
c002a24d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a250:	eb 7d                	jmp    c002a2cf <list_sort+0xec>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c002a252:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c002a256:	83 ec 0c             	sub    $0xc,%esp
c002a259:	ff 75 08             	pushl  0x8(%ebp)
c002a25c:	e8 14 f7 ff ff       	call   c0029975 <list_end>
c002a261:	83 c4 10             	add    $0x10,%esp
c002a264:	ff 75 10             	pushl  0x10(%ebp)
c002a267:	ff 75 0c             	pushl  0xc(%ebp)
c002a26a:	50                   	push   %eax
c002a26b:	ff 75 f0             	pushl  -0x10(%ebp)
c002a26e:	e8 fd fc ff ff       	call   c0029f70 <find_end_of_run>
c002a273:	83 c4 10             	add    $0x10,%esp
c002a276:	89 45 ec             	mov    %eax,-0x14(%ebp)
          if (a1b0 == list_end (list))
c002a279:	83 ec 0c             	sub    $0xc,%esp
c002a27c:	ff 75 08             	pushl  0x8(%ebp)
c002a27f:	e8 f1 f6 ff ff       	call   c0029975 <list_end>
c002a284:	83 c4 10             	add    $0x10,%esp
c002a287:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002a28a:	74 5c                	je     c002a2e8 <list_sort+0x105>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c002a28c:	83 ec 0c             	sub    $0xc,%esp
c002a28f:	ff 75 08             	pushl  0x8(%ebp)
c002a292:	e8 de f6 ff ff       	call   c0029975 <list_end>
c002a297:	83 c4 10             	add    $0x10,%esp
c002a29a:	ff 75 10             	pushl  0x10(%ebp)
c002a29d:	ff 75 0c             	pushl  0xc(%ebp)
c002a2a0:	50                   	push   %eax
c002a2a1:	ff 75 ec             	pushl  -0x14(%ebp)
c002a2a4:	e8 c7 fc ff ff       	call   c0029f70 <find_end_of_run>
c002a2a9:	83 c4 10             	add    $0x10,%esp
c002a2ac:	89 45 e8             	mov    %eax,-0x18(%ebp)

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
c002a2af:	83 ec 0c             	sub    $0xc,%esp
c002a2b2:	ff 75 10             	pushl  0x10(%ebp)
c002a2b5:	ff 75 0c             	pushl  0xc(%ebp)
c002a2b8:	ff 75 e8             	pushl  -0x18(%ebp)
c002a2bb:	ff 75 ec             	pushl  -0x14(%ebp)
c002a2be:	ff 75 f0             	pushl  -0x10(%ebp)
c002a2c1:	e8 93 fd ff ff       	call   c002a059 <inplace_merge>
c002a2c6:	83 c4 20             	add    $0x20,%esp
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a2c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a2cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a2cf:	83 ec 0c             	sub    $0xc,%esp
c002a2d2:	ff 75 08             	pushl  0x8(%ebp)
c002a2d5:	e8 9b f6 ff ff       	call   c0029975 <list_end>
c002a2da:	83 c4 10             	add    $0x10,%esp
c002a2dd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a2e0:	0f 85 6c ff ff ff    	jne    c002a252 <list_sort+0x6f>
c002a2e6:	eb 01                	jmp    c002a2e9 <list_sort+0x106>

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
          if (a1b0 == list_end (list))
            break;
c002a2e8:	90                   	nop

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
        }
    }
  while (output_run_cnt > 1);
c002a2e9:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002a2ed:	0f 87 45 ff ff ff    	ja     c002a238 <list_sort+0x55>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c002a2f3:	83 ec 0c             	sub    $0xc,%esp
c002a2f6:	ff 75 08             	pushl  0x8(%ebp)
c002a2f9:	e8 77 f6 ff ff       	call   c0029975 <list_end>
c002a2fe:	83 c4 10             	add    $0x10,%esp
c002a301:	89 c3                	mov    %eax,%ebx
c002a303:	83 ec 0c             	sub    $0xc,%esp
c002a306:	ff 75 08             	pushl  0x8(%ebp)
c002a309:	e8 eb f5 ff ff       	call   c00298f9 <list_begin>
c002a30e:	83 c4 10             	add    $0x10,%esp
c002a311:	ff 75 10             	pushl  0x10(%ebp)
c002a314:	ff 75 0c             	pushl  0xc(%ebp)
c002a317:	53                   	push   %ebx
c002a318:	50                   	push   %eax
c002a319:	e8 f7 fb ff ff       	call   c0029f15 <is_sorted>
c002a31e:	83 c4 10             	add    $0x10,%esp
c002a321:	84 c0                	test   %al,%al
c002a323:	75 21                	jne    c002a346 <list_sort+0x163>
c002a325:	83 ec 0c             	sub    $0xc,%esp
c002a328:	68 ec 0e 03 c0       	push   $0xc0030eec
c002a32d:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a332:	68 f0 0f 03 c0       	push   $0xc0030ff0
c002a337:	68 b7 01 00 00       	push   $0x1b7
c002a33c:	68 74 0d 03 c0       	push   $0xc0030d74
c002a341:	e8 eb f2 ff ff       	call   c0029631 <debug_panic>
}
c002a346:	90                   	nop
c002a347:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a34a:	c9                   	leave  
c002a34b:	c3                   	ret    

c002a34c <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c002a34c:	55                   	push   %ebp
c002a34d:	89 e5                	mov    %esp,%ebp
c002a34f:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (list != NULL);
c002a352:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a356:	75 21                	jne    c002a379 <list_insert_ordered+0x2d>
c002a358:	83 ec 0c             	sub    $0xc,%esp
c002a35b:	68 50 0d 03 c0       	push   $0xc0030d50
c002a360:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a365:	68 fc 0f 03 c0       	push   $0xc0030ffc
c002a36a:	68 c3 01 00 00       	push   $0x1c3
c002a36f:	68 74 0d 03 c0       	push   $0xc0030d74
c002a374:	e8 b8 f2 ff ff       	call   c0029631 <debug_panic>
  ASSERT (elem != NULL);
c002a379:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a37d:	75 21                	jne    c002a3a0 <list_insert_ordered+0x54>
c002a37f:	83 ec 0c             	sub    $0xc,%esp
c002a382:	68 05 0e 03 c0       	push   $0xc0030e05
c002a387:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a38c:	68 fc 0f 03 c0       	push   $0xc0030ffc
c002a391:	68 c4 01 00 00       	push   $0x1c4
c002a396:	68 74 0d 03 c0       	push   $0xc0030d74
c002a39b:	e8 91 f2 ff ff       	call   c0029631 <debug_panic>
  ASSERT (less != NULL);
c002a3a0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a3a4:	75 21                	jne    c002a3c7 <list_insert_ordered+0x7b>
c002a3a6:	83 ec 0c             	sub    $0xc,%esp
c002a3a9:	68 73 0e 03 c0       	push   $0xc0030e73
c002a3ae:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a3b3:	68 fc 0f 03 c0       	push   $0xc0030ffc
c002a3b8:	68 c5 01 00 00       	push   $0x1c5
c002a3bd:	68 74 0d 03 c0       	push   $0xc0030d74
c002a3c2:	e8 6a f2 ff ff       	call   c0029631 <debug_panic>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a3c7:	83 ec 0c             	sub    $0xc,%esp
c002a3ca:	ff 75 08             	pushl  0x8(%ebp)
c002a3cd:	e8 27 f5 ff ff       	call   c00298f9 <list_begin>
c002a3d2:	83 c4 10             	add    $0x10,%esp
c002a3d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a3d8:	eb 29                	jmp    c002a403 <list_insert_ordered+0xb7>
    if (less (elem, e, aux))
c002a3da:	83 ec 04             	sub    $0x4,%esp
c002a3dd:	ff 75 14             	pushl  0x14(%ebp)
c002a3e0:	ff 75 f4             	pushl  -0xc(%ebp)
c002a3e3:	ff 75 0c             	pushl  0xc(%ebp)
c002a3e6:	8b 45 10             	mov    0x10(%ebp),%eax
c002a3e9:	ff d0                	call   *%eax
c002a3eb:	83 c4 10             	add    $0x10,%esp
c002a3ee:	84 c0                	test   %al,%al
c002a3f0:	75 26                	jne    c002a418 <list_insert_ordered+0xcc>

  ASSERT (list != NULL);
  ASSERT (elem != NULL);
  ASSERT (less != NULL);

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a3f2:	83 ec 0c             	sub    $0xc,%esp
c002a3f5:	ff 75 f4             	pushl  -0xc(%ebp)
c002a3f8:	e8 2e f5 ff ff       	call   c002992b <list_next>
c002a3fd:	83 c4 10             	add    $0x10,%esp
c002a400:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a403:	83 ec 0c             	sub    $0xc,%esp
c002a406:	ff 75 08             	pushl  0x8(%ebp)
c002a409:	e8 67 f5 ff ff       	call   c0029975 <list_end>
c002a40e:	83 c4 10             	add    $0x10,%esp
c002a411:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a414:	75 c4                	jne    c002a3da <list_insert_ordered+0x8e>
c002a416:	eb 01                	jmp    c002a419 <list_insert_ordered+0xcd>
    if (less (elem, e, aux))
      break;
c002a418:	90                   	nop
  return list_insert (e, elem);
c002a419:	83 ec 08             	sub    $0x8,%esp
c002a41c:	ff 75 0c             	pushl  0xc(%ebp)
c002a41f:	ff 75 f4             	pushl  -0xc(%ebp)
c002a422:	e8 94 f6 ff ff       	call   c0029abb <list_insert>
c002a427:	83 c4 10             	add    $0x10,%esp
}
c002a42a:	c9                   	leave  
c002a42b:	c3                   	ret    

c002a42c <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c002a42c:	55                   	push   %ebp
c002a42d:	89 e5                	mov    %esp,%ebp
c002a42f:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c002a432:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a436:	75 21                	jne    c002a459 <list_unique+0x2d>
c002a438:	83 ec 0c             	sub    $0xc,%esp
c002a43b:	68 50 0d 03 c0       	push   $0xc0030d50
c002a440:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a445:	68 10 10 03 c0       	push   $0xc0031010
c002a44a:	68 d7 01 00 00       	push   $0x1d7
c002a44f:	68 74 0d 03 c0       	push   $0xc0030d74
c002a454:	e8 d8 f1 ff ff       	call   c0029631 <debug_panic>
  ASSERT (less != NULL);
c002a459:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a45d:	75 21                	jne    c002a480 <list_unique+0x54>
c002a45f:	83 ec 0c             	sub    $0xc,%esp
c002a462:	68 73 0e 03 c0       	push   $0xc0030e73
c002a467:	68 5d 0d 03 c0       	push   $0xc0030d5d
c002a46c:	68 10 10 03 c0       	push   $0xc0031010
c002a471:	68 d8 01 00 00       	push   $0x1d8
c002a476:	68 74 0d 03 c0       	push   $0xc0030d74
c002a47b:	e8 b1 f1 ff ff       	call   c0029631 <debug_panic>
  if (list_empty (list))
c002a480:	83 ec 0c             	sub    $0xc,%esp
c002a483:	ff 75 08             	pushl  0x8(%ebp)
c002a486:	e8 a1 f9 ff ff       	call   c0029e2c <list_empty>
c002a48b:	83 c4 10             	add    $0x10,%esp
c002a48e:	84 c0                	test   %al,%al
c002a490:	0f 85 a0 00 00 00    	jne    c002a536 <list_unique+0x10a>
    return;

  elem = list_begin (list);
c002a496:	83 ec 0c             	sub    $0xc,%esp
c002a499:	ff 75 08             	pushl  0x8(%ebp)
c002a49c:	e8 58 f4 ff ff       	call   c00298f9 <list_begin>
c002a4a1:	83 c4 10             	add    $0x10,%esp
c002a4a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002a4a7:	eb 63                	jmp    c002a50c <list_unique+0xe0>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002a4a9:	83 ec 04             	sub    $0x4,%esp
c002a4ac:	ff 75 14             	pushl  0x14(%ebp)
c002a4af:	ff 75 f0             	pushl  -0x10(%ebp)
c002a4b2:	ff 75 f4             	pushl  -0xc(%ebp)
c002a4b5:	8b 45 10             	mov    0x10(%ebp),%eax
c002a4b8:	ff d0                	call   *%eax
c002a4ba:	83 c4 10             	add    $0x10,%esp
c002a4bd:	83 f0 01             	xor    $0x1,%eax
c002a4c0:	84 c0                	test   %al,%al
c002a4c2:	74 42                	je     c002a506 <list_unique+0xda>
c002a4c4:	83 ec 04             	sub    $0x4,%esp
c002a4c7:	ff 75 14             	pushl  0x14(%ebp)
c002a4ca:	ff 75 f4             	pushl  -0xc(%ebp)
c002a4cd:	ff 75 f0             	pushl  -0x10(%ebp)
c002a4d0:	8b 45 10             	mov    0x10(%ebp),%eax
c002a4d3:	ff d0                	call   *%eax
c002a4d5:	83 c4 10             	add    $0x10,%esp
c002a4d8:	83 f0 01             	xor    $0x1,%eax
c002a4db:	84 c0                	test   %al,%al
c002a4dd:	74 27                	je     c002a506 <list_unique+0xda>
      {
        list_remove (next);
c002a4df:	83 ec 0c             	sub    $0xc,%esp
c002a4e2:	ff 75 f0             	pushl  -0x10(%ebp)
c002a4e5:	e8 c0 f7 ff ff       	call   c0029caa <list_remove>
c002a4ea:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002a4ed:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a4f1:	74 19                	je     c002a50c <list_unique+0xe0>
          list_push_back (duplicates, next);
c002a4f3:	83 ec 08             	sub    $0x8,%esp
c002a4f6:	ff 75 f0             	pushl  -0x10(%ebp)
c002a4f9:	ff 75 0c             	pushl  0xc(%ebp)
c002a4fc:	e8 83 f7 ff ff       	call   c0029c84 <list_push_back>
c002a501:	83 c4 10             	add    $0x10,%esp
  elem = list_begin (list);
  while ((next = list_next (elem)) != list_end (list))
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
      {
        list_remove (next);
        if (duplicates != NULL)
c002a504:	eb 06                	jmp    c002a50c <list_unique+0xe0>
          list_push_back (duplicates, next);
      }
    else
      elem = next;
c002a506:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a509:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (less != NULL);
  if (list_empty (list))
    return;

  elem = list_begin (list);
  while ((next = list_next (elem)) != list_end (list))
c002a50c:	83 ec 0c             	sub    $0xc,%esp
c002a50f:	ff 75 f4             	pushl  -0xc(%ebp)
c002a512:	e8 14 f4 ff ff       	call   c002992b <list_next>
c002a517:	83 c4 10             	add    $0x10,%esp
c002a51a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a51d:	83 ec 0c             	sub    $0xc,%esp
c002a520:	ff 75 08             	pushl  0x8(%ebp)
c002a523:	e8 4d f4 ff ff       	call   c0029975 <list_end>
c002a528:	83 c4 10             	add    $0x10,%esp
c002a52b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002a52e:	0f 85 75 ff ff ff    	jne    c002a4a9 <list_unique+0x7d>
c002a534:	eb 01                	jmp    c002a537 <list_unique+0x10b>
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
  ASSERT (less != NULL);
  if (list_empty (list))
    return;
c002a536:	90                   	nop
        if (duplicates != NULL)
          list_push_back (duplicates, next);
      }
    else
      elem = next;
}
c002a537:	c9                   	leave  
c002a538:	c3                   	ret    

c002a539 <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c002a539:	55                   	push   %ebp
c002a53a:	89 e5                	mov    %esp,%ebp
c002a53c:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *max = list_begin (list);
c002a53f:	83 ec 0c             	sub    $0xc,%esp
c002a542:	ff 75 08             	pushl  0x8(%ebp)
c002a545:	e8 af f3 ff ff       	call   c00298f9 <list_begin>
c002a54a:	83 c4 10             	add    $0x10,%esp
c002a54d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (max != list_end (list)) 
c002a550:	83 ec 0c             	sub    $0xc,%esp
c002a553:	ff 75 08             	pushl  0x8(%ebp)
c002a556:	e8 1a f4 ff ff       	call   c0029975 <list_end>
c002a55b:	83 c4 10             	add    $0x10,%esp
c002a55e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a561:	74 55                	je     c002a5b8 <list_max+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a563:	83 ec 0c             	sub    $0xc,%esp
c002a566:	ff 75 f4             	pushl  -0xc(%ebp)
c002a569:	e8 bd f3 ff ff       	call   c002992b <list_next>
c002a56e:	83 c4 10             	add    $0x10,%esp
c002a571:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a574:	eb 2f                	jmp    c002a5a5 <list_max+0x6c>
        if (less (max, e, aux))
c002a576:	83 ec 04             	sub    $0x4,%esp
c002a579:	ff 75 10             	pushl  0x10(%ebp)
c002a57c:	ff 75 f0             	pushl  -0x10(%ebp)
c002a57f:	ff 75 f4             	pushl  -0xc(%ebp)
c002a582:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a585:	ff d0                	call   *%eax
c002a587:	83 c4 10             	add    $0x10,%esp
c002a58a:	84 c0                	test   %al,%al
c002a58c:	74 06                	je     c002a594 <list_max+0x5b>
          max = e; 
c002a58e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a591:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct list_elem *max = list_begin (list);
  if (max != list_end (list)) 
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a594:	83 ec 0c             	sub    $0xc,%esp
c002a597:	ff 75 f0             	pushl  -0x10(%ebp)
c002a59a:	e8 8c f3 ff ff       	call   c002992b <list_next>
c002a59f:	83 c4 10             	add    $0x10,%esp
c002a5a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a5a5:	83 ec 0c             	sub    $0xc,%esp
c002a5a8:	ff 75 08             	pushl  0x8(%ebp)
c002a5ab:	e8 c5 f3 ff ff       	call   c0029975 <list_end>
c002a5b0:	83 c4 10             	add    $0x10,%esp
c002a5b3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a5b6:	75 be                	jne    c002a576 <list_max+0x3d>
        if (less (max, e, aux))
          max = e; 
    }
  return max;
c002a5b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a5bb:	c9                   	leave  
c002a5bc:	c3                   	ret    

c002a5bd <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002a5bd:	55                   	push   %ebp
c002a5be:	89 e5                	mov    %esp,%ebp
c002a5c0:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *min = list_begin (list);
c002a5c3:	83 ec 0c             	sub    $0xc,%esp
c002a5c6:	ff 75 08             	pushl  0x8(%ebp)
c002a5c9:	e8 2b f3 ff ff       	call   c00298f9 <list_begin>
c002a5ce:	83 c4 10             	add    $0x10,%esp
c002a5d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (min != list_end (list)) 
c002a5d4:	83 ec 0c             	sub    $0xc,%esp
c002a5d7:	ff 75 08             	pushl  0x8(%ebp)
c002a5da:	e8 96 f3 ff ff       	call   c0029975 <list_end>
c002a5df:	83 c4 10             	add    $0x10,%esp
c002a5e2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a5e5:	74 55                	je     c002a63c <list_min+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a5e7:	83 ec 0c             	sub    $0xc,%esp
c002a5ea:	ff 75 f4             	pushl  -0xc(%ebp)
c002a5ed:	e8 39 f3 ff ff       	call   c002992b <list_next>
c002a5f2:	83 c4 10             	add    $0x10,%esp
c002a5f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a5f8:	eb 2f                	jmp    c002a629 <list_min+0x6c>
        if (less (e, min, aux))
c002a5fa:	83 ec 04             	sub    $0x4,%esp
c002a5fd:	ff 75 10             	pushl  0x10(%ebp)
c002a600:	ff 75 f4             	pushl  -0xc(%ebp)
c002a603:	ff 75 f0             	pushl  -0x10(%ebp)
c002a606:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a609:	ff d0                	call   *%eax
c002a60b:	83 c4 10             	add    $0x10,%esp
c002a60e:	84 c0                	test   %al,%al
c002a610:	74 06                	je     c002a618 <list_min+0x5b>
          min = e; 
c002a612:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a615:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct list_elem *min = list_begin (list);
  if (min != list_end (list)) 
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a618:	83 ec 0c             	sub    $0xc,%esp
c002a61b:	ff 75 f0             	pushl  -0x10(%ebp)
c002a61e:	e8 08 f3 ff ff       	call   c002992b <list_next>
c002a623:	83 c4 10             	add    $0x10,%esp
c002a626:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a629:	83 ec 0c             	sub    $0xc,%esp
c002a62c:	ff 75 08             	pushl  0x8(%ebp)
c002a62f:	e8 41 f3 ff ff       	call   c0029975 <list_end>
c002a634:	83 c4 10             	add    $0x10,%esp
c002a637:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a63a:	75 be                	jne    c002a5fa <list_min+0x3d>
        if (less (e, min, aux))
          min = e; 
    }
  return min;
c002a63c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a63f:	c9                   	leave  
c002a640:	c3                   	ret    

c002a641 <elem_idx>:

/* Returns the index of the element that contains the bit
   numbered BIT_IDX. */
static inline size_t
elem_idx (size_t bit_idx) 
{
c002a641:	55                   	push   %ebp
c002a642:	89 e5                	mov    %esp,%ebp
  return bit_idx / ELEM_BITS;
c002a644:	8b 45 08             	mov    0x8(%ebp),%eax
c002a647:	c1 e8 05             	shr    $0x5,%eax
}
c002a64a:	5d                   	pop    %ebp
c002a64b:	c3                   	ret    

c002a64c <bit_mask>:

/* Returns an elem_type where only the bit corresponding to
   BIT_IDX is turned on. */
static inline elem_type
bit_mask (size_t bit_idx) 
{
c002a64c:	55                   	push   %ebp
c002a64d:	89 e5                	mov    %esp,%ebp
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a64f:	8b 45 08             	mov    0x8(%ebp),%eax
c002a652:	83 e0 1f             	and    $0x1f,%eax
c002a655:	ba 01 00 00 00       	mov    $0x1,%edx
c002a65a:	89 c1                	mov    %eax,%ecx
c002a65c:	d3 e2                	shl    %cl,%edx
c002a65e:	89 d0                	mov    %edx,%eax
}
c002a660:	5d                   	pop    %ebp
c002a661:	c3                   	ret    

c002a662 <elem_cnt>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
c002a662:	55                   	push   %ebp
c002a663:	89 e5                	mov    %esp,%ebp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a665:	8b 45 08             	mov    0x8(%ebp),%eax
c002a668:	83 c0 1f             	add    $0x1f,%eax
c002a66b:	c1 e8 05             	shr    $0x5,%eax
}
c002a66e:	5d                   	pop    %ebp
c002a66f:	c3                   	ret    

c002a670 <byte_cnt>:

/* Returns the number of bytes required for BIT_CNT bits. */
static inline size_t
byte_cnt (size_t bit_cnt)
{
c002a670:	55                   	push   %ebp
c002a671:	89 e5                	mov    %esp,%ebp
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a673:	ff 75 08             	pushl  0x8(%ebp)
c002a676:	e8 e7 ff ff ff       	call   c002a662 <elem_cnt>
c002a67b:	83 c4 04             	add    $0x4,%esp
c002a67e:	c1 e0 02             	shl    $0x2,%eax
}
c002a681:	c9                   	leave  
c002a682:	c3                   	ret    

c002a683 <bitmap_create>:
   BIT_CNT (or more) bits.  Returns a null pointer if memory allocation fails.
   The caller is responsible for freeing the bitmap, with bitmap_destroy(),
   when it is no longer needed. */
struct bitmap *
bitmap_create (size_t bit_cnt) 
{
c002a683:	55                   	push   %ebp
c002a684:	89 e5                	mov    %esp,%ebp
c002a686:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = malloc (sizeof *b);
c002a689:	83 ec 0c             	sub    $0xc,%esp
c002a68c:	6a 08                	push   $0x8
c002a68e:	e8 f8 8d ff ff       	call   c002348b <malloc>
c002a693:	83 c4 10             	add    $0x10,%esp
c002a696:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (b != NULL)
c002a699:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a69d:	74 5d                	je     c002a6fc <bitmap_create+0x79>
    {
      b->bit_cnt = bit_cnt;
c002a69f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a6a2:	8b 55 08             	mov    0x8(%ebp),%edx
c002a6a5:	89 10                	mov    %edx,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002a6a7:	83 ec 0c             	sub    $0xc,%esp
c002a6aa:	ff 75 08             	pushl  0x8(%ebp)
c002a6ad:	e8 be ff ff ff       	call   c002a670 <byte_cnt>
c002a6b2:	83 c4 10             	add    $0x10,%esp
c002a6b5:	83 ec 0c             	sub    $0xc,%esp
c002a6b8:	50                   	push   %eax
c002a6b9:	e8 cd 8d ff ff       	call   c002348b <malloc>
c002a6be:	83 c4 10             	add    $0x10,%esp
c002a6c1:	89 c2                	mov    %eax,%edx
c002a6c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a6c6:	89 50 04             	mov    %edx,0x4(%eax)
      if (b->bits != NULL || bit_cnt == 0)
c002a6c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a6cc:	8b 40 04             	mov    0x4(%eax),%eax
c002a6cf:	85 c0                	test   %eax,%eax
c002a6d1:	75 06                	jne    c002a6d9 <bitmap_create+0x56>
c002a6d3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a6d7:	75 15                	jne    c002a6ee <bitmap_create+0x6b>
        {
          bitmap_set_all (b, false);
c002a6d9:	83 ec 08             	sub    $0x8,%esp
c002a6dc:	6a 00                	push   $0x0
c002a6de:	ff 75 f4             	pushl  -0xc(%ebp)
c002a6e1:	e8 92 02 00 00       	call   c002a978 <bitmap_set_all>
c002a6e6:	83 c4 10             	add    $0x10,%esp
          return b;
c002a6e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a6ec:	eb 13                	jmp    c002a701 <bitmap_create+0x7e>
        }
      free (b);
c002a6ee:	83 ec 0c             	sub    $0xc,%esp
c002a6f1:	ff 75 f4             	pushl  -0xc(%ebp)
c002a6f4:	e8 8b 90 ff ff       	call   c0023784 <free>
c002a6f9:	83 c4 10             	add    $0x10,%esp
    }
  return NULL;
c002a6fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002a701:	c9                   	leave  
c002a702:	c3                   	ret    

c002a703 <bitmap_create_in_buf>:
/* Creates and returns a bitmap with BIT_CNT bits in the
   BLOCK_SIZE bytes of storage preallocated at BLOCK.
   BLOCK_SIZE must be at least bitmap_needed_bytes(BIT_CNT). */
struct bitmap *
bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size UNUSED)
{
c002a703:	55                   	push   %ebp
c002a704:	89 e5                	mov    %esp,%ebp
c002a706:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = block;
c002a709:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a70c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a70f:	83 ec 0c             	sub    $0xc,%esp
c002a712:	ff 75 08             	pushl  0x8(%ebp)
c002a715:	e8 4f 00 00 00       	call   c002a769 <bitmap_buf_size>
c002a71a:	83 c4 10             	add    $0x10,%esp
c002a71d:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a720:	76 1e                	jbe    c002a740 <bitmap_create_in_buf+0x3d>
c002a722:	83 ec 0c             	sub    $0xc,%esp
c002a725:	68 1c 10 03 c0       	push   $0xc003101c
c002a72a:	68 44 10 03 c0       	push   $0xc0031044
c002a72f:	68 c0 10 03 c0       	push   $0xc00310c0
c002a734:	6a 68                	push   $0x68
c002a736:	68 5b 10 03 c0       	push   $0xc003105b
c002a73b:	e8 f1 ee ff ff       	call   c0029631 <debug_panic>

  b->bit_cnt = bit_cnt;
c002a740:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a743:	8b 55 08             	mov    0x8(%ebp),%edx
c002a746:	89 10                	mov    %edx,(%eax)
  b->bits = (elem_type *) (b + 1);
c002a748:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a74b:	8d 50 08             	lea    0x8(%eax),%edx
c002a74e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a751:	89 50 04             	mov    %edx,0x4(%eax)
  bitmap_set_all (b, false);
c002a754:	83 ec 08             	sub    $0x8,%esp
c002a757:	6a 00                	push   $0x0
c002a759:	ff 75 f4             	pushl  -0xc(%ebp)
c002a75c:	e8 17 02 00 00       	call   c002a978 <bitmap_set_all>
c002a761:	83 c4 10             	add    $0x10,%esp
  return b;
c002a764:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a767:	c9                   	leave  
c002a768:	c3                   	ret    

c002a769 <bitmap_buf_size>:

/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
c002a769:	55                   	push   %ebp
c002a76a:	89 e5                	mov    %esp,%ebp
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002a76c:	ff 75 08             	pushl  0x8(%ebp)
c002a76f:	e8 fc fe ff ff       	call   c002a670 <byte_cnt>
c002a774:	83 c4 04             	add    $0x4,%esp
c002a777:	83 c0 08             	add    $0x8,%eax
}
c002a77a:	c9                   	leave  
c002a77b:	c3                   	ret    

c002a77c <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c002a77c:	55                   	push   %ebp
c002a77d:	89 e5                	mov    %esp,%ebp
c002a77f:	83 ec 08             	sub    $0x8,%esp
  if (b != NULL) 
c002a782:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a786:	74 20                	je     c002a7a8 <bitmap_destroy+0x2c>
    {
      free (b->bits);
c002a788:	8b 45 08             	mov    0x8(%ebp),%eax
c002a78b:	8b 40 04             	mov    0x4(%eax),%eax
c002a78e:	83 ec 0c             	sub    $0xc,%esp
c002a791:	50                   	push   %eax
c002a792:	e8 ed 8f ff ff       	call   c0023784 <free>
c002a797:	83 c4 10             	add    $0x10,%esp
      free (b);
c002a79a:	83 ec 0c             	sub    $0xc,%esp
c002a79d:	ff 75 08             	pushl  0x8(%ebp)
c002a7a0:	e8 df 8f ff ff       	call   c0023784 <free>
c002a7a5:	83 c4 10             	add    $0x10,%esp
    }
}
c002a7a8:	90                   	nop
c002a7a9:	c9                   	leave  
c002a7aa:	c3                   	ret    

c002a7ab <bitmap_size>:
/* Bitmap size. */

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
c002a7ab:	55                   	push   %ebp
c002a7ac:	89 e5                	mov    %esp,%ebp
  return b->bit_cnt;
c002a7ae:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7b1:	8b 00                	mov    (%eax),%eax
}
c002a7b3:	5d                   	pop    %ebp
c002a7b4:	c3                   	ret    

c002a7b5 <bitmap_set>:
/* Setting and testing single bits. */

/* Atomically sets the bit numbered IDX in B to VALUE. */
void
bitmap_set (struct bitmap *b, size_t idx, bool value) 
{
c002a7b5:	55                   	push   %ebp
c002a7b6:	89 e5                	mov    %esp,%ebp
c002a7b8:	83 ec 18             	sub    $0x18,%esp
c002a7bb:	8b 45 10             	mov    0x10(%ebp),%eax
c002a7be:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002a7c1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a7c5:	75 21                	jne    c002a7e8 <bitmap_set+0x33>
c002a7c7:	83 ec 0c             	sub    $0xc,%esp
c002a7ca:	68 75 10 03 c0       	push   $0xc0031075
c002a7cf:	68 44 10 03 c0       	push   $0xc0031044
c002a7d4:	68 d8 10 03 c0       	push   $0xc00310d8
c002a7d9:	68 93 00 00 00       	push   $0x93
c002a7de:	68 5b 10 03 c0       	push   $0xc003105b
c002a7e3:	e8 49 ee ff ff       	call   c0029631 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a7e8:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7eb:	8b 00                	mov    (%eax),%eax
c002a7ed:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a7f0:	77 21                	ja     c002a813 <bitmap_set+0x5e>
c002a7f2:	83 ec 0c             	sub    $0xc,%esp
c002a7f5:	68 7f 10 03 c0       	push   $0xc003107f
c002a7fa:	68 44 10 03 c0       	push   $0xc0031044
c002a7ff:	68 d8 10 03 c0       	push   $0xc00310d8
c002a804:	68 94 00 00 00       	push   $0x94
c002a809:	68 5b 10 03 c0       	push   $0xc003105b
c002a80e:	e8 1e ee ff ff       	call   c0029631 <debug_panic>
  if (value)
c002a813:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002a817:	74 13                	je     c002a82c <bitmap_set+0x77>
    bitmap_mark (b, idx);
c002a819:	83 ec 08             	sub    $0x8,%esp
c002a81c:	ff 75 0c             	pushl  0xc(%ebp)
c002a81f:	ff 75 08             	pushl  0x8(%ebp)
c002a822:	e8 19 00 00 00       	call   c002a840 <bitmap_mark>
c002a827:	83 c4 10             	add    $0x10,%esp
  else
    bitmap_reset (b, idx);
}
c002a82a:	eb 11                	jmp    c002a83d <bitmap_set+0x88>
  ASSERT (b != NULL);
  ASSERT (idx < b->bit_cnt);
  if (value)
    bitmap_mark (b, idx);
  else
    bitmap_reset (b, idx);
c002a82c:	83 ec 08             	sub    $0x8,%esp
c002a82f:	ff 75 0c             	pushl  0xc(%ebp)
c002a832:	ff 75 08             	pushl  0x8(%ebp)
c002a835:	e8 3e 00 00 00       	call   c002a878 <bitmap_reset>
c002a83a:	83 c4 10             	add    $0x10,%esp
}
c002a83d:	90                   	nop
c002a83e:	c9                   	leave  
c002a83f:	c3                   	ret    

c002a840 <bitmap_mark>:

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002a840:	55                   	push   %ebp
c002a841:	89 e5                	mov    %esp,%ebp
c002a843:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a846:	ff 75 0c             	pushl  0xc(%ebp)
c002a849:	e8 f3 fd ff ff       	call   c002a641 <elem_idx>
c002a84e:	83 c4 04             	add    $0x4,%esp
c002a851:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a854:	ff 75 0c             	pushl  0xc(%ebp)
c002a857:	e8 f0 fd ff ff       	call   c002a64c <bit_mask>
c002a85c:	83 c4 04             	add    $0x4,%esp
c002a85f:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a862:	8b 45 08             	mov    0x8(%ebp),%eax
c002a865:	8b 40 04             	mov    0x4(%eax),%eax
c002a868:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a86b:	c1 e2 02             	shl    $0x2,%edx
c002a86e:	01 c2                	add    %eax,%edx
c002a870:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002a873:	09 02                	or     %eax,(%edx)
}
c002a875:	90                   	nop
c002a876:	c9                   	leave  
c002a877:	c3                   	ret    

c002a878 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002a878:	55                   	push   %ebp
c002a879:	89 e5                	mov    %esp,%ebp
c002a87b:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a87e:	ff 75 0c             	pushl  0xc(%ebp)
c002a881:	e8 bb fd ff ff       	call   c002a641 <elem_idx>
c002a886:	83 c4 04             	add    $0x4,%esp
c002a889:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a88c:	ff 75 0c             	pushl  0xc(%ebp)
c002a88f:	e8 b8 fd ff ff       	call   c002a64c <bit_mask>
c002a894:	83 c4 04             	add    $0x4,%esp
c002a897:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002a89a:	8b 45 08             	mov    0x8(%ebp),%eax
c002a89d:	8b 40 04             	mov    0x4(%eax),%eax
c002a8a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a8a3:	c1 e2 02             	shl    $0x2,%edx
c002a8a6:	01 d0                	add    %edx,%eax
c002a8a8:	8b 55 f8             	mov    -0x8(%ebp),%edx
c002a8ab:	f7 d2                	not    %edx
c002a8ad:	21 10                	and    %edx,(%eax)
}
c002a8af:	90                   	nop
c002a8b0:	c9                   	leave  
c002a8b1:	c3                   	ret    

c002a8b2 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002a8b2:	55                   	push   %ebp
c002a8b3:	89 e5                	mov    %esp,%ebp
c002a8b5:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a8b8:	ff 75 0c             	pushl  0xc(%ebp)
c002a8bb:	e8 81 fd ff ff       	call   c002a641 <elem_idx>
c002a8c0:	83 c4 04             	add    $0x4,%esp
c002a8c3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a8c6:	ff 75 0c             	pushl  0xc(%ebp)
c002a8c9:	e8 7e fd ff ff       	call   c002a64c <bit_mask>
c002a8ce:	83 c4 04             	add    $0x4,%esp
c002a8d1:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a8d4:	8b 45 08             	mov    0x8(%ebp),%eax
c002a8d7:	8b 40 04             	mov    0x4(%eax),%eax
c002a8da:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a8dd:	c1 e2 02             	shl    $0x2,%edx
c002a8e0:	01 c2                	add    %eax,%edx
c002a8e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002a8e5:	31 02                	xor    %eax,(%edx)
}
c002a8e7:	90                   	nop
c002a8e8:	c9                   	leave  
c002a8e9:	c3                   	ret    

c002a8ea <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002a8ea:	55                   	push   %ebp
c002a8eb:	89 e5                	mov    %esp,%ebp
c002a8ed:	53                   	push   %ebx
c002a8ee:	83 ec 04             	sub    $0x4,%esp
  ASSERT (b != NULL);
c002a8f1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a8f5:	75 21                	jne    c002a918 <bitmap_test+0x2e>
c002a8f7:	83 ec 0c             	sub    $0xc,%esp
c002a8fa:	68 75 10 03 c0       	push   $0xc0031075
c002a8ff:	68 44 10 03 c0       	push   $0xc0031044
c002a904:	68 e4 10 03 c0       	push   $0xc00310e4
c002a909:	68 c8 00 00 00       	push   $0xc8
c002a90e:	68 5b 10 03 c0       	push   $0xc003105b
c002a913:	e8 19 ed ff ff       	call   c0029631 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a918:	8b 45 08             	mov    0x8(%ebp),%eax
c002a91b:	8b 00                	mov    (%eax),%eax
c002a91d:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a920:	77 21                	ja     c002a943 <bitmap_test+0x59>
c002a922:	83 ec 0c             	sub    $0xc,%esp
c002a925:	68 7f 10 03 c0       	push   $0xc003107f
c002a92a:	68 44 10 03 c0       	push   $0xc0031044
c002a92f:	68 e4 10 03 c0       	push   $0xc00310e4
c002a934:	68 c9 00 00 00       	push   $0xc9
c002a939:	68 5b 10 03 c0       	push   $0xc003105b
c002a93e:	e8 ee ec ff ff       	call   c0029631 <debug_panic>
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002a943:	8b 45 08             	mov    0x8(%ebp),%eax
c002a946:	8b 58 04             	mov    0x4(%eax),%ebx
c002a949:	83 ec 0c             	sub    $0xc,%esp
c002a94c:	ff 75 0c             	pushl  0xc(%ebp)
c002a94f:	e8 ed fc ff ff       	call   c002a641 <elem_idx>
c002a954:	83 c4 10             	add    $0x10,%esp
c002a957:	c1 e0 02             	shl    $0x2,%eax
c002a95a:	01 d8                	add    %ebx,%eax
c002a95c:	8b 18                	mov    (%eax),%ebx
c002a95e:	83 ec 0c             	sub    $0xc,%esp
c002a961:	ff 75 0c             	pushl  0xc(%ebp)
c002a964:	e8 e3 fc ff ff       	call   c002a64c <bit_mask>
c002a969:	83 c4 10             	add    $0x10,%esp
c002a96c:	21 d8                	and    %ebx,%eax
c002a96e:	85 c0                	test   %eax,%eax
c002a970:	0f 95 c0             	setne  %al
}
c002a973:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a976:	c9                   	leave  
c002a977:	c3                   	ret    

c002a978 <bitmap_set_all>:
/* Setting and testing multiple bits. */

/* Sets all bits in B to VALUE. */
void
bitmap_set_all (struct bitmap *b, bool value) 
{
c002a978:	55                   	push   %ebp
c002a979:	89 e5                	mov    %esp,%ebp
c002a97b:	53                   	push   %ebx
c002a97c:	83 ec 14             	sub    $0x14,%esp
c002a97f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a982:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002a985:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a989:	75 21                	jne    c002a9ac <bitmap_set_all+0x34>
c002a98b:	83 ec 0c             	sub    $0xc,%esp
c002a98e:	68 75 10 03 c0       	push   $0xc0031075
c002a993:	68 44 10 03 c0       	push   $0xc0031044
c002a998:	68 f0 10 03 c0       	push   $0xc00310f0
c002a99d:	68 d3 00 00 00       	push   $0xd3
c002a9a2:	68 5b 10 03 c0       	push   $0xc003105b
c002a9a7:	e8 85 ec ff ff       	call   c0029631 <debug_panic>

  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002a9ac:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002a9b0:	83 ec 0c             	sub    $0xc,%esp
c002a9b3:	ff 75 08             	pushl  0x8(%ebp)
c002a9b6:	e8 f0 fd ff ff       	call   c002a7ab <bitmap_size>
c002a9bb:	83 c4 10             	add    $0x10,%esp
c002a9be:	53                   	push   %ebx
c002a9bf:	50                   	push   %eax
c002a9c0:	6a 00                	push   $0x0
c002a9c2:	ff 75 08             	pushl  0x8(%ebp)
c002a9c5:	e8 09 00 00 00       	call   c002a9d3 <bitmap_set_multiple>
c002a9ca:	83 c4 10             	add    $0x10,%esp
}
c002a9cd:	90                   	nop
c002a9ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a9d1:	c9                   	leave  
c002a9d2:	c3                   	ret    

c002a9d3 <bitmap_set_multiple>:

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a9d3:	55                   	push   %ebp
c002a9d4:	89 e5                	mov    %esp,%ebp
c002a9d6:	83 ec 28             	sub    $0x28,%esp
c002a9d9:	8b 45 14             	mov    0x14(%ebp),%eax
c002a9dc:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002a9df:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a9e3:	75 21                	jne    c002aa06 <bitmap_set_multiple+0x33>
c002a9e5:	83 ec 0c             	sub    $0xc,%esp
c002a9e8:	68 75 10 03 c0       	push   $0xc0031075
c002a9ed:	68 44 10 03 c0       	push   $0xc0031044
c002a9f2:	68 00 11 03 c0       	push   $0xc0031100
c002a9f7:	68 de 00 00 00       	push   $0xde
c002a9fc:	68 5b 10 03 c0       	push   $0xc003105b
c002aa01:	e8 2b ec ff ff       	call   c0029631 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002aa06:	8b 45 08             	mov    0x8(%ebp),%eax
c002aa09:	8b 00                	mov    (%eax),%eax
c002aa0b:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002aa0e:	73 21                	jae    c002aa31 <bitmap_set_multiple+0x5e>
c002aa10:	83 ec 0c             	sub    $0xc,%esp
c002aa13:	68 90 10 03 c0       	push   $0xc0031090
c002aa18:	68 44 10 03 c0       	push   $0xc0031044
c002aa1d:	68 00 11 03 c0       	push   $0xc0031100
c002aa22:	68 df 00 00 00       	push   $0xdf
c002aa27:	68 5b 10 03 c0       	push   $0xc003105b
c002aa2c:	e8 00 ec ff ff       	call   c0029631 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002aa31:	8b 55 0c             	mov    0xc(%ebp),%edx
c002aa34:	8b 45 10             	mov    0x10(%ebp),%eax
c002aa37:	01 c2                	add    %eax,%edx
c002aa39:	8b 45 08             	mov    0x8(%ebp),%eax
c002aa3c:	8b 00                	mov    (%eax),%eax
c002aa3e:	39 c2                	cmp    %eax,%edx
c002aa40:	76 21                	jbe    c002aa63 <bitmap_set_multiple+0x90>
c002aa42:	83 ec 0c             	sub    $0xc,%esp
c002aa45:	68 a4 10 03 c0       	push   $0xc00310a4
c002aa4a:	68 44 10 03 c0       	push   $0xc0031044
c002aa4f:	68 00 11 03 c0       	push   $0xc0031100
c002aa54:	68 e0 00 00 00       	push   $0xe0
c002aa59:	68 5b 10 03 c0       	push   $0xc003105b
c002aa5e:	e8 ce eb ff ff       	call   c0029631 <debug_panic>

  for (i = 0; i < cnt; i++)
c002aa63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002aa6a:	eb 20                	jmp    c002aa8c <bitmap_set_multiple+0xb9>
    bitmap_set (b, start + i, value);
c002aa6c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002aa70:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002aa73:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002aa76:	01 ca                	add    %ecx,%edx
c002aa78:	83 ec 04             	sub    $0x4,%esp
c002aa7b:	50                   	push   %eax
c002aa7c:	52                   	push   %edx
c002aa7d:	ff 75 08             	pushl  0x8(%ebp)
c002aa80:	e8 30 fd ff ff       	call   c002a7b5 <bitmap_set>
c002aa85:	83 c4 10             	add    $0x10,%esp
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  for (i = 0; i < cnt; i++)
c002aa88:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002aa8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aa8f:	3b 45 10             	cmp    0x10(%ebp),%eax
c002aa92:	72 d8                	jb     c002aa6c <bitmap_set_multiple+0x99>
    bitmap_set (b, start + i, value);
}
c002aa94:	90                   	nop
c002aa95:	c9                   	leave  
c002aa96:	c3                   	ret    

c002aa97 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002aa97:	55                   	push   %ebp
c002aa98:	89 e5                	mov    %esp,%ebp
c002aa9a:	83 ec 28             	sub    $0x28,%esp
c002aa9d:	8b 45 14             	mov    0x14(%ebp),%eax
c002aaa0:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002aaa3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aaa7:	75 21                	jne    c002aaca <bitmap_count+0x33>
c002aaa9:	83 ec 0c             	sub    $0xc,%esp
c002aaac:	68 75 10 03 c0       	push   $0xc0031075
c002aab1:	68 44 10 03 c0       	push   $0xc0031044
c002aab6:	68 14 11 03 c0       	push   $0xc0031114
c002aabb:	68 ed 00 00 00       	push   $0xed
c002aac0:	68 5b 10 03 c0       	push   $0xc003105b
c002aac5:	e8 67 eb ff ff       	call   c0029631 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002aaca:	8b 45 08             	mov    0x8(%ebp),%eax
c002aacd:	8b 00                	mov    (%eax),%eax
c002aacf:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002aad2:	73 21                	jae    c002aaf5 <bitmap_count+0x5e>
c002aad4:	83 ec 0c             	sub    $0xc,%esp
c002aad7:	68 90 10 03 c0       	push   $0xc0031090
c002aadc:	68 44 10 03 c0       	push   $0xc0031044
c002aae1:	68 14 11 03 c0       	push   $0xc0031114
c002aae6:	68 ee 00 00 00       	push   $0xee
c002aaeb:	68 5b 10 03 c0       	push   $0xc003105b
c002aaf0:	e8 3c eb ff ff       	call   c0029631 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002aaf5:	8b 55 0c             	mov    0xc(%ebp),%edx
c002aaf8:	8b 45 10             	mov    0x10(%ebp),%eax
c002aafb:	01 c2                	add    %eax,%edx
c002aafd:	8b 45 08             	mov    0x8(%ebp),%eax
c002ab00:	8b 00                	mov    (%eax),%eax
c002ab02:	39 c2                	cmp    %eax,%edx
c002ab04:	76 21                	jbe    c002ab27 <bitmap_count+0x90>
c002ab06:	83 ec 0c             	sub    $0xc,%esp
c002ab09:	68 a4 10 03 c0       	push   $0xc00310a4
c002ab0e:	68 44 10 03 c0       	push   $0xc0031044
c002ab13:	68 14 11 03 c0       	push   $0xc0031114
c002ab18:	68 ef 00 00 00       	push   $0xef
c002ab1d:	68 5b 10 03 c0       	push   $0xc003105b
c002ab22:	e8 0a eb ff ff       	call   c0029631 <debug_panic>

  value_cnt = 0;
c002ab27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002ab2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ab35:	eb 24                	jmp    c002ab5b <bitmap_count+0xc4>
    if (bitmap_test (b, start + i) == value)
c002ab37:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ab3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ab3d:	01 d0                	add    %edx,%eax
c002ab3f:	83 ec 08             	sub    $0x8,%esp
c002ab42:	50                   	push   %eax
c002ab43:	ff 75 08             	pushl  0x8(%ebp)
c002ab46:	e8 9f fd ff ff       	call   c002a8ea <bitmap_test>
c002ab4b:	83 c4 10             	add    $0x10,%esp
c002ab4e:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002ab51:	75 04                	jne    c002ab57 <bitmap_count+0xc0>
      value_cnt++;
c002ab53:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  value_cnt = 0;
  for (i = 0; i < cnt; i++)
c002ab57:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002ab5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ab5e:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ab61:	72 d4                	jb     c002ab37 <bitmap_count+0xa0>
    if (bitmap_test (b, start + i) == value)
      value_cnt++;
  return value_cnt;
c002ab63:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002ab66:	c9                   	leave  
c002ab67:	c3                   	ret    

c002ab68 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002ab68:	55                   	push   %ebp
c002ab69:	89 e5                	mov    %esp,%ebp
c002ab6b:	83 ec 28             	sub    $0x28,%esp
c002ab6e:	8b 45 14             	mov    0x14(%ebp),%eax
c002ab71:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002ab74:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ab78:	75 21                	jne    c002ab9b <bitmap_contains+0x33>
c002ab7a:	83 ec 0c             	sub    $0xc,%esp
c002ab7d:	68 75 10 03 c0       	push   $0xc0031075
c002ab82:	68 44 10 03 c0       	push   $0xc0031044
c002ab87:	68 24 11 03 c0       	push   $0xc0031124
c002ab8c:	68 ff 00 00 00       	push   $0xff
c002ab91:	68 5b 10 03 c0       	push   $0xc003105b
c002ab96:	e8 96 ea ff ff       	call   c0029631 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002ab9b:	8b 45 08             	mov    0x8(%ebp),%eax
c002ab9e:	8b 00                	mov    (%eax),%eax
c002aba0:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002aba3:	73 21                	jae    c002abc6 <bitmap_contains+0x5e>
c002aba5:	83 ec 0c             	sub    $0xc,%esp
c002aba8:	68 90 10 03 c0       	push   $0xc0031090
c002abad:	68 44 10 03 c0       	push   $0xc0031044
c002abb2:	68 24 11 03 c0       	push   $0xc0031124
c002abb7:	68 00 01 00 00       	push   $0x100
c002abbc:	68 5b 10 03 c0       	push   $0xc003105b
c002abc1:	e8 6b ea ff ff       	call   c0029631 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002abc6:	8b 55 0c             	mov    0xc(%ebp),%edx
c002abc9:	8b 45 10             	mov    0x10(%ebp),%eax
c002abcc:	01 c2                	add    %eax,%edx
c002abce:	8b 45 08             	mov    0x8(%ebp),%eax
c002abd1:	8b 00                	mov    (%eax),%eax
c002abd3:	39 c2                	cmp    %eax,%edx
c002abd5:	76 21                	jbe    c002abf8 <bitmap_contains+0x90>
c002abd7:	83 ec 0c             	sub    $0xc,%esp
c002abda:	68 a4 10 03 c0       	push   $0xc00310a4
c002abdf:	68 44 10 03 c0       	push   $0xc0031044
c002abe4:	68 24 11 03 c0       	push   $0xc0031124
c002abe9:	68 01 01 00 00       	push   $0x101
c002abee:	68 5b 10 03 c0       	push   $0xc003105b
c002abf3:	e8 39 ea ff ff       	call   c0029631 <debug_panic>

  for (i = 0; i < cnt; i++)
c002abf8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002abff:	eb 27                	jmp    c002ac28 <bitmap_contains+0xc0>
    if (bitmap_test (b, start + i) == value)
c002ac01:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ac04:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac07:	01 d0                	add    %edx,%eax
c002ac09:	83 ec 08             	sub    $0x8,%esp
c002ac0c:	50                   	push   %eax
c002ac0d:	ff 75 08             	pushl  0x8(%ebp)
c002ac10:	e8 d5 fc ff ff       	call   c002a8ea <bitmap_test>
c002ac15:	83 c4 10             	add    $0x10,%esp
c002ac18:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002ac1b:	75 07                	jne    c002ac24 <bitmap_contains+0xbc>
      return true;
c002ac1d:	b8 01 00 00 00       	mov    $0x1,%eax
c002ac22:	eb 11                	jmp    c002ac35 <bitmap_contains+0xcd>
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  for (i = 0; i < cnt; i++)
c002ac24:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002ac28:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac2b:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ac2e:	72 d1                	jb     c002ac01 <bitmap_contains+0x99>
    if (bitmap_test (b, start + i) == value)
      return true;
  return false;
c002ac30:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002ac35:	c9                   	leave  
c002ac36:	c3                   	ret    

c002ac37 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ac37:	55                   	push   %ebp
c002ac38:	89 e5                	mov    %esp,%ebp
c002ac3a:	83 ec 08             	sub    $0x8,%esp
  return bitmap_contains (b, start, cnt, true);
c002ac3d:	6a 01                	push   $0x1
c002ac3f:	ff 75 10             	pushl  0x10(%ebp)
c002ac42:	ff 75 0c             	pushl  0xc(%ebp)
c002ac45:	ff 75 08             	pushl  0x8(%ebp)
c002ac48:	e8 1b ff ff ff       	call   c002ab68 <bitmap_contains>
c002ac4d:	83 c4 10             	add    $0x10,%esp
}
c002ac50:	c9                   	leave  
c002ac51:	c3                   	ret    

c002ac52 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ac52:	55                   	push   %ebp
c002ac53:	89 e5                	mov    %esp,%ebp
c002ac55:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, true);
c002ac58:	6a 01                	push   $0x1
c002ac5a:	ff 75 10             	pushl  0x10(%ebp)
c002ac5d:	ff 75 0c             	pushl  0xc(%ebp)
c002ac60:	ff 75 08             	pushl  0x8(%ebp)
c002ac63:	e8 00 ff ff ff       	call   c002ab68 <bitmap_contains>
c002ac68:	83 c4 10             	add    $0x10,%esp
c002ac6b:	0f b6 c0             	movzbl %al,%eax
c002ac6e:	85 c0                	test   %eax,%eax
c002ac70:	0f 95 c0             	setne  %al
c002ac73:	83 f0 01             	xor    $0x1,%eax
c002ac76:	0f b6 c0             	movzbl %al,%eax
c002ac79:	83 e0 01             	and    $0x1,%eax
}
c002ac7c:	c9                   	leave  
c002ac7d:	c3                   	ret    

c002ac7e <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ac7e:	55                   	push   %ebp
c002ac7f:	89 e5                	mov    %esp,%ebp
c002ac81:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, false);
c002ac84:	6a 00                	push   $0x0
c002ac86:	ff 75 10             	pushl  0x10(%ebp)
c002ac89:	ff 75 0c             	pushl  0xc(%ebp)
c002ac8c:	ff 75 08             	pushl  0x8(%ebp)
c002ac8f:	e8 d4 fe ff ff       	call   c002ab68 <bitmap_contains>
c002ac94:	83 c4 10             	add    $0x10,%esp
c002ac97:	0f b6 c0             	movzbl %al,%eax
c002ac9a:	85 c0                	test   %eax,%eax
c002ac9c:	0f 95 c0             	setne  %al
c002ac9f:	83 f0 01             	xor    $0x1,%eax
c002aca2:	0f b6 c0             	movzbl %al,%eax
c002aca5:	83 e0 01             	and    $0x1,%eax
}
c002aca8:	c9                   	leave  
c002aca9:	c3                   	ret    

c002acaa <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002acaa:	55                   	push   %ebp
c002acab:	89 e5                	mov    %esp,%ebp
c002acad:	83 ec 28             	sub    $0x28,%esp
c002acb0:	8b 45 14             	mov    0x14(%ebp),%eax
c002acb3:	88 45 e4             	mov    %al,-0x1c(%ebp)
  ASSERT (b != NULL);
c002acb6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002acba:	75 21                	jne    c002acdd <bitmap_scan+0x33>
c002acbc:	83 ec 0c             	sub    $0xc,%esp
c002acbf:	68 75 10 03 c0       	push   $0xc0031075
c002acc4:	68 44 10 03 c0       	push   $0xc0031044
c002acc9:	68 34 11 03 c0       	push   $0xc0031134
c002acce:	68 2a 01 00 00       	push   $0x12a
c002acd3:	68 5b 10 03 c0       	push   $0xc003105b
c002acd8:	e8 54 e9 ff ff       	call   c0029631 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002acdd:	8b 45 08             	mov    0x8(%ebp),%eax
c002ace0:	8b 00                	mov    (%eax),%eax
c002ace2:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002ace5:	73 21                	jae    c002ad08 <bitmap_scan+0x5e>
c002ace7:	83 ec 0c             	sub    $0xc,%esp
c002acea:	68 90 10 03 c0       	push   $0xc0031090
c002acef:	68 44 10 03 c0       	push   $0xc0031044
c002acf4:	68 34 11 03 c0       	push   $0xc0031134
c002acf9:	68 2b 01 00 00       	push   $0x12b
c002acfe:	68 5b 10 03 c0       	push   $0xc003105b
c002ad03:	e8 29 e9 ff ff       	call   c0029631 <debug_panic>

  if (cnt <= b->bit_cnt) 
c002ad08:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad0b:	8b 00                	mov    (%eax),%eax
c002ad0d:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ad10:	72 47                	jb     c002ad59 <bitmap_scan+0xaf>
    {
      size_t last = b->bit_cnt - cnt;
c002ad12:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad15:	8b 00                	mov    (%eax),%eax
c002ad17:	2b 45 10             	sub    0x10(%ebp),%eax
c002ad1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t i;
      for (i = start; i <= last; i++)
c002ad1d:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ad20:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002ad23:	eb 2c                	jmp    c002ad51 <bitmap_scan+0xa7>
        if (!bitmap_contains (b, i, cnt, !value))
c002ad25:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ad29:	83 f0 01             	xor    $0x1,%eax
c002ad2c:	0f b6 c0             	movzbl %al,%eax
c002ad2f:	50                   	push   %eax
c002ad30:	ff 75 10             	pushl  0x10(%ebp)
c002ad33:	ff 75 f4             	pushl  -0xc(%ebp)
c002ad36:	ff 75 08             	pushl  0x8(%ebp)
c002ad39:	e8 2a fe ff ff       	call   c002ab68 <bitmap_contains>
c002ad3e:	83 c4 10             	add    $0x10,%esp
c002ad41:	83 f0 01             	xor    $0x1,%eax
c002ad44:	84 c0                	test   %al,%al
c002ad46:	74 05                	je     c002ad4d <bitmap_scan+0xa3>
          return i; 
c002ad48:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ad4b:	eb 11                	jmp    c002ad5e <bitmap_scan+0xb4>

  if (cnt <= b->bit_cnt) 
    {
      size_t last = b->bit_cnt - cnt;
      size_t i;
      for (i = start; i <= last; i++)
c002ad4d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002ad51:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ad54:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002ad57:	76 cc                	jbe    c002ad25 <bitmap_scan+0x7b>
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c002ad59:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002ad5e:	c9                   	leave  
c002ad5f:	c3                   	ret    

c002ad60 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002ad60:	55                   	push   %ebp
c002ad61:	89 e5                	mov    %esp,%ebp
c002ad63:	83 ec 28             	sub    $0x28,%esp
c002ad66:	8b 45 14             	mov    0x14(%ebp),%eax
c002ad69:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t idx = bitmap_scan (b, start, cnt, value);
c002ad6c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ad70:	50                   	push   %eax
c002ad71:	ff 75 10             	pushl  0x10(%ebp)
c002ad74:	ff 75 0c             	pushl  0xc(%ebp)
c002ad77:	ff 75 08             	pushl  0x8(%ebp)
c002ad7a:	e8 2b ff ff ff       	call   c002acaa <bitmap_scan>
c002ad7f:	83 c4 10             	add    $0x10,%esp
c002ad82:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (idx != BITMAP_ERROR) 
c002ad85:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002ad89:	74 1c                	je     c002ada7 <bitmap_scan_and_flip+0x47>
    bitmap_set_multiple (b, idx, cnt, !value);
c002ad8b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ad8f:	83 f0 01             	xor    $0x1,%eax
c002ad92:	0f b6 c0             	movzbl %al,%eax
c002ad95:	50                   	push   %eax
c002ad96:	ff 75 10             	pushl  0x10(%ebp)
c002ad99:	ff 75 f4             	pushl  -0xc(%ebp)
c002ad9c:	ff 75 08             	pushl  0x8(%ebp)
c002ad9f:	e8 2f fc ff ff       	call   c002a9d3 <bitmap_set_multiple>
c002ada4:	83 c4 10             	add    $0x10,%esp
  return idx;
c002ada7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002adaa:	c9                   	leave  
c002adab:	c3                   	ret    

c002adac <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002adac:	55                   	push   %ebp
c002adad:	89 e5                	mov    %esp,%ebp
c002adaf:	83 ec 08             	sub    $0x8,%esp
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002adb2:	8b 45 08             	mov    0x8(%ebp),%eax
c002adb5:	8b 00                	mov    (%eax),%eax
c002adb7:	50                   	push   %eax
c002adb8:	e8 b3 f8 ff ff       	call   c002a670 <byte_cnt>
c002adbd:	83 c4 04             	add    $0x4,%esp
c002adc0:	89 c2                	mov    %eax,%edx
c002adc2:	8b 45 08             	mov    0x8(%ebp),%eax
c002adc5:	8b 40 04             	mov    0x4(%eax),%eax
c002adc8:	6a 00                	push   $0x0
c002adca:	52                   	push   %edx
c002adcb:	50                   	push   %eax
c002adcc:	6a 00                	push   $0x0
c002adce:	e8 66 cf ff ff       	call   c0027d39 <hex_dump>
c002add3:	83 c4 10             	add    $0x10,%esp
}
c002add6:	90                   	nop
c002add7:	c9                   	leave  
c002add8:	c3                   	ret    

c002add9 <hash_init>:
/* Initializes hash table H to compute hash values using HASH and
   compare hash elements using LESS, given auxiliary data AUX. */
bool
hash_init (struct hash *h,
           hash_hash_func *hash, hash_less_func *less, void *aux) 
{
c002add9:	55                   	push   %ebp
c002adda:	89 e5                	mov    %esp,%ebp
c002addc:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt = 0;
c002addf:	8b 45 08             	mov    0x8(%ebp),%eax
c002ade2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  h->bucket_cnt = 4;
c002ade8:	8b 45 08             	mov    0x8(%ebp),%eax
c002adeb:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002adf2:	8b 45 08             	mov    0x8(%ebp),%eax
c002adf5:	8b 40 04             	mov    0x4(%eax),%eax
c002adf8:	c1 e0 04             	shl    $0x4,%eax
c002adfb:	83 ec 0c             	sub    $0xc,%esp
c002adfe:	50                   	push   %eax
c002adff:	e8 87 86 ff ff       	call   c002348b <malloc>
c002ae04:	83 c4 10             	add    $0x10,%esp
c002ae07:	89 c2                	mov    %eax,%edx
c002ae09:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae0c:	89 50 08             	mov    %edx,0x8(%eax)
  h->hash = hash;
c002ae0f:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae12:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ae15:	89 50 0c             	mov    %edx,0xc(%eax)
  h->less = less;
c002ae18:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae1b:	8b 55 10             	mov    0x10(%ebp),%edx
c002ae1e:	89 50 10             	mov    %edx,0x10(%eax)
  h->aux = aux;
c002ae21:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae24:	8b 55 14             	mov    0x14(%ebp),%edx
c002ae27:	89 50 14             	mov    %edx,0x14(%eax)

  if (h->buckets != NULL) 
c002ae2a:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae2d:	8b 40 08             	mov    0x8(%eax),%eax
c002ae30:	85 c0                	test   %eax,%eax
c002ae32:	74 17                	je     c002ae4b <hash_init+0x72>
    {
      hash_clear (h, NULL);
c002ae34:	83 ec 08             	sub    $0x8,%esp
c002ae37:	6a 00                	push   $0x0
c002ae39:	ff 75 08             	pushl  0x8(%ebp)
c002ae3c:	e8 11 00 00 00       	call   c002ae52 <hash_clear>
c002ae41:	83 c4 10             	add    $0x10,%esp
      return true;
c002ae44:	b8 01 00 00 00       	mov    $0x1,%eax
c002ae49:	eb 05                	jmp    c002ae50 <hash_init+0x77>
    }
  else
    return false;
c002ae4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002ae50:	c9                   	leave  
c002ae51:	c3                   	ret    

c002ae52 <hash_clear>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), yields undefined behavior,
   whether done in DESTRUCTOR or elsewhere. */
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
c002ae52:	55                   	push   %ebp
c002ae53:	89 e5                	mov    %esp,%ebp
c002ae55:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002ae58:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ae5f:	eb 72                	jmp    c002aed3 <hash_clear+0x81>
    {
      struct list *bucket = &h->buckets[i];
c002ae61:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae64:	8b 40 08             	mov    0x8(%eax),%eax
c002ae67:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002ae6a:	c1 e2 04             	shl    $0x4,%edx
c002ae6d:	01 d0                	add    %edx,%eax
c002ae6f:	89 45 f0             	mov    %eax,-0x10(%ebp)

      if (destructor != NULL) 
c002ae72:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ae76:	74 49                	je     c002aec1 <hash_clear+0x6f>
        while (!list_empty (bucket)) 
c002ae78:	eb 32                	jmp    c002aeac <hash_clear+0x5a>
          {
            struct list_elem *list_elem = list_pop_front (bucket);
c002ae7a:	83 ec 0c             	sub    $0xc,%esp
c002ae7d:	ff 75 f0             	pushl  -0x10(%ebp)
c002ae80:	e8 7e ee ff ff       	call   c0029d03 <list_pop_front>
c002ae85:	83 c4 10             	add    $0x10,%esp
c002ae88:	89 45 ec             	mov    %eax,-0x14(%ebp)
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
c002ae8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ae8e:	83 c0 04             	add    $0x4,%eax
c002ae91:	83 e8 04             	sub    $0x4,%eax
c002ae94:	89 45 e8             	mov    %eax,-0x18(%ebp)
            destructor (hash_elem, h->aux);
c002ae97:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae9a:	8b 40 14             	mov    0x14(%eax),%eax
c002ae9d:	83 ec 08             	sub    $0x8,%esp
c002aea0:	50                   	push   %eax
c002aea1:	ff 75 e8             	pushl  -0x18(%ebp)
c002aea4:	8b 45 0c             	mov    0xc(%ebp),%eax
c002aea7:	ff d0                	call   *%eax
c002aea9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
    {
      struct list *bucket = &h->buckets[i];

      if (destructor != NULL) 
        while (!list_empty (bucket)) 
c002aeac:	83 ec 0c             	sub    $0xc,%esp
c002aeaf:	ff 75 f0             	pushl  -0x10(%ebp)
c002aeb2:	e8 75 ef ff ff       	call   c0029e2c <list_empty>
c002aeb7:	83 c4 10             	add    $0x10,%esp
c002aeba:	83 f0 01             	xor    $0x1,%eax
c002aebd:	84 c0                	test   %al,%al
c002aebf:	75 b9                	jne    c002ae7a <hash_clear+0x28>
            struct list_elem *list_elem = list_pop_front (bucket);
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
            destructor (hash_elem, h->aux);
          }

      list_init (bucket); 
c002aec1:	83 ec 0c             	sub    $0xc,%esp
c002aec4:	ff 75 f0             	pushl  -0x10(%ebp)
c002aec7:	e8 d8 e9 ff ff       	call   c00298a4 <list_init>
c002aecc:	83 c4 10             	add    $0x10,%esp
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002aecf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002aed3:	8b 45 08             	mov    0x8(%ebp),%eax
c002aed6:	8b 40 04             	mov    0x4(%eax),%eax
c002aed9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002aedc:	77 83                	ja     c002ae61 <hash_clear+0xf>
          }

      list_init (bucket); 
    }    

  h->elem_cnt = 0;
c002aede:	8b 45 08             	mov    0x8(%ebp),%eax
c002aee1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c002aee7:	90                   	nop
c002aee8:	c9                   	leave  
c002aee9:	c3                   	ret    

c002aeea <hash_destroy>:
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done in DESTRUCTOR or
   elsewhere. */
void
hash_destroy (struct hash *h, hash_action_func *destructor) 
{
c002aeea:	55                   	push   %ebp
c002aeeb:	89 e5                	mov    %esp,%ebp
c002aeed:	83 ec 08             	sub    $0x8,%esp
  if (destructor != NULL)
c002aef0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002aef4:	74 11                	je     c002af07 <hash_destroy+0x1d>
    hash_clear (h, destructor);
c002aef6:	83 ec 08             	sub    $0x8,%esp
c002aef9:	ff 75 0c             	pushl  0xc(%ebp)
c002aefc:	ff 75 08             	pushl  0x8(%ebp)
c002aeff:	e8 4e ff ff ff       	call   c002ae52 <hash_clear>
c002af04:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002af07:	8b 45 08             	mov    0x8(%ebp),%eax
c002af0a:	8b 40 08             	mov    0x8(%eax),%eax
c002af0d:	83 ec 0c             	sub    $0xc,%esp
c002af10:	50                   	push   %eax
c002af11:	e8 6e 88 ff ff       	call   c0023784 <free>
c002af16:	83 c4 10             	add    $0x10,%esp
}
c002af19:	90                   	nop
c002af1a:	c9                   	leave  
c002af1b:	c3                   	ret    

c002af1c <hash_insert>:
   no equal element is already in the table.
   If an equal element is already in the table, returns it
   without inserting NEW. */   
struct hash_elem *
hash_insert (struct hash *h, struct hash_elem *new)
{
c002af1c:	55                   	push   %ebp
c002af1d:	89 e5                	mov    %esp,%ebp
c002af1f:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002af22:	83 ec 08             	sub    $0x8,%esp
c002af25:	ff 75 0c             	pushl  0xc(%ebp)
c002af28:	ff 75 08             	pushl  0x8(%ebp)
c002af2b:	e8 5a 04 00 00       	call   c002b38a <find_bucket>
c002af30:	83 c4 10             	add    $0x10,%esp
c002af33:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002af36:	83 ec 04             	sub    $0x4,%esp
c002af39:	ff 75 0c             	pushl  0xc(%ebp)
c002af3c:	ff 75 f4             	pushl  -0xc(%ebp)
c002af3f:	ff 75 08             	pushl  0x8(%ebp)
c002af42:	e8 81 04 00 00       	call   c002b3c8 <find_elem>
c002af47:	83 c4 10             	add    $0x10,%esp
c002af4a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old == NULL) 
c002af4d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002af51:	75 14                	jne    c002af67 <hash_insert+0x4b>
    insert_elem (h, bucket, new);
c002af53:	83 ec 04             	sub    $0x4,%esp
c002af56:	ff 75 0c             	pushl  0xc(%ebp)
c002af59:	ff 75 f4             	pushl  -0xc(%ebp)
c002af5c:	ff 75 08             	pushl  0x8(%ebp)
c002af5f:	e8 d0 06 00 00       	call   c002b634 <insert_elem>
c002af64:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002af67:	83 ec 0c             	sub    $0xc,%esp
c002af6a:	ff 75 08             	pushl  0x8(%ebp)
c002af6d:	e8 23 05 00 00       	call   c002b495 <rehash>
c002af72:	83 c4 10             	add    $0x10,%esp

  return old; 
c002af75:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002af78:	c9                   	leave  
c002af79:	c3                   	ret    

c002af7a <hash_replace>:

/* Inserts NEW into hash table H, replacing any equal element
   already in the table, which is returned. */
struct hash_elem *
hash_replace (struct hash *h, struct hash_elem *new) 
{
c002af7a:	55                   	push   %ebp
c002af7b:	89 e5                	mov    %esp,%ebp
c002af7d:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002af80:	83 ec 08             	sub    $0x8,%esp
c002af83:	ff 75 0c             	pushl  0xc(%ebp)
c002af86:	ff 75 08             	pushl  0x8(%ebp)
c002af89:	e8 fc 03 00 00       	call   c002b38a <find_bucket>
c002af8e:	83 c4 10             	add    $0x10,%esp
c002af91:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002af94:	83 ec 04             	sub    $0x4,%esp
c002af97:	ff 75 0c             	pushl  0xc(%ebp)
c002af9a:	ff 75 f4             	pushl  -0xc(%ebp)
c002af9d:	ff 75 08             	pushl  0x8(%ebp)
c002afa0:	e8 23 04 00 00       	call   c002b3c8 <find_elem>
c002afa5:	83 c4 10             	add    $0x10,%esp
c002afa8:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old != NULL)
c002afab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002afaf:	74 11                	je     c002afc2 <hash_replace+0x48>
    remove_elem (h, old);
c002afb1:	83 ec 08             	sub    $0x8,%esp
c002afb4:	ff 75 f0             	pushl  -0x10(%ebp)
c002afb7:	ff 75 08             	pushl  0x8(%ebp)
c002afba:	e8 9d 06 00 00       	call   c002b65c <remove_elem>
c002afbf:	83 c4 10             	add    $0x10,%esp
  insert_elem (h, bucket, new);
c002afc2:	83 ec 04             	sub    $0x4,%esp
c002afc5:	ff 75 0c             	pushl  0xc(%ebp)
c002afc8:	ff 75 f4             	pushl  -0xc(%ebp)
c002afcb:	ff 75 08             	pushl  0x8(%ebp)
c002afce:	e8 61 06 00 00       	call   c002b634 <insert_elem>
c002afd3:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002afd6:	83 ec 0c             	sub    $0xc,%esp
c002afd9:	ff 75 08             	pushl  0x8(%ebp)
c002afdc:	e8 b4 04 00 00       	call   c002b495 <rehash>
c002afe1:	83 c4 10             	add    $0x10,%esp

  return old;
c002afe4:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002afe7:	c9                   	leave  
c002afe8:	c3                   	ret    

c002afe9 <hash_find>:

/* Finds and returns an element equal to E in hash table H, or a
   null pointer if no equal element exists in the table. */
struct hash_elem *
hash_find (struct hash *h, struct hash_elem *e) 
{
c002afe9:	55                   	push   %ebp
c002afea:	89 e5                	mov    %esp,%ebp
c002afec:	83 ec 08             	sub    $0x8,%esp
  return find_elem (h, find_bucket (h, e), e);
c002afef:	83 ec 08             	sub    $0x8,%esp
c002aff2:	ff 75 0c             	pushl  0xc(%ebp)
c002aff5:	ff 75 08             	pushl  0x8(%ebp)
c002aff8:	e8 8d 03 00 00       	call   c002b38a <find_bucket>
c002affd:	83 c4 10             	add    $0x10,%esp
c002b000:	83 ec 04             	sub    $0x4,%esp
c002b003:	ff 75 0c             	pushl  0xc(%ebp)
c002b006:	50                   	push   %eax
c002b007:	ff 75 08             	pushl  0x8(%ebp)
c002b00a:	e8 b9 03 00 00       	call   c002b3c8 <find_elem>
c002b00f:	83 c4 10             	add    $0x10,%esp
}
c002b012:	c9                   	leave  
c002b013:	c3                   	ret    

c002b014 <hash_delete>:
   If the elements of the hash table are dynamically allocated,
   or own resources that are, then it is the caller's
   responsibility to deallocate them. */
struct hash_elem *
hash_delete (struct hash *h, struct hash_elem *e)
{
c002b014:	55                   	push   %ebp
c002b015:	89 e5                	mov    %esp,%ebp
c002b017:	83 ec 18             	sub    $0x18,%esp
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002b01a:	83 ec 08             	sub    $0x8,%esp
c002b01d:	ff 75 0c             	pushl  0xc(%ebp)
c002b020:	ff 75 08             	pushl  0x8(%ebp)
c002b023:	e8 62 03 00 00       	call   c002b38a <find_bucket>
c002b028:	83 c4 10             	add    $0x10,%esp
c002b02b:	83 ec 04             	sub    $0x4,%esp
c002b02e:	ff 75 0c             	pushl  0xc(%ebp)
c002b031:	50                   	push   %eax
c002b032:	ff 75 08             	pushl  0x8(%ebp)
c002b035:	e8 8e 03 00 00       	call   c002b3c8 <find_elem>
c002b03a:	83 c4 10             	add    $0x10,%esp
c002b03d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (found != NULL) 
c002b040:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b044:	74 1f                	je     c002b065 <hash_delete+0x51>
    {
      remove_elem (h, found);
c002b046:	83 ec 08             	sub    $0x8,%esp
c002b049:	ff 75 f4             	pushl  -0xc(%ebp)
c002b04c:	ff 75 08             	pushl  0x8(%ebp)
c002b04f:	e8 08 06 00 00       	call   c002b65c <remove_elem>
c002b054:	83 c4 10             	add    $0x10,%esp
      rehash (h); 
c002b057:	83 ec 0c             	sub    $0xc,%esp
c002b05a:	ff 75 08             	pushl  0x8(%ebp)
c002b05d:	e8 33 04 00 00       	call   c002b495 <rehash>
c002b062:	83 c4 10             	add    $0x10,%esp
    }
  return found;
c002b065:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b068:	c9                   	leave  
c002b069:	c3                   	ret    

c002b06a <hash_apply>:
   any of the functions hash_clear(), hash_destroy(),
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done from ACTION or elsewhere. */
void
hash_apply (struct hash *h, hash_action_func *action) 
{
c002b06a:	55                   	push   %ebp
c002b06b:	89 e5                	mov    %esp,%ebp
c002b06d:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  
  ASSERT (action != NULL);
c002b070:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b074:	75 21                	jne    c002b097 <hash_apply+0x2d>
c002b076:	83 ec 0c             	sub    $0xc,%esp
c002b079:	68 40 11 03 c0       	push   $0xc0031140
c002b07e:	68 4f 11 03 c0       	push   $0xc003114f
c002b083:	68 a8 11 03 c0       	push   $0xc00311a8
c002b088:	68 a7 00 00 00       	push   $0xa7
c002b08d:	68 66 11 03 c0       	push   $0xc0031166
c002b092:	e8 9a e5 ff ff       	call   c0029631 <debug_panic>

  for (i = 0; i < h->bucket_cnt; i++) 
c002b097:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b09e:	eb 6e                	jmp    c002b10e <hash_apply+0xa4>
    {
      struct list *bucket = &h->buckets[i];
c002b0a0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0a3:	8b 40 08             	mov    0x8(%eax),%eax
c002b0a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b0a9:	c1 e2 04             	shl    $0x4,%edx
c002b0ac:	01 d0                	add    %edx,%eax
c002b0ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002b0b1:	83 ec 0c             	sub    $0xc,%esp
c002b0b4:	ff 75 ec             	pushl  -0x14(%ebp)
c002b0b7:	e8 3d e8 ff ff       	call   c00298f9 <list_begin>
c002b0bc:	83 c4 10             	add    $0x10,%esp
c002b0bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b0c2:	eb 33                	jmp    c002b0f7 <hash_apply+0x8d>
        {
          next = list_next (elem);
c002b0c4:	83 ec 0c             	sub    $0xc,%esp
c002b0c7:	ff 75 f0             	pushl  -0x10(%ebp)
c002b0ca:	e8 5c e8 ff ff       	call   c002992b <list_next>
c002b0cf:	83 c4 10             	add    $0x10,%esp
c002b0d2:	89 45 e8             	mov    %eax,-0x18(%ebp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002b0d5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0d8:	8b 40 14             	mov    0x14(%eax),%eax
c002b0db:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b0de:	83 c2 04             	add    $0x4,%edx
c002b0e1:	83 ea 04             	sub    $0x4,%edx
c002b0e4:	83 ec 08             	sub    $0x8,%esp
c002b0e7:	50                   	push   %eax
c002b0e8:	52                   	push   %edx
c002b0e9:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b0ec:	ff d0                	call   *%eax
c002b0ee:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
    {
      struct list *bucket = &h->buckets[i];
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002b0f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b0f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b0f7:	83 ec 0c             	sub    $0xc,%esp
c002b0fa:	ff 75 ec             	pushl  -0x14(%ebp)
c002b0fd:	e8 73 e8 ff ff       	call   c0029975 <list_end>
c002b102:	83 c4 10             	add    $0x10,%esp
c002b105:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b108:	75 ba                	jne    c002b0c4 <hash_apply+0x5a>
{
  size_t i;
  
  ASSERT (action != NULL);

  for (i = 0; i < h->bucket_cnt; i++) 
c002b10a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002b10e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b111:	8b 40 04             	mov    0x4(%eax),%eax
c002b114:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b117:	77 87                	ja     c002b0a0 <hash_apply+0x36>
        {
          next = list_next (elem);
          action (list_elem_to_hash_elem (elem), h->aux);
        }
    }
}
c002b119:	90                   	nop
c002b11a:	c9                   	leave  
c002b11b:	c3                   	ret    

c002b11c <hash_first>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
void
hash_first (struct hash_iterator *i, struct hash *h) 
{
c002b11c:	55                   	push   %ebp
c002b11d:	89 e5                	mov    %esp,%ebp
c002b11f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (i != NULL);
c002b122:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b126:	75 21                	jne    c002b149 <hash_first+0x2d>
c002b128:	83 ec 0c             	sub    $0xc,%esp
c002b12b:	68 7e 11 03 c0       	push   $0xc003117e
c002b130:	68 4f 11 03 c0       	push   $0xc003114f
c002b135:	68 b4 11 03 c0       	push   $0xc00311b4
c002b13a:	68 ca 00 00 00       	push   $0xca
c002b13f:	68 66 11 03 c0       	push   $0xc0031166
c002b144:	e8 e8 e4 ff ff       	call   c0029631 <debug_panic>
  ASSERT (h != NULL);
c002b149:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b14d:	75 21                	jne    c002b170 <hash_first+0x54>
c002b14f:	83 ec 0c             	sub    $0xc,%esp
c002b152:	68 88 11 03 c0       	push   $0xc0031188
c002b157:	68 4f 11 03 c0       	push   $0xc003114f
c002b15c:	68 b4 11 03 c0       	push   $0xc00311b4
c002b161:	68 cb 00 00 00       	push   $0xcb
c002b166:	68 66 11 03 c0       	push   $0xc0031166
c002b16b:	e8 c1 e4 ff ff       	call   c0029631 <debug_panic>

  i->hash = h;
c002b170:	8b 45 08             	mov    0x8(%ebp),%eax
c002b173:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b176:	89 10                	mov    %edx,(%eax)
  i->bucket = i->hash->buckets;
c002b178:	8b 45 08             	mov    0x8(%ebp),%eax
c002b17b:	8b 00                	mov    (%eax),%eax
c002b17d:	8b 50 08             	mov    0x8(%eax),%edx
c002b180:	8b 45 08             	mov    0x8(%ebp),%eax
c002b183:	89 50 04             	mov    %edx,0x4(%eax)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002b186:	8b 45 08             	mov    0x8(%ebp),%eax
c002b189:	8b 40 04             	mov    0x4(%eax),%eax
c002b18c:	83 ec 0c             	sub    $0xc,%esp
c002b18f:	50                   	push   %eax
c002b190:	e8 bf e8 ff ff       	call   c0029a54 <list_head>
c002b195:	83 c4 10             	add    $0x10,%esp
c002b198:	83 c0 04             	add    $0x4,%eax
c002b19b:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b19e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b1a1:	89 50 08             	mov    %edx,0x8(%eax)
}
c002b1a4:	90                   	nop
c002b1a5:	c9                   	leave  
c002b1a6:	c3                   	ret    

c002b1a7 <hash_next>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
struct hash_elem *
hash_next (struct hash_iterator *i)
{
c002b1a7:	55                   	push   %ebp
c002b1a8:	89 e5                	mov    %esp,%ebp
c002b1aa:	53                   	push   %ebx
c002b1ab:	83 ec 04             	sub    $0x4,%esp
  ASSERT (i != NULL);
c002b1ae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b1b2:	75 21                	jne    c002b1d5 <hash_next+0x2e>
c002b1b4:	83 ec 0c             	sub    $0xc,%esp
c002b1b7:	68 7e 11 03 c0       	push   $0xc003117e
c002b1bc:	68 4f 11 03 c0       	push   $0xc003114f
c002b1c1:	68 c0 11 03 c0       	push   $0xc00311c0
c002b1c6:	68 dd 00 00 00       	push   $0xdd
c002b1cb:	68 66 11 03 c0       	push   $0xc0031166
c002b1d0:	e8 5c e4 ff ff       	call   c0029631 <debug_panic>

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002b1d5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b1d8:	8b 40 08             	mov    0x8(%eax),%eax
c002b1db:	83 ec 0c             	sub    $0xc,%esp
c002b1de:	50                   	push   %eax
c002b1df:	e8 47 e7 ff ff       	call   c002992b <list_next>
c002b1e4:	83 c4 10             	add    $0x10,%esp
c002b1e7:	83 c0 04             	add    $0x4,%eax
c002b1ea:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b1ed:	8b 45 08             	mov    0x8(%ebp),%eax
c002b1f0:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b1f3:	eb 58                	jmp    c002b24d <hash_next+0xa6>
    {
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002b1f5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b1f8:	8b 40 04             	mov    0x4(%eax),%eax
c002b1fb:	8d 50 10             	lea    0x10(%eax),%edx
c002b1fe:	8b 45 08             	mov    0x8(%ebp),%eax
c002b201:	89 50 04             	mov    %edx,0x4(%eax)
c002b204:	8b 45 08             	mov    0x8(%ebp),%eax
c002b207:	8b 50 04             	mov    0x4(%eax),%edx
c002b20a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b20d:	8b 00                	mov    (%eax),%eax
c002b20f:	8b 48 08             	mov    0x8(%eax),%ecx
c002b212:	8b 45 08             	mov    0x8(%ebp),%eax
c002b215:	8b 00                	mov    (%eax),%eax
c002b217:	8b 40 04             	mov    0x4(%eax),%eax
c002b21a:	c1 e0 04             	shl    $0x4,%eax
c002b21d:	01 c8                	add    %ecx,%eax
c002b21f:	39 c2                	cmp    %eax,%edx
c002b221:	72 0c                	jb     c002b22f <hash_next+0x88>
        {
          i->elem = NULL;
c002b223:	8b 45 08             	mov    0x8(%ebp),%eax
c002b226:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          break;
c002b22d:	eb 40                	jmp    c002b26f <hash_next+0xc8>
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002b22f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b232:	8b 40 04             	mov    0x4(%eax),%eax
c002b235:	83 ec 0c             	sub    $0xc,%esp
c002b238:	50                   	push   %eax
c002b239:	e8 bb e6 ff ff       	call   c00298f9 <list_begin>
c002b23e:	83 c4 10             	add    $0x10,%esp
c002b241:	83 c0 04             	add    $0x4,%eax
c002b244:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b247:	8b 45 08             	mov    0x8(%ebp),%eax
c002b24a:	89 50 08             	mov    %edx,0x8(%eax)
hash_next (struct hash_iterator *i)
{
  ASSERT (i != NULL);

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b24d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b250:	8b 58 08             	mov    0x8(%eax),%ebx
c002b253:	8b 45 08             	mov    0x8(%ebp),%eax
c002b256:	8b 40 04             	mov    0x4(%eax),%eax
c002b259:	83 ec 0c             	sub    $0xc,%esp
c002b25c:	50                   	push   %eax
c002b25d:	e8 13 e7 ff ff       	call   c0029975 <list_end>
c002b262:	83 c4 10             	add    $0x10,%esp
c002b265:	83 c0 04             	add    $0x4,%eax
c002b268:	83 e8 04             	sub    $0x4,%eax
c002b26b:	39 c3                	cmp    %eax,%ebx
c002b26d:	74 86                	je     c002b1f5 <hash_next+0x4e>
          break;
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
    }
  
  return i->elem;
c002b26f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b272:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b275:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b278:	c9                   	leave  
c002b279:	c3                   	ret    

c002b27a <hash_cur>:
/* Returns the current element in the hash table iteration, or a
   null pointer at the end of the table.  Undefined behavior
   after calling hash_first() but before hash_next(). */
struct hash_elem *
hash_cur (struct hash_iterator *i) 
{
c002b27a:	55                   	push   %ebp
c002b27b:	89 e5                	mov    %esp,%ebp
  return i->elem;
c002b27d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b280:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b283:	5d                   	pop    %ebp
c002b284:	c3                   	ret    

c002b285 <hash_size>:

/* Returns the number of elements in H. */
size_t
hash_size (struct hash *h) 
{
c002b285:	55                   	push   %ebp
c002b286:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt;
c002b288:	8b 45 08             	mov    0x8(%ebp),%eax
c002b28b:	8b 00                	mov    (%eax),%eax
}
c002b28d:	5d                   	pop    %ebp
c002b28e:	c3                   	ret    

c002b28f <hash_empty>:

/* Returns true if H contains no elements, false otherwise. */
bool
hash_empty (struct hash *h) 
{
c002b28f:	55                   	push   %ebp
c002b290:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt == 0;
c002b292:	8b 45 08             	mov    0x8(%ebp),%eax
c002b295:	8b 00                	mov    (%eax),%eax
c002b297:	85 c0                	test   %eax,%eax
c002b299:	0f 94 c0             	sete   %al
}
c002b29c:	5d                   	pop    %ebp
c002b29d:	c3                   	ret    

c002b29e <hash_bytes>:
#define FNV_32_BASIS 2166136261u

/* Returns a hash of the SIZE bytes in BUF. */
unsigned
hash_bytes (const void *buf_, size_t size)
{
c002b29e:	55                   	push   %ebp
c002b29f:	89 e5                	mov    %esp,%ebp
c002b2a1:	83 ec 18             	sub    $0x18,%esp
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
c002b2a4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);
c002b2aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b2ae:	75 21                	jne    c002b2d1 <hash_bytes+0x33>
c002b2b0:	83 ec 0c             	sub    $0xc,%esp
c002b2b3:	68 92 11 03 c0       	push   $0xc0031192
c002b2b8:	68 4f 11 03 c0       	push   $0xc003114f
c002b2bd:	68 cc 11 03 c0       	push   $0xc00311cc
c002b2c2:	68 10 01 00 00       	push   $0x110
c002b2c7:	68 66 11 03 c0       	push   $0xc0031166
c002b2cc:	e8 60 e3 ff ff       	call   c0029631 <debug_panic>

  hash = FNV_32_BASIS;
c002b2d1:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (size-- > 0)
c002b2d8:	eb 1d                	jmp    c002b2f7 <hash_bytes+0x59>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002b2da:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b2dd:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002b2e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b2e6:	8d 50 01             	lea    0x1(%eax),%edx
c002b2e9:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b2ec:	0f b6 00             	movzbl (%eax),%eax
c002b2ef:	0f b6 c0             	movzbl %al,%eax
c002b2f2:	31 c8                	xor    %ecx,%eax
c002b2f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);

  hash = FNV_32_BASIS;
  while (size-- > 0)
c002b2f7:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b2fa:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b2fd:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b300:	85 c0                	test   %eax,%eax
c002b302:	75 d6                	jne    c002b2da <hash_bytes+0x3c>
    hash = (hash * FNV_32_PRIME) ^ *buf++;

  return hash;
c002b304:	8b 45 f0             	mov    -0x10(%ebp),%eax
} 
c002b307:	c9                   	leave  
c002b308:	c3                   	ret    

c002b309 <hash_string>:

/* Returns a hash of string S. */
unsigned
hash_string (const char *s_) 
{
c002b309:	55                   	push   %ebp
c002b30a:	89 e5                	mov    %esp,%ebp
c002b30c:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *s = (const unsigned char *) s_;
c002b30f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b312:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (s != NULL);
c002b315:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b319:	75 21                	jne    c002b33c <hash_string+0x33>
c002b31b:	83 ec 0c             	sub    $0xc,%esp
c002b31e:	68 9e 11 03 c0       	push   $0xc003119e
c002b323:	68 4f 11 03 c0       	push   $0xc003114f
c002b328:	68 d8 11 03 c0       	push   $0xc00311d8
c002b32d:	68 20 01 00 00       	push   $0x120
c002b332:	68 66 11 03 c0       	push   $0xc0031166
c002b337:	e8 f5 e2 ff ff       	call   c0029631 <debug_panic>

  hash = FNV_32_BASIS;
c002b33c:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (*s != '\0')
c002b343:	eb 1d                	jmp    c002b362 <hash_string+0x59>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002b345:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b348:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002b34e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b351:	8d 50 01             	lea    0x1(%eax),%edx
c002b354:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b357:	0f b6 00             	movzbl (%eax),%eax
c002b35a:	0f b6 c0             	movzbl %al,%eax
c002b35d:	31 c8                	xor    %ecx,%eax
c002b35f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  unsigned hash;

  ASSERT (s != NULL);

  hash = FNV_32_BASIS;
  while (*s != '\0')
c002b362:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b365:	0f b6 00             	movzbl (%eax),%eax
c002b368:	84 c0                	test   %al,%al
c002b36a:	75 d9                	jne    c002b345 <hash_string+0x3c>
    hash = (hash * FNV_32_PRIME) ^ *s++;

  return hash;
c002b36c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b36f:	c9                   	leave  
c002b370:	c3                   	ret    

c002b371 <hash_int>:

/* Returns a hash of integer I. */
unsigned
hash_int (int i) 
{
c002b371:	55                   	push   %ebp
c002b372:	89 e5                	mov    %esp,%ebp
c002b374:	83 ec 08             	sub    $0x8,%esp
  return hash_bytes (&i, sizeof i);
c002b377:	83 ec 08             	sub    $0x8,%esp
c002b37a:	6a 04                	push   $0x4
c002b37c:	8d 45 08             	lea    0x8(%ebp),%eax
c002b37f:	50                   	push   %eax
c002b380:	e8 19 ff ff ff       	call   c002b29e <hash_bytes>
c002b385:	83 c4 10             	add    $0x10,%esp
}
c002b388:	c9                   	leave  
c002b389:	c3                   	ret    

c002b38a <find_bucket>:

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002b38a:	55                   	push   %ebp
c002b38b:	89 e5                	mov    %esp,%ebp
c002b38d:	83 ec 18             	sub    $0x18,%esp
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002b390:	8b 45 08             	mov    0x8(%ebp),%eax
c002b393:	8b 40 0c             	mov    0xc(%eax),%eax
c002b396:	8b 55 08             	mov    0x8(%ebp),%edx
c002b399:	8b 52 14             	mov    0x14(%edx),%edx
c002b39c:	83 ec 08             	sub    $0x8,%esp
c002b39f:	52                   	push   %edx
c002b3a0:	ff 75 0c             	pushl  0xc(%ebp)
c002b3a3:	ff d0                	call   *%eax
c002b3a5:	83 c4 10             	add    $0x10,%esp
c002b3a8:	89 c2                	mov    %eax,%edx
c002b3aa:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3ad:	8b 40 04             	mov    0x4(%eax),%eax
c002b3b0:	83 e8 01             	sub    $0x1,%eax
c002b3b3:	21 d0                	and    %edx,%eax
c002b3b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return &h->buckets[bucket_idx];
c002b3b8:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3bb:	8b 40 08             	mov    0x8(%eax),%eax
c002b3be:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b3c1:	c1 e2 04             	shl    $0x4,%edx
c002b3c4:	01 d0                	add    %edx,%eax
}
c002b3c6:	c9                   	leave  
c002b3c7:	c3                   	ret    

c002b3c8 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b3c8:	55                   	push   %ebp
c002b3c9:	89 e5                	mov    %esp,%ebp
c002b3cb:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b3ce:	83 ec 0c             	sub    $0xc,%esp
c002b3d1:	ff 75 0c             	pushl  0xc(%ebp)
c002b3d4:	e8 20 e5 ff ff       	call   c00298f9 <list_begin>
c002b3d9:	83 c4 10             	add    $0x10,%esp
c002b3dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b3df:	eb 66                	jmp    c002b447 <find_elem+0x7f>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
c002b3e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b3e4:	83 c0 04             	add    $0x4,%eax
c002b3e7:	83 e8 04             	sub    $0x4,%eax
c002b3ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002b3ed:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3f0:	8b 40 10             	mov    0x10(%eax),%eax
c002b3f3:	8b 55 08             	mov    0x8(%ebp),%edx
c002b3f6:	8b 52 14             	mov    0x14(%edx),%edx
c002b3f9:	83 ec 04             	sub    $0x4,%esp
c002b3fc:	52                   	push   %edx
c002b3fd:	ff 75 10             	pushl  0x10(%ebp)
c002b400:	ff 75 f0             	pushl  -0x10(%ebp)
c002b403:	ff d0                	call   *%eax
c002b405:	83 c4 10             	add    $0x10,%esp
c002b408:	83 f0 01             	xor    $0x1,%eax
c002b40b:	84 c0                	test   %al,%al
c002b40d:	74 27                	je     c002b436 <find_elem+0x6e>
c002b40f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b412:	8b 40 10             	mov    0x10(%eax),%eax
c002b415:	8b 55 08             	mov    0x8(%ebp),%edx
c002b418:	8b 52 14             	mov    0x14(%edx),%edx
c002b41b:	83 ec 04             	sub    $0x4,%esp
c002b41e:	52                   	push   %edx
c002b41f:	ff 75 f0             	pushl  -0x10(%ebp)
c002b422:	ff 75 10             	pushl  0x10(%ebp)
c002b425:	ff d0                	call   *%eax
c002b427:	83 c4 10             	add    $0x10,%esp
c002b42a:	83 f0 01             	xor    $0x1,%eax
c002b42d:	84 c0                	test   %al,%al
c002b42f:	74 05                	je     c002b436 <find_elem+0x6e>
        return hi; 
c002b431:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b434:	eb 29                	jmp    c002b45f <find_elem+0x97>
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b436:	83 ec 0c             	sub    $0xc,%esp
c002b439:	ff 75 f4             	pushl  -0xc(%ebp)
c002b43c:	e8 ea e4 ff ff       	call   c002992b <list_next>
c002b441:	83 c4 10             	add    $0x10,%esp
c002b444:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b447:	83 ec 0c             	sub    $0xc,%esp
c002b44a:	ff 75 0c             	pushl  0xc(%ebp)
c002b44d:	e8 23 e5 ff ff       	call   c0029975 <list_end>
c002b452:	83 c4 10             	add    $0x10,%esp
c002b455:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b458:	75 87                	jne    c002b3e1 <find_elem+0x19>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
        return hi; 
    }
  return NULL;
c002b45a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b45f:	c9                   	leave  
c002b460:	c3                   	ret    

c002b461 <turn_off_least_1bit>:

/* Returns X with its lowest-order bit set to 1 turned off. */
static inline size_t
turn_off_least_1bit (size_t x) 
{
c002b461:	55                   	push   %ebp
c002b462:	89 e5                	mov    %esp,%ebp
  return x & (x - 1);
c002b464:	8b 45 08             	mov    0x8(%ebp),%eax
c002b467:	83 e8 01             	sub    $0x1,%eax
c002b46a:	23 45 08             	and    0x8(%ebp),%eax
}
c002b46d:	5d                   	pop    %ebp
c002b46e:	c3                   	ret    

c002b46f <is_power_of_2>:

/* Returns true if X is a power of 2, otherwise false. */
static inline size_t
is_power_of_2 (size_t x) 
{
c002b46f:	55                   	push   %ebp
c002b470:	89 e5                	mov    %esp,%ebp
  return x != 0 && turn_off_least_1bit (x) == 0;
c002b472:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b476:	74 16                	je     c002b48e <is_power_of_2+0x1f>
c002b478:	ff 75 08             	pushl  0x8(%ebp)
c002b47b:	e8 e1 ff ff ff       	call   c002b461 <turn_off_least_1bit>
c002b480:	83 c4 04             	add    $0x4,%esp
c002b483:	85 c0                	test   %eax,%eax
c002b485:	75 07                	jne    c002b48e <is_power_of_2+0x1f>
c002b487:	b8 01 00 00 00       	mov    $0x1,%eax
c002b48c:	eb 05                	jmp    c002b493 <is_power_of_2+0x24>
c002b48e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b493:	c9                   	leave  
c002b494:	c3                   	ret    

c002b495 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002b495:	55                   	push   %ebp
c002b496:	89 e5                	mov    %esp,%ebp
c002b498:	83 ec 38             	sub    $0x38,%esp
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002b49b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b49f:	75 21                	jne    c002b4c2 <rehash+0x2d>
c002b4a1:	83 ec 0c             	sub    $0xc,%esp
c002b4a4:	68 88 11 03 c0       	push   $0xc0031188
c002b4a9:	68 4f 11 03 c0       	push   $0xc003114f
c002b4ae:	68 e4 11 03 c0       	push   $0xc00311e4
c002b4b3:	68 66 01 00 00       	push   $0x166
c002b4b8:	68 66 11 03 c0       	push   $0xc0031166
c002b4bd:	e8 6f e1 ff ff       	call   c0029631 <debug_panic>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
c002b4c2:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4c5:	8b 40 08             	mov    0x8(%eax),%eax
c002b4c8:	89 45 e8             	mov    %eax,-0x18(%ebp)
  old_bucket_cnt = h->bucket_cnt;
c002b4cb:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4ce:	8b 40 04             	mov    0x4(%eax),%eax
c002b4d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002b4d4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4d7:	8b 00                	mov    (%eax),%eax
c002b4d9:	d1 e8                	shr    %eax
c002b4db:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (new_bucket_cnt < 4)
c002b4de:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002b4e2:	77 1a                	ja     c002b4fe <rehash+0x69>
    new_bucket_cnt = 4;
c002b4e4:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002b4eb:	eb 11                	jmp    c002b4fe <rehash+0x69>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);
c002b4ed:	83 ec 0c             	sub    $0xc,%esp
c002b4f0:	ff 75 f4             	pushl  -0xc(%ebp)
c002b4f3:	e8 69 ff ff ff       	call   c002b461 <turn_off_least_1bit>
c002b4f8:	83 c4 10             	add    $0x10,%esp
c002b4fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c002b4fe:	83 ec 0c             	sub    $0xc,%esp
c002b501:	ff 75 f4             	pushl  -0xc(%ebp)
c002b504:	e8 66 ff ff ff       	call   c002b46f <is_power_of_2>
c002b509:	83 c4 10             	add    $0x10,%esp
c002b50c:	85 c0                	test   %eax,%eax
c002b50e:	74 dd                	je     c002b4ed <rehash+0x58>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002b510:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b513:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002b516:	0f 84 12 01 00 00    	je     c002b62e <rehash+0x199>
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002b51c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b51f:	c1 e0 04             	shl    $0x4,%eax
c002b522:	83 ec 0c             	sub    $0xc,%esp
c002b525:	50                   	push   %eax
c002b526:	e8 60 7f ff ff       	call   c002348b <malloc>
c002b52b:	83 c4 10             	add    $0x10,%esp
c002b52e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (new_buckets == NULL) 
c002b531:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002b535:	0f 84 f6 00 00 00    	je     c002b631 <rehash+0x19c>
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002b53b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002b542:	eb 1d                	jmp    c002b561 <rehash+0xcc>
    list_init (&new_buckets[i]);
c002b544:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b547:	c1 e0 04             	shl    $0x4,%eax
c002b54a:	89 c2                	mov    %eax,%edx
c002b54c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002b54f:	01 d0                	add    %edx,%eax
c002b551:	83 ec 0c             	sub    $0xc,%esp
c002b554:	50                   	push   %eax
c002b555:	e8 4a e3 ff ff       	call   c00298a4 <list_init>
c002b55a:	83 c4 10             	add    $0x10,%esp
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002b55d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002b561:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b564:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b567:	72 db                	jb     c002b544 <rehash+0xaf>
    list_init (&new_buckets[i]);

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002b569:	8b 45 08             	mov    0x8(%ebp),%eax
c002b56c:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002b56f:	89 50 08             	mov    %edx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002b572:	8b 45 08             	mov    0x8(%ebp),%eax
c002b575:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b578:	89 50 04             	mov    %edx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002b57b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002b582:	e9 8b 00 00 00       	jmp    c002b612 <rehash+0x17d>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002b587:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b58a:	c1 e0 04             	shl    $0x4,%eax
c002b58d:	89 c2                	mov    %eax,%edx
c002b58f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b592:	01 d0                	add    %edx,%eax
c002b594:	89 45 dc             	mov    %eax,-0x24(%ebp)
      for (elem = list_begin (old_bucket);
c002b597:	83 ec 0c             	sub    $0xc,%esp
c002b59a:	ff 75 dc             	pushl  -0x24(%ebp)
c002b59d:	e8 57 e3 ff ff       	call   c00298f9 <list_begin>
c002b5a2:	83 c4 10             	add    $0x10,%esp
c002b5a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002b5a8:	eb 51                	jmp    c002b5fb <rehash+0x166>
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002b5aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b5ad:	83 c0 04             	add    $0x4,%eax
c002b5b0:	83 e8 04             	sub    $0x4,%eax

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
c002b5b3:	83 ec 08             	sub    $0x8,%esp
c002b5b6:	50                   	push   %eax
c002b5b7:	ff 75 08             	pushl  0x8(%ebp)
c002b5ba:	e8 cb fd ff ff       	call   c002b38a <find_bucket>
c002b5bf:	83 c4 10             	add    $0x10,%esp
c002b5c2:	89 45 d8             	mov    %eax,-0x28(%ebp)
            = find_bucket (h, list_elem_to_hash_elem (elem));
          next = list_next (elem);
c002b5c5:	83 ec 0c             	sub    $0xc,%esp
c002b5c8:	ff 75 ec             	pushl  -0x14(%ebp)
c002b5cb:	e8 5b e3 ff ff       	call   c002992b <list_next>
c002b5d0:	83 c4 10             	add    $0x10,%esp
c002b5d3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          list_remove (elem);
c002b5d6:	83 ec 0c             	sub    $0xc,%esp
c002b5d9:	ff 75 ec             	pushl  -0x14(%ebp)
c002b5dc:	e8 c9 e6 ff ff       	call   c0029caa <list_remove>
c002b5e1:	83 c4 10             	add    $0x10,%esp
          list_push_front (new_bucket, elem);
c002b5e4:	83 ec 08             	sub    $0x8,%esp
c002b5e7:	ff 75 ec             	pushl  -0x14(%ebp)
c002b5ea:	ff 75 d8             	pushl  -0x28(%ebp)
c002b5ed:	e8 6c e6 ff ff       	call   c0029c5e <list_push_front>
c002b5f2:	83 c4 10             	add    $0x10,%esp
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
c002b5f5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002b5f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002b5fb:	83 ec 0c             	sub    $0xc,%esp
c002b5fe:	ff 75 dc             	pushl  -0x24(%ebp)
c002b601:	e8 6f e3 ff ff       	call   c0029975 <list_end>
c002b606:	83 c4 10             	add    $0x10,%esp
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
c002b609:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002b60c:	75 9c                	jne    c002b5aa <rehash+0x115>
  /* Install new bucket info. */
  h->buckets = new_buckets;
  h->bucket_cnt = new_bucket_cnt;

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002b60e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002b612:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b615:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002b618:	0f 82 69 ff ff ff    	jb     c002b587 <rehash+0xf2>
          list_remove (elem);
          list_push_front (new_bucket, elem);
        }
    }

  free (old_buckets);
c002b61e:	83 ec 0c             	sub    $0xc,%esp
c002b621:	ff 75 e8             	pushl  -0x18(%ebp)
c002b624:	e8 5b 81 ff ff       	call   c0023784 <free>
c002b629:	83 c4 10             	add    $0x10,%esp
c002b62c:	eb 04                	jmp    c002b632 <rehash+0x19d>
  while (!is_power_of_2 (new_bucket_cnt))
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
    return;
c002b62e:	90                   	nop
c002b62f:	eb 01                	jmp    c002b632 <rehash+0x19d>
  if (new_buckets == NULL) 
    {
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
c002b631:	90                   	nop
          list_push_front (new_bucket, elem);
        }
    }

  free (old_buckets);
}
c002b632:	c9                   	leave  
c002b633:	c3                   	ret    

c002b634 <insert_elem>:

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b634:	55                   	push   %ebp
c002b635:	89 e5                	mov    %esp,%ebp
c002b637:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt++;
c002b63a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b63d:	8b 00                	mov    (%eax),%eax
c002b63f:	8d 50 01             	lea    0x1(%eax),%edx
c002b642:	8b 45 08             	mov    0x8(%ebp),%eax
c002b645:	89 10                	mov    %edx,(%eax)
  list_push_front (bucket, &e->list_elem);
c002b647:	8b 45 10             	mov    0x10(%ebp),%eax
c002b64a:	83 ec 08             	sub    $0x8,%esp
c002b64d:	50                   	push   %eax
c002b64e:	ff 75 0c             	pushl  0xc(%ebp)
c002b651:	e8 08 e6 ff ff       	call   c0029c5e <list_push_front>
c002b656:	83 c4 10             	add    $0x10,%esp
}
c002b659:	90                   	nop
c002b65a:	c9                   	leave  
c002b65b:	c3                   	ret    

c002b65c <remove_elem>:

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
c002b65c:	55                   	push   %ebp
c002b65d:	89 e5                	mov    %esp,%ebp
c002b65f:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt--;
c002b662:	8b 45 08             	mov    0x8(%ebp),%eax
c002b665:	8b 00                	mov    (%eax),%eax
c002b667:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b66a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b66d:	89 10                	mov    %edx,(%eax)
  list_remove (&e->list_elem);
c002b66f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b672:	83 ec 0c             	sub    $0xc,%esp
c002b675:	50                   	push   %eax
c002b676:	e8 2f e6 ff ff       	call   c0029caa <list_remove>
c002b67b:	83 c4 10             	add    $0x10,%esp
}
c002b67e:	90                   	nop
c002b67f:	c9                   	leave  
c002b680:	c3                   	ret    

c002b681 <console_init>:
static int64_t write_cnt;

/* Enable console locking. */
void
console_init (void) 
{
c002b681:	55                   	push   %ebp
c002b682:	89 e5                	mov    %esp,%ebp
c002b684:	83 ec 08             	sub    $0x8,%esp
  lock_init (&console_lock);
c002b687:	83 ec 0c             	sub    $0xc,%esp
c002b68a:	68 e8 9b 03 c0       	push   $0xc0039be8
c002b68f:	e8 e1 73 ff ff       	call   c0022a75 <lock_init>
c002b694:	83 c4 10             	add    $0x10,%esp
  use_console_lock = true;
c002b697:	c6 05 00 9c 03 c0 01 	movb   $0x1,0xc0039c00
}
c002b69e:	90                   	nop
c002b69f:	c9                   	leave  
c002b6a0:	c3                   	ret    

c002b6a1 <console_panic>:
/* Notifies the console that a kernel panic is underway,
   which warns it to avoid trying to take the console lock from
   now on. */
void
console_panic (void) 
{
c002b6a1:	55                   	push   %ebp
c002b6a2:	89 e5                	mov    %esp,%ebp
  use_console_lock = false;
c002b6a4:	c6 05 00 9c 03 c0 00 	movb   $0x0,0xc0039c00
}
c002b6ab:	90                   	nop
c002b6ac:	5d                   	pop    %ebp
c002b6ad:	c3                   	ret    

c002b6ae <console_print_stats>:

/* Prints console statistics. */
void
console_print_stats (void) 
{
c002b6ae:	55                   	push   %ebp
c002b6af:	89 e5                	mov    %esp,%ebp
c002b6b1:	83 ec 08             	sub    $0x8,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c002b6b4:	a1 08 9c 03 c0       	mov    0xc0039c08,%eax
c002b6b9:	8b 15 0c 9c 03 c0    	mov    0xc0039c0c,%edx
c002b6bf:	83 ec 04             	sub    $0x4,%esp
c002b6c2:	52                   	push   %edx
c002b6c3:	50                   	push   %eax
c002b6c4:	68 ec 11 03 c0       	push   $0xc00311ec
c002b6c9:	e8 30 bb ff ff       	call   c00271fe <printf>
c002b6ce:	83 c4 10             	add    $0x10,%esp
}
c002b6d1:	90                   	nop
c002b6d2:	c9                   	leave  
c002b6d3:	c3                   	ret    

c002b6d4 <acquire_console>:

/* Acquires the console lock. */
static void
acquire_console (void) 
{
c002b6d4:	55                   	push   %ebp
c002b6d5:	89 e5                	mov    %esp,%ebp
c002b6d7:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002b6da:	e8 9e 5f ff ff       	call   c002167d <intr_context>
c002b6df:	83 f0 01             	xor    $0x1,%eax
c002b6e2:	84 c0                	test   %al,%al
c002b6e4:	74 3e                	je     c002b724 <acquire_console+0x50>
c002b6e6:	0f b6 05 00 9c 03 c0 	movzbl 0xc0039c00,%eax
c002b6ed:	84 c0                	test   %al,%al
c002b6ef:	74 33                	je     c002b724 <acquire_console+0x50>
    {
      if (lock_held_by_current_thread (&console_lock)) 
c002b6f1:	83 ec 0c             	sub    $0xc,%esp
c002b6f4:	68 e8 9b 03 c0       	push   $0xc0039be8
c002b6f9:	e8 83 75 ff ff       	call   c0022c81 <lock_held_by_current_thread>
c002b6fe:	83 c4 10             	add    $0x10,%esp
c002b701:	84 c0                	test   %al,%al
c002b703:	74 0f                	je     c002b714 <acquire_console+0x40>
        console_lock_depth++; 
c002b705:	a1 04 9c 03 c0       	mov    0xc0039c04,%eax
c002b70a:	83 c0 01             	add    $0x1,%eax
c002b70d:	a3 04 9c 03 c0       	mov    %eax,0xc0039c04
      else
        lock_acquire (&console_lock); 
    }
}
c002b712:	eb 10                	jmp    c002b724 <acquire_console+0x50>
  if (!intr_context () && use_console_lock) 
    {
      if (lock_held_by_current_thread (&console_lock)) 
        console_lock_depth++; 
      else
        lock_acquire (&console_lock); 
c002b714:	83 ec 0c             	sub    $0xc,%esp
c002b717:	68 e8 9b 03 c0       	push   $0xc0039be8
c002b71c:	e8 a1 73 ff ff       	call   c0022ac2 <lock_acquire>
c002b721:	83 c4 10             	add    $0x10,%esp
    }
}
c002b724:	90                   	nop
c002b725:	c9                   	leave  
c002b726:	c3                   	ret    

c002b727 <release_console>:

/* Releases the console lock. */
static void
release_console (void) 
{
c002b727:	55                   	push   %ebp
c002b728:	89 e5                	mov    %esp,%ebp
c002b72a:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002b72d:	e8 4b 5f ff ff       	call   c002167d <intr_context>
c002b732:	83 f0 01             	xor    $0x1,%eax
c002b735:	84 c0                	test   %al,%al
c002b737:	74 33                	je     c002b76c <release_console+0x45>
c002b739:	0f b6 05 00 9c 03 c0 	movzbl 0xc0039c00,%eax
c002b740:	84 c0                	test   %al,%al
c002b742:	74 28                	je     c002b76c <release_console+0x45>
    {
      if (console_lock_depth > 0)
c002b744:	a1 04 9c 03 c0       	mov    0xc0039c04,%eax
c002b749:	85 c0                	test   %eax,%eax
c002b74b:	7e 0f                	jle    c002b75c <release_console+0x35>
        console_lock_depth--;
c002b74d:	a1 04 9c 03 c0       	mov    0xc0039c04,%eax
c002b752:	83 e8 01             	sub    $0x1,%eax
c002b755:	a3 04 9c 03 c0       	mov    %eax,0xc0039c04
      else
        lock_release (&console_lock); 
    }
}
c002b75a:	eb 10                	jmp    c002b76c <release_console+0x45>
  if (!intr_context () && use_console_lock) 
    {
      if (console_lock_depth > 0)
        console_lock_depth--;
      else
        lock_release (&console_lock); 
c002b75c:	83 ec 0c             	sub    $0xc,%esp
c002b75f:	68 e8 9b 03 c0       	push   $0xc0039be8
c002b764:	e8 9a 74 ff ff       	call   c0022c03 <lock_release>
c002b769:	83 c4 10             	add    $0x10,%esp
    }
}
c002b76c:	90                   	nop
c002b76d:	c9                   	leave  
c002b76e:	c3                   	ret    

c002b76f <console_locked_by_current_thread>:

/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
c002b76f:	55                   	push   %ebp
c002b770:	89 e5                	mov    %esp,%ebp
c002b772:	83 ec 08             	sub    $0x8,%esp
  return (intr_context ()
c002b775:	e8 03 5f ff ff       	call   c002167d <intr_context>
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
c002b77a:	84 c0                	test   %al,%al
c002b77c:	75 22                	jne    c002b7a0 <console_locked_by_current_thread+0x31>
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
  return (intr_context ()
          || !use_console_lock
c002b77e:	0f b6 05 00 9c 03 c0 	movzbl 0xc0039c00,%eax
c002b785:	83 f0 01             	xor    $0x1,%eax
c002b788:	84 c0                	test   %al,%al
c002b78a:	75 14                	jne    c002b7a0 <console_locked_by_current_thread+0x31>
          || lock_held_by_current_thread (&console_lock));
c002b78c:	83 ec 0c             	sub    $0xc,%esp
c002b78f:	68 e8 9b 03 c0       	push   $0xc0039be8
c002b794:	e8 e8 74 ff ff       	call   c0022c81 <lock_held_by_current_thread>
c002b799:	83 c4 10             	add    $0x10,%esp
c002b79c:	84 c0                	test   %al,%al
c002b79e:	74 07                	je     c002b7a7 <console_locked_by_current_thread+0x38>
c002b7a0:	b8 01 00 00 00       	mov    $0x1,%eax
c002b7a5:	eb 05                	jmp    c002b7ac <console_locked_by_current_thread+0x3d>
c002b7a7:	b8 00 00 00 00       	mov    $0x0,%eax
/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
  return (intr_context ()
c002b7ac:	83 e0 01             	and    $0x1,%eax
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
}
c002b7af:	c9                   	leave  
c002b7b0:	c3                   	ret    

c002b7b1 <vprintf>:
/* The standard vprintf() function,
   which is like printf() but uses a va_list.
   Writes its output to both vga display and serial port. */
int
vprintf (const char *format, va_list args) 
{
c002b7b1:	55                   	push   %ebp
c002b7b2:	89 e5                	mov    %esp,%ebp
c002b7b4:	83 ec 18             	sub    $0x18,%esp
  int char_cnt = 0;
c002b7b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  acquire_console ();
c002b7be:	e8 11 ff ff ff       	call   c002b6d4 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002b7c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
c002b7c6:	50                   	push   %eax
c002b7c7:	68 93 b8 02 c0       	push   $0xc002b893
c002b7cc:	ff 75 0c             	pushl  0xc(%ebp)
c002b7cf:	ff 75 08             	pushl  0x8(%ebp)
c002b7d2:	e8 4d ba ff ff       	call   c0027224 <__vprintf>
c002b7d7:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b7da:	e8 48 ff ff ff       	call   c002b727 <release_console>

  return char_cnt;
c002b7df:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b7e2:	c9                   	leave  
c002b7e3:	c3                   	ret    

c002b7e4 <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
c002b7e4:	55                   	push   %ebp
c002b7e5:	89 e5                	mov    %esp,%ebp
c002b7e7:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b7ea:	e8 e5 fe ff ff       	call   c002b6d4 <acquire_console>
  while (*s != '\0')
c002b7ef:	eb 1b                	jmp    c002b80c <puts+0x28>
    putchar_have_lock (*s++);
c002b7f1:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7f4:	8d 50 01             	lea    0x1(%eax),%edx
c002b7f7:	89 55 08             	mov    %edx,0x8(%ebp)
c002b7fa:	0f b6 00             	movzbl (%eax),%eax
c002b7fd:	0f b6 c0             	movzbl %al,%eax
c002b800:	83 ec 0c             	sub    $0xc,%esp
c002b803:	50                   	push   %eax
c002b804:	e8 bf 00 00 00       	call   c002b8c8 <putchar_have_lock>
c002b809:	83 c4 10             	add    $0x10,%esp
   character. */
int
puts (const char *s) 
{
  acquire_console ();
  while (*s != '\0')
c002b80c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b80f:	0f b6 00             	movzbl (%eax),%eax
c002b812:	84 c0                	test   %al,%al
c002b814:	75 db                	jne    c002b7f1 <puts+0xd>
    putchar_have_lock (*s++);
  putchar_have_lock ('\n');
c002b816:	83 ec 0c             	sub    $0xc,%esp
c002b819:	6a 0a                	push   $0xa
c002b81b:	e8 a8 00 00 00       	call   c002b8c8 <putchar_have_lock>
c002b820:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b823:	e8 ff fe ff ff       	call   c002b727 <release_console>

  return 0;
c002b828:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b82d:	c9                   	leave  
c002b82e:	c3                   	ret    

c002b82f <putbuf>:

/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
c002b82f:	55                   	push   %ebp
c002b830:	89 e5                	mov    %esp,%ebp
c002b832:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b835:	e8 9a fe ff ff       	call   c002b6d4 <acquire_console>
  while (n-- > 0)
c002b83a:	eb 1b                	jmp    c002b857 <putbuf+0x28>
    putchar_have_lock (*buffer++);
c002b83c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b83f:	8d 50 01             	lea    0x1(%eax),%edx
c002b842:	89 55 08             	mov    %edx,0x8(%ebp)
c002b845:	0f b6 00             	movzbl (%eax),%eax
c002b848:	0f b6 c0             	movzbl %al,%eax
c002b84b:	83 ec 0c             	sub    $0xc,%esp
c002b84e:	50                   	push   %eax
c002b84f:	e8 74 00 00 00       	call   c002b8c8 <putchar_have_lock>
c002b854:	83 c4 10             	add    $0x10,%esp
/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
  acquire_console ();
  while (n-- > 0)
c002b857:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b85a:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b85d:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b860:	85 c0                	test   %eax,%eax
c002b862:	75 d8                	jne    c002b83c <putbuf+0xd>
    putchar_have_lock (*buffer++);
  release_console ();
c002b864:	e8 be fe ff ff       	call   c002b727 <release_console>
}
c002b869:	90                   	nop
c002b86a:	c9                   	leave  
c002b86b:	c3                   	ret    

c002b86c <putchar>:

/* Writes C to the vga display and serial port. */
int
putchar (int c) 
{
c002b86c:	55                   	push   %ebp
c002b86d:	89 e5                	mov    %esp,%ebp
c002b86f:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b872:	e8 5d fe ff ff       	call   c002b6d4 <acquire_console>
  putchar_have_lock (c);
c002b877:	8b 45 08             	mov    0x8(%ebp),%eax
c002b87a:	0f b6 c0             	movzbl %al,%eax
c002b87d:	83 ec 0c             	sub    $0xc,%esp
c002b880:	50                   	push   %eax
c002b881:	e8 42 00 00 00       	call   c002b8c8 <putchar_have_lock>
c002b886:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b889:	e8 99 fe ff ff       	call   c002b727 <release_console>
  
  return c;
c002b88e:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002b891:	c9                   	leave  
c002b892:	c3                   	ret    

c002b893 <vprintf_helper>:

/* Helper function for vprintf(). */
static void
vprintf_helper (char c, void *char_cnt_) 
{
c002b893:	55                   	push   %ebp
c002b894:	89 e5                	mov    %esp,%ebp
c002b896:	83 ec 28             	sub    $0x28,%esp
c002b899:	8b 45 08             	mov    0x8(%ebp),%eax
c002b89c:	88 45 e4             	mov    %al,-0x1c(%ebp)
  int *char_cnt = char_cnt_;
c002b89f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b8a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  (*char_cnt)++;
c002b8a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b8a8:	8b 00                	mov    (%eax),%eax
c002b8aa:	8d 50 01             	lea    0x1(%eax),%edx
c002b8ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b8b0:	89 10                	mov    %edx,(%eax)
  putchar_have_lock (c);
c002b8b2:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b8b6:	0f b6 c0             	movzbl %al,%eax
c002b8b9:	83 ec 0c             	sub    $0xc,%esp
c002b8bc:	50                   	push   %eax
c002b8bd:	e8 06 00 00 00       	call   c002b8c8 <putchar_have_lock>
c002b8c2:	83 c4 10             	add    $0x10,%esp
}
c002b8c5:	90                   	nop
c002b8c6:	c9                   	leave  
c002b8c7:	c3                   	ret    

c002b8c8 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002b8c8:	55                   	push   %ebp
c002b8c9:	89 e5                	mov    %esp,%ebp
c002b8cb:	83 ec 18             	sub    $0x18,%esp
c002b8ce:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8d1:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (console_locked_by_current_thread ());
c002b8d4:	e8 96 fe ff ff       	call   c002b76f <console_locked_by_current_thread>
c002b8d9:	84 c0                	test   %al,%al
c002b8db:	75 21                	jne    c002b8fe <putchar_have_lock+0x36>
c002b8dd:	83 ec 0c             	sub    $0xc,%esp
c002b8e0:	68 10 12 03 c0       	push   $0xc0031210
c002b8e5:	68 34 12 03 c0       	push   $0xc0031234
c002b8ea:	68 68 12 03 c0       	push   $0xc0031268
c002b8ef:	68 bb 00 00 00       	push   $0xbb
c002b8f4:	68 4b 12 03 c0       	push   $0xc003124b
c002b8f9:	e8 33 dd ff ff       	call   c0029631 <debug_panic>
  write_cnt++;
c002b8fe:	a1 08 9c 03 c0       	mov    0xc0039c08,%eax
c002b903:	8b 15 0c 9c 03 c0    	mov    0xc0039c0c,%edx
c002b909:	83 c0 01             	add    $0x1,%eax
c002b90c:	83 d2 00             	adc    $0x0,%edx
c002b90f:	a3 08 9c 03 c0       	mov    %eax,0xc0039c08
c002b914:	89 15 0c 9c 03 c0    	mov    %edx,0xc0039c0c
  serial_putc (c);
c002b91a:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002b91e:	83 ec 0c             	sub    $0xc,%esp
c002b921:	50                   	push   %eax
c002b922:	e8 d9 90 ff ff       	call   c0024a00 <serial_putc>
c002b927:	83 c4 10             	add    $0x10,%esp
  vga_putc (c);
c002b92a:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002b92e:	83 ec 0c             	sub    $0xc,%esp
c002b931:	50                   	push   %eax
c002b932:	e8 5b 8c ff ff       	call   c0024592 <vga_putc>
c002b937:	83 c4 10             	add    $0x10,%esp
}
c002b93a:	90                   	nop
c002b93b:	c9                   	leave  
c002b93c:	c3                   	ret    

c002b93d <run_test>:
static const char *test_name;

/* Runs the test named NAME. */
void
run_test (const char *name) 
{
c002b93d:	55                   	push   %ebp
c002b93e:	89 e5                	mov    %esp,%ebp
c002b940:	83 ec 18             	sub    $0x18,%esp
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002b943:	c7 45 f4 40 14 03 c0 	movl   $0xc0031440,-0xc(%ebp)
c002b94a:	eb 4e                	jmp    c002b99a <run_test+0x5d>
    if (!strcmp (name, t->name))
c002b94c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b94f:	8b 00                	mov    (%eax),%eax
c002b951:	83 ec 08             	sub    $0x8,%esp
c002b954:	50                   	push   %eax
c002b955:	ff 75 08             	pushl  0x8(%ebp)
c002b958:	e8 ca cc ff ff       	call   c0028627 <strcmp>
c002b95d:	83 c4 10             	add    $0x10,%esp
c002b960:	85 c0                	test   %eax,%eax
c002b962:	75 32                	jne    c002b996 <run_test+0x59>
      {
        test_name = name;
c002b964:	8b 45 08             	mov    0x8(%ebp),%eax
c002b967:	a3 10 9c 03 c0       	mov    %eax,0xc0039c10
        msg ("begin");
c002b96c:	83 ec 0c             	sub    $0xc,%esp
c002b96f:	68 18 15 03 c0       	push   $0xc0031518
c002b974:	e8 49 00 00 00       	call   c002b9c2 <msg>
c002b979:	83 c4 10             	add    $0x10,%esp
        t->function ();
c002b97c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b97f:	8b 40 04             	mov    0x4(%eax),%eax
c002b982:	ff d0                	call   *%eax
        msg ("end");
c002b984:	83 ec 0c             	sub    $0xc,%esp
c002b987:	68 1e 15 03 c0       	push   $0xc003151e
c002b98c:	e8 31 00 00 00       	call   c002b9c2 <msg>
c002b991:	83 c4 10             	add    $0x10,%esp
        return;
c002b994:	eb 2a                	jmp    c002b9c0 <run_test+0x83>
void
run_test (const char *name) 
{
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002b996:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
c002b99a:	b8 18 15 03 c0       	mov    $0xc0031518,%eax
c002b99f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002b9a2:	72 a8                	jb     c002b94c <run_test+0xf>
        msg ("begin");
        t->function ();
        msg ("end");
        return;
      }
  PANIC ("no test named \"%s\"", name);
c002b9a4:	83 ec 0c             	sub    $0xc,%esp
c002b9a7:	ff 75 08             	pushl  0x8(%ebp)
c002b9aa:	68 22 15 03 c0       	push   $0xc0031522
c002b9af:	68 7c 15 03 c0       	push   $0xc003157c
c002b9b4:	6a 3c                	push   $0x3c
c002b9b6:	68 35 15 03 c0       	push   $0xc0031535
c002b9bb:	e8 71 dc ff ff       	call   c0029631 <debug_panic>
}
c002b9c0:	c9                   	leave  
c002b9c1:	c3                   	ret    

c002b9c2 <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c002b9c2:	55                   	push   %ebp
c002b9c3:	89 e5                	mov    %esp,%ebp
c002b9c5:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) ", test_name);
c002b9c8:	a1 10 9c 03 c0       	mov    0xc0039c10,%eax
c002b9cd:	83 ec 08             	sub    $0x8,%esp
c002b9d0:	50                   	push   %eax
c002b9d1:	68 51 15 03 c0       	push   $0xc0031551
c002b9d6:	e8 23 b8 ff ff       	call   c00271fe <printf>
c002b9db:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002b9de:	8d 45 0c             	lea    0xc(%ebp),%eax
c002b9e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002b9e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b9e7:	83 ec 08             	sub    $0x8,%esp
c002b9ea:	50                   	push   %eax
c002b9eb:	ff 75 08             	pushl  0x8(%ebp)
c002b9ee:	e8 be fd ff ff       	call   c002b7b1 <vprintf>
c002b9f3:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002b9f6:	83 ec 0c             	sub    $0xc,%esp
c002b9f9:	6a 0a                	push   $0xa
c002b9fb:	e8 6c fe ff ff       	call   c002b86c <putchar>
c002ba00:	83 c4 10             	add    $0x10,%esp
}
c002ba03:	90                   	nop
c002ba04:	c9                   	leave  
c002ba05:	c3                   	ret    

c002ba06 <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c002ba06:	55                   	push   %ebp
c002ba07:	89 e5                	mov    %esp,%ebp
c002ba09:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c002ba0c:	a1 10 9c 03 c0       	mov    0xc0039c10,%eax
c002ba11:	83 ec 08             	sub    $0x8,%esp
c002ba14:	50                   	push   %eax
c002ba15:	68 57 15 03 c0       	push   $0xc0031557
c002ba1a:	e8 df b7 ff ff       	call   c00271fe <printf>
c002ba1f:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002ba22:	8d 45 0c             	lea    0xc(%ebp),%eax
c002ba25:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002ba28:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ba2b:	83 ec 08             	sub    $0x8,%esp
c002ba2e:	50                   	push   %eax
c002ba2f:	ff 75 08             	pushl  0x8(%ebp)
c002ba32:	e8 7a fd ff ff       	call   c002b7b1 <vprintf>
c002ba37:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002ba3a:	83 ec 0c             	sub    $0xc,%esp
c002ba3d:	6a 0a                	push   $0xa
c002ba3f:	e8 28 fe ff ff       	call   c002b86c <putchar>
c002ba44:	83 c4 10             	add    $0x10,%esp

  PANIC ("test failed");
c002ba47:	68 63 15 03 c0       	push   $0xc0031563
c002ba4c:	68 88 15 03 c0       	push   $0xc0031588
c002ba51:	6a 5d                	push   $0x5d
c002ba53:	68 35 15 03 c0       	push   $0xc0031535
c002ba58:	e8 d4 db ff ff       	call   c0029631 <debug_panic>

c002ba5d <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c002ba5d:	55                   	push   %ebp
c002ba5e:	89 e5                	mov    %esp,%ebp
c002ba60:	83 ec 08             	sub    $0x8,%esp
  printf ("(%s) PASS\n", test_name);
c002ba63:	a1 10 9c 03 c0       	mov    0xc0039c10,%eax
c002ba68:	83 ec 08             	sub    $0x8,%esp
c002ba6b:	50                   	push   %eax
c002ba6c:	68 6f 15 03 c0       	push   $0xc003156f
c002ba71:	e8 88 b7 ff ff       	call   c00271fe <printf>
c002ba76:	83 c4 10             	add    $0x10,%esp
}
c002ba79:	90                   	nop
c002ba7a:	c9                   	leave  
c002ba7b:	c3                   	ret    

c002ba7c <test_alarm_single>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_single (void) 
{
c002ba7c:	55                   	push   %ebp
c002ba7d:	89 e5                	mov    %esp,%ebp
c002ba7f:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 1);
c002ba82:	83 ec 08             	sub    $0x8,%esp
c002ba85:	6a 01                	push   $0x1
c002ba87:	6a 05                	push   $0x5
c002ba89:	e8 1e 00 00 00       	call   c002baac <test_sleep>
c002ba8e:	83 c4 10             	add    $0x10,%esp
}
c002ba91:	90                   	nop
c002ba92:	c9                   	leave  
c002ba93:	c3                   	ret    

c002ba94 <test_alarm_multiple>:

void
test_alarm_multiple (void) 
{
c002ba94:	55                   	push   %ebp
c002ba95:	89 e5                	mov    %esp,%ebp
c002ba97:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 7);
c002ba9a:	83 ec 08             	sub    $0x8,%esp
c002ba9d:	6a 07                	push   $0x7
c002ba9f:	6a 05                	push   $0x5
c002baa1:	e8 06 00 00 00       	call   c002baac <test_sleep>
c002baa6:	83 c4 10             	add    $0x10,%esp
}
c002baa9:	90                   	nop
c002baaa:	c9                   	leave  
c002baab:	c3                   	ret    

c002baac <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002baac:	55                   	push   %ebp
c002baad:	89 e5                	mov    %esp,%ebp
c002baaf:	83 ec 68             	sub    $0x68,%esp
  int *output, *op;
  int product;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002bab2:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002bab9:	83 f0 01             	xor    $0x1,%eax
c002babc:	84 c0                	test   %al,%al
c002babe:	75 1e                	jne    c002bade <test_sleep+0x32>
c002bac0:	83 ec 0c             	sub    $0xc,%esp
c002bac3:	68 90 15 03 c0       	push   $0xc0031590
c002bac8:	68 9e 15 03 c0       	push   $0xc003159e
c002bacd:	68 a4 17 03 c0       	push   $0xc00317a4
c002bad2:	6a 3c                	push   $0x3c
c002bad4:	68 b8 15 03 c0       	push   $0xc00315b8
c002bad9:	e8 53 db ff ff       	call   c0029631 <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002bade:	83 ec 04             	sub    $0x4,%esp
c002bae1:	ff 75 0c             	pushl  0xc(%ebp)
c002bae4:	ff 75 08             	pushl  0x8(%ebp)
c002bae7:	68 dc 15 03 c0       	push   $0xc00315dc
c002baec:	e8 d1 fe ff ff       	call   c002b9c2 <msg>
c002baf1:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 0 sleeps 10 ticks each time,");
c002baf4:	83 ec 0c             	sub    $0xc,%esp
c002baf7:	68 08 16 03 c0       	push   $0xc0031608
c002bafc:	e8 c1 fe ff ff       	call   c002b9c2 <msg>
c002bb01:	83 c4 10             	add    $0x10,%esp
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c002bb04:	83 ec 0c             	sub    $0xc,%esp
c002bb07:	68 2c 16 03 c0       	push   $0xc003162c
c002bb0c:	e8 b1 fe ff ff       	call   c002b9c2 <msg>
c002bb11:	83 c4 10             	add    $0x10,%esp
  msg ("If successful, product of iteration count and");
c002bb14:	83 ec 0c             	sub    $0xc,%esp
c002bb17:	68 5c 16 03 c0       	push   $0xc003165c
c002bb1c:	e8 a1 fe ff ff       	call   c002b9c2 <msg>
c002bb21:	83 c4 10             	add    $0x10,%esp
  msg ("sleep duration will appear in nondescending order.");
c002bb24:	83 ec 0c             	sub    $0xc,%esp
c002bb27:	68 8c 16 03 c0       	push   $0xc003168c
c002bb2c:	e8 91 fe ff ff       	call   c002b9c2 <msg>
c002bb31:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  threads = malloc (sizeof *threads * thread_cnt);
c002bb34:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb37:	c1 e0 04             	shl    $0x4,%eax
c002bb3a:	83 ec 0c             	sub    $0xc,%esp
c002bb3d:	50                   	push   %eax
c002bb3e:	e8 48 79 ff ff       	call   c002348b <malloc>
c002bb43:	83 c4 10             	add    $0x10,%esp
c002bb46:	89 45 e8             	mov    %eax,-0x18(%ebp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002bb49:	8b 55 0c             	mov    0xc(%ebp),%edx
c002bb4c:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb4f:	0f af c2             	imul   %edx,%eax
c002bb52:	c1 e0 03             	shl    $0x3,%eax
c002bb55:	83 ec 0c             	sub    $0xc,%esp
c002bb58:	50                   	push   %eax
c002bb59:	e8 2d 79 ff ff       	call   c002348b <malloc>
c002bb5e:	83 c4 10             	add    $0x10,%esp
c002bb61:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (threads == NULL || output == NULL)
c002bb64:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002bb68:	74 06                	je     c002bb70 <test_sleep+0xc4>
c002bb6a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002bb6e:	75 16                	jne    c002bb86 <test_sleep+0xda>
    PANIC ("couldn't allocate memory for test");
c002bb70:	68 c0 16 03 c0       	push   $0xc00316c0
c002bb75:	68 a4 17 03 c0       	push   $0xc00317a4
c002bb7a:	6a 48                	push   $0x48
c002bb7c:	68 b8 15 03 c0       	push   $0xc00315b8
c002bb81:	e8 ab da ff ff       	call   c0029631 <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002bb86:	e8 45 81 ff ff       	call   c0023cd0 <timer_ticks>
c002bb8b:	83 c0 64             	add    $0x64,%eax
c002bb8e:	83 d2 00             	adc    $0x0,%edx
c002bb91:	89 45 b0             	mov    %eax,-0x50(%ebp)
c002bb94:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  test.iterations = iterations;
c002bb97:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bb9a:	89 45 b8             	mov    %eax,-0x48(%ebp)
  lock_init (&test.output_lock);
c002bb9d:	83 ec 0c             	sub    $0xc,%esp
c002bba0:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002bba3:	83 c0 0c             	add    $0xc,%eax
c002bba6:	50                   	push   %eax
c002bba7:	e8 c9 6e ff ff       	call   c0022a75 <lock_init>
c002bbac:	83 c4 10             	add    $0x10,%esp
  test.output_pos = output;
c002bbaf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002bbb2:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002bbb5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002bbb9:	75 1e                	jne    c002bbd9 <test_sleep+0x12d>
c002bbbb:	83 ec 0c             	sub    $0xc,%esp
c002bbbe:	68 e2 16 03 c0       	push   $0xc00316e2
c002bbc3:	68 9e 15 03 c0       	push   $0xc003159e
c002bbc8:	68 a4 17 03 c0       	push   $0xc00317a4
c002bbcd:	6a 51                	push   $0x51
c002bbcf:	68 b8 15 03 c0       	push   $0xc00315b8
c002bbd4:	e8 58 da ff ff       	call   c0029631 <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002bbd9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002bbe0:	eb 72                	jmp    c002bc54 <test_sleep+0x1a8>
    {
      struct sleep_thread *t = threads + i;
c002bbe2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bbe5:	c1 e0 04             	shl    $0x4,%eax
c002bbe8:	89 c2                	mov    %eax,%edx
c002bbea:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bbed:	01 d0                	add    %edx,%eax
c002bbef:	89 45 e0             	mov    %eax,-0x20(%ebp)
      char name[16];
      
      t->test = &test;
c002bbf2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bbf5:	8d 55 b0             	lea    -0x50(%ebp),%edx
c002bbf8:	89 10                	mov    %edx,(%eax)
      t->id = i;
c002bbfa:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bbfd:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002bc00:	89 50 04             	mov    %edx,0x4(%eax)
      t->duration = (i + 1) * 10;
c002bc03:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bc06:	8d 50 01             	lea    0x1(%eax),%edx
c002bc09:	89 d0                	mov    %edx,%eax
c002bc0b:	c1 e0 02             	shl    $0x2,%eax
c002bc0e:	01 d0                	add    %edx,%eax
c002bc10:	01 c0                	add    %eax,%eax
c002bc12:	89 c2                	mov    %eax,%edx
c002bc14:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bc17:	89 50 08             	mov    %edx,0x8(%eax)
      t->iterations = 0;
c002bc1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bc1d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

      snprintf (name, sizeof name, "thread %d", i);
c002bc24:	ff 75 ec             	pushl  -0x14(%ebp)
c002bc27:	68 f1 16 03 c0       	push   $0xc00316f1
c002bc2c:	6a 10                	push   $0x10
c002bc2e:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bc31:	50                   	push   %eax
c002bc32:	e8 9e b5 ff ff       	call   c00271d5 <snprintf>
c002bc37:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, t);
c002bc3a:	ff 75 e0             	pushl  -0x20(%ebp)
c002bc3d:	68 ea bd 02 c0       	push   $0xc002bdea
c002bc42:	6a 1f                	push   $0x1f
c002bc44:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bc47:	50                   	push   %eax
c002bc48:	e8 1b 4e ff ff       	call   c0020a68 <thread_create>
c002bc4d:	83 c4 10             	add    $0x10,%esp
  lock_init (&test.output_lock);
  test.output_pos = output;

  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
c002bc50:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002bc54:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bc57:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bc5a:	7c 86                	jl     c002bbe2 <test_sleep+0x136>
      snprintf (name, sizeof name, "thread %d", i);
      thread_create (name, PRI_DEFAULT, sleeper, t);
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002bc5c:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc5f:	0f af 45 0c          	imul   0xc(%ebp),%eax
c002bc63:	89 c2                	mov    %eax,%edx
c002bc65:	89 d0                	mov    %edx,%eax
c002bc67:	c1 e0 02             	shl    $0x2,%eax
c002bc6a:	01 d0                	add    %edx,%eax
c002bc6c:	01 c0                	add    %eax,%eax
c002bc6e:	05 c8 00 00 00       	add    $0xc8,%eax
c002bc73:	99                   	cltd   
c002bc74:	83 ec 08             	sub    $0x8,%esp
c002bc77:	52                   	push   %edx
c002bc78:	50                   	push   %eax
c002bc79:	e8 a6 80 ff ff       	call   c0023d24 <timer_sleep>
c002bc7e:	83 c4 10             	add    $0x10,%esp

  /* Acquire the output lock in case some rogue thread is still
     running. */
  lock_acquire (&test.output_lock);
c002bc81:	83 ec 0c             	sub    $0xc,%esp
c002bc84:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002bc87:	83 c0 0c             	add    $0xc,%eax
c002bc8a:	50                   	push   %eax
c002bc8b:	e8 32 6e ff ff       	call   c0022ac2 <lock_acquire>
c002bc90:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  product = 0;
c002bc93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (op = output; op < test.output_pos; op++) 
c002bc9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002bc9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002bca0:	e9 ba 00 00 00       	jmp    c002bd5f <test_sleep+0x2b3>
    {
      struct sleep_thread *t;
      int new_prod;

      ASSERT (*op >= 0 && *op < thread_cnt);
c002bca5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bca8:	8b 00                	mov    (%eax),%eax
c002bcaa:	85 c0                	test   %eax,%eax
c002bcac:	78 0a                	js     c002bcb8 <test_sleep+0x20c>
c002bcae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bcb1:	8b 00                	mov    (%eax),%eax
c002bcb3:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bcb6:	7c 1e                	jl     c002bcd6 <test_sleep+0x22a>
c002bcb8:	83 ec 0c             	sub    $0xc,%esp
c002bcbb:	68 fb 16 03 c0       	push   $0xc00316fb
c002bcc0:	68 9e 15 03 c0       	push   $0xc003159e
c002bcc5:	68 a4 17 03 c0       	push   $0xc00317a4
c002bcca:	6a 6e                	push   $0x6e
c002bccc:	68 b8 15 03 c0       	push   $0xc00315b8
c002bcd1:	e8 5b d9 ff ff       	call   c0029631 <debug_panic>
      t = threads + *op;
c002bcd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bcd9:	8b 00                	mov    (%eax),%eax
c002bcdb:	c1 e0 04             	shl    $0x4,%eax
c002bcde:	89 c2                	mov    %eax,%edx
c002bce0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bce3:	01 d0                	add    %edx,%eax
c002bce5:	89 45 dc             	mov    %eax,-0x24(%ebp)

      new_prod = ++t->iterations * t->duration;
c002bce8:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bceb:	8b 40 0c             	mov    0xc(%eax),%eax
c002bcee:	8d 50 01             	lea    0x1(%eax),%edx
c002bcf1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bcf4:	89 50 0c             	mov    %edx,0xc(%eax)
c002bcf7:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bcfa:	8b 50 0c             	mov    0xc(%eax),%edx
c002bcfd:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bd00:	8b 40 08             	mov    0x8(%eax),%eax
c002bd03:	0f af c2             	imul   %edx,%eax
c002bd06:	89 45 d8             	mov    %eax,-0x28(%ebp)
        
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002bd09:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bd0c:	8b 48 0c             	mov    0xc(%eax),%ecx
c002bd0f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bd12:	8b 50 08             	mov    0x8(%eax),%edx
c002bd15:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bd18:	8b 40 04             	mov    0x4(%eax),%eax
c002bd1b:	83 ec 0c             	sub    $0xc,%esp
c002bd1e:	ff 75 d8             	pushl  -0x28(%ebp)
c002bd21:	51                   	push   %ecx
c002bd22:	52                   	push   %edx
c002bd23:	50                   	push   %eax
c002bd24:	68 18 17 03 c0       	push   $0xc0031718
c002bd29:	e8 94 fc ff ff       	call   c002b9c2 <msg>
c002bd2e:	83 c4 20             	add    $0x20,%esp
           t->id, t->duration, t->iterations, new_prod);
      
      if (new_prod >= product)
c002bd31:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002bd34:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002bd37:	7c 08                	jl     c002bd41 <test_sleep+0x295>
        product = new_prod;
c002bd39:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002bd3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002bd3f:	eb 1a                	jmp    c002bd5b <test_sleep+0x2af>
      else
        fail ("thread %d woke up out of order (%d > %d)!",
c002bd41:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bd44:	8b 40 04             	mov    0x4(%eax),%eax
c002bd47:	ff 75 d8             	pushl  -0x28(%ebp)
c002bd4a:	ff 75 f0             	pushl  -0x10(%ebp)
c002bd4d:	50                   	push   %eax
c002bd4e:	68 4c 17 03 c0       	push   $0xc003174c
c002bd53:	e8 ae fc ff ff       	call   c002ba06 <fail>
c002bd58:	83 c4 10             	add    $0x10,%esp
     running. */
  lock_acquire (&test.output_lock);

  /* Print completion order. */
  product = 0;
  for (op = output; op < test.output_pos; op++) 
c002bd5b:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002bd5f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002bd62:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002bd65:	0f 87 3a ff ff ff    	ja     c002bca5 <test_sleep+0x1f9>
        fail ("thread %d woke up out of order (%d > %d)!",
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c002bd6b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002bd72:	eb 3d                	jmp    c002bdb1 <test_sleep+0x305>
    if (threads[i].iterations != iterations)
c002bd74:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd77:	c1 e0 04             	shl    $0x4,%eax
c002bd7a:	89 c2                	mov    %eax,%edx
c002bd7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bd7f:	01 d0                	add    %edx,%eax
c002bd81:	8b 40 0c             	mov    0xc(%eax),%eax
c002bd84:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002bd87:	74 24                	je     c002bdad <test_sleep+0x301>
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
c002bd89:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd8c:	c1 e0 04             	shl    $0x4,%eax
c002bd8f:	89 c2                	mov    %eax,%edx
c002bd91:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bd94:	01 d0                	add    %edx,%eax
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
    if (threads[i].iterations != iterations)
      fail ("thread %d woke up %d times instead of %d",
c002bd96:	8b 40 0c             	mov    0xc(%eax),%eax
c002bd99:	ff 75 0c             	pushl  0xc(%ebp)
c002bd9c:	50                   	push   %eax
c002bd9d:	ff 75 ec             	pushl  -0x14(%ebp)
c002bda0:	68 78 17 03 c0       	push   $0xc0031778
c002bda5:	e8 5c fc ff ff       	call   c002ba06 <fail>
c002bdaa:	83 c4 10             	add    $0x10,%esp
        fail ("thread %d woke up out of order (%d > %d)!",
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c002bdad:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002bdb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bdb4:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bdb7:	7c bb                	jl     c002bd74 <test_sleep+0x2c8>
    if (threads[i].iterations != iterations)
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
  
  lock_release (&test.output_lock);
c002bdb9:	83 ec 0c             	sub    $0xc,%esp
c002bdbc:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002bdbf:	83 c0 0c             	add    $0xc,%eax
c002bdc2:	50                   	push   %eax
c002bdc3:	e8 3b 6e ff ff       	call   c0022c03 <lock_release>
c002bdc8:	83 c4 10             	add    $0x10,%esp
  free (output);
c002bdcb:	83 ec 0c             	sub    $0xc,%esp
c002bdce:	ff 75 e4             	pushl  -0x1c(%ebp)
c002bdd1:	e8 ae 79 ff ff       	call   c0023784 <free>
c002bdd6:	83 c4 10             	add    $0x10,%esp
  free (threads);
c002bdd9:	83 ec 0c             	sub    $0xc,%esp
c002bddc:	ff 75 e8             	pushl  -0x18(%ebp)
c002bddf:	e8 a0 79 ff ff       	call   c0023784 <free>
c002bde4:	83 c4 10             	add    $0x10,%esp
}
c002bde7:	90                   	nop
c002bde8:	c9                   	leave  
c002bde9:	c3                   	ret    

c002bdea <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c002bdea:	55                   	push   %ebp
c002bdeb:	89 e5                	mov    %esp,%ebp
c002bded:	53                   	push   %ebx
c002bdee:	83 ec 24             	sub    $0x24,%esp
  struct sleep_thread *t = t_;
c002bdf1:	8b 45 08             	mov    0x8(%ebp),%eax
c002bdf4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct sleep_test *test = t->test;
c002bdf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bdfa:	8b 00                	mov    (%eax),%eax
c002bdfc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002bdff:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002be06:	eb 7c                	jmp    c002be84 <sleeper+0x9a>
    {
      int64_t sleep_until = test->start + i * t->duration;
c002be08:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002be0b:	8b 08                	mov    (%eax),%ecx
c002be0d:	8b 58 04             	mov    0x4(%eax),%ebx
c002be10:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002be13:	8b 40 08             	mov    0x8(%eax),%eax
c002be16:	0f af 45 f4          	imul   -0xc(%ebp),%eax
c002be1a:	99                   	cltd   
c002be1b:	01 c8                	add    %ecx,%eax
c002be1d:	11 da                	adc    %ebx,%edx
c002be1f:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002be22:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002be25:	e8 a6 7e ff ff       	call   c0023cd0 <timer_ticks>
c002be2a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002be2d:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002be30:	29 c1                	sub    %eax,%ecx
c002be32:	19 d3                	sbb    %edx,%ebx
c002be34:	89 c8                	mov    %ecx,%eax
c002be36:	89 da                	mov    %ebx,%edx
c002be38:	83 ec 08             	sub    $0x8,%esp
c002be3b:	52                   	push   %edx
c002be3c:	50                   	push   %eax
c002be3d:	e8 e2 7e ff ff       	call   c0023d24 <timer_sleep>
c002be42:	83 c4 10             	add    $0x10,%esp
      lock_acquire (&test->output_lock);
c002be45:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002be48:	83 c0 0c             	add    $0xc,%eax
c002be4b:	83 ec 0c             	sub    $0xc,%esp
c002be4e:	50                   	push   %eax
c002be4f:	e8 6e 6c ff ff       	call   c0022ac2 <lock_acquire>
c002be54:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = t->id;
c002be57:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002be5a:	8b 40 24             	mov    0x24(%eax),%eax
c002be5d:	8d 48 04             	lea    0x4(%eax),%ecx
c002be60:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002be63:	89 4a 24             	mov    %ecx,0x24(%edx)
c002be66:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002be69:	8b 52 04             	mov    0x4(%edx),%edx
c002be6c:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c002be6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002be71:	83 c0 0c             	add    $0xc,%eax
c002be74:	83 ec 0c             	sub    $0xc,%esp
c002be77:	50                   	push   %eax
c002be78:	e8 86 6d ff ff       	call   c0022c03 <lock_release>
c002be7d:	83 c4 10             	add    $0x10,%esp
{
  struct sleep_thread *t = t_;
  struct sleep_test *test = t->test;
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002be80:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002be84:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002be87:	8b 40 08             	mov    0x8(%eax),%eax
c002be8a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002be8d:	0f 8d 75 ff ff ff    	jge    c002be08 <sleeper+0x1e>
      timer_sleep (sleep_until - timer_ticks ());
      lock_acquire (&test->output_lock);
      *test->output_pos++ = t->id;
      lock_release (&test->output_lock);
    }
}
c002be93:	90                   	nop
c002be94:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002be97:	c9                   	leave  
c002be98:	c3                   	ret    

c002be99 <test_alarm_simultaneous>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_simultaneous (void) 
{
c002be99:	55                   	push   %ebp
c002be9a:	89 e5                	mov    %esp,%ebp
c002be9c:	83 ec 08             	sub    $0x8,%esp
  test_sleep (3, 5);
c002be9f:	83 ec 08             	sub    $0x8,%esp
c002bea2:	6a 05                	push   $0x5
c002bea4:	6a 03                	push   $0x3
c002bea6:	e8 06 00 00 00       	call   c002beb1 <test_sleep>
c002beab:	83 c4 10             	add    $0x10,%esp
}
c002beae:	90                   	nop
c002beaf:	c9                   	leave  
c002beb0:	c3                   	ret    

c002beb1 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002beb1:	55                   	push   %ebp
c002beb2:	89 e5                	mov    %esp,%ebp
c002beb4:	53                   	push   %ebx
c002beb5:	83 ec 34             	sub    $0x34,%esp
  struct sleep_test test;
  int *output;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002beb8:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002bebf:	83 f0 01             	xor    $0x1,%eax
c002bec2:	84 c0                	test   %al,%al
c002bec4:	75 1e                	jne    c002bee4 <test_sleep+0x33>
c002bec6:	83 ec 0c             	sub    $0xc,%esp
c002bec9:	68 b0 17 03 c0       	push   $0xc00317b0
c002bece:	68 be 17 03 c0       	push   $0xc00317be
c002bed3:	68 38 19 03 c0       	push   $0xc0031938
c002bed8:	6a 28                	push   $0x28
c002beda:	68 d8 17 03 c0       	push   $0xc00317d8
c002bedf:	e8 4d d7 ff ff       	call   c0029631 <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002bee4:	83 ec 04             	sub    $0x4,%esp
c002bee7:	ff 75 0c             	pushl  0xc(%ebp)
c002beea:	ff 75 08             	pushl  0x8(%ebp)
c002beed:	68 04 18 03 c0       	push   $0xc0031804
c002bef2:	e8 cb fa ff ff       	call   c002b9c2 <msg>
c002bef7:	83 c4 10             	add    $0x10,%esp
  msg ("Each thread sleeps 10 ticks each time.");
c002befa:	83 ec 0c             	sub    $0xc,%esp
c002befd:	68 30 18 03 c0       	push   $0xc0031830
c002bf02:	e8 bb fa ff ff       	call   c002b9c2 <msg>
c002bf07:	83 c4 10             	add    $0x10,%esp
  msg ("Within an iteration, all threads should wake up on the same tick.");
c002bf0a:	83 ec 0c             	sub    $0xc,%esp
c002bf0d:	68 58 18 03 c0       	push   $0xc0031858
c002bf12:	e8 ab fa ff ff       	call   c002b9c2 <msg>
c002bf17:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002bf1a:	8b 55 0c             	mov    0xc(%ebp),%edx
c002bf1d:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf20:	0f af c2             	imul   %edx,%eax
c002bf23:	c1 e0 03             	shl    $0x3,%eax
c002bf26:	83 ec 0c             	sub    $0xc,%esp
c002bf29:	50                   	push   %eax
c002bf2a:	e8 5c 75 ff ff       	call   c002348b <malloc>
c002bf2f:	83 c4 10             	add    $0x10,%esp
c002bf32:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (output == NULL)
c002bf35:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002bf39:	75 16                	jne    c002bf51 <test_sleep+0xa0>
    PANIC ("couldn't allocate memory for test");
c002bf3b:	68 9c 18 03 c0       	push   $0xc003189c
c002bf40:	68 38 19 03 c0       	push   $0xc0031938
c002bf45:	6a 31                	push   $0x31
c002bf47:	68 d8 17 03 c0       	push   $0xc00317d8
c002bf4c:	e8 e0 d6 ff ff       	call   c0029631 <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002bf51:	e8 7a 7d ff ff       	call   c0023cd0 <timer_ticks>
c002bf56:	83 c0 64             	add    $0x64,%eax
c002bf59:	83 d2 00             	adc    $0x0,%edx
c002bf5c:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002bf5f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  test.iterations = iterations;
c002bf62:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bf65:	89 45 e8             	mov    %eax,-0x18(%ebp)
  test.output_pos = output;
c002bf68:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf6b:	89 45 ec             	mov    %eax,-0x14(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002bf6e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002bf72:	75 1e                	jne    c002bf92 <test_sleep+0xe1>
c002bf74:	83 ec 0c             	sub    $0xc,%esp
c002bf77:	68 be 18 03 c0       	push   $0xc00318be
c002bf7c:	68 be 17 03 c0       	push   $0xc00317be
c002bf81:	68 38 19 03 c0       	push   $0xc0031938
c002bf86:	6a 39                	push   $0x39
c002bf88:	68 d8 17 03 c0       	push   $0xc00317d8
c002bf8d:	e8 9f d6 ff ff       	call   c0029631 <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002bf92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002bf99:	eb 31                	jmp    c002bfcc <test_sleep+0x11b>
    {
      char name[16];
      snprintf (name, sizeof name, "thread %d", i);
c002bf9b:	ff 75 f4             	pushl  -0xc(%ebp)
c002bf9e:	68 cd 18 03 c0       	push   $0xc00318cd
c002bfa3:	6a 10                	push   $0x10
c002bfa5:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002bfa8:	50                   	push   %eax
c002bfa9:	e8 27 b2 ff ff       	call   c00271d5 <snprintf>
c002bfae:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002bfb1:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002bfb4:	50                   	push   %eax
c002bfb5:	68 89 c0 02 c0       	push   $0xc002c089
c002bfba:	6a 1f                	push   $0x1f
c002bfbc:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002bfbf:	50                   	push   %eax
c002bfc0:	e8 a3 4a ff ff       	call   c0020a68 <thread_create>
c002bfc5:	83 c4 10             	add    $0x10,%esp
  test.iterations = iterations;
  test.output_pos = output;

  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
c002bfc8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002bfcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bfcf:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bfd2:	7c c7                	jl     c002bf9b <test_sleep+0xea>
      snprintf (name, sizeof name, "thread %d", i);
      thread_create (name, PRI_DEFAULT, sleeper, &test);
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);
c002bfd4:	8b 55 0c             	mov    0xc(%ebp),%edx
c002bfd7:	89 d0                	mov    %edx,%eax
c002bfd9:	c1 e0 02             	shl    $0x2,%eax
c002bfdc:	01 d0                	add    %edx,%eax
c002bfde:	01 c0                	add    %eax,%eax
c002bfe0:	05 c8 00 00 00       	add    $0xc8,%eax
c002bfe5:	99                   	cltd   
c002bfe6:	83 ec 08             	sub    $0x8,%esp
c002bfe9:	52                   	push   %edx
c002bfea:	50                   	push   %eax
c002bfeb:	e8 34 7d ff ff       	call   c0023d24 <timer_sleep>
c002bff0:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c002bff3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bff6:	8b 00                	mov    (%eax),%eax
c002bff8:	83 ec 08             	sub    $0x8,%esp
c002bffb:	50                   	push   %eax
c002bffc:	68 d8 18 03 c0       	push   $0xc00318d8
c002c001:	e8 bc f9 ff ff       	call   c002b9c2 <msg>
c002c006:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002c009:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002c010:	eb 4f                	jmp    c002c061 <test_sleep+0x1b0>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
c002c012:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c015:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c01c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c01f:	01 d0                	add    %edx,%eax
c002c021:	8b 10                	mov    (%eax),%edx
c002c023:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c026:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
c002c02b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c002c032:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c035:	01 c8                	add    %ecx,%eax
c002c037:	8b 00                	mov    (%eax),%eax
  timer_sleep (100 + iterations * 10 + 100);

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
  for (i = 1; i < test.output_pos - output; i++) 
    msg ("iteration %d, thread %d: woke up %d ticks later",
c002c039:	89 d1                	mov    %edx,%ecx
c002c03b:	29 c1                	sub    %eax,%ecx
c002c03d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c040:	99                   	cltd   
c002c041:	f7 7d 08             	idivl  0x8(%ebp)
c002c044:	89 d3                	mov    %edx,%ebx
c002c046:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c049:	99                   	cltd   
c002c04a:	f7 7d 08             	idivl  0x8(%ebp)
c002c04d:	51                   	push   %ecx
c002c04e:	53                   	push   %ebx
c002c04f:	50                   	push   %eax
c002c050:	68 08 19 03 c0       	push   $0xc0031908
c002c055:	e8 68 f9 ff ff       	call   c002b9c2 <msg>
c002c05a:	83 c4 10             	add    $0x10,%esp
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
  for (i = 1; i < test.output_pos - output; i++) 
c002c05d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c061:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c064:	89 c2                	mov    %eax,%edx
c002c066:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c069:	29 c2                	sub    %eax,%edx
c002c06b:	89 d0                	mov    %edx,%eax
c002c06d:	c1 f8 02             	sar    $0x2,%eax
c002c070:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c073:	7f 9d                	jg     c002c012 <test_sleep+0x161>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
  
  free (output);
c002c075:	83 ec 0c             	sub    $0xc,%esp
c002c078:	ff 75 f0             	pushl  -0x10(%ebp)
c002c07b:	e8 04 77 ff ff       	call   c0023784 <free>
c002c080:	83 c4 10             	add    $0x10,%esp
}
c002c083:	90                   	nop
c002c084:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c087:	c9                   	leave  
c002c088:	c3                   	ret    

c002c089 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c002c089:	55                   	push   %ebp
c002c08a:	89 e5                	mov    %esp,%ebp
c002c08c:	53                   	push   %ebx
c002c08d:	83 ec 14             	sub    $0x14,%esp
  struct sleep_test *test = test_;
c002c090:	8b 45 08             	mov    0x8(%ebp),%eax
c002c093:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c002c096:	83 ec 08             	sub    $0x8,%esp
c002c099:	6a 00                	push   $0x0
c002c09b:	6a 01                	push   $0x1
c002c09d:	e8 82 7c ff ff       	call   c0023d24 <timer_sleep>
c002c0a2:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i <= test->iterations; i++) 
c002c0a5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002c0ac:	eb 6c                	jmp    c002c11a <sleeper+0x91>
    {
      int64_t sleep_until = test->start + i * 10;
c002c0ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c0b1:	8b 08                	mov    (%eax),%ecx
c002c0b3:	8b 58 04             	mov    0x4(%eax),%ebx
c002c0b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002c0b9:	89 d0                	mov    %edx,%eax
c002c0bb:	c1 e0 02             	shl    $0x2,%eax
c002c0be:	01 d0                	add    %edx,%eax
c002c0c0:	01 c0                	add    %eax,%eax
c002c0c2:	99                   	cltd   
c002c0c3:	01 c8                	add    %ecx,%eax
c002c0c5:	11 da                	adc    %ebx,%edx
c002c0c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002c0ca:	89 55 ec             	mov    %edx,-0x14(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002c0cd:	e8 fe 7b ff ff       	call   c0023cd0 <timer_ticks>
c002c0d2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002c0d5:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002c0d8:	29 c1                	sub    %eax,%ecx
c002c0da:	19 d3                	sbb    %edx,%ebx
c002c0dc:	89 c8                	mov    %ecx,%eax
c002c0de:	89 da                	mov    %ebx,%edx
c002c0e0:	83 ec 08             	sub    $0x8,%esp
c002c0e3:	52                   	push   %edx
c002c0e4:	50                   	push   %eax
c002c0e5:	e8 3a 7c ff ff       	call   c0023d24 <timer_sleep>
c002c0ea:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = timer_ticks () - test->start;
c002c0ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c0f0:	8b 58 0c             	mov    0xc(%eax),%ebx
c002c0f3:	8d 53 04             	lea    0x4(%ebx),%edx
c002c0f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c0f9:	89 50 0c             	mov    %edx,0xc(%eax)
c002c0fc:	e8 cf 7b ff ff       	call   c0023cd0 <timer_ticks>
c002c101:	89 c1                	mov    %eax,%ecx
c002c103:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c106:	8b 50 04             	mov    0x4(%eax),%edx
c002c109:	8b 00                	mov    (%eax),%eax
c002c10b:	29 c1                	sub    %eax,%ecx
c002c10d:	89 c8                	mov    %ecx,%eax
c002c10f:	89 03                	mov    %eax,(%ebx)
      thread_yield ();
c002c111:	e8 61 4c ff ff       	call   c0020d77 <thread_yield>
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);

  for (i = 1; i <= test->iterations; i++) 
c002c116:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c11a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c11d:	8b 40 08             	mov    0x8(%eax),%eax
c002c120:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c123:	7d 89                	jge    c002c0ae <sleeper+0x25>
      int64_t sleep_until = test->start + i * 10;
      timer_sleep (sleep_until - timer_ticks ());
      *test->output_pos++ = timer_ticks () - test->start;
      thread_yield ();
    }
}
c002c125:	90                   	nop
c002c126:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c129:	c9                   	leave  
c002c12a:	c3                   	ret    

c002c12b <test_alarm_priority>:
static int64_t wake_time;
static struct semaphore wait_sema;

void
test_alarm_priority (void) 
{
c002c12b:	55                   	push   %ebp
c002c12c:	89 e5                	mov    %esp,%ebp
c002c12e:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c131:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002c138:	83 f0 01             	xor    $0x1,%eax
c002c13b:	84 c0                	test   %al,%al
c002c13d:	75 1e                	jne    c002c15d <test_alarm_priority+0x32>
c002c13f:	83 ec 0c             	sub    $0xc,%esp
c002c142:	68 44 19 03 c0       	push   $0xc0031944
c002c147:	68 52 19 03 c0       	push   $0xc0031952
c002c14c:	68 b0 19 03 c0       	push   $0xc00319b0
c002c151:	6a 16                	push   $0x16
c002c153:	68 6c 19 03 c0       	push   $0xc003196c
c002c158:	e8 d4 d4 ff ff       	call   c0029631 <debug_panic>

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c002c15d:	e8 6e 7b ff ff       	call   c0023cd0 <timer_ticks>
c002c162:	05 f4 01 00 00       	add    $0x1f4,%eax
c002c167:	83 d2 00             	adc    $0x0,%edx
c002c16a:	a3 18 9c 03 c0       	mov    %eax,0xc0039c18
c002c16f:	89 15 1c 9c 03 c0    	mov    %edx,0xc0039c1c
  sema_init (&wait_sema, 0);
c002c175:	83 ec 08             	sub    $0x8,%esp
c002c178:	6a 00                	push   $0x0
c002c17a:	68 20 9c 03 c0       	push   $0xc0039c20
c002c17f:	e8 36 66 ff ff       	call   c00227ba <sema_init>
c002c184:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 10; i++) 
c002c187:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c18e:	eb 60                	jmp    c002c1f0 <test_alarm_priority+0xc5>
    {
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002c190:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c193:	8d 48 05             	lea    0x5(%eax),%ecx
c002c196:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002c19b:	89 c8                	mov    %ecx,%eax
c002c19d:	f7 ea                	imul   %edx
c002c19f:	c1 fa 02             	sar    $0x2,%edx
c002c1a2:	89 c8                	mov    %ecx,%eax
c002c1a4:	c1 f8 1f             	sar    $0x1f,%eax
c002c1a7:	29 c2                	sub    %eax,%edx
c002c1a9:	89 d0                	mov    %edx,%eax
c002c1ab:	c1 e0 02             	shl    $0x2,%eax
c002c1ae:	01 d0                	add    %edx,%eax
c002c1b0:	01 c0                	add    %eax,%eax
c002c1b2:	29 c1                	sub    %eax,%ecx
c002c1b4:	89 ca                	mov    %ecx,%edx
c002c1b6:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002c1bb:	29 d0                	sub    %edx,%eax
c002c1bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002c1c0:	ff 75 f0             	pushl  -0x10(%ebp)
c002c1c3:	68 91 19 03 c0       	push   $0xc0031991
c002c1c8:	6a 10                	push   $0x10
c002c1ca:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c1cd:	50                   	push   %eax
c002c1ce:	e8 02 b0 ff ff       	call   c00271d5 <snprintf>
c002c1d3:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, alarm_priority_thread, NULL);
c002c1d6:	6a 00                	push   $0x0
c002c1d8:	68 29 c2 02 c0       	push   $0xc002c229
c002c1dd:	ff 75 f0             	pushl  -0x10(%ebp)
c002c1e0:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c1e3:	50                   	push   %eax
c002c1e4:	e8 7f 48 ff ff       	call   c0020a68 <thread_create>
c002c1e9:	83 c4 10             	add    $0x10,%esp
  ASSERT (!thread_mlfqs);

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
  sema_init (&wait_sema, 0);
  
  for (i = 0; i < 10; i++) 
c002c1ec:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c1f0:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002c1f4:	7e 9a                	jle    c002c190 <test_alarm_priority+0x65>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, alarm_priority_thread, NULL);
    }

  thread_set_priority (PRI_MIN);
c002c1f6:	83 ec 0c             	sub    $0xc,%esp
c002c1f9:	6a 00                	push   $0x0
c002c1fb:	e8 86 4c ff ff       	call   c0020e86 <thread_set_priority>
c002c200:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 10; i++)
c002c203:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c20a:	eb 14                	jmp    c002c220 <test_alarm_priority+0xf5>
    sema_down (&wait_sema);
c002c20c:	83 ec 0c             	sub    $0xc,%esp
c002c20f:	68 20 9c 03 c0       	push   $0xc0039c20
c002c214:	e8 e8 65 ff ff       	call   c0022801 <sema_down>
c002c219:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, alarm_priority_thread, NULL);
    }

  thread_set_priority (PRI_MIN);

  for (i = 0; i < 10; i++)
c002c21c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c220:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002c224:	7e e6                	jle    c002c20c <test_alarm_priority+0xe1>
    sema_down (&wait_sema);
}
c002c226:	90                   	nop
c002c227:	c9                   	leave  
c002c228:	c3                   	ret    

c002c229 <alarm_priority_thread>:

static void
alarm_priority_thread (void *aux UNUSED) 
{
c002c229:	55                   	push   %ebp
c002c22a:	89 e5                	mov    %esp,%ebp
c002c22c:	56                   	push   %esi
c002c22d:	53                   	push   %ebx
c002c22e:	83 ec 10             	sub    $0x10,%esp
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c002c231:	e8 9a 7a ff ff       	call   c0023cd0 <timer_ticks>
c002c236:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c239:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) == 0)
c002c23c:	eb 01                	jmp    c002c23f <alarm_priority_thread+0x16>
    continue;
c002c23e:	90                   	nop
static void
alarm_priority_thread (void *aux UNUSED) 
{
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
  while (timer_elapsed (start_time) == 0)
c002c23f:	83 ec 08             	sub    $0x8,%esp
c002c242:	ff 75 f4             	pushl  -0xc(%ebp)
c002c245:	ff 75 f0             	pushl  -0x10(%ebp)
c002c248:	e8 b8 7a ff ff       	call   c0023d05 <timer_elapsed>
c002c24d:	83 c4 10             	add    $0x10,%esp
c002c250:	09 d0                	or     %edx,%eax
c002c252:	85 c0                	test   %eax,%eax
c002c254:	74 e8                	je     c002c23e <alarm_priority_thread+0x15>
    continue;

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c002c256:	8b 1d 18 9c 03 c0    	mov    0xc0039c18,%ebx
c002c25c:	8b 35 1c 9c 03 c0    	mov    0xc0039c1c,%esi
c002c262:	e8 69 7a ff ff       	call   c0023cd0 <timer_ticks>
c002c267:	29 c3                	sub    %eax,%ebx
c002c269:	19 d6                	sbb    %edx,%esi
c002c26b:	89 d8                	mov    %ebx,%eax
c002c26d:	89 f2                	mov    %esi,%edx
c002c26f:	83 ec 08             	sub    $0x8,%esp
c002c272:	52                   	push   %edx
c002c273:	50                   	push   %eax
c002c274:	e8 ab 7a ff ff       	call   c0023d24 <timer_sleep>
c002c279:	83 c4 10             	add    $0x10,%esp

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c002c27c:	e8 f0 49 ff ff       	call   c0020c71 <thread_name>
c002c281:	83 ec 08             	sub    $0x8,%esp
c002c284:	50                   	push   %eax
c002c285:	68 9d 19 03 c0       	push   $0xc003199d
c002c28a:	e8 33 f7 ff ff       	call   c002b9c2 <msg>
c002c28f:	83 c4 10             	add    $0x10,%esp

  sema_up (&wait_sema);
c002c292:	83 ec 0c             	sub    $0xc,%esp
c002c295:	68 20 9c 03 c0       	push   $0xc0039c20
c002c29a:	e8 6d 66 ff ff       	call   c002290c <sema_up>
c002c29f:	83 c4 10             	add    $0x10,%esp
}
c002c2a2:	90                   	nop
c002c2a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002c2a6:	5b                   	pop    %ebx
c002c2a7:	5e                   	pop    %esi
c002c2a8:	5d                   	pop    %ebp
c002c2a9:	c3                   	ret    

c002c2aa <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c002c2aa:	55                   	push   %ebp
c002c2ab:	89 e5                	mov    %esp,%ebp
c002c2ad:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (0);
c002c2b0:	83 ec 08             	sub    $0x8,%esp
c002c2b3:	6a 00                	push   $0x0
c002c2b5:	6a 00                	push   $0x0
c002c2b7:	e8 68 7a ff ff       	call   c0023d24 <timer_sleep>
c002c2bc:	83 c4 10             	add    $0x10,%esp
  pass ();
c002c2bf:	e8 99 f7 ff ff       	call   c002ba5d <pass>
}
c002c2c4:	90                   	nop
c002c2c5:	c9                   	leave  
c002c2c6:	c3                   	ret    

c002c2c7 <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c002c2c7:	55                   	push   %ebp
c002c2c8:	89 e5                	mov    %esp,%ebp
c002c2ca:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (-100);
c002c2cd:	83 ec 08             	sub    $0x8,%esp
c002c2d0:	6a ff                	push   $0xffffffff
c002c2d2:	6a 9c                	push   $0xffffff9c
c002c2d4:	e8 4b 7a ff ff       	call   c0023d24 <timer_sleep>
c002c2d9:	83 c4 10             	add    $0x10,%esp
  pass ();
c002c2dc:	e8 7c f7 ff ff       	call   c002ba5d <pass>
}
c002c2e1:	90                   	nop
c002c2e2:	c9                   	leave  
c002c2e3:	c3                   	ret    

c002c2e4 <test_priority_change>:

static thread_func changing_thread;

void
test_priority_change (void) 
{
c002c2e4:	55                   	push   %ebp
c002c2e5:	89 e5                	mov    %esp,%ebp
c002c2e7:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c2ea:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002c2f1:	83 f0 01             	xor    $0x1,%eax
c002c2f4:	84 c0                	test   %al,%al
c002c2f6:	75 1e                	jne    c002c316 <test_priority_change+0x32>
c002c2f8:	83 ec 0c             	sub    $0xc,%esp
c002c2fb:	68 c4 19 03 c0       	push   $0xc00319c4
c002c300:	68 d2 19 03 c0       	push   $0xc00319d2
c002c305:	68 c8 1a 03 c0       	push   $0xc0031ac8
c002c30a:	6a 10                	push   $0x10
c002c30c:	68 ec 19 03 c0       	push   $0xc00319ec
c002c311:	e8 1b d3 ff ff       	call   c0029631 <debug_panic>

  msg ("Creating a high-priority thread 2.");
c002c316:	83 ec 0c             	sub    $0xc,%esp
c002c319:	68 14 1a 03 c0       	push   $0xc0031a14
c002c31e:	e8 9f f6 ff ff       	call   c002b9c2 <msg>
c002c323:	83 c4 10             	add    $0x10,%esp
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c002c326:	6a 00                	push   $0x0
c002c328:	68 6c c3 02 c0       	push   $0xc002c36c
c002c32d:	6a 20                	push   $0x20
c002c32f:	68 37 1a 03 c0       	push   $0xc0031a37
c002c334:	e8 2f 47 ff ff       	call   c0020a68 <thread_create>
c002c339:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just lowered its priority.");
c002c33c:	83 ec 0c             	sub    $0xc,%esp
c002c33f:	68 40 1a 03 c0       	push   $0xc0031a40
c002c344:	e8 79 f6 ff ff       	call   c002b9c2 <msg>
c002c349:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 2);
c002c34c:	83 ec 0c             	sub    $0xc,%esp
c002c34f:	6a 1d                	push   $0x1d
c002c351:	e8 30 4b ff ff       	call   c0020e86 <thread_set_priority>
c002c356:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just exited.");
c002c359:	83 ec 0c             	sub    $0xc,%esp
c002c35c:	68 70 1a 03 c0       	push   $0xc0031a70
c002c361:	e8 5c f6 ff ff       	call   c002b9c2 <msg>
c002c366:	83 c4 10             	add    $0x10,%esp
}
c002c369:	90                   	nop
c002c36a:	c9                   	leave  
c002c36b:	c3                   	ret    

c002c36c <changing_thread>:

static void
changing_thread (void *aux UNUSED) 
{
c002c36c:	55                   	push   %ebp
c002c36d:	89 e5                	mov    %esp,%ebp
c002c36f:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread 2 now lowering priority.");
c002c372:	83 ec 0c             	sub    $0xc,%esp
c002c375:	68 94 1a 03 c0       	push   $0xc0031a94
c002c37a:	e8 43 f6 ff ff       	call   c002b9c2 <msg>
c002c37f:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 1);
c002c382:	83 ec 0c             	sub    $0xc,%esp
c002c385:	6a 1e                	push   $0x1e
c002c387:	e8 fa 4a ff ff       	call   c0020e86 <thread_set_priority>
c002c38c:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 exiting.");
c002c38f:	83 ec 0c             	sub    $0xc,%esp
c002c392:	68 b4 1a 03 c0       	push   $0xc0031ab4
c002c397:	e8 26 f6 ff ff       	call   c002b9c2 <msg>
c002c39c:	83 c4 10             	add    $0x10,%esp
}
c002c39f:	90                   	nop
c002c3a0:	c9                   	leave  
c002c3a1:	c3                   	ret    

c002c3a2 <test_priority_donate_one>:
static thread_func acquire1_thread_func;
static thread_func acquire2_thread_func;

void
test_priority_donate_one (void) 
{
c002c3a2:	55                   	push   %ebp
c002c3a3:	89 e5                	mov    %esp,%ebp
c002c3a5:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c3a8:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002c3af:	83 f0 01             	xor    $0x1,%eax
c002c3b2:	84 c0                	test   %al,%al
c002c3b4:	75 1e                	jne    c002c3d4 <test_priority_donate_one+0x32>
c002c3b6:	83 ec 0c             	sub    $0xc,%esp
c002c3b9:	68 e0 1a 03 c0       	push   $0xc0031ae0
c002c3be:	68 ee 1a 03 c0       	push   $0xc0031aee
c002c3c3:	68 70 1c 03 c0       	push   $0xc0031c70
c002c3c8:	6a 1b                	push   $0x1b
c002c3ca:	68 08 1b 03 c0       	push   $0xc0031b08
c002c3cf:	e8 5d d2 ff ff       	call   c0029631 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c3d4:	e8 c3 4a ff ff       	call   c0020e9c <thread_get_priority>
c002c3d9:	83 f8 1f             	cmp    $0x1f,%eax
c002c3dc:	74 1e                	je     c002c3fc <test_priority_donate_one+0x5a>
c002c3de:	83 ec 0c             	sub    $0xc,%esp
c002c3e1:	68 34 1b 03 c0       	push   $0xc0031b34
c002c3e6:	68 ee 1a 03 c0       	push   $0xc0031aee
c002c3eb:	68 70 1c 03 c0       	push   $0xc0031c70
c002c3f0:	6a 1e                	push   $0x1e
c002c3f2:	68 08 1b 03 c0       	push   $0xc0031b08
c002c3f7:	e8 35 d2 ff ff       	call   c0029631 <debug_panic>

  lock_init (&lock);
c002c3fc:	83 ec 0c             	sub    $0xc,%esp
c002c3ff:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c402:	50                   	push   %eax
c002c403:	e8 6d 66 ff ff       	call   c0022a75 <lock_init>
c002c408:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002c40b:	83 ec 0c             	sub    $0xc,%esp
c002c40e:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c411:	50                   	push   %eax
c002c412:	e8 ab 66 ff ff       	call   c0022ac2 <lock_acquire>
c002c417:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002c41a:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c41d:	50                   	push   %eax
c002c41e:	68 ac c4 02 c0       	push   $0xc002c4ac
c002c423:	6a 20                	push   $0x20
c002c425:	68 5a 1b 03 c0       	push   $0xc0031b5a
c002c42a:	e8 39 46 ff ff       	call   c0020a68 <thread_create>
c002c42f:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002c432:	e8 65 4a ff ff       	call   c0020e9c <thread_get_priority>
c002c437:	83 ec 04             	sub    $0x4,%esp
c002c43a:	50                   	push   %eax
c002c43b:	6a 20                	push   $0x20
c002c43d:	68 64 1b 03 c0       	push   $0xc0031b64
c002c442:	e8 7b f5 ff ff       	call   c002b9c2 <msg>
c002c447:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002c44a:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c44d:	50                   	push   %eax
c002c44e:	68 f7 c4 02 c0       	push   $0xc002c4f7
c002c453:	6a 21                	push   $0x21
c002c455:	68 9f 1b 03 c0       	push   $0xc0031b9f
c002c45a:	e8 09 46 ff ff       	call   c0020a68 <thread_create>
c002c45f:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002c462:	e8 35 4a ff ff       	call   c0020e9c <thread_get_priority>
c002c467:	83 ec 04             	sub    $0x4,%esp
c002c46a:	50                   	push   %eax
c002c46b:	6a 21                	push   $0x21
c002c46d:	68 64 1b 03 c0       	push   $0xc0031b64
c002c472:	e8 4b f5 ff ff       	call   c002b9c2 <msg>
c002c477:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  lock_release (&lock);
c002c47a:	83 ec 0c             	sub    $0xc,%esp
c002c47d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c480:	50                   	push   %eax
c002c481:	e8 7d 67 ff ff       	call   c0022c03 <lock_release>
c002c486:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002c489:	83 ec 0c             	sub    $0xc,%esp
c002c48c:	68 a8 1b 03 c0       	push   $0xc0031ba8
c002c491:	e8 2c f5 ff ff       	call   c002b9c2 <msg>
c002c496:	83 c4 10             	add    $0x10,%esp
  msg ("This should be the last line before finishing this test.");
c002c499:	83 ec 0c             	sub    $0xc,%esp
c002c49c:	68 e8 1b 03 c0       	push   $0xc0031be8
c002c4a1:	e8 1c f5 ff ff       	call   c002b9c2 <msg>
c002c4a6:	83 c4 10             	add    $0x10,%esp
}
c002c4a9:	90                   	nop
c002c4aa:	c9                   	leave  
c002c4ab:	c3                   	ret    

c002c4ac <acquire1_thread_func>:

static void
acquire1_thread_func (void *lock_) 
{
c002c4ac:	55                   	push   %ebp
c002c4ad:	89 e5                	mov    %esp,%ebp
c002c4af:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c4b2:	8b 45 08             	mov    0x8(%ebp),%eax
c002c4b5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c4b8:	83 ec 0c             	sub    $0xc,%esp
c002c4bb:	ff 75 f4             	pushl  -0xc(%ebp)
c002c4be:	e8 ff 65 ff ff       	call   c0022ac2 <lock_acquire>
c002c4c3:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: got the lock");
c002c4c6:	83 ec 0c             	sub    $0xc,%esp
c002c4c9:	68 21 1c 03 c0       	push   $0xc0031c21
c002c4ce:	e8 ef f4 ff ff       	call   c002b9c2 <msg>
c002c4d3:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c4d6:	83 ec 0c             	sub    $0xc,%esp
c002c4d9:	ff 75 f4             	pushl  -0xc(%ebp)
c002c4dc:	e8 22 67 ff ff       	call   c0022c03 <lock_release>
c002c4e1:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: done");
c002c4e4:	83 ec 0c             	sub    $0xc,%esp
c002c4e7:	68 38 1c 03 c0       	push   $0xc0031c38
c002c4ec:	e8 d1 f4 ff ff       	call   c002b9c2 <msg>
c002c4f1:	83 c4 10             	add    $0x10,%esp
}
c002c4f4:	90                   	nop
c002c4f5:	c9                   	leave  
c002c4f6:	c3                   	ret    

c002c4f7 <acquire2_thread_func>:

static void
acquire2_thread_func (void *lock_) 
{
c002c4f7:	55                   	push   %ebp
c002c4f8:	89 e5                	mov    %esp,%ebp
c002c4fa:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c4fd:	8b 45 08             	mov    0x8(%ebp),%eax
c002c500:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c503:	83 ec 0c             	sub    $0xc,%esp
c002c506:	ff 75 f4             	pushl  -0xc(%ebp)
c002c509:	e8 b4 65 ff ff       	call   c0022ac2 <lock_acquire>
c002c50e:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: got the lock");
c002c511:	83 ec 0c             	sub    $0xc,%esp
c002c514:	68 47 1c 03 c0       	push   $0xc0031c47
c002c519:	e8 a4 f4 ff ff       	call   c002b9c2 <msg>
c002c51e:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c521:	83 ec 0c             	sub    $0xc,%esp
c002c524:	ff 75 f4             	pushl  -0xc(%ebp)
c002c527:	e8 d7 66 ff ff       	call   c0022c03 <lock_release>
c002c52c:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: done");
c002c52f:	83 ec 0c             	sub    $0xc,%esp
c002c532:	68 5e 1c 03 c0       	push   $0xc0031c5e
c002c537:	e8 86 f4 ff ff       	call   c002b9c2 <msg>
c002c53c:	83 c4 10             	add    $0x10,%esp
}
c002c53f:	90                   	nop
c002c540:	c9                   	leave  
c002c541:	c3                   	ret    

c002c542 <test_priority_donate_multiple>:
static thread_func a_thread_func;
static thread_func b_thread_func;

void
test_priority_donate_multiple (void) 
{
c002c542:	55                   	push   %ebp
c002c543:	89 e5                	mov    %esp,%ebp
c002c545:	83 ec 38             	sub    $0x38,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c548:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002c54f:	83 f0 01             	xor    $0x1,%eax
c002c552:	84 c0                	test   %al,%al
c002c554:	75 1e                	jne    c002c574 <test_priority_donate_multiple+0x32>
c002c556:	83 ec 0c             	sub    $0xc,%esp
c002c559:	68 8c 1c 03 c0       	push   $0xc0031c8c
c002c55e:	68 9a 1c 03 c0       	push   $0xc0031c9a
c002c563:	68 f0 1d 03 c0       	push   $0xc0031df0
c002c568:	6a 1b                	push   $0x1b
c002c56a:	68 b4 1c 03 c0       	push   $0xc0031cb4
c002c56f:	e8 bd d0 ff ff       	call   c0029631 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c574:	e8 23 49 ff ff       	call   c0020e9c <thread_get_priority>
c002c579:	83 f8 1f             	cmp    $0x1f,%eax
c002c57c:	74 1e                	je     c002c59c <test_priority_donate_multiple+0x5a>
c002c57e:	83 ec 0c             	sub    $0xc,%esp
c002c581:	68 e4 1c 03 c0       	push   $0xc0031ce4
c002c586:	68 9a 1c 03 c0       	push   $0xc0031c9a
c002c58b:	68 f0 1d 03 c0       	push   $0xc0031df0
c002c590:	6a 1e                	push   $0x1e
c002c592:	68 b4 1c 03 c0       	push   $0xc0031cb4
c002c597:	e8 95 d0 ff ff       	call   c0029631 <debug_panic>

  lock_init (&a);
c002c59c:	83 ec 0c             	sub    $0xc,%esp
c002c59f:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c5a2:	50                   	push   %eax
c002c5a3:	e8 cd 64 ff ff       	call   c0022a75 <lock_init>
c002c5a8:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c5ab:	83 ec 0c             	sub    $0xc,%esp
c002c5ae:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c5b1:	50                   	push   %eax
c002c5b2:	e8 be 64 ff ff       	call   c0022a75 <lock_init>
c002c5b7:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c5ba:	83 ec 0c             	sub    $0xc,%esp
c002c5bd:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c5c0:	50                   	push   %eax
c002c5c1:	e8 fc 64 ff ff       	call   c0022ac2 <lock_acquire>
c002c5c6:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002c5c9:	83 ec 0c             	sub    $0xc,%esp
c002c5cc:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c5cf:	50                   	push   %eax
c002c5d0:	e8 ed 64 ff ff       	call   c0022ac2 <lock_acquire>
c002c5d5:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002c5d8:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c5db:	50                   	push   %eax
c002c5dc:	68 a9 c6 02 c0       	push   $0xc002c6a9
c002c5e1:	6a 20                	push   $0x20
c002c5e3:	68 0a 1d 03 c0       	push   $0xc0031d0a
c002c5e8:	e8 7b 44 ff ff       	call   c0020a68 <thread_create>
c002c5ed:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c5f0:	e8 a7 48 ff ff       	call   c0020e9c <thread_get_priority>
c002c5f5:	83 ec 04             	sub    $0x4,%esp
c002c5f8:	50                   	push   %eax
c002c5f9:	6a 20                	push   $0x20
c002c5fb:	68 0c 1d 03 c0       	push   $0xc0031d0c
c002c600:	e8 bd f3 ff ff       	call   c002b9c2 <msg>
c002c605:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002c608:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c60b:	50                   	push   %eax
c002c60c:	68 f4 c6 02 c0       	push   $0xc002c6f4
c002c611:	6a 21                	push   $0x21
c002c613:	68 47 1d 03 c0       	push   $0xc0031d47
c002c618:	e8 4b 44 ff ff       	call   c0020a68 <thread_create>
c002c61d:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c620:	e8 77 48 ff ff       	call   c0020e9c <thread_get_priority>
c002c625:	83 ec 04             	sub    $0x4,%esp
c002c628:	50                   	push   %eax
c002c629:	6a 21                	push   $0x21
c002c62b:	68 0c 1d 03 c0       	push   $0xc0031d0c
c002c630:	e8 8d f3 ff ff       	call   c002b9c2 <msg>
c002c635:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&b);
c002c638:	83 ec 0c             	sub    $0xc,%esp
c002c63b:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c63e:	50                   	push   %eax
c002c63f:	e8 bf 65 ff ff       	call   c0022c03 <lock_release>
c002c644:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b should have just finished.");
c002c647:	83 ec 0c             	sub    $0xc,%esp
c002c64a:	68 4c 1d 03 c0       	push   $0xc0031d4c
c002c64f:	e8 6e f3 ff ff       	call   c002b9c2 <msg>
c002c654:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c657:	e8 40 48 ff ff       	call   c0020e9c <thread_get_priority>
c002c65c:	83 ec 04             	sub    $0x4,%esp
c002c65f:	50                   	push   %eax
c002c660:	6a 20                	push   $0x20
c002c662:	68 0c 1d 03 c0       	push   $0xc0031d0c
c002c667:	e8 56 f3 ff ff       	call   c002b9c2 <msg>
c002c66c:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  lock_release (&a);
c002c66f:	83 ec 0c             	sub    $0xc,%esp
c002c672:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c675:	50                   	push   %eax
c002c676:	e8 88 65 ff ff       	call   c0022c03 <lock_release>
c002c67b:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a should have just finished.");
c002c67e:	83 ec 0c             	sub    $0xc,%esp
c002c681:	68 70 1d 03 c0       	push   $0xc0031d70
c002c686:	e8 37 f3 ff ff       	call   c002b9c2 <msg>
c002c68b:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c68e:	e8 09 48 ff ff       	call   c0020e9c <thread_get_priority>
c002c693:	83 ec 04             	sub    $0x4,%esp
c002c696:	50                   	push   %eax
c002c697:	6a 1f                	push   $0x1f
c002c699:	68 0c 1d 03 c0       	push   $0xc0031d0c
c002c69e:	e8 1f f3 ff ff       	call   c002b9c2 <msg>
c002c6a3:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002c6a6:	90                   	nop
c002c6a7:	c9                   	leave  
c002c6a8:	c3                   	ret    

c002c6a9 <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002c6a9:	55                   	push   %ebp
c002c6aa:	89 e5                	mov    %esp,%ebp
c002c6ac:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c6af:	8b 45 08             	mov    0x8(%ebp),%eax
c002c6b2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c6b5:	83 ec 0c             	sub    $0xc,%esp
c002c6b8:	ff 75 f4             	pushl  -0xc(%ebp)
c002c6bb:	e8 02 64 ff ff       	call   c0022ac2 <lock_acquire>
c002c6c0:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002c6c3:	83 ec 0c             	sub    $0xc,%esp
c002c6c6:	68 94 1d 03 c0       	push   $0xc0031d94
c002c6cb:	e8 f2 f2 ff ff       	call   c002b9c2 <msg>
c002c6d0:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c6d3:	83 ec 0c             	sub    $0xc,%esp
c002c6d6:	ff 75 f4             	pushl  -0xc(%ebp)
c002c6d9:	e8 25 65 ff ff       	call   c0022c03 <lock_release>
c002c6de:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002c6e1:	83 ec 0c             	sub    $0xc,%esp
c002c6e4:	68 ae 1d 03 c0       	push   $0xc0031dae
c002c6e9:	e8 d4 f2 ff ff       	call   c002b9c2 <msg>
c002c6ee:	83 c4 10             	add    $0x10,%esp
}
c002c6f1:	90                   	nop
c002c6f2:	c9                   	leave  
c002c6f3:	c3                   	ret    

c002c6f4 <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002c6f4:	55                   	push   %ebp
c002c6f5:	89 e5                	mov    %esp,%ebp
c002c6f7:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c6fa:	8b 45 08             	mov    0x8(%ebp),%eax
c002c6fd:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c700:	83 ec 0c             	sub    $0xc,%esp
c002c703:	ff 75 f4             	pushl  -0xc(%ebp)
c002c706:	e8 b7 63 ff ff       	call   c0022ac2 <lock_acquire>
c002c70b:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002c70e:	83 ec 0c             	sub    $0xc,%esp
c002c711:	68 c1 1d 03 c0       	push   $0xc0031dc1
c002c716:	e8 a7 f2 ff ff       	call   c002b9c2 <msg>
c002c71b:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c71e:	83 ec 0c             	sub    $0xc,%esp
c002c721:	ff 75 f4             	pushl  -0xc(%ebp)
c002c724:	e8 da 64 ff ff       	call   c0022c03 <lock_release>
c002c729:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002c72c:	83 ec 0c             	sub    $0xc,%esp
c002c72f:	68 db 1d 03 c0       	push   $0xc0031ddb
c002c734:	e8 89 f2 ff ff       	call   c002b9c2 <msg>
c002c739:	83 c4 10             	add    $0x10,%esp
}
c002c73c:	90                   	nop
c002c73d:	c9                   	leave  
c002c73e:	c3                   	ret    

c002c73f <test_priority_donate_multiple2>:
static thread_func b_thread_func;
static thread_func c_thread_func;

void
test_priority_donate_multiple2 (void) 
{
c002c73f:	55                   	push   %ebp
c002c740:	89 e5                	mov    %esp,%ebp
c002c742:	83 ec 38             	sub    $0x38,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c745:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002c74c:	83 f0 01             	xor    $0x1,%eax
c002c74f:	84 c0                	test   %al,%al
c002c751:	75 1e                	jne    c002c771 <test_priority_donate_multiple2+0x32>
c002c753:	83 ec 0c             	sub    $0xc,%esp
c002c756:	68 10 1e 03 c0       	push   $0xc0031e10
c002c75b:	68 1e 1e 03 c0       	push   $0xc0031e1e
c002c760:	68 78 1f 03 c0       	push   $0xc0031f78
c002c765:	6a 21                	push   $0x21
c002c767:	68 38 1e 03 c0       	push   $0xc0031e38
c002c76c:	e8 c0 ce ff ff       	call   c0029631 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c771:	e8 26 47 ff ff       	call   c0020e9c <thread_get_priority>
c002c776:	83 f8 1f             	cmp    $0x1f,%eax
c002c779:	74 1e                	je     c002c799 <test_priority_donate_multiple2+0x5a>
c002c77b:	83 ec 0c             	sub    $0xc,%esp
c002c77e:	68 68 1e 03 c0       	push   $0xc0031e68
c002c783:	68 1e 1e 03 c0       	push   $0xc0031e1e
c002c788:	68 78 1f 03 c0       	push   $0xc0031f78
c002c78d:	6a 24                	push   $0x24
c002c78f:	68 38 1e 03 c0       	push   $0xc0031e38
c002c794:	e8 98 ce ff ff       	call   c0029631 <debug_panic>

  lock_init (&a);
c002c799:	83 ec 0c             	sub    $0xc,%esp
c002c79c:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c79f:	50                   	push   %eax
c002c7a0:	e8 d0 62 ff ff       	call   c0022a75 <lock_init>
c002c7a5:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c7a8:	83 ec 0c             	sub    $0xc,%esp
c002c7ab:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c7ae:	50                   	push   %eax
c002c7af:	e8 c1 62 ff ff       	call   c0022a75 <lock_init>
c002c7b4:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c7b7:	83 ec 0c             	sub    $0xc,%esp
c002c7ba:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c7bd:	50                   	push   %eax
c002c7be:	e8 ff 62 ff ff       	call   c0022ac2 <lock_acquire>
c002c7c3:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002c7c6:	83 ec 0c             	sub    $0xc,%esp
c002c7c9:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c7cc:	50                   	push   %eax
c002c7cd:	e8 f0 62 ff ff       	call   c0022ac2 <lock_acquire>
c002c7d2:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002c7d5:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c7d8:	50                   	push   %eax
c002c7d9:	68 ac c8 02 c0       	push   $0xc002c8ac
c002c7de:	6a 22                	push   $0x22
c002c7e0:	68 8e 1e 03 c0       	push   $0xc0031e8e
c002c7e5:	e8 7e 42 ff ff       	call   c0020a68 <thread_create>
c002c7ea:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c7ed:	e8 aa 46 ff ff       	call   c0020e9c <thread_get_priority>
c002c7f2:	83 ec 04             	sub    $0x4,%esp
c002c7f5:	50                   	push   %eax
c002c7f6:	6a 22                	push   $0x22
c002c7f8:	68 90 1e 03 c0       	push   $0xc0031e90
c002c7fd:	e8 c0 f1 ff ff       	call   c002b9c2 <msg>
c002c802:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 3, thread_get_priority ());

  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002c805:	6a 00                	push   $0x0
c002c807:	68 42 c9 02 c0       	push   $0xc002c942
c002c80c:	6a 20                	push   $0x20
c002c80e:	68 cb 1e 03 c0       	push   $0xc0031ecb
c002c813:	e8 50 42 ff ff       	call   c0020a68 <thread_create>
c002c818:	83 c4 10             	add    $0x10,%esp

  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002c81b:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c81e:	50                   	push   %eax
c002c81f:	68 f7 c8 02 c0       	push   $0xc002c8f7
c002c824:	6a 24                	push   $0x24
c002c826:	68 cd 1e 03 c0       	push   $0xc0031ecd
c002c82b:	e8 38 42 ff ff       	call   c0020a68 <thread_create>
c002c830:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c833:	e8 64 46 ff ff       	call   c0020e9c <thread_get_priority>
c002c838:	83 ec 04             	sub    $0x4,%esp
c002c83b:	50                   	push   %eax
c002c83c:	6a 24                	push   $0x24
c002c83e:	68 90 1e 03 c0       	push   $0xc0031e90
c002c843:	e8 7a f1 ff ff       	call   c002b9c2 <msg>
c002c848:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&a);
c002c84b:	83 ec 0c             	sub    $0xc,%esp
c002c84e:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c851:	50                   	push   %eax
c002c852:	e8 ac 63 ff ff       	call   c0022c03 <lock_release>
c002c857:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c85a:	e8 3d 46 ff ff       	call   c0020e9c <thread_get_priority>
c002c85f:	83 ec 04             	sub    $0x4,%esp
c002c862:	50                   	push   %eax
c002c863:	6a 24                	push   $0x24
c002c865:	68 90 1e 03 c0       	push   $0xc0031e90
c002c86a:	e8 53 f1 ff ff       	call   c002b9c2 <msg>
c002c86f:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&b);
c002c872:	83 ec 0c             	sub    $0xc,%esp
c002c875:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c878:	50                   	push   %eax
c002c879:	e8 85 63 ff ff       	call   c0022c03 <lock_release>
c002c87e:	83 c4 10             	add    $0x10,%esp
  msg ("Threads b, a, c should have just finished, in that order.");
c002c881:	83 ec 0c             	sub    $0xc,%esp
c002c884:	68 d0 1e 03 c0       	push   $0xc0031ed0
c002c889:	e8 34 f1 ff ff       	call   c002b9c2 <msg>
c002c88e:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c891:	e8 06 46 ff ff       	call   c0020e9c <thread_get_priority>
c002c896:	83 ec 04             	sub    $0x4,%esp
c002c899:	50                   	push   %eax
c002c89a:	6a 1f                	push   $0x1f
c002c89c:	68 90 1e 03 c0       	push   $0xc0031e90
c002c8a1:	e8 1c f1 ff ff       	call   c002b9c2 <msg>
c002c8a6:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002c8a9:	90                   	nop
c002c8aa:	c9                   	leave  
c002c8ab:	c3                   	ret    

c002c8ac <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002c8ac:	55                   	push   %ebp
c002c8ad:	89 e5                	mov    %esp,%ebp
c002c8af:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c8b2:	8b 45 08             	mov    0x8(%ebp),%eax
c002c8b5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c8b8:	83 ec 0c             	sub    $0xc,%esp
c002c8bb:	ff 75 f4             	pushl  -0xc(%ebp)
c002c8be:	e8 ff 61 ff ff       	call   c0022ac2 <lock_acquire>
c002c8c3:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002c8c6:	83 ec 0c             	sub    $0xc,%esp
c002c8c9:	68 0a 1f 03 c0       	push   $0xc0031f0a
c002c8ce:	e8 ef f0 ff ff       	call   c002b9c2 <msg>
c002c8d3:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c8d6:	83 ec 0c             	sub    $0xc,%esp
c002c8d9:	ff 75 f4             	pushl  -0xc(%ebp)
c002c8dc:	e8 22 63 ff ff       	call   c0022c03 <lock_release>
c002c8e1:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002c8e4:	83 ec 0c             	sub    $0xc,%esp
c002c8e7:	68 24 1f 03 c0       	push   $0xc0031f24
c002c8ec:	e8 d1 f0 ff ff       	call   c002b9c2 <msg>
c002c8f1:	83 c4 10             	add    $0x10,%esp
}
c002c8f4:	90                   	nop
c002c8f5:	c9                   	leave  
c002c8f6:	c3                   	ret    

c002c8f7 <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002c8f7:	55                   	push   %ebp
c002c8f8:	89 e5                	mov    %esp,%ebp
c002c8fa:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c8fd:	8b 45 08             	mov    0x8(%ebp),%eax
c002c900:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c903:	83 ec 0c             	sub    $0xc,%esp
c002c906:	ff 75 f4             	pushl  -0xc(%ebp)
c002c909:	e8 b4 61 ff ff       	call   c0022ac2 <lock_acquire>
c002c90e:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002c911:	83 ec 0c             	sub    $0xc,%esp
c002c914:	68 37 1f 03 c0       	push   $0xc0031f37
c002c919:	e8 a4 f0 ff ff       	call   c002b9c2 <msg>
c002c91e:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c921:	83 ec 0c             	sub    $0xc,%esp
c002c924:	ff 75 f4             	pushl  -0xc(%ebp)
c002c927:	e8 d7 62 ff ff       	call   c0022c03 <lock_release>
c002c92c:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002c92f:	83 ec 0c             	sub    $0xc,%esp
c002c932:	68 51 1f 03 c0       	push   $0xc0031f51
c002c937:	e8 86 f0 ff ff       	call   c002b9c2 <msg>
c002c93c:	83 c4 10             	add    $0x10,%esp
}
c002c93f:	90                   	nop
c002c940:	c9                   	leave  
c002c941:	c3                   	ret    

c002c942 <c_thread_func>:

static void
c_thread_func (void *a_ UNUSED) 
{
c002c942:	55                   	push   %ebp
c002c943:	89 e5                	mov    %esp,%ebp
c002c945:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread c finished.");
c002c948:	83 ec 0c             	sub    $0xc,%esp
c002c94b:	68 64 1f 03 c0       	push   $0xc0031f64
c002c950:	e8 6d f0 ff ff       	call   c002b9c2 <msg>
c002c955:	83 c4 10             	add    $0x10,%esp
}
c002c958:	90                   	nop
c002c959:	c9                   	leave  
c002c95a:	c3                   	ret    

c002c95b <test_priority_donate_nest>:
static thread_func medium_thread_func;
static thread_func high_thread_func;

void
test_priority_donate_nest (void) 
{
c002c95b:	55                   	push   %ebp
c002c95c:	89 e5                	mov    %esp,%ebp
c002c95e:	83 ec 48             	sub    $0x48,%esp
  struct lock a, b;
  struct locks locks;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c961:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002c968:	83 f0 01             	xor    $0x1,%eax
c002c96b:	84 c0                	test   %al,%al
c002c96d:	75 1e                	jne    c002c98d <test_priority_donate_nest+0x32>
c002c96f:	83 ec 0c             	sub    $0xc,%esp
c002c972:	68 98 1f 03 c0       	push   $0xc0031f98
c002c977:	68 a6 1f 03 c0       	push   $0xc0031fa6
c002c97c:	68 54 21 03 c0       	push   $0xc0032154
c002c981:	6a 22                	push   $0x22
c002c983:	68 c0 1f 03 c0       	push   $0xc0031fc0
c002c988:	e8 a4 cc ff ff       	call   c0029631 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c98d:	e8 0a 45 ff ff       	call   c0020e9c <thread_get_priority>
c002c992:	83 f8 1f             	cmp    $0x1f,%eax
c002c995:	74 1e                	je     c002c9b5 <test_priority_donate_nest+0x5a>
c002c997:	83 ec 0c             	sub    $0xc,%esp
c002c99a:	68 ec 1f 03 c0       	push   $0xc0031fec
c002c99f:	68 a6 1f 03 c0       	push   $0xc0031fa6
c002c9a4:	68 54 21 03 c0       	push   $0xc0032154
c002c9a9:	6a 25                	push   $0x25
c002c9ab:	68 c0 1f 03 c0       	push   $0xc0031fc0
c002c9b0:	e8 7c cc ff ff       	call   c0029631 <debug_panic>

  lock_init (&a);
c002c9b5:	83 ec 0c             	sub    $0xc,%esp
c002c9b8:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c9bb:	50                   	push   %eax
c002c9bc:	e8 b4 60 ff ff       	call   c0022a75 <lock_init>
c002c9c1:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c9c4:	83 ec 0c             	sub    $0xc,%esp
c002c9c7:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c9ca:	50                   	push   %eax
c002c9cb:	e8 a5 60 ff ff       	call   c0022a75 <lock_init>
c002c9d0:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c9d3:	83 ec 0c             	sub    $0xc,%esp
c002c9d6:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c9d9:	50                   	push   %eax
c002c9da:	e8 e3 60 ff ff       	call   c0022ac2 <lock_acquire>
c002c9df:	83 c4 10             	add    $0x10,%esp

  locks.a = &a;
c002c9e2:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c9e5:	89 45 c0             	mov    %eax,-0x40(%ebp)
  locks.b = &b;
c002c9e8:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c9eb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002c9ee:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002c9f1:	50                   	push   %eax
c002c9f2:	68 97 ca 02 c0       	push   $0xc002ca97
c002c9f7:	6a 20                	push   $0x20
c002c9f9:	68 12 20 03 c0       	push   $0xc0032012
c002c9fe:	e8 65 40 ff ff       	call   c0020a68 <thread_create>
c002ca03:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002ca06:	e8 6c 43 ff ff       	call   c0020d77 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002ca0b:	e8 8c 44 ff ff       	call   c0020e9c <thread_get_priority>
c002ca10:	83 ec 04             	sub    $0x4,%esp
c002ca13:	50                   	push   %eax
c002ca14:	6a 20                	push   $0x20
c002ca16:	68 1c 20 03 c0       	push   $0xc003201c
c002ca1b:	e8 a2 ef ff ff       	call   c002b9c2 <msg>
c002ca20:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002ca23:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002ca26:	50                   	push   %eax
c002ca27:	68 3e cb 02 c0       	push   $0xc002cb3e
c002ca2c:	6a 21                	push   $0x21
c002ca2e:	68 56 20 03 c0       	push   $0xc0032056
c002ca33:	e8 30 40 ff ff       	call   c0020a68 <thread_create>
c002ca38:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002ca3b:	e8 37 43 ff ff       	call   c0020d77 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002ca40:	e8 57 44 ff ff       	call   c0020e9c <thread_get_priority>
c002ca45:	83 ec 04             	sub    $0x4,%esp
c002ca48:	50                   	push   %eax
c002ca49:	6a 21                	push   $0x21
c002ca4b:	68 1c 20 03 c0       	push   $0xc003201c
c002ca50:	e8 6d ef ff ff       	call   c002b9c2 <msg>
c002ca55:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&a);
c002ca58:	83 ec 0c             	sub    $0xc,%esp
c002ca5b:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ca5e:	50                   	push   %eax
c002ca5f:	e8 9f 61 ff ff       	call   c0022c03 <lock_release>
c002ca64:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002ca67:	e8 0b 43 ff ff       	call   c0020d77 <thread_yield>
  msg ("Medium thread should just have finished.");
c002ca6c:	83 ec 0c             	sub    $0xc,%esp
c002ca6f:	68 5c 20 03 c0       	push   $0xc003205c
c002ca74:	e8 49 ef ff ff       	call   c002b9c2 <msg>
c002ca79:	83 c4 10             	add    $0x10,%esp
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002ca7c:	e8 1b 44 ff ff       	call   c0020e9c <thread_get_priority>
c002ca81:	83 ec 04             	sub    $0x4,%esp
c002ca84:	50                   	push   %eax
c002ca85:	6a 1f                	push   $0x1f
c002ca87:	68 1c 20 03 c0       	push   $0xc003201c
c002ca8c:	e8 31 ef ff ff       	call   c002b9c2 <msg>
c002ca91:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002ca94:	90                   	nop
c002ca95:	c9                   	leave  
c002ca96:	c3                   	ret    

c002ca97 <medium_thread_func>:

static void
medium_thread_func (void *locks_) 
{
c002ca97:	55                   	push   %ebp
c002ca98:	89 e5                	mov    %esp,%ebp
c002ca9a:	83 ec 18             	sub    $0x18,%esp
  struct locks *locks = locks_;
c002ca9d:	8b 45 08             	mov    0x8(%ebp),%eax
c002caa0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (locks->b);
c002caa3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002caa6:	8b 40 04             	mov    0x4(%eax),%eax
c002caa9:	83 ec 0c             	sub    $0xc,%esp
c002caac:	50                   	push   %eax
c002caad:	e8 10 60 ff ff       	call   c0022ac2 <lock_acquire>
c002cab2:	83 c4 10             	add    $0x10,%esp
  lock_acquire (locks->a);
c002cab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cab8:	8b 00                	mov    (%eax),%eax
c002caba:	83 ec 0c             	sub    $0xc,%esp
c002cabd:	50                   	push   %eax
c002cabe:	e8 ff 5f ff ff       	call   c0022ac2 <lock_acquire>
c002cac3:	83 c4 10             	add    $0x10,%esp

  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002cac6:	e8 d1 43 ff ff       	call   c0020e9c <thread_get_priority>
c002cacb:	83 ec 04             	sub    $0x4,%esp
c002cace:	50                   	push   %eax
c002cacf:	6a 21                	push   $0x21
c002cad1:	68 88 20 03 c0       	push   $0xc0032088
c002cad6:	e8 e7 ee ff ff       	call   c002b9c2 <msg>
c002cadb:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  msg ("Medium thread got the lock.");
c002cade:	83 ec 0c             	sub    $0xc,%esp
c002cae1:	68 c5 20 03 c0       	push   $0xc00320c5
c002cae6:	e8 d7 ee ff ff       	call   c002b9c2 <msg>
c002caeb:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->a);
c002caee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002caf1:	8b 00                	mov    (%eax),%eax
c002caf3:	83 ec 0c             	sub    $0xc,%esp
c002caf6:	50                   	push   %eax
c002caf7:	e8 07 61 ff ff       	call   c0022c03 <lock_release>
c002cafc:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002caff:	e8 73 42 ff ff       	call   c0020d77 <thread_yield>

  lock_release (locks->b);
c002cb04:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb07:	8b 40 04             	mov    0x4(%eax),%eax
c002cb0a:	83 ec 0c             	sub    $0xc,%esp
c002cb0d:	50                   	push   %eax
c002cb0e:	e8 f0 60 ff ff       	call   c0022c03 <lock_release>
c002cb13:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002cb16:	e8 5c 42 ff ff       	call   c0020d77 <thread_yield>

  msg ("High thread should have just finished.");
c002cb1b:	83 ec 0c             	sub    $0xc,%esp
c002cb1e:	68 e4 20 03 c0       	push   $0xc00320e4
c002cb23:	e8 9a ee ff ff       	call   c002b9c2 <msg>
c002cb28:	83 c4 10             	add    $0x10,%esp
  msg ("Middle thread finished.");
c002cb2b:	83 ec 0c             	sub    $0xc,%esp
c002cb2e:	68 0b 21 03 c0       	push   $0xc003210b
c002cb33:	e8 8a ee ff ff       	call   c002b9c2 <msg>
c002cb38:	83 c4 10             	add    $0x10,%esp
}
c002cb3b:	90                   	nop
c002cb3c:	c9                   	leave  
c002cb3d:	c3                   	ret    

c002cb3e <high_thread_func>:

static void
high_thread_func (void *lock_) 
{
c002cb3e:	55                   	push   %ebp
c002cb3f:	89 e5                	mov    %esp,%ebp
c002cb41:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002cb44:	8b 45 08             	mov    0x8(%ebp),%eax
c002cb47:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002cb4a:	83 ec 0c             	sub    $0xc,%esp
c002cb4d:	ff 75 f4             	pushl  -0xc(%ebp)
c002cb50:	e8 6d 5f ff ff       	call   c0022ac2 <lock_acquire>
c002cb55:	83 c4 10             	add    $0x10,%esp
  msg ("High thread got the lock.");
c002cb58:	83 ec 0c             	sub    $0xc,%esp
c002cb5b:	68 23 21 03 c0       	push   $0xc0032123
c002cb60:	e8 5d ee ff ff       	call   c002b9c2 <msg>
c002cb65:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cb68:	83 ec 0c             	sub    $0xc,%esp
c002cb6b:	ff 75 f4             	pushl  -0xc(%ebp)
c002cb6e:	e8 90 60 ff ff       	call   c0022c03 <lock_release>
c002cb73:	83 c4 10             	add    $0x10,%esp
  msg ("High thread finished.");
c002cb76:	83 ec 0c             	sub    $0xc,%esp
c002cb79:	68 3d 21 03 c0       	push   $0xc003213d
c002cb7e:	e8 3f ee ff ff       	call   c002b9c2 <msg>
c002cb83:	83 c4 10             	add    $0x10,%esp
}
c002cb86:	90                   	nop
c002cb87:	c9                   	leave  
c002cb88:	c3                   	ret    

c002cb89 <test_priority_donate_sema>:
static thread_func m_thread_func;
static thread_func h_thread_func;

void
test_priority_donate_sema (void) 
{
c002cb89:	55                   	push   %ebp
c002cb8a:	89 e5                	mov    %esp,%ebp
c002cb8c:	83 ec 38             	sub    $0x38,%esp
  struct lock_and_sema ls;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cb8f:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002cb96:	83 f0 01             	xor    $0x1,%eax
c002cb99:	84 c0                	test   %al,%al
c002cb9b:	75 1e                	jne    c002cbbb <test_priority_donate_sema+0x32>
c002cb9d:	83 ec 0c             	sub    $0xc,%esp
c002cba0:	68 70 21 03 c0       	push   $0xc0032170
c002cba5:	68 7e 21 03 c0       	push   $0xc003217e
c002cbaa:	68 94 22 03 c0       	push   $0xc0032294
c002cbaf:	6a 23                	push   $0x23
c002cbb1:	68 98 21 03 c0       	push   $0xc0032198
c002cbb6:	e8 76 ca ff ff       	call   c0029631 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cbbb:	e8 dc 42 ff ff       	call   c0020e9c <thread_get_priority>
c002cbc0:	83 f8 1f             	cmp    $0x1f,%eax
c002cbc3:	74 1e                	je     c002cbe3 <test_priority_donate_sema+0x5a>
c002cbc5:	83 ec 0c             	sub    $0xc,%esp
c002cbc8:	68 c4 21 03 c0       	push   $0xc00321c4
c002cbcd:	68 7e 21 03 c0       	push   $0xc003217e
c002cbd2:	68 94 22 03 c0       	push   $0xc0032294
c002cbd7:	6a 26                	push   $0x26
c002cbd9:	68 98 21 03 c0       	push   $0xc0032198
c002cbde:	e8 4e ca ff ff       	call   c0029631 <debug_panic>

  lock_init (&ls.lock);
c002cbe3:	83 ec 0c             	sub    $0xc,%esp
c002cbe6:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cbe9:	50                   	push   %eax
c002cbea:	e8 86 5e ff ff       	call   c0022a75 <lock_init>
c002cbef:	83 c4 10             	add    $0x10,%esp
  sema_init (&ls.sema, 0);
c002cbf2:	83 ec 08             	sub    $0x8,%esp
c002cbf5:	6a 00                	push   $0x0
c002cbf7:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cbfa:	83 c0 18             	add    $0x18,%eax
c002cbfd:	50                   	push   %eax
c002cbfe:	e8 b7 5b ff ff       	call   c00227ba <sema_init>
c002cc03:	83 c4 10             	add    $0x10,%esp
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002cc06:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cc09:	50                   	push   %eax
c002cc0a:	68 73 cc 02 c0       	push   $0xc002cc73
c002cc0f:	6a 20                	push   $0x20
c002cc11:	68 ea 21 03 c0       	push   $0xc00321ea
c002cc16:	e8 4d 3e ff ff       	call   c0020a68 <thread_create>
c002cc1b:	83 c4 10             	add    $0x10,%esp
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002cc1e:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cc21:	50                   	push   %eax
c002cc22:	68 e2 cc 02 c0       	push   $0xc002cce2
c002cc27:	6a 22                	push   $0x22
c002cc29:	68 ee 21 03 c0       	push   $0xc00321ee
c002cc2e:	e8 35 3e ff ff       	call   c0020a68 <thread_create>
c002cc33:	83 c4 10             	add    $0x10,%esp
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002cc36:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cc39:	50                   	push   %eax
c002cc3a:	68 13 cd 02 c0       	push   $0xc002cd13
c002cc3f:	6a 24                	push   $0x24
c002cc41:	68 f2 21 03 c0       	push   $0xc00321f2
c002cc46:	e8 1d 3e ff ff       	call   c0020a68 <thread_create>
c002cc4b:	83 c4 10             	add    $0x10,%esp
  sema_up (&ls.sema);
c002cc4e:	83 ec 0c             	sub    $0xc,%esp
c002cc51:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cc54:	83 c0 18             	add    $0x18,%eax
c002cc57:	50                   	push   %eax
c002cc58:	e8 af 5c ff ff       	call   c002290c <sema_up>
c002cc5d:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread finished.");
c002cc60:	83 ec 0c             	sub    $0xc,%esp
c002cc63:	68 f7 21 03 c0       	push   $0xc00321f7
c002cc68:	e8 55 ed ff ff       	call   c002b9c2 <msg>
c002cc6d:	83 c4 10             	add    $0x10,%esp
}
c002cc70:	90                   	nop
c002cc71:	c9                   	leave  
c002cc72:	c3                   	ret    

c002cc73 <l_thread_func>:

static void
l_thread_func (void *ls_) 
{
c002cc73:	55                   	push   %ebp
c002cc74:	89 e5                	mov    %esp,%ebp
c002cc76:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002cc79:	8b 45 08             	mov    0x8(%ebp),%eax
c002cc7c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002cc7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc82:	83 ec 0c             	sub    $0xc,%esp
c002cc85:	50                   	push   %eax
c002cc86:	e8 37 5e ff ff       	call   c0022ac2 <lock_acquire>
c002cc8b:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L acquired lock.");
c002cc8e:	83 ec 0c             	sub    $0xc,%esp
c002cc91:	68 0d 22 03 c0       	push   $0xc003220d
c002cc96:	e8 27 ed ff ff       	call   c002b9c2 <msg>
c002cc9b:	83 c4 10             	add    $0x10,%esp
  sema_down (&ls->sema);
c002cc9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cca1:	83 c0 18             	add    $0x18,%eax
c002cca4:	83 ec 0c             	sub    $0xc,%esp
c002cca7:	50                   	push   %eax
c002cca8:	e8 54 5b ff ff       	call   c0022801 <sema_down>
c002ccad:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L downed semaphore.");
c002ccb0:	83 ec 0c             	sub    $0xc,%esp
c002ccb3:	68 25 22 03 c0       	push   $0xc0032225
c002ccb8:	e8 05 ed ff ff       	call   c002b9c2 <msg>
c002ccbd:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002ccc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ccc3:	83 ec 0c             	sub    $0xc,%esp
c002ccc6:	50                   	push   %eax
c002ccc7:	e8 37 5f ff ff       	call   c0022c03 <lock_release>
c002cccc:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L finished.");
c002cccf:	83 ec 0c             	sub    $0xc,%esp
c002ccd2:	68 40 22 03 c0       	push   $0xc0032240
c002ccd7:	e8 e6 ec ff ff       	call   c002b9c2 <msg>
c002ccdc:	83 c4 10             	add    $0x10,%esp
}
c002ccdf:	90                   	nop
c002cce0:	c9                   	leave  
c002cce1:	c3                   	ret    

c002cce2 <m_thread_func>:

static void
m_thread_func (void *ls_) 
{
c002cce2:	55                   	push   %ebp
c002cce3:	89 e5                	mov    %esp,%ebp
c002cce5:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002cce8:	8b 45 08             	mov    0x8(%ebp),%eax
c002cceb:	89 45 f4             	mov    %eax,-0xc(%ebp)

  sema_down (&ls->sema);
c002ccee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ccf1:	83 c0 18             	add    $0x18,%eax
c002ccf4:	83 ec 0c             	sub    $0xc,%esp
c002ccf7:	50                   	push   %eax
c002ccf8:	e8 04 5b ff ff       	call   c0022801 <sema_down>
c002ccfd:	83 c4 10             	add    $0x10,%esp
  msg ("Thread M finished.");
c002cd00:	83 ec 0c             	sub    $0xc,%esp
c002cd03:	68 53 22 03 c0       	push   $0xc0032253
c002cd08:	e8 b5 ec ff ff       	call   c002b9c2 <msg>
c002cd0d:	83 c4 10             	add    $0x10,%esp
}
c002cd10:	90                   	nop
c002cd11:	c9                   	leave  
c002cd12:	c3                   	ret    

c002cd13 <h_thread_func>:

static void
h_thread_func (void *ls_) 
{
c002cd13:	55                   	push   %ebp
c002cd14:	89 e5                	mov    %esp,%ebp
c002cd16:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002cd19:	8b 45 08             	mov    0x8(%ebp),%eax
c002cd1c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002cd1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cd22:	83 ec 0c             	sub    $0xc,%esp
c002cd25:	50                   	push   %eax
c002cd26:	e8 97 5d ff ff       	call   c0022ac2 <lock_acquire>
c002cd2b:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H acquired lock.");
c002cd2e:	83 ec 0c             	sub    $0xc,%esp
c002cd31:	68 66 22 03 c0       	push   $0xc0032266
c002cd36:	e8 87 ec ff ff       	call   c002b9c2 <msg>
c002cd3b:	83 c4 10             	add    $0x10,%esp

  sema_up (&ls->sema);
c002cd3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cd41:	83 c0 18             	add    $0x18,%eax
c002cd44:	83 ec 0c             	sub    $0xc,%esp
c002cd47:	50                   	push   %eax
c002cd48:	e8 bf 5b ff ff       	call   c002290c <sema_up>
c002cd4d:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002cd50:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cd53:	83 ec 0c             	sub    $0xc,%esp
c002cd56:	50                   	push   %eax
c002cd57:	e8 a7 5e ff ff       	call   c0022c03 <lock_release>
c002cd5c:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H finished.");
c002cd5f:	83 ec 0c             	sub    $0xc,%esp
c002cd62:	68 7e 22 03 c0       	push   $0xc003227e
c002cd67:	e8 56 ec ff ff       	call   c002b9c2 <msg>
c002cd6c:	83 c4 10             	add    $0x10,%esp
}
c002cd6f:	90                   	nop
c002cd70:	c9                   	leave  
c002cd71:	c3                   	ret    

c002cd72 <test_priority_donate_lower>:

static thread_func acquire_thread_func;

void
test_priority_donate_lower (void) 
{
c002cd72:	55                   	push   %ebp
c002cd73:	89 e5                	mov    %esp,%ebp
c002cd75:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cd78:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002cd7f:	83 f0 01             	xor    $0x1,%eax
c002cd82:	84 c0                	test   %al,%al
c002cd84:	75 1e                	jne    c002cda4 <test_priority_donate_lower+0x32>
c002cd86:	83 ec 0c             	sub    $0xc,%esp
c002cd89:	68 b0 22 03 c0       	push   $0xc00322b0
c002cd8e:	68 be 22 03 c0       	push   $0xc00322be
c002cd93:	68 d4 23 03 c0       	push   $0xc00323d4
c002cd98:	6a 15                	push   $0x15
c002cd9a:	68 d8 22 03 c0       	push   $0xc00322d8
c002cd9f:	e8 8d c8 ff ff       	call   c0029631 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cda4:	e8 f3 40 ff ff       	call   c0020e9c <thread_get_priority>
c002cda9:	83 f8 1f             	cmp    $0x1f,%eax
c002cdac:	74 1e                	je     c002cdcc <test_priority_donate_lower+0x5a>
c002cdae:	83 ec 0c             	sub    $0xc,%esp
c002cdb1:	68 04 23 03 c0       	push   $0xc0032304
c002cdb6:	68 be 22 03 c0       	push   $0xc00322be
c002cdbb:	68 d4 23 03 c0       	push   $0xc00323d4
c002cdc0:	6a 18                	push   $0x18
c002cdc2:	68 d8 22 03 c0       	push   $0xc00322d8
c002cdc7:	e8 65 c8 ff ff       	call   c0029631 <debug_panic>

  lock_init (&lock);
c002cdcc:	83 ec 0c             	sub    $0xc,%esp
c002cdcf:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cdd2:	50                   	push   %eax
c002cdd3:	e8 9d 5c ff ff       	call   c0022a75 <lock_init>
c002cdd8:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002cddb:	83 ec 0c             	sub    $0xc,%esp
c002cdde:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cde1:	50                   	push   %eax
c002cde2:	e8 db 5c ff ff       	call   c0022ac2 <lock_acquire>
c002cde7:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002cdea:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cded:	50                   	push   %eax
c002cdee:	68 89 ce 02 c0       	push   $0xc002ce89
c002cdf3:	6a 29                	push   $0x29
c002cdf5:	68 2a 23 03 c0       	push   $0xc003232a
c002cdfa:	e8 69 3c ff ff       	call   c0020a68 <thread_create>
c002cdff:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002ce02:	e8 95 40 ff ff       	call   c0020e9c <thread_get_priority>
c002ce07:	83 ec 04             	sub    $0x4,%esp
c002ce0a:	50                   	push   %eax
c002ce0b:	6a 29                	push   $0x29
c002ce0d:	68 34 23 03 c0       	push   $0xc0032334
c002ce12:	e8 ab eb ff ff       	call   c002b9c2 <msg>
c002ce17:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());

  msg ("Lowering base priority...");
c002ce1a:	83 ec 0c             	sub    $0xc,%esp
c002ce1d:	68 6f 23 03 c0       	push   $0xc003236f
c002ce22:	e8 9b eb ff ff       	call   c002b9c2 <msg>
c002ce27:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 10);
c002ce2a:	83 ec 0c             	sub    $0xc,%esp
c002ce2d:	6a 15                	push   $0x15
c002ce2f:	e8 52 40 ff ff       	call   c0020e86 <thread_set_priority>
c002ce34:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002ce37:	e8 60 40 ff ff       	call   c0020e9c <thread_get_priority>
c002ce3c:	83 ec 04             	sub    $0x4,%esp
c002ce3f:	50                   	push   %eax
c002ce40:	6a 29                	push   $0x29
c002ce42:	68 34 23 03 c0       	push   $0xc0032334
c002ce47:	e8 76 eb ff ff       	call   c002b9c2 <msg>
c002ce4c:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());
  lock_release (&lock);
c002ce4f:	83 ec 0c             	sub    $0xc,%esp
c002ce52:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ce55:	50                   	push   %eax
c002ce56:	e8 a8 5d ff ff       	call   c0022c03 <lock_release>
c002ce5b:	83 c4 10             	add    $0x10,%esp
  msg ("acquire must already have finished.");
c002ce5e:	83 ec 0c             	sub    $0xc,%esp
c002ce61:	68 8c 23 03 c0       	push   $0xc003238c
c002ce66:	e8 57 eb ff ff       	call   c002b9c2 <msg>
c002ce6b:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002ce6e:	e8 29 40 ff ff       	call   c0020e9c <thread_get_priority>
c002ce73:	83 ec 04             	sub    $0x4,%esp
c002ce76:	50                   	push   %eax
c002ce77:	6a 15                	push   $0x15
c002ce79:	68 34 23 03 c0       	push   $0xc0032334
c002ce7e:	e8 3f eb ff ff       	call   c002b9c2 <msg>
c002ce83:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT - 10, thread_get_priority ());
}
c002ce86:	90                   	nop
c002ce87:	c9                   	leave  
c002ce88:	c3                   	ret    

c002ce89 <acquire_thread_func>:

static void
acquire_thread_func (void *lock_) 
{
c002ce89:	55                   	push   %ebp
c002ce8a:	89 e5                	mov    %esp,%ebp
c002ce8c:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002ce8f:	8b 45 08             	mov    0x8(%ebp),%eax
c002ce92:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002ce95:	83 ec 0c             	sub    $0xc,%esp
c002ce98:	ff 75 f4             	pushl  -0xc(%ebp)
c002ce9b:	e8 22 5c ff ff       	call   c0022ac2 <lock_acquire>
c002cea0:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: got the lock");
c002cea3:	83 ec 0c             	sub    $0xc,%esp
c002cea6:	68 b0 23 03 c0       	push   $0xc00323b0
c002ceab:	e8 12 eb ff ff       	call   c002b9c2 <msg>
c002ceb0:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002ceb3:	83 ec 0c             	sub    $0xc,%esp
c002ceb6:	ff 75 f4             	pushl  -0xc(%ebp)
c002ceb9:	e8 45 5d ff ff       	call   c0022c03 <lock_release>
c002cebe:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: done");
c002cec1:	83 ec 0c             	sub    $0xc,%esp
c002cec4:	68 c6 23 03 c0       	push   $0xc00323c6
c002cec9:	e8 f4 ea ff ff       	call   c002b9c2 <msg>
c002cece:	83 c4 10             	add    $0x10,%esp
}
c002ced1:	90                   	nop
c002ced2:	c9                   	leave  
c002ced3:	c3                   	ret    

c002ced4 <test_priority_fifo>:

static thread_func simple_thread_func;

void
test_priority_fifo (void) 
{
c002ced4:	55                   	push   %ebp
c002ced5:	89 e5                	mov    %esp,%ebp
c002ced7:	81 ec 48 01 00 00    	sub    $0x148,%esp
  struct lock lock;
  int *output, *op;
  int i, cnt;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cedd:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002cee4:	83 f0 01             	xor    $0x1,%eax
c002cee7:	84 c0                	test   %al,%al
c002cee9:	75 1e                	jne    c002cf09 <test_priority_fifo+0x35>
c002ceeb:	83 ec 0c             	sub    $0xc,%esp
c002ceee:	68 f0 23 03 c0       	push   $0xc00323f0
c002cef3:	68 fe 23 03 c0       	push   $0xc00323fe
c002cef8:	68 38 25 03 c0       	push   $0xc0032538
c002cefd:	6a 28                	push   $0x28
c002ceff:	68 18 24 03 c0       	push   $0xc0032418
c002cf04:	e8 28 c7 ff ff       	call   c0029631 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cf09:	e8 8e 3f ff ff       	call   c0020e9c <thread_get_priority>
c002cf0e:	83 f8 1f             	cmp    $0x1f,%eax
c002cf11:	74 1e                	je     c002cf31 <test_priority_fifo+0x5d>
c002cf13:	83 ec 0c             	sub    $0xc,%esp
c002cf16:	68 3c 24 03 c0       	push   $0xc003243c
c002cf1b:	68 fe 23 03 c0       	push   $0xc00323fe
c002cf20:	68 38 25 03 c0       	push   $0xc0032538
c002cf25:	6a 2b                	push   $0x2b
c002cf27:	68 18 24 03 c0       	push   $0xc0032418
c002cf2c:	e8 00 c7 ff ff       	call   c0029631 <debug_panic>

  msg ("%d threads will iterate %d times in the same order each time.",
c002cf31:	83 ec 04             	sub    $0x4,%esp
c002cf34:	6a 10                	push   $0x10
c002cf36:	6a 10                	push   $0x10
c002cf38:	68 64 24 03 c0       	push   $0xc0032464
c002cf3d:	e8 80 ea ff ff       	call   c002b9c2 <msg>
c002cf42:	83 c4 10             	add    $0x10,%esp
       THREAD_CNT, ITER_CNT);
  msg ("If the order varies then there is a bug.");
c002cf45:	83 ec 0c             	sub    $0xc,%esp
c002cf48:	68 a4 24 03 c0       	push   $0xc00324a4
c002cf4d:	e8 70 ea ff ff       	call   c002b9c2 <msg>
c002cf52:	83 c4 10             	add    $0x10,%esp

  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002cf55:	83 ec 0c             	sub    $0xc,%esp
c002cf58:	68 00 08 00 00       	push   $0x800
c002cf5d:	e8 29 65 ff ff       	call   c002348b <malloc>
c002cf62:	83 c4 10             	add    $0x10,%esp
c002cf65:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
c002cf6b:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
c002cf71:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (output != NULL);
c002cf74:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002cf78:	75 1e                	jne    c002cf98 <test_priority_fifo+0xc4>
c002cf7a:	83 ec 0c             	sub    $0xc,%esp
c002cf7d:	68 cd 24 03 c0       	push   $0xc00324cd
c002cf82:	68 fe 23 03 c0       	push   $0xc00323fe
c002cf87:	68 38 25 03 c0       	push   $0xc0032538
c002cf8c:	6a 32                	push   $0x32
c002cf8e:	68 18 24 03 c0       	push   $0xc0032418
c002cf93:	e8 99 c6 ff ff       	call   c0029631 <debug_panic>
  lock_init (&lock);
c002cf98:	83 ec 0c             	sub    $0xc,%esp
c002cf9b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
c002cfa1:	50                   	push   %eax
c002cfa2:	e8 ce 5a ff ff       	call   c0022a75 <lock_init>
c002cfa7:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_DEFAULT + 2);
c002cfaa:	83 ec 0c             	sub    $0xc,%esp
c002cfad:	6a 21                	push   $0x21
c002cfaf:	e8 d2 3e ff ff       	call   c0020e86 <thread_set_priority>
c002cfb4:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002cfb7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002cfbe:	eb 73                	jmp    c002d033 <test_priority_fifo+0x15f>
    {
      char name[16];
      struct simple_thread_data *d = data + i;
c002cfc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002cfc3:	c1 e0 04             	shl    $0x4,%eax
c002cfc6:	89 c2                	mov    %eax,%edx
c002cfc8:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002cfce:	01 d0                	add    %edx,%eax
c002cfd0:	89 45 e8             	mov    %eax,-0x18(%ebp)
      snprintf (name, sizeof name, "%d", i);
c002cfd3:	ff 75 f0             	pushl  -0x10(%ebp)
c002cfd6:	68 dc 24 03 c0       	push   $0xc00324dc
c002cfdb:	6a 10                	push   $0x10
c002cfdd:	8d 85 b8 fe ff ff    	lea    -0x148(%ebp),%eax
c002cfe3:	50                   	push   %eax
c002cfe4:	e8 ec a1 ff ff       	call   c00271d5 <snprintf>
c002cfe9:	83 c4 10             	add    $0x10,%esp
      d->id = i;
c002cfec:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002cfef:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002cff2:	89 10                	mov    %edx,(%eax)
      d->iterations = 0;
c002cff4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002cff7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      d->lock = &lock;
c002cffe:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d001:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
c002d007:	89 50 08             	mov    %edx,0x8(%eax)
      d->op = &op;
c002d00a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d00d:	8d 95 c8 fe ff ff    	lea    -0x138(%ebp),%edx
c002d013:	89 50 0c             	mov    %edx,0xc(%eax)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002d016:	ff 75 e8             	pushl  -0x18(%ebp)
c002d019:	68 30 d1 02 c0       	push   $0xc002d130
c002d01e:	6a 20                	push   $0x20
c002d020:	8d 85 b8 fe ff ff    	lea    -0x148(%ebp),%eax
c002d026:	50                   	push   %eax
c002d027:	e8 3c 3a ff ff       	call   c0020a68 <thread_create>
c002d02c:	83 c4 10             	add    $0x10,%esp
  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
  ASSERT (output != NULL);
  lock_init (&lock);

  thread_set_priority (PRI_DEFAULT + 2);
  for (i = 0; i < THREAD_CNT; i++) 
c002d02f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002d033:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
c002d037:	7e 87                	jle    c002cfc0 <test_priority_fifo+0xec>
      d->lock = &lock;
      d->op = &op;
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
    }

  thread_set_priority (PRI_DEFAULT);
c002d039:	83 ec 0c             	sub    $0xc,%esp
c002d03c:	6a 1f                	push   $0x1f
c002d03e:	e8 43 3e ff ff       	call   c0020e86 <thread_set_priority>
c002d043:	83 c4 10             	add    $0x10,%esp
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);
c002d046:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
c002d04c:	85 c0                	test   %eax,%eax
c002d04e:	74 1e                	je     c002d06e <test_priority_fifo+0x19a>
c002d050:	83 ec 0c             	sub    $0xc,%esp
c002d053:	68 df 24 03 c0       	push   $0xc00324df
c002d058:	68 fe 23 03 c0       	push   $0xc00323fe
c002d05d:	68 38 25 03 c0       	push   $0xc0032538
c002d062:	6a 44                	push   $0x44
c002d064:	68 18 24 03 c0       	push   $0xc0032418
c002d069:	e8 c3 c5 ff ff       	call   c0029631 <debug_panic>

  cnt = 0;
c002d06e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  for (; output < op; output++) 
c002d075:	e9 a4 00 00 00       	jmp    c002d11e <test_priority_fifo+0x24a>
    {
      struct simple_thread_data *d;

      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002d07a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d07d:	8b 00                	mov    (%eax),%eax
c002d07f:	85 c0                	test   %eax,%eax
c002d081:	78 0a                	js     c002d08d <test_priority_fifo+0x1b9>
c002d083:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d086:	8b 00                	mov    (%eax),%eax
c002d088:	83 f8 0f             	cmp    $0xf,%eax
c002d08b:	7e 1e                	jle    c002d0ab <test_priority_fifo+0x1d7>
c002d08d:	83 ec 0c             	sub    $0xc,%esp
c002d090:	68 f4 24 03 c0       	push   $0xc00324f4
c002d095:	68 fe 23 03 c0       	push   $0xc00323fe
c002d09a:	68 38 25 03 c0       	push   $0xc0032538
c002d09f:	6a 4b                	push   $0x4b
c002d0a1:	68 18 24 03 c0       	push   $0xc0032418
c002d0a6:	e8 86 c5 ff ff       	call   c0029631 <debug_panic>
      d = data + *output;
c002d0ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d0ae:	8b 00                	mov    (%eax),%eax
c002d0b0:	c1 e0 04             	shl    $0x4,%eax
c002d0b3:	89 c2                	mov    %eax,%edx
c002d0b5:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002d0bb:	01 d0                	add    %edx,%eax
c002d0bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if (cnt % THREAD_CNT == 0)
c002d0c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d0c3:	83 e0 0f             	and    $0xf,%eax
c002d0c6:	85 c0                	test   %eax,%eax
c002d0c8:	75 10                	jne    c002d0da <test_priority_fifo+0x206>
        printf ("(priority-fifo) iteration:");
c002d0ca:	83 ec 0c             	sub    $0xc,%esp
c002d0cd:	68 19 25 03 c0       	push   $0xc0032519
c002d0d2:	e8 27 a1 ff ff       	call   c00271fe <printf>
c002d0d7:	83 c4 10             	add    $0x10,%esp
      printf (" %d", d->id);
c002d0da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d0dd:	8b 00                	mov    (%eax),%eax
c002d0df:	83 ec 08             	sub    $0x8,%esp
c002d0e2:	50                   	push   %eax
c002d0e3:	68 34 25 03 c0       	push   $0xc0032534
c002d0e8:	e8 11 a1 ff ff       	call   c00271fe <printf>
c002d0ed:	83 c4 10             	add    $0x10,%esp
      if (++cnt % THREAD_CNT == 0)
c002d0f0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002d0f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d0f7:	83 e0 0f             	and    $0xf,%eax
c002d0fa:	85 c0                	test   %eax,%eax
c002d0fc:	75 0d                	jne    c002d10b <test_priority_fifo+0x237>
        printf ("\n");
c002d0fe:	83 ec 0c             	sub    $0xc,%esp
c002d101:	6a 0a                	push   $0xa
c002d103:	e8 64 e7 ff ff       	call   c002b86c <putchar>
c002d108:	83 c4 10             	add    $0x10,%esp
      d->iterations++;
c002d10b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d10e:	8b 40 04             	mov    0x4(%eax),%eax
c002d111:	8d 50 01             	lea    0x1(%eax),%edx
c002d114:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d117:	89 50 04             	mov    %edx,0x4(%eax)
  thread_set_priority (PRI_DEFAULT);
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);

  cnt = 0;
  for (; output < op; output++) 
c002d11a:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002d11e:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
c002d124:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002d127:	0f 82 4d ff ff ff    	jb     c002d07a <test_priority_fifo+0x1a6>
      printf (" %d", d->id);
      if (++cnt % THREAD_CNT == 0)
        printf ("\n");
      d->iterations++;
    }
}
c002d12d:	90                   	nop
c002d12e:	c9                   	leave  
c002d12f:	c3                   	ret    

c002d130 <simple_thread_func>:

static void 
simple_thread_func (void *data_) 
{
c002d130:	55                   	push   %ebp
c002d131:	89 e5                	mov    %esp,%ebp
c002d133:	83 ec 18             	sub    $0x18,%esp
  struct simple_thread_data *data = data_;
c002d136:	8b 45 08             	mov    0x8(%ebp),%eax
c002d139:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002d13c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d143:	eb 41                	jmp    c002d186 <simple_thread_func+0x56>
    {
      lock_acquire (data->lock);
c002d145:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d148:	8b 40 08             	mov    0x8(%eax),%eax
c002d14b:	83 ec 0c             	sub    $0xc,%esp
c002d14e:	50                   	push   %eax
c002d14f:	e8 6e 59 ff ff       	call   c0022ac2 <lock_acquire>
c002d154:	83 c4 10             	add    $0x10,%esp
      *(*data->op)++ = data->id;
c002d157:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d15a:	8b 50 0c             	mov    0xc(%eax),%edx
c002d15d:	8b 02                	mov    (%edx),%eax
c002d15f:	8d 48 04             	lea    0x4(%eax),%ecx
c002d162:	89 0a                	mov    %ecx,(%edx)
c002d164:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002d167:	8b 12                	mov    (%edx),%edx
c002d169:	89 10                	mov    %edx,(%eax)
      lock_release (data->lock);
c002d16b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d16e:	8b 40 08             	mov    0x8(%eax),%eax
c002d171:	83 ec 0c             	sub    $0xc,%esp
c002d174:	50                   	push   %eax
c002d175:	e8 89 5a ff ff       	call   c0022c03 <lock_release>
c002d17a:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002d17d:	e8 f5 3b ff ff       	call   c0020d77 <thread_yield>
simple_thread_func (void *data_) 
{
  struct simple_thread_data *data = data_;
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002d182:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d186:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
c002d18a:	7e b9                	jle    c002d145 <simple_thread_func+0x15>
      lock_acquire (data->lock);
      *(*data->op)++ = data->id;
      lock_release (data->lock);
      thread_yield ();
    }
}
c002d18c:	90                   	nop
c002d18d:	c9                   	leave  
c002d18e:	c3                   	ret    

c002d18f <test_priority_preempt>:

static thread_func simple_thread_func;

void
test_priority_preempt (void) 
{
c002d18f:	55                   	push   %ebp
c002d190:	89 e5                	mov    %esp,%ebp
c002d192:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d195:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002d19c:	83 f0 01             	xor    $0x1,%eax
c002d19f:	84 c0                	test   %al,%al
c002d1a1:	75 1e                	jne    c002d1c1 <test_priority_preempt+0x32>
c002d1a3:	83 ec 0c             	sub    $0xc,%esp
c002d1a6:	68 4c 25 03 c0       	push   $0xc003254c
c002d1ab:	68 5a 25 03 c0       	push   $0xc003255a
c002d1b0:	68 30 26 03 c0       	push   $0xc0032630
c002d1b5:	6a 15                	push   $0x15
c002d1b7:	68 74 25 03 c0       	push   $0xc0032574
c002d1bc:	e8 70 c4 ff ff       	call   c0029631 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d1c1:	e8 d6 3c ff ff       	call   c0020e9c <thread_get_priority>
c002d1c6:	83 f8 1f             	cmp    $0x1f,%eax
c002d1c9:	74 1e                	je     c002d1e9 <test_priority_preempt+0x5a>
c002d1cb:	83 ec 0c             	sub    $0xc,%esp
c002d1ce:	68 9c 25 03 c0       	push   $0xc003259c
c002d1d3:	68 5a 25 03 c0       	push   $0xc003255a
c002d1d8:	68 30 26 03 c0       	push   $0xc0032630
c002d1dd:	6a 18                	push   $0x18
c002d1df:	68 74 25 03 c0       	push   $0xc0032574
c002d1e4:	e8 48 c4 ff ff       	call   c0029631 <debug_panic>

  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002d1e9:	6a 00                	push   $0x0
c002d1eb:	68 12 d2 02 c0       	push   $0xc002d212
c002d1f0:	6a 20                	push   $0x20
c002d1f2:	68 c2 25 03 c0       	push   $0xc00325c2
c002d1f7:	e8 6c 38 ff ff       	call   c0020a68 <thread_create>
c002d1fc:	83 c4 10             	add    $0x10,%esp
  msg ("The high-priority thread should have already completed.");
c002d1ff:	83 ec 0c             	sub    $0xc,%esp
c002d202:	68 d0 25 03 c0       	push   $0xc00325d0
c002d207:	e8 b6 e7 ff ff       	call   c002b9c2 <msg>
c002d20c:	83 c4 10             	add    $0x10,%esp
}
c002d20f:	90                   	nop
c002d210:	c9                   	leave  
c002d211:	c3                   	ret    

c002d212 <simple_thread_func>:

static void 
simple_thread_func (void *aux UNUSED) 
{
c002d212:	55                   	push   %ebp
c002d213:	89 e5                	mov    %esp,%ebp
c002d215:	83 ec 18             	sub    $0x18,%esp
  int i;
  
  for (i = 0; i < 5; i++) 
c002d218:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d21f:	eb 22                	jmp    c002d243 <simple_thread_func+0x31>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002d221:	e8 4b 3a ff ff       	call   c0020c71 <thread_name>
c002d226:	83 ec 04             	sub    $0x4,%esp
c002d229:	ff 75 f4             	pushl  -0xc(%ebp)
c002d22c:	50                   	push   %eax
c002d22d:	68 08 26 03 c0       	push   $0xc0032608
c002d232:	e8 8b e7 ff ff       	call   c002b9c2 <msg>
c002d237:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002d23a:	e8 38 3b ff ff       	call   c0020d77 <thread_yield>
static void 
simple_thread_func (void *aux UNUSED) 
{
  int i;
  
  for (i = 0; i < 5; i++) 
c002d23f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d243:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c002d247:	7e d8                	jle    c002d221 <simple_thread_func+0xf>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
      thread_yield ();
    }
  msg ("Thread %s done!", thread_name ());
c002d249:	e8 23 3a ff ff       	call   c0020c71 <thread_name>
c002d24e:	83 ec 08             	sub    $0x8,%esp
c002d251:	50                   	push   %eax
c002d252:	68 1f 26 03 c0       	push   $0xc003261f
c002d257:	e8 66 e7 ff ff       	call   c002b9c2 <msg>
c002d25c:	83 c4 10             	add    $0x10,%esp
}
c002d25f:	90                   	nop
c002d260:	c9                   	leave  
c002d261:	c3                   	ret    

c002d262 <test_priority_sema>:
static thread_func priority_sema_thread;
static struct semaphore sema;

void
test_priority_sema (void) 
{
c002d262:	55                   	push   %ebp
c002d263:	89 e5                	mov    %esp,%ebp
c002d265:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d268:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002d26f:	83 f0 01             	xor    $0x1,%eax
c002d272:	84 c0                	test   %al,%al
c002d274:	75 1e                	jne    c002d294 <test_priority_sema+0x32>
c002d276:	83 ec 0c             	sub    $0xc,%esp
c002d279:	68 48 26 03 c0       	push   $0xc0032648
c002d27e:	68 56 26 03 c0       	push   $0xc0032656
c002d283:	68 c8 26 03 c0       	push   $0xc00326c8
c002d288:	6a 15                	push   $0x15
c002d28a:	68 70 26 03 c0       	push   $0xc0032670
c002d28f:	e8 9d c3 ff ff       	call   c0029631 <debug_panic>

  sema_init (&sema, 0);
c002d294:	83 ec 08             	sub    $0x8,%esp
c002d297:	6a 00                	push   $0x0
c002d299:	68 34 9c 03 c0       	push   $0xc0039c34
c002d29e:	e8 17 55 ff ff       	call   c00227ba <sema_init>
c002d2a3:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_MIN);
c002d2a6:	83 ec 0c             	sub    $0xc,%esp
c002d2a9:	6a 00                	push   $0x0
c002d2ab:	e8 d6 3b ff ff       	call   c0020e86 <thread_set_priority>
c002d2b0:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d2b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d2ba:	eb 60                	jmp    c002d31c <test_priority_sema+0xba>
    {
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002d2bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d2bf:	8d 48 03             	lea    0x3(%eax),%ecx
c002d2c2:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002d2c7:	89 c8                	mov    %ecx,%eax
c002d2c9:	f7 ea                	imul   %edx
c002d2cb:	c1 fa 02             	sar    $0x2,%edx
c002d2ce:	89 c8                	mov    %ecx,%eax
c002d2d0:	c1 f8 1f             	sar    $0x1f,%eax
c002d2d3:	29 c2                	sub    %eax,%edx
c002d2d5:	89 d0                	mov    %edx,%eax
c002d2d7:	c1 e0 02             	shl    $0x2,%eax
c002d2da:	01 d0                	add    %edx,%eax
c002d2dc:	01 c0                	add    %eax,%eax
c002d2de:	29 c1                	sub    %eax,%ecx
c002d2e0:	89 ca                	mov    %ecx,%edx
c002d2e2:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002d2e7:	29 d0                	sub    %edx,%eax
c002d2e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002d2ec:	ff 75 f0             	pushl  -0x10(%ebp)
c002d2ef:	68 94 26 03 c0       	push   $0xc0032694
c002d2f4:	6a 10                	push   $0x10
c002d2f6:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d2f9:	50                   	push   %eax
c002d2fa:	e8 d6 9e ff ff       	call   c00271d5 <snprintf>
c002d2ff:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_sema_thread, NULL);
c002d302:	6a 00                	push   $0x0
c002d304:	68 58 d3 02 c0       	push   $0xc002d358
c002d309:	ff 75 f0             	pushl  -0x10(%ebp)
c002d30c:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d30f:	50                   	push   %eax
c002d310:	e8 53 37 ff ff       	call   c0020a68 <thread_create>
c002d315:	83 c4 10             	add    $0x10,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);

  sema_init (&sema, 0);
  thread_set_priority (PRI_MIN);
  for (i = 0; i < 10; i++) 
c002d318:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d31c:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d320:	7e 9a                	jle    c002d2bc <test_priority_sema+0x5a>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_sema_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002d322:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d329:	eb 24                	jmp    c002d34f <test_priority_sema+0xed>
    {
      sema_up (&sema);
c002d32b:	83 ec 0c             	sub    $0xc,%esp
c002d32e:	68 34 9c 03 c0       	push   $0xc0039c34
c002d333:	e8 d4 55 ff ff       	call   c002290c <sema_up>
c002d338:	83 c4 10             	add    $0x10,%esp
      msg ("Back in main thread."); 
c002d33b:	83 ec 0c             	sub    $0xc,%esp
c002d33e:	68 a0 26 03 c0       	push   $0xc00326a0
c002d343:	e8 7a e6 ff ff       	call   c002b9c2 <msg>
c002d348:	83 c4 10             	add    $0x10,%esp
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_sema_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002d34b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d34f:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d353:	7e d6                	jle    c002d32b <test_priority_sema+0xc9>
    {
      sema_up (&sema);
      msg ("Back in main thread."); 
    }
}
c002d355:	90                   	nop
c002d356:	c9                   	leave  
c002d357:	c3                   	ret    

c002d358 <priority_sema_thread>:

static void
priority_sema_thread (void *aux UNUSED) 
{
c002d358:	55                   	push   %ebp
c002d359:	89 e5                	mov    %esp,%ebp
c002d35b:	83 ec 08             	sub    $0x8,%esp
  sema_down (&sema);
c002d35e:	83 ec 0c             	sub    $0xc,%esp
c002d361:	68 34 9c 03 c0       	push   $0xc0039c34
c002d366:	e8 96 54 ff ff       	call   c0022801 <sema_down>
c002d36b:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002d36e:	e8 fe 38 ff ff       	call   c0020c71 <thread_name>
c002d373:	83 ec 08             	sub    $0x8,%esp
c002d376:	50                   	push   %eax
c002d377:	68 b5 26 03 c0       	push   $0xc00326b5
c002d37c:	e8 41 e6 ff ff       	call   c002b9c2 <msg>
c002d381:	83 c4 10             	add    $0x10,%esp
}
c002d384:	90                   	nop
c002d385:	c9                   	leave  
c002d386:	c3                   	ret    

c002d387 <test_priority_condvar>:
static struct lock lock;
static struct condition condition;

void
test_priority_condvar (void) 
{
c002d387:	55                   	push   %ebp
c002d388:	89 e5                	mov    %esp,%ebp
c002d38a:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d38d:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002d394:	83 f0 01             	xor    $0x1,%eax
c002d397:	84 c0                	test   %al,%al
c002d399:	75 1e                	jne    c002d3b9 <test_priority_condvar+0x32>
c002d39b:	83 ec 0c             	sub    $0xc,%esp
c002d39e:	68 dc 26 03 c0       	push   $0xc00326dc
c002d3a3:	68 ea 26 03 c0       	push   $0xc00326ea
c002d3a8:	68 6c 27 03 c0       	push   $0xc003276c
c002d3ad:	6a 16                	push   $0x16
c002d3af:	68 04 27 03 c0       	push   $0xc0032704
c002d3b4:	e8 78 c2 ff ff       	call   c0029631 <debug_panic>

  lock_init (&lock);
c002d3b9:	83 ec 0c             	sub    $0xc,%esp
c002d3bc:	68 48 9c 03 c0       	push   $0xc0039c48
c002d3c1:	e8 af 56 ff ff       	call   c0022a75 <lock_init>
c002d3c6:	83 c4 10             	add    $0x10,%esp
  cond_init (&condition);
c002d3c9:	83 ec 0c             	sub    $0xc,%esp
c002d3cc:	68 60 9c 03 c0       	push   $0xc0039c60
c002d3d1:	e8 ed 58 ff ff       	call   c0022cc3 <cond_init>
c002d3d6:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_MIN);
c002d3d9:	83 ec 0c             	sub    $0xc,%esp
c002d3dc:	6a 00                	push   $0x0
c002d3de:	e8 a3 3a ff ff       	call   c0020e86 <thread_set_priority>
c002d3e3:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d3e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d3ed:	eb 60                	jmp    c002d44f <test_priority_condvar+0xc8>
    {
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002d3ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d3f2:	8d 48 07             	lea    0x7(%eax),%ecx
c002d3f5:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002d3fa:	89 c8                	mov    %ecx,%eax
c002d3fc:	f7 ea                	imul   %edx
c002d3fe:	c1 fa 02             	sar    $0x2,%edx
c002d401:	89 c8                	mov    %ecx,%eax
c002d403:	c1 f8 1f             	sar    $0x1f,%eax
c002d406:	29 c2                	sub    %eax,%edx
c002d408:	89 d0                	mov    %edx,%eax
c002d40a:	c1 e0 02             	shl    $0x2,%eax
c002d40d:	01 d0                	add    %edx,%eax
c002d40f:	01 c0                	add    %eax,%eax
c002d411:	29 c1                	sub    %eax,%ecx
c002d413:	89 ca                	mov    %ecx,%edx
c002d415:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002d41a:	29 d0                	sub    %edx,%eax
c002d41c:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002d41f:	ff 75 f0             	pushl  -0x10(%ebp)
c002d422:	68 2b 27 03 c0       	push   $0xc003272b
c002d427:	6a 10                	push   $0x10
c002d429:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d42c:	50                   	push   %eax
c002d42d:	e8 a3 9d ff ff       	call   c00271d5 <snprintf>
c002d432:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_condvar_thread, NULL);
c002d435:	6a 00                	push   $0x0
c002d437:	68 b0 d4 02 c0       	push   $0xc002d4b0
c002d43c:	ff 75 f0             	pushl  -0x10(%ebp)
c002d43f:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d442:	50                   	push   %eax
c002d443:	e8 20 36 ff ff       	call   c0020a68 <thread_create>
c002d448:	83 c4 10             	add    $0x10,%esp

  lock_init (&lock);
  cond_init (&condition);

  thread_set_priority (PRI_MIN);
  for (i = 0; i < 10; i++) 
c002d44b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d44f:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d453:	7e 9a                	jle    c002d3ef <test_priority_condvar+0x68>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_condvar_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002d455:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d45c:	eb 49                	jmp    c002d4a7 <test_priority_condvar+0x120>
    {
      lock_acquire (&lock);
c002d45e:	83 ec 0c             	sub    $0xc,%esp
c002d461:	68 48 9c 03 c0       	push   $0xc0039c48
c002d466:	e8 57 56 ff ff       	call   c0022ac2 <lock_acquire>
c002d46b:	83 c4 10             	add    $0x10,%esp
      msg ("Signaling...");
c002d46e:	83 ec 0c             	sub    $0xc,%esp
c002d471:	68 37 27 03 c0       	push   $0xc0032737
c002d476:	e8 47 e5 ff ff       	call   c002b9c2 <msg>
c002d47b:	83 c4 10             	add    $0x10,%esp
      cond_signal (&condition, &lock);
c002d47e:	83 ec 08             	sub    $0x8,%esp
c002d481:	68 48 9c 03 c0       	push   $0xc0039c48
c002d486:	68 60 9c 03 c0       	push   $0xc0039c60
c002d48b:	e8 7e 59 ff ff       	call   c0022e0e <cond_signal>
c002d490:	83 c4 10             	add    $0x10,%esp
      lock_release (&lock);
c002d493:	83 ec 0c             	sub    $0xc,%esp
c002d496:	68 48 9c 03 c0       	push   $0xc0039c48
c002d49b:	e8 63 57 ff ff       	call   c0022c03 <lock_release>
c002d4a0:	83 c4 10             	add    $0x10,%esp
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_condvar_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002d4a3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d4a7:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d4ab:	7e b1                	jle    c002d45e <test_priority_condvar+0xd7>
      lock_acquire (&lock);
      msg ("Signaling...");
      cond_signal (&condition, &lock);
      lock_release (&lock);
    }
}
c002d4ad:	90                   	nop
c002d4ae:	c9                   	leave  
c002d4af:	c3                   	ret    

c002d4b0 <priority_condvar_thread>:

static void
priority_condvar_thread (void *aux UNUSED) 
{
c002d4b0:	55                   	push   %ebp
c002d4b1:	89 e5                	mov    %esp,%ebp
c002d4b3:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread %s starting.", thread_name ());
c002d4b6:	e8 b6 37 ff ff       	call   c0020c71 <thread_name>
c002d4bb:	83 ec 08             	sub    $0x8,%esp
c002d4be:	50                   	push   %eax
c002d4bf:	68 44 27 03 c0       	push   $0xc0032744
c002d4c4:	e8 f9 e4 ff ff       	call   c002b9c2 <msg>
c002d4c9:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002d4cc:	83 ec 0c             	sub    $0xc,%esp
c002d4cf:	68 48 9c 03 c0       	push   $0xc0039c48
c002d4d4:	e8 e9 55 ff ff       	call   c0022ac2 <lock_acquire>
c002d4d9:	83 c4 10             	add    $0x10,%esp
  cond_wait (&condition, &lock);
c002d4dc:	83 ec 08             	sub    $0x8,%esp
c002d4df:	68 48 9c 03 c0       	push   $0xc0039c48
c002d4e4:	68 60 9c 03 c0       	push   $0xc0039c60
c002d4e9:	e8 14 58 ff ff       	call   c0022d02 <cond_wait>
c002d4ee:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002d4f1:	e8 7b 37 ff ff       	call   c0020c71 <thread_name>
c002d4f6:	83 ec 08             	sub    $0x8,%esp
c002d4f9:	50                   	push   %eax
c002d4fa:	68 58 27 03 c0       	push   $0xc0032758
c002d4ff:	e8 be e4 ff ff       	call   c002b9c2 <msg>
c002d504:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002d507:	83 ec 0c             	sub    $0xc,%esp
c002d50a:	68 48 9c 03 c0       	push   $0xc0039c48
c002d50f:	e8 ef 56 ff ff       	call   c0022c03 <lock_release>
c002d514:	83 c4 10             	add    $0x10,%esp
}
c002d517:	90                   	nop
c002d518:	c9                   	leave  
c002d519:	c3                   	ret    

c002d51a <test_priority_donate_chain>:
static thread_func donor_thread_func;
static thread_func interloper_thread_func;

void
test_priority_donate_chain (void) 
{
c002d51a:	55                   	push   %ebp
c002d51b:	89 e5                	mov    %esp,%ebp
c002d51d:	53                   	push   %ebx
c002d51e:	81 ec 04 01 00 00    	sub    $0x104,%esp
  int i;  
  struct lock locks[NESTING_DEPTH - 1];
  struct lock_pair lock_pairs[NESTING_DEPTH];

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d524:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002d52b:	83 f0 01             	xor    $0x1,%eax
c002d52e:	84 c0                	test   %al,%al
c002d530:	75 1e                	jne    c002d550 <test_priority_donate_chain+0x36>
c002d532:	83 ec 0c             	sub    $0xc,%esp
c002d535:	68 84 27 03 c0       	push   $0xc0032784
c002d53a:	68 92 27 03 c0       	push   $0xc0032792
c002d53f:	68 9c 28 03 c0       	push   $0xc003289c
c002d544:	6a 34                	push   $0x34
c002d546:	68 ac 27 03 c0       	push   $0xc00327ac
c002d54b:	e8 e1 c0 ff ff       	call   c0029631 <debug_panic>

  thread_set_priority (PRI_MIN);
c002d550:	83 ec 0c             	sub    $0xc,%esp
c002d553:	6a 00                	push   $0x0
c002d555:	e8 2c 39 ff ff       	call   c0020e86 <thread_set_priority>
c002d55a:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002d55d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d564:	eb 24                	jmp    c002d58a <test_priority_donate_chain+0x70>
    lock_init (&locks[i]);
c002d566:	8d 8d 48 ff ff ff    	lea    -0xb8(%ebp),%ecx
c002d56c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d56f:	89 d0                	mov    %edx,%eax
c002d571:	01 c0                	add    %eax,%eax
c002d573:	01 d0                	add    %edx,%eax
c002d575:	c1 e0 03             	shl    $0x3,%eax
c002d578:	01 c8                	add    %ecx,%eax
c002d57a:	83 ec 0c             	sub    $0xc,%esp
c002d57d:	50                   	push   %eax
c002d57e:	e8 f2 54 ff ff       	call   c0022a75 <lock_init>
c002d583:	83 c4 10             	add    $0x10,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);

  thread_set_priority (PRI_MIN);

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002d586:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d58a:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002d58e:	7e d6                	jle    c002d566 <test_priority_donate_chain+0x4c>
    lock_init (&locks[i]);

  lock_acquire (&locks[0]);
c002d590:	83 ec 0c             	sub    $0xc,%esp
c002d593:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d599:	50                   	push   %eax
c002d59a:	e8 23 55 ff ff       	call   c0022ac2 <lock_acquire>
c002d59f:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock.", thread_name ());
c002d5a2:	e8 ca 36 ff ff       	call   c0020c71 <thread_name>
c002d5a7:	83 ec 08             	sub    $0x8,%esp
c002d5aa:	50                   	push   %eax
c002d5ab:	68 d8 27 03 c0       	push   $0xc00327d8
c002d5b0:	e8 0d e4 ff ff       	call   c002b9c2 <msg>
c002d5b5:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i < NESTING_DEPTH; i++)
c002d5b8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002d5bf:	e9 f5 00 00 00       	jmp    c002d6b9 <test_priority_donate_chain+0x19f>
    {
      char name[16];
      int thread_priority;

      snprintf (name, sizeof name, "thread %d", i);
c002d5c4:	ff 75 f4             	pushl  -0xc(%ebp)
c002d5c7:	68 e5 27 03 c0       	push   $0xc00327e5
c002d5cc:	6a 10                	push   $0x10
c002d5ce:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d5d4:	50                   	push   %eax
c002d5d5:	e8 fb 9b ff ff       	call   c00271d5 <snprintf>
c002d5da:	83 c4 10             	add    $0x10,%esp
      thread_priority = PRI_MIN + i * 3;
c002d5dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d5e0:	89 d0                	mov    %edx,%eax
c002d5e2:	01 c0                	add    %eax,%eax
c002d5e4:	01 d0                	add    %edx,%eax
c002d5e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002d5e9:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002d5ed:	7f 18                	jg     c002d607 <test_priority_donate_chain+0xed>
c002d5ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d5f2:	89 d0                	mov    %edx,%eax
c002d5f4:	01 c0                	add    %eax,%eax
c002d5f6:	01 d0                	add    %edx,%eax
c002d5f8:	c1 e0 03             	shl    $0x3,%eax
c002d5fb:	89 c2                	mov    %eax,%edx
c002d5fd:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d603:	01 c2                	add    %eax,%edx
c002d605:	eb 05                	jmp    c002d60c <test_priority_donate_chain+0xf2>
c002d607:	ba 00 00 00 00       	mov    $0x0,%edx
c002d60c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d60f:	89 94 c5 0c ff ff ff 	mov    %edx,-0xf4(%ebp,%eax,8)
      lock_pairs[i].second = locks + i - 1;
c002d616:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d619:	89 d0                	mov    %edx,%eax
c002d61b:	01 c0                	add    %eax,%eax
c002d61d:	01 d0                	add    %edx,%eax
c002d61f:	c1 e0 03             	shl    $0x3,%eax
c002d622:	8d 50 e8             	lea    -0x18(%eax),%edx
c002d625:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d62b:	01 c2                	add    %eax,%edx
c002d62d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d630:	89 94 c5 08 ff ff ff 	mov    %edx,-0xf8(%ebp,%eax,8)

      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c002d637:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d63a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c002d641:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
c002d647:	01 d0                	add    %edx,%eax
c002d649:	50                   	push   %eax
c002d64a:	68 f9 d6 02 c0       	push   $0xc002d6f9
c002d64f:	ff 75 f0             	pushl  -0x10(%ebp)
c002d652:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d658:	50                   	push   %eax
c002d659:	e8 0a 34 ff ff       	call   c0020a68 <thread_create>
c002d65e:	83 c4 10             	add    $0x10,%esp
      msg ("%s should have priority %d.  Actual priority: %d.",
c002d661:	e8 36 38 ff ff       	call   c0020e9c <thread_get_priority>
c002d666:	89 c3                	mov    %eax,%ebx
c002d668:	e8 04 36 ff ff       	call   c0020c71 <thread_name>
c002d66d:	53                   	push   %ebx
c002d66e:	ff 75 f0             	pushl  -0x10(%ebp)
c002d671:	50                   	push   %eax
c002d672:	68 f0 27 03 c0       	push   $0xc00327f0
c002d677:	e8 46 e3 ff ff       	call   c002b9c2 <msg>
c002d67c:	83 c4 10             	add    $0x10,%esp
          thread_name (), thread_priority, thread_get_priority ());

      snprintf (name, sizeof name, "interloper %d", i);
c002d67f:	ff 75 f4             	pushl  -0xc(%ebp)
c002d682:	68 22 28 03 c0       	push   $0xc0032822
c002d687:	6a 10                	push   $0x10
c002d689:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d68f:	50                   	push   %eax
c002d690:	e8 40 9b ff ff       	call   c00271d5 <snprintf>
c002d695:	83 c4 10             	add    $0x10,%esp
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c002d698:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d69b:	83 e8 01             	sub    $0x1,%eax
c002d69e:	6a 00                	push   $0x0
c002d6a0:	68 b7 d7 02 c0       	push   $0xc002d7b7
c002d6a5:	50                   	push   %eax
c002d6a6:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d6ac:	50                   	push   %eax
c002d6ad:	e8 b6 33 ff ff       	call   c0020a68 <thread_create>
c002d6b2:	83 c4 10             	add    $0x10,%esp
    lock_init (&locks[i]);

  lock_acquire (&locks[0]);
  msg ("%s got lock.", thread_name ());

  for (i = 1; i < NESTING_DEPTH; i++)
c002d6b5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d6b9:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c002d6bd:	0f 8e 01 ff ff ff    	jle    c002d5c4 <test_priority_donate_chain+0xaa>

      snprintf (name, sizeof name, "interloper %d", i);
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
    }

  lock_release (&locks[0]);
c002d6c3:	83 ec 0c             	sub    $0xc,%esp
c002d6c6:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d6cc:	50                   	push   %eax
c002d6cd:	e8 31 55 ff ff       	call   c0022c03 <lock_release>
c002d6d2:	83 c4 10             	add    $0x10,%esp
  msg ("%s finishing with priority %d.", thread_name (),
c002d6d5:	e8 c2 37 ff ff       	call   c0020e9c <thread_get_priority>
c002d6da:	89 c3                	mov    %eax,%ebx
c002d6dc:	e8 90 35 ff ff       	call   c0020c71 <thread_name>
c002d6e1:	83 ec 04             	sub    $0x4,%esp
c002d6e4:	53                   	push   %ebx
c002d6e5:	50                   	push   %eax
c002d6e6:	68 30 28 03 c0       	push   $0xc0032830
c002d6eb:	e8 d2 e2 ff ff       	call   c002b9c2 <msg>
c002d6f0:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002d6f3:	90                   	nop
c002d6f4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d6f7:	c9                   	leave  
c002d6f8:	c3                   	ret    

c002d6f9 <donor_thread_func>:

static void
donor_thread_func (void *locks_) 
{
c002d6f9:	55                   	push   %ebp
c002d6fa:	89 e5                	mov    %esp,%ebp
c002d6fc:	53                   	push   %ebx
c002d6fd:	83 ec 14             	sub    $0x14,%esp
  struct lock_pair *locks = locks_;
c002d700:	8b 45 08             	mov    0x8(%ebp),%eax
c002d703:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (locks->first)
c002d706:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d709:	8b 40 04             	mov    0x4(%eax),%eax
c002d70c:	85 c0                	test   %eax,%eax
c002d70e:	74 12                	je     c002d722 <donor_thread_func+0x29>
    lock_acquire (locks->first);
c002d710:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d713:	8b 40 04             	mov    0x4(%eax),%eax
c002d716:	83 ec 0c             	sub    $0xc,%esp
c002d719:	50                   	push   %eax
c002d71a:	e8 a3 53 ff ff       	call   c0022ac2 <lock_acquire>
c002d71f:	83 c4 10             	add    $0x10,%esp

  lock_acquire (locks->second);
c002d722:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d725:	8b 00                	mov    (%eax),%eax
c002d727:	83 ec 0c             	sub    $0xc,%esp
c002d72a:	50                   	push   %eax
c002d72b:	e8 92 53 ff ff       	call   c0022ac2 <lock_acquire>
c002d730:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock", thread_name ());
c002d733:	e8 39 35 ff ff       	call   c0020c71 <thread_name>
c002d738:	83 ec 08             	sub    $0x8,%esp
c002d73b:	50                   	push   %eax
c002d73c:	68 4f 28 03 c0       	push   $0xc003284f
c002d741:	e8 7c e2 ff ff       	call   c002b9c2 <msg>
c002d746:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->second);
c002d749:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d74c:	8b 00                	mov    (%eax),%eax
c002d74e:	83 ec 0c             	sub    $0xc,%esp
c002d751:	50                   	push   %eax
c002d752:	e8 ac 54 ff ff       	call   c0022c03 <lock_release>
c002d757:	83 c4 10             	add    $0x10,%esp
  msg ("%s should have priority %d. Actual priority: %d", 
c002d75a:	e8 3d 37 ff ff       	call   c0020e9c <thread_get_priority>
c002d75f:	89 c3                	mov    %eax,%ebx
c002d761:	e8 0b 35 ff ff       	call   c0020c71 <thread_name>
c002d766:	53                   	push   %ebx
c002d767:	6a 15                	push   $0x15
c002d769:	50                   	push   %eax
c002d76a:	68 5c 28 03 c0       	push   $0xc003285c
c002d76f:	e8 4e e2 ff ff       	call   c002b9c2 <msg>
c002d774:	83 c4 10             	add    $0x10,%esp
        thread_name (), (NESTING_DEPTH - 1) * 3,
        thread_get_priority ());

  if (locks->first)
c002d777:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d77a:	8b 40 04             	mov    0x4(%eax),%eax
c002d77d:	85 c0                	test   %eax,%eax
c002d77f:	74 12                	je     c002d793 <donor_thread_func+0x9a>
    lock_release (locks->first);
c002d781:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d784:	8b 40 04             	mov    0x4(%eax),%eax
c002d787:	83 ec 0c             	sub    $0xc,%esp
c002d78a:	50                   	push   %eax
c002d78b:	e8 73 54 ff ff       	call   c0022c03 <lock_release>
c002d790:	83 c4 10             	add    $0x10,%esp

  msg ("%s finishing with priority %d.", thread_name (),
c002d793:	e8 04 37 ff ff       	call   c0020e9c <thread_get_priority>
c002d798:	89 c3                	mov    %eax,%ebx
c002d79a:	e8 d2 34 ff ff       	call   c0020c71 <thread_name>
c002d79f:	83 ec 04             	sub    $0x4,%esp
c002d7a2:	53                   	push   %ebx
c002d7a3:	50                   	push   %eax
c002d7a4:	68 30 28 03 c0       	push   $0xc0032830
c002d7a9:	e8 14 e2 ff ff       	call   c002b9c2 <msg>
c002d7ae:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002d7b1:	90                   	nop
c002d7b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d7b5:	c9                   	leave  
c002d7b6:	c3                   	ret    

c002d7b7 <interloper_thread_func>:

static void
interloper_thread_func (void *arg_ UNUSED)
{
c002d7b7:	55                   	push   %ebp
c002d7b8:	89 e5                	mov    %esp,%ebp
c002d7ba:	83 ec 08             	sub    $0x8,%esp
  msg ("%s finished.", thread_name ());
c002d7bd:	e8 af 34 ff ff       	call   c0020c71 <thread_name>
c002d7c2:	83 ec 08             	sub    $0x8,%esp
c002d7c5:	50                   	push   %eax
c002d7c6:	68 8c 28 03 c0       	push   $0xc003288c
c002d7cb:	e8 f2 e1 ff ff       	call   c002b9c2 <msg>
c002d7d0:	83 c4 10             	add    $0x10,%esp
}
c002d7d3:	90                   	nop
c002d7d4:	c9                   	leave  
c002d7d5:	c3                   	ret    

c002d7d6 <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c002d7d6:	55                   	push   %ebp
c002d7d7:	89 e5                	mov    %esp,%ebp
c002d7d9:	53                   	push   %ebx
c002d7da:	83 ec 14             	sub    $0x14,%esp
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c002d7dd:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002d7e4:	84 c0                	test   %al,%al
c002d7e6:	75 1e                	jne    c002d806 <test_mlfqs_load_1+0x30>
c002d7e8:	83 ec 0c             	sub    $0xc,%esp
c002d7eb:	68 b8 28 03 c0       	push   $0xc00328b8
c002d7f0:	68 c5 28 03 c0       	push   $0xc00328c5
c002d7f5:	68 d4 2a 03 c0       	push   $0xc0032ad4
c002d7fa:	6a 18                	push   $0x18
c002d7fc:	68 dc 28 03 c0       	push   $0xc00328dc
c002d801:	e8 2b be ff ff       	call   c0029631 <debug_panic>

  msg ("spinning for up to 45 seconds, please wait...");
c002d806:	83 ec 0c             	sub    $0xc,%esp
c002d809:	68 00 29 03 c0       	push   $0xc0032900
c002d80e:	e8 af e1 ff ff       	call   c002b9c2 <msg>
c002d813:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002d816:	e8 b5 64 ff ff       	call   c0023cd0 <timer_ticks>
c002d81b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002d81e:	89 55 f4             	mov    %edx,-0xc(%ebp)
  for (;;) 
    {
      load_avg = thread_get_load_avg ();
c002d821:	e8 96 36 ff ff       	call   c0020ebc <thread_get_load_avg>
c002d826:	89 45 ec             	mov    %eax,-0x14(%ebp)
      ASSERT (load_avg >= 0);
c002d829:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002d82d:	79 1e                	jns    c002d84d <test_mlfqs_load_1+0x77>
c002d82f:	83 ec 0c             	sub    $0xc,%esp
c002d832:	68 2e 29 03 c0       	push   $0xc003292e
c002d837:	68 c5 28 03 c0       	push   $0xc00328c5
c002d83c:	68 d4 2a 03 c0       	push   $0xc0032ad4
c002d841:	6a 20                	push   $0x20
c002d843:	68 dc 28 03 c0       	push   $0xc00328dc
c002d848:	e8 e4 bd ff ff       	call   c0029631 <debug_panic>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c002d84d:	83 ec 08             	sub    $0x8,%esp
c002d850:	ff 75 f4             	pushl  -0xc(%ebp)
c002d853:	ff 75 f0             	pushl  -0x10(%ebp)
c002d856:	e8 aa 64 ff ff       	call   c0023d05 <timer_elapsed>
c002d85b:	83 c4 10             	add    $0x10,%esp
c002d85e:	6a 00                	push   $0x0
c002d860:	6a 64                	push   $0x64
c002d862:	52                   	push   %edx
c002d863:	50                   	push   %eax
c002d864:	e8 a2 b7 ff ff       	call   c002900b <__divdi3>
c002d869:	83 c4 10             	add    $0x10,%esp
c002d86c:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (load_avg > 100)
c002d86f:	83 7d ec 64          	cmpl   $0x64,-0x14(%ebp)
c002d873:	7e 4e                	jle    c002d8c3 <test_mlfqs_load_1+0xed>
        fail ("load average is %d.%02d "
c002d875:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d878:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002d87d:	89 d8                	mov    %ebx,%eax
c002d87f:	f7 ea                	imul   %edx
c002d881:	c1 fa 05             	sar    $0x5,%edx
c002d884:	89 d8                	mov    %ebx,%eax
c002d886:	c1 f8 1f             	sar    $0x1f,%eax
c002d889:	89 d1                	mov    %edx,%ecx
c002d88b:	29 c1                	sub    %eax,%ecx
c002d88d:	6b c1 64             	imul   $0x64,%ecx,%eax
c002d890:	89 d9                	mov    %ebx,%ecx
c002d892:	29 c1                	sub    %eax,%ecx
c002d894:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d897:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002d89c:	89 d8                	mov    %ebx,%eax
c002d89e:	f7 ea                	imul   %edx
c002d8a0:	c1 fa 05             	sar    $0x5,%edx
c002d8a3:	89 d8                	mov    %ebx,%eax
c002d8a5:	c1 f8 1f             	sar    $0x1f,%eax
c002d8a8:	29 c2                	sub    %eax,%edx
c002d8aa:	89 d0                	mov    %edx,%eax
c002d8ac:	ff 75 e8             	pushl  -0x18(%ebp)
c002d8af:	51                   	push   %ecx
c002d8b0:	50                   	push   %eax
c002d8b1:	68 3c 29 03 c0       	push   $0xc003293c
c002d8b6:	e8 4b e1 ff ff       	call   c002ba06 <fail>
c002d8bb:	83 c4 10             	add    $0x10,%esp
c002d8be:	e9 5e ff ff ff       	jmp    c002d821 <test_mlfqs_load_1+0x4b>
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
c002d8c3:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002d8c7:	7f 1f                	jg     c002d8e8 <test_mlfqs_load_1+0x112>
        break;
      else if (elapsed > 45)
c002d8c9:	83 7d e8 2d          	cmpl   $0x2d,-0x18(%ebp)
c002d8cd:	0f 8e 4e ff ff ff    	jle    c002d821 <test_mlfqs_load_1+0x4b>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002d8d3:	83 ec 0c             	sub    $0xc,%esp
c002d8d6:	68 88 29 03 c0       	push   $0xc0032988
c002d8db:	e8 26 e1 ff ff       	call   c002ba06 <fail>
c002d8e0:	83 c4 10             	add    $0x10,%esp
    }
c002d8e3:	e9 39 ff ff ff       	jmp    c002d821 <test_mlfqs_load_1+0x4b>
      if (load_avg > 100)
        fail ("load average is %d.%02d "
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
        break;
c002d8e8:	90                   	nop
      else if (elapsed > 45)
        fail ("load average stayed below 0.5 for more than 45 seconds");
    }

  if (elapsed < 38)
c002d8e9:	83 7d e8 25          	cmpl   $0x25,-0x18(%ebp)
c002d8ed:	7f 13                	jg     c002d902 <test_mlfqs_load_1+0x12c>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c002d8ef:	83 ec 08             	sub    $0x8,%esp
c002d8f2:	ff 75 e8             	pushl  -0x18(%ebp)
c002d8f5:	68 c0 29 03 c0       	push   $0xc00329c0
c002d8fa:	e8 07 e1 ff ff       	call   c002ba06 <fail>
c002d8ff:	83 c4 10             	add    $0x10,%esp
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c002d902:	83 ec 08             	sub    $0x8,%esp
c002d905:	ff 75 e8             	pushl  -0x18(%ebp)
c002d908:	68 f4 29 03 c0       	push   $0xc00329f4
c002d90d:	e8 b0 e0 ff ff       	call   c002b9c2 <msg>
c002d912:	83 c4 10             	add    $0x10,%esp

  msg ("sleeping for another 10 seconds, please wait...");
c002d915:	83 ec 0c             	sub    $0xc,%esp
c002d918:	68 20 2a 03 c0       	push   $0xc0032a20
c002d91d:	e8 a0 e0 ff ff       	call   c002b9c2 <msg>
c002d922:	83 c4 10             	add    $0x10,%esp
  timer_sleep (TIMER_FREQ * 10);
c002d925:	83 ec 08             	sub    $0x8,%esp
c002d928:	6a 00                	push   $0x0
c002d92a:	68 e8 03 00 00       	push   $0x3e8
c002d92f:	e8 f0 63 ff ff       	call   c0023d24 <timer_sleep>
c002d934:	83 c4 10             	add    $0x10,%esp

  load_avg = thread_get_load_avg ();
c002d937:	e8 80 35 ff ff       	call   c0020ebc <thread_get_load_avg>
c002d93c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (load_avg < 0)
c002d93f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002d943:	79 10                	jns    c002d955 <test_mlfqs_load_1+0x17f>
    fail ("load average fell below 0");
c002d945:	83 ec 0c             	sub    $0xc,%esp
c002d948:	68 50 2a 03 c0       	push   $0xc0032a50
c002d94d:	e8 b4 e0 ff ff       	call   c002ba06 <fail>
c002d952:	83 c4 10             	add    $0x10,%esp
  if (load_avg > 50)
c002d955:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002d959:	7e 10                	jle    c002d96b <test_mlfqs_load_1+0x195>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c002d95b:	83 ec 0c             	sub    $0xc,%esp
c002d95e:	68 6c 2a 03 c0       	push   $0xc0032a6c
c002d963:	e8 9e e0 ff ff       	call   c002ba06 <fail>
c002d968:	83 c4 10             	add    $0x10,%esp
  msg ("load average fell back below 0.5 (to %d.%02d)",
c002d96b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d96e:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002d973:	89 d8                	mov    %ebx,%eax
c002d975:	f7 ea                	imul   %edx
c002d977:	c1 fa 05             	sar    $0x5,%edx
c002d97a:	89 d8                	mov    %ebx,%eax
c002d97c:	c1 f8 1f             	sar    $0x1f,%eax
c002d97f:	89 d1                	mov    %edx,%ecx
c002d981:	29 c1                	sub    %eax,%ecx
c002d983:	6b c1 64             	imul   $0x64,%ecx,%eax
c002d986:	29 c3                	sub    %eax,%ebx
c002d988:	89 d9                	mov    %ebx,%ecx
c002d98a:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d98d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002d992:	89 d8                	mov    %ebx,%eax
c002d994:	f7 ea                	imul   %edx
c002d996:	c1 fa 05             	sar    $0x5,%edx
c002d999:	89 d8                	mov    %ebx,%eax
c002d99b:	c1 f8 1f             	sar    $0x1f,%eax
c002d99e:	29 c2                	sub    %eax,%edx
c002d9a0:	89 d0                	mov    %edx,%eax
c002d9a2:	83 ec 04             	sub    $0x4,%esp
c002d9a5:	51                   	push   %ecx
c002d9a6:	50                   	push   %eax
c002d9a7:	68 a4 2a 03 c0       	push   $0xc0032aa4
c002d9ac:	e8 11 e0 ff ff       	call   c002b9c2 <msg>
c002d9b1:	83 c4 10             	add    $0x10,%esp
       load_avg / 100, load_avg % 100);

  pass ();
c002d9b4:	e8 a4 e0 ff ff       	call   c002ba5d <pass>
}
c002d9b9:	90                   	nop
c002d9ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d9bd:	c9                   	leave  
c002d9be:	c3                   	ret    

c002d9bf <test_mlfqs_load_60>:

#define THREAD_CNT 60

void
test_mlfqs_load_60 (void) 
{
c002d9bf:	55                   	push   %ebp
c002d9c0:	89 e5                	mov    %esp,%ebp
c002d9c2:	53                   	push   %ebx
c002d9c3:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002d9c6:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002d9cd:	84 c0                	test   %al,%al
c002d9cf:	75 1e                	jne    c002d9ef <test_mlfqs_load_60+0x30>
c002d9d1:	83 ec 0c             	sub    $0xc,%esp
c002d9d4:	68 e8 2a 03 c0       	push   $0xc0032ae8
c002d9d9:	68 f5 2a 03 c0       	push   $0xc0032af5
c002d9de:	68 a8 2b 03 c0       	push   $0xc0032ba8
c002d9e3:	6a 77                	push   $0x77
c002d9e5:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002d9ea:	e8 42 bc ff ff       	call   c0029631 <debug_panic>

  start_time = timer_ticks ();
c002d9ef:	e8 dc 62 ff ff       	call   c0023cd0 <timer_ticks>
c002d9f4:	a3 70 9c 03 c0       	mov    %eax,0xc0039c70
c002d9f9:	89 15 74 9c 03 c0    	mov    %edx,0xc0039c74
  msg ("Starting %d niced load threads...", THREAD_CNT);
c002d9ff:	83 ec 08             	sub    $0x8,%esp
c002da02:	6a 3c                	push   $0x3c
c002da04:	68 30 2b 03 c0       	push   $0xc0032b30
c002da09:	e8 b4 df ff ff       	call   c002b9c2 <msg>
c002da0e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002da11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002da18:	eb 2f                	jmp    c002da49 <test_mlfqs_load_60+0x8a>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002da1a:	ff 75 f4             	pushl  -0xc(%ebp)
c002da1d:	68 52 2b 03 c0       	push   $0xc0032b52
c002da22:	6a 10                	push   $0x10
c002da24:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002da27:	50                   	push   %eax
c002da28:	e8 a8 97 ff ff       	call   c00271d5 <snprintf>
c002da2d:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c002da30:	6a 00                	push   $0x0
c002da32:	68 41 db 02 c0       	push   $0xc002db41
c002da37:	6a 1f                	push   $0x1f
c002da39:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002da3c:	50                   	push   %eax
c002da3d:	e8 26 30 ff ff       	call   c0020a68 <thread_create>
c002da42:	83 c4 10             	add    $0x10,%esp
  
  ASSERT (thread_mlfqs);

  start_time = timer_ticks ();
  msg ("Starting %d niced load threads...", THREAD_CNT);
  for (i = 0; i < THREAD_CNT; i++) 
c002da45:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002da49:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002da4d:	7e cb                	jle    c002da1a <test_mlfqs_load_60+0x5b>
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002da4f:	a1 70 9c 03 c0       	mov    0xc0039c70,%eax
c002da54:	8b 15 74 9c 03 c0    	mov    0xc0039c74,%edx
c002da5a:	83 ec 08             	sub    $0x8,%esp
c002da5d:	52                   	push   %edx
c002da5e:	50                   	push   %eax
c002da5f:	e8 a1 62 ff ff       	call   c0023d05 <timer_elapsed>
c002da64:	83 c4 10             	add    $0x10,%esp
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
c002da67:	6a 00                	push   $0x0
c002da69:	6a 64                	push   $0x64
c002da6b:	52                   	push   %edx
c002da6c:	50                   	push   %eax
c002da6d:	e8 99 b5 ff ff       	call   c002900b <__divdi3>
c002da72:	83 c4 10             	add    $0x10,%esp
c002da75:	83 ec 04             	sub    $0x4,%esp
c002da78:	52                   	push   %edx
c002da79:	50                   	push   %eax
c002da7a:	68 5c 2b 03 c0       	push   $0xc0032b5c
c002da7f:	e8 3e df ff ff       	call   c002b9c2 <msg>
c002da84:	83 c4 10             	add    $0x10,%esp
       timer_elapsed (start_time) / TIMER_FREQ);
  
  for (i = 0; i < 90; i++) 
c002da87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002da8e:	e9 9e 00 00 00       	jmp    c002db31 <test_mlfqs_load_60+0x172>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002da93:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002da96:	83 c0 05             	add    $0x5,%eax
c002da99:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c002da9f:	89 c1                	mov    %eax,%ecx
c002daa1:	89 c3                	mov    %eax,%ebx
c002daa3:	c1 fb 1f             	sar    $0x1f,%ebx
c002daa6:	a1 70 9c 03 c0       	mov    0xc0039c70,%eax
c002daab:	8b 15 74 9c 03 c0    	mov    0xc0039c74,%edx
c002dab1:	01 c8                	add    %ecx,%eax
c002dab3:	11 da                	adc    %ebx,%edx
c002dab5:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002dab8:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002dabb:	e8 10 62 ff ff       	call   c0023cd0 <timer_ticks>
c002dac0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002dac3:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002dac6:	29 c1                	sub    %eax,%ecx
c002dac8:	19 d3                	sbb    %edx,%ebx
c002daca:	89 c8                	mov    %ecx,%eax
c002dacc:	89 da                	mov    %ebx,%edx
c002dace:	83 ec 08             	sub    $0x8,%esp
c002dad1:	52                   	push   %edx
c002dad2:	50                   	push   %eax
c002dad3:	e8 4c 62 ff ff       	call   c0023d24 <timer_sleep>
c002dad8:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002dadb:	e8 dc 33 ff ff       	call   c0020ebc <thread_get_load_avg>
c002dae0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002dae3:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dae6:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002daeb:	89 d8                	mov    %ebx,%eax
c002daed:	f7 ea                	imul   %edx
c002daef:	c1 fa 05             	sar    $0x5,%edx
c002daf2:	89 d8                	mov    %ebx,%eax
c002daf4:	c1 f8 1f             	sar    $0x1f,%eax
c002daf7:	89 d1                	mov    %edx,%ecx
c002daf9:	29 c1                	sub    %eax,%ecx
c002dafb:	6b c1 64             	imul   $0x64,%ecx,%eax
c002dafe:	29 c3                	sub    %eax,%ebx
c002db00:	89 d9                	mov    %ebx,%ecx
c002db02:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002db05:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002db0a:	89 d8                	mov    %ebx,%eax
c002db0c:	f7 ea                	imul   %edx
c002db0e:	c1 fa 05             	sar    $0x5,%edx
c002db11:	89 d8                	mov    %ebx,%eax
c002db13:	c1 f8 1f             	sar    $0x1f,%eax
c002db16:	29 c2                	sub    %eax,%edx
c002db18:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002db1b:	01 c0                	add    %eax,%eax
c002db1d:	51                   	push   %ecx
c002db1e:	52                   	push   %edx
c002db1f:	50                   	push   %eax
c002db20:	68 80 2b 03 c0       	push   $0xc0032b80
c002db25:	e8 98 de ff ff       	call   c002b9c2 <msg>
c002db2a:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
  
  for (i = 0; i < 90; i++) 
c002db2d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002db31:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002db35:	0f 8e 58 ff ff ff    	jle    c002da93 <test_mlfqs_load_60+0xd4>
      timer_sleep (sleep_until - timer_ticks ());
      load_avg = thread_get_load_avg ();
      msg ("After %d seconds, load average=%d.%02d.",
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002db3b:	90                   	nop
c002db3c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002db3f:	c9                   	leave  
c002db40:	c3                   	ret    

c002db41 <load_thread>:

static void
load_thread (void *aux UNUSED) 
{
c002db41:	55                   	push   %ebp
c002db42:	89 e5                	mov    %esp,%ebp
c002db44:	53                   	push   %ebx
c002db45:	83 ec 24             	sub    $0x24,%esp
  int64_t sleep_time = 10 * TIMER_FREQ;
c002db48:	c7 45 f0 e8 03 00 00 	movl   $0x3e8,-0x10(%ebp)
c002db4f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
c002db56:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002db59:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002db5c:	05 70 17 00 00       	add    $0x1770,%eax
c002db61:	83 d2 00             	adc    $0x0,%edx
c002db64:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002db67:	89 55 ec             	mov    %edx,-0x14(%ebp)
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;
c002db6a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002db6d:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002db70:	05 70 17 00 00       	add    $0x1770,%eax
c002db75:	83 d2 00             	adc    $0x0,%edx
c002db78:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002db7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  thread_set_nice (20);
c002db7e:	83 ec 0c             	sub    $0xc,%esp
c002db81:	6a 14                	push   $0x14
c002db83:	e8 24 33 ff ff       	call   c0020eac <thread_set_nice>
c002db88:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (start_time));
c002db8b:	a1 70 9c 03 c0       	mov    0xc0039c70,%eax
c002db90:	8b 15 74 9c 03 c0    	mov    0xc0039c74,%edx
c002db96:	83 ec 08             	sub    $0x8,%esp
c002db99:	52                   	push   %edx
c002db9a:	50                   	push   %eax
c002db9b:	e8 65 61 ff ff       	call   c0023d05 <timer_elapsed>
c002dba0:	83 c4 10             	add    $0x10,%esp
c002dba3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c002dba6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c002dba9:	29 c1                	sub    %eax,%ecx
c002dbab:	19 d3                	sbb    %edx,%ebx
c002dbad:	89 c8                	mov    %ecx,%eax
c002dbaf:	89 da                	mov    %ebx,%edx
c002dbb1:	83 ec 08             	sub    $0x8,%esp
c002dbb4:	52                   	push   %edx
c002dbb5:	50                   	push   %eax
c002dbb6:	e8 69 61 ff ff       	call   c0023d24 <timer_sleep>
c002dbbb:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002dbbe:	eb 01                	jmp    c002dbc1 <load_thread+0x80>
    continue;
c002dbc0:	90                   	nop
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;

  thread_set_nice (20);
  timer_sleep (sleep_time - timer_elapsed (start_time));
  while (timer_elapsed (start_time) < spin_time)
c002dbc1:	a1 70 9c 03 c0       	mov    0xc0039c70,%eax
c002dbc6:	8b 15 74 9c 03 c0    	mov    0xc0039c74,%edx
c002dbcc:	83 ec 08             	sub    $0x8,%esp
c002dbcf:	52                   	push   %edx
c002dbd0:	50                   	push   %eax
c002dbd1:	e8 2f 61 ff ff       	call   c0023d05 <timer_elapsed>
c002dbd6:	83 c4 10             	add    $0x10,%esp
c002dbd9:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c002dbdc:	7c e2                	jl     c002dbc0 <load_thread+0x7f>
c002dbde:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c002dbe1:	7f 05                	jg     c002dbe8 <load_thread+0xa7>
c002dbe3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002dbe6:	72 d8                	jb     c002dbc0 <load_thread+0x7f>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002dbe8:	a1 70 9c 03 c0       	mov    0xc0039c70,%eax
c002dbed:	8b 15 74 9c 03 c0    	mov    0xc0039c74,%edx
c002dbf3:	83 ec 08             	sub    $0x8,%esp
c002dbf6:	52                   	push   %edx
c002dbf7:	50                   	push   %eax
c002dbf8:	e8 08 61 ff ff       	call   c0023d05 <timer_elapsed>
c002dbfd:	83 c4 10             	add    $0x10,%esp
c002dc00:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002dc03:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dc06:	29 c1                	sub    %eax,%ecx
c002dc08:	19 d3                	sbb    %edx,%ebx
c002dc0a:	89 c8                	mov    %ecx,%eax
c002dc0c:	89 da                	mov    %ebx,%edx
c002dc0e:	83 ec 08             	sub    $0x8,%esp
c002dc11:	52                   	push   %edx
c002dc12:	50                   	push   %eax
c002dc13:	e8 0c 61 ff ff       	call   c0023d24 <timer_sleep>
c002dc18:	83 c4 10             	add    $0x10,%esp
}
c002dc1b:	90                   	nop
c002dc1c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dc1f:	c9                   	leave  
c002dc20:	c3                   	ret    

c002dc21 <test_mlfqs_load_avg>:

#define THREAD_CNT 60

void
test_mlfqs_load_avg (void) 
{
c002dc21:	55                   	push   %ebp
c002dc22:	89 e5                	mov    %esp,%ebp
c002dc24:	53                   	push   %ebx
c002dc25:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002dc28:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002dc2f:	84 c0                	test   %al,%al
c002dc31:	75 21                	jne    c002dc54 <test_mlfqs_load_avg+0x33>
c002dc33:	83 ec 0c             	sub    $0xc,%esp
c002dc36:	68 bc 2b 03 c0       	push   $0xc0032bbc
c002dc3b:	68 c9 2b 03 c0       	push   $0xc0032bc9
c002dc40:	68 78 2c 03 c0       	push   $0xc0032c78
c002dc45:	68 82 00 00 00       	push   $0x82
c002dc4a:	68 e0 2b 03 c0       	push   $0xc0032be0
c002dc4f:	e8 dd b9 ff ff       	call   c0029631 <debug_panic>

  start_time = timer_ticks ();
c002dc54:	e8 77 60 ff ff       	call   c0023cd0 <timer_ticks>
c002dc59:	a3 78 9c 03 c0       	mov    %eax,0xc0039c78
c002dc5e:	89 15 7c 9c 03 c0    	mov    %edx,0xc0039c7c
  msg ("Starting %d load threads...", THREAD_CNT);
c002dc64:	83 ec 08             	sub    $0x8,%esp
c002dc67:	6a 3c                	push   $0x3c
c002dc69:	68 05 2c 03 c0       	push   $0xc0032c05
c002dc6e:	e8 4f dd ff ff       	call   c002b9c2 <msg>
c002dc73:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002dc76:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002dc7d:	eb 31                	jmp    c002dcb0 <test_mlfqs_load_avg+0x8f>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002dc7f:	ff 75 f4             	pushl  -0xc(%ebp)
c002dc82:	68 21 2c 03 c0       	push   $0xc0032c21
c002dc87:	6a 10                	push   $0x10
c002dc89:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002dc8c:	50                   	push   %eax
c002dc8d:	e8 43 95 ff ff       	call   c00271d5 <snprintf>
c002dc92:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c002dc95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dc98:	50                   	push   %eax
c002dc99:	68 b5 dd 02 c0       	push   $0xc002ddb5
c002dc9e:	6a 1f                	push   $0x1f
c002dca0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002dca3:	50                   	push   %eax
c002dca4:	e8 bf 2d ff ff       	call   c0020a68 <thread_create>
c002dca9:	83 c4 10             	add    $0x10,%esp
  
  ASSERT (thread_mlfqs);

  start_time = timer_ticks ();
  msg ("Starting %d load threads...", THREAD_CNT);
  for (i = 0; i < THREAD_CNT; i++) 
c002dcac:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002dcb0:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002dcb4:	7e c9                	jle    c002dc7f <test_mlfqs_load_avg+0x5e>
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002dcb6:	a1 78 9c 03 c0       	mov    0xc0039c78,%eax
c002dcbb:	8b 15 7c 9c 03 c0    	mov    0xc0039c7c,%edx
c002dcc1:	83 ec 08             	sub    $0x8,%esp
c002dcc4:	52                   	push   %edx
c002dcc5:	50                   	push   %eax
c002dcc6:	e8 3a 60 ff ff       	call   c0023d05 <timer_elapsed>
c002dccb:	83 c4 10             	add    $0x10,%esp
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
    }
  msg ("Starting threads took %d seconds.",
c002dcce:	6a 00                	push   $0x0
c002dcd0:	6a 64                	push   $0x64
c002dcd2:	52                   	push   %edx
c002dcd3:	50                   	push   %eax
c002dcd4:	e8 32 b3 ff ff       	call   c002900b <__divdi3>
c002dcd9:	83 c4 10             	add    $0x10,%esp
c002dcdc:	83 ec 04             	sub    $0x4,%esp
c002dcdf:	52                   	push   %edx
c002dce0:	50                   	push   %eax
c002dce1:	68 2c 2c 03 c0       	push   $0xc0032c2c
c002dce6:	e8 d7 dc ff ff       	call   c002b9c2 <msg>
c002dceb:	83 c4 10             	add    $0x10,%esp
       timer_elapsed (start_time) / TIMER_FREQ);
  thread_set_nice (-20);
c002dcee:	83 ec 0c             	sub    $0xc,%esp
c002dcf1:	6a ec                	push   $0xffffffec
c002dcf3:	e8 b4 31 ff ff       	call   c0020eac <thread_set_nice>
c002dcf8:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 90; i++) 
c002dcfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002dd02:	e9 9e 00 00 00       	jmp    c002dda5 <test_mlfqs_load_avg+0x184>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002dd07:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dd0a:	83 c0 05             	add    $0x5,%eax
c002dd0d:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c002dd13:	89 c1                	mov    %eax,%ecx
c002dd15:	89 c3                	mov    %eax,%ebx
c002dd17:	c1 fb 1f             	sar    $0x1f,%ebx
c002dd1a:	a1 78 9c 03 c0       	mov    0xc0039c78,%eax
c002dd1f:	8b 15 7c 9c 03 c0    	mov    0xc0039c7c,%edx
c002dd25:	01 c8                	add    %ecx,%eax
c002dd27:	11 da                	adc    %ebx,%edx
c002dd29:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002dd2c:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002dd2f:	e8 9c 5f ff ff       	call   c0023cd0 <timer_ticks>
c002dd34:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002dd37:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002dd3a:	29 c1                	sub    %eax,%ecx
c002dd3c:	19 d3                	sbb    %edx,%ebx
c002dd3e:	89 c8                	mov    %ecx,%eax
c002dd40:	89 da                	mov    %ebx,%edx
c002dd42:	83 ec 08             	sub    $0x8,%esp
c002dd45:	52                   	push   %edx
c002dd46:	50                   	push   %eax
c002dd47:	e8 d8 5f ff ff       	call   c0023d24 <timer_sleep>
c002dd4c:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002dd4f:	e8 68 31 ff ff       	call   c0020ebc <thread_get_load_avg>
c002dd54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002dd57:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dd5a:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dd5f:	89 d8                	mov    %ebx,%eax
c002dd61:	f7 ea                	imul   %edx
c002dd63:	c1 fa 05             	sar    $0x5,%edx
c002dd66:	89 d8                	mov    %ebx,%eax
c002dd68:	c1 f8 1f             	sar    $0x1f,%eax
c002dd6b:	89 d1                	mov    %edx,%ecx
c002dd6d:	29 c1                	sub    %eax,%ecx
c002dd6f:	6b c1 64             	imul   $0x64,%ecx,%eax
c002dd72:	29 c3                	sub    %eax,%ebx
c002dd74:	89 d9                	mov    %ebx,%ecx
c002dd76:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dd79:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dd7e:	89 d8                	mov    %ebx,%eax
c002dd80:	f7 ea                	imul   %edx
c002dd82:	c1 fa 05             	sar    $0x5,%edx
c002dd85:	89 d8                	mov    %ebx,%eax
c002dd87:	c1 f8 1f             	sar    $0x1f,%eax
c002dd8a:	29 c2                	sub    %eax,%edx
c002dd8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dd8f:	01 c0                	add    %eax,%eax
c002dd91:	51                   	push   %ecx
c002dd92:	52                   	push   %edx
c002dd93:	50                   	push   %eax
c002dd94:	68 50 2c 03 c0       	push   $0xc0032c50
c002dd99:	e8 24 dc ff ff       	call   c002b9c2 <msg>
c002dd9e:	83 c4 10             	add    $0x10,%esp
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
  thread_set_nice (-20);

  for (i = 0; i < 90; i++) 
c002dda1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002dda5:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002dda9:	0f 8e 58 ff ff ff    	jle    c002dd07 <test_mlfqs_load_avg+0xe6>
      timer_sleep (sleep_until - timer_ticks ());
      load_avg = thread_get_load_avg ();
      msg ("After %d seconds, load average=%d.%02d.",
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002ddaf:	90                   	nop
c002ddb0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ddb3:	c9                   	leave  
c002ddb4:	c3                   	ret    

c002ddb5 <load_thread>:

static void
load_thread (void *seq_no_) 
{
c002ddb5:	55                   	push   %ebp
c002ddb6:	89 e5                	mov    %esp,%ebp
c002ddb8:	56                   	push   %esi
c002ddb9:	53                   	push   %ebx
c002ddba:	83 ec 10             	sub    $0x10,%esp
  int seq_no = (int) seq_no_;
c002ddbd:	8b 45 08             	mov    0x8(%ebp),%eax
c002ddc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c002ddc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ddc6:	83 c0 0a             	add    $0xa,%eax
c002ddc9:	6b c0 64             	imul   $0x64,%eax,%eax
c002ddcc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c002ddcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ddd2:	05 70 17 00 00       	add    $0x1770,%eax
c002ddd7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);
c002ddda:	c7 45 e8 e0 2e 00 00 	movl   $0x2ee0,-0x18(%ebp)

  timer_sleep (sleep_time - timer_elapsed (start_time));
c002dde1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dde4:	89 c3                	mov    %eax,%ebx
c002dde6:	89 c6                	mov    %eax,%esi
c002dde8:	c1 fe 1f             	sar    $0x1f,%esi
c002ddeb:	a1 78 9c 03 c0       	mov    0xc0039c78,%eax
c002ddf0:	8b 15 7c 9c 03 c0    	mov    0xc0039c7c,%edx
c002ddf6:	83 ec 08             	sub    $0x8,%esp
c002ddf9:	52                   	push   %edx
c002ddfa:	50                   	push   %eax
c002ddfb:	e8 05 5f ff ff       	call   c0023d05 <timer_elapsed>
c002de00:	83 c4 10             	add    $0x10,%esp
c002de03:	29 c3                	sub    %eax,%ebx
c002de05:	19 d6                	sbb    %edx,%esi
c002de07:	89 d8                	mov    %ebx,%eax
c002de09:	89 f2                	mov    %esi,%edx
c002de0b:	83 ec 08             	sub    $0x8,%esp
c002de0e:	52                   	push   %edx
c002de0f:	50                   	push   %eax
c002de10:	e8 0f 5f ff ff       	call   c0023d24 <timer_sleep>
c002de15:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002de18:	eb 01                	jmp    c002de1b <load_thread+0x66>
    continue;
c002de1a:	90                   	nop
  int sleep_time = TIMER_FREQ * (10 + seq_no);
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);

  timer_sleep (sleep_time - timer_elapsed (start_time));
  while (timer_elapsed (start_time) < spin_time)
c002de1b:	a1 78 9c 03 c0       	mov    0xc0039c78,%eax
c002de20:	8b 15 7c 9c 03 c0    	mov    0xc0039c7c,%edx
c002de26:	83 ec 08             	sub    $0x8,%esp
c002de29:	52                   	push   %edx
c002de2a:	50                   	push   %eax
c002de2b:	e8 d5 5e ff ff       	call   c0023d05 <timer_elapsed>
c002de30:	83 c4 10             	add    $0x10,%esp
c002de33:	89 c1                	mov    %eax,%ecx
c002de35:	89 d3                	mov    %edx,%ebx
c002de37:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002de3a:	99                   	cltd   
c002de3b:	39 d3                	cmp    %edx,%ebx
c002de3d:	7c db                	jl     c002de1a <load_thread+0x65>
c002de3f:	39 d3                	cmp    %edx,%ebx
c002de41:	7f 04                	jg     c002de47 <load_thread+0x92>
c002de43:	39 c1                	cmp    %eax,%ecx
c002de45:	72 d3                	jb     c002de1a <load_thread+0x65>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002de47:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002de4a:	89 c3                	mov    %eax,%ebx
c002de4c:	89 c6                	mov    %eax,%esi
c002de4e:	c1 fe 1f             	sar    $0x1f,%esi
c002de51:	a1 78 9c 03 c0       	mov    0xc0039c78,%eax
c002de56:	8b 15 7c 9c 03 c0    	mov    0xc0039c7c,%edx
c002de5c:	83 ec 08             	sub    $0x8,%esp
c002de5f:	52                   	push   %edx
c002de60:	50                   	push   %eax
c002de61:	e8 9f 5e ff ff       	call   c0023d05 <timer_elapsed>
c002de66:	83 c4 10             	add    $0x10,%esp
c002de69:	29 c3                	sub    %eax,%ebx
c002de6b:	19 d6                	sbb    %edx,%esi
c002de6d:	89 d8                	mov    %ebx,%eax
c002de6f:	89 f2                	mov    %esi,%edx
c002de71:	83 ec 08             	sub    $0x8,%esp
c002de74:	52                   	push   %edx
c002de75:	50                   	push   %eax
c002de76:	e8 a9 5e ff ff       	call   c0023d24 <timer_sleep>
c002de7b:	83 c4 10             	add    $0x10,%esp
}
c002de7e:	90                   	nop
c002de7f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002de82:	5b                   	pop    %ebx
c002de83:	5e                   	pop    %esi
c002de84:	5d                   	pop    %ebp
c002de85:	c3                   	ret    

c002de86 <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002de86:	55                   	push   %ebp
c002de87:	89 e5                	mov    %esp,%ebp
c002de89:	57                   	push   %edi
c002de8a:	56                   	push   %esi
c002de8b:	53                   	push   %ebx
c002de8c:	83 ec 2c             	sub    $0x2c,%esp
  int64_t start_time;
  int last_elapsed = 0;
c002de8f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  
  ASSERT (thread_mlfqs);
c002de96:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002de9d:	84 c0                	test   %al,%al
c002de9f:	75 1e                	jne    c002debf <test_mlfqs_recent_1+0x39>
c002dea1:	83 ec 0c             	sub    $0xc,%esp
c002dea4:	68 8c 2c 03 c0       	push   $0xc0032c8c
c002dea9:	68 99 2c 03 c0       	push   $0xc0032c99
c002deae:	68 5c 2d 03 c0       	push   $0xc0032d5c
c002deb3:	6a 73                	push   $0x73
c002deb5:	68 b0 2c 03 c0       	push   $0xc0032cb0
c002deba:	e8 72 b7 ff ff       	call   c0029631 <debug_panic>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c002debf:	83 ec 0c             	sub    $0xc,%esp
c002dec2:	68 d8 2c 03 c0       	push   $0xc0032cd8
c002dec7:	e8 f6 da ff ff       	call   c002b9c2 <msg>
c002decc:	83 c4 10             	add    $0x10,%esp
      start_time = timer_ticks ();
c002decf:	e8 fc 5d ff ff       	call   c0023cd0 <timer_ticks>
c002ded4:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002ded7:	89 55 dc             	mov    %edx,-0x24(%ebp)
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c002deda:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002dedd:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002dee0:	83 c0 63             	add    $0x63,%eax
c002dee3:	83 d2 00             	adc    $0x0,%edx
c002dee6:	6a 00                	push   $0x0
c002dee8:	6a 64                	push   $0x64
c002deea:	52                   	push   %edx
c002deeb:	50                   	push   %eax
c002deec:	e8 1a b1 ff ff       	call   c002900b <__divdi3>
c002def1:	83 c4 10             	add    $0x10,%esp
c002def4:	2b 45 d8             	sub    -0x28(%ebp),%eax
c002def7:	1b 55 dc             	sbb    -0x24(%ebp),%edx
c002defa:	05 e8 03 00 00       	add    $0x3e8,%eax
c002deff:	83 d2 00             	adc    $0x0,%edx
c002df02:	83 ec 08             	sub    $0x8,%esp
c002df05:	52                   	push   %edx
c002df06:	50                   	push   %eax
c002df07:	e8 18 5e ff ff       	call   c0023d24 <timer_sleep>
c002df0c:	83 c4 10             	add    $0x10,%esp
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c002df0f:	e8 b2 2f ff ff       	call   c0020ec6 <thread_get_recent_cpu>
c002df14:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c002df19:	7f a4                	jg     c002debf <test_mlfqs_recent_1+0x39>

  start_time = timer_ticks ();
c002df1b:	e8 b0 5d ff ff       	call   c0023cd0 <timer_ticks>
c002df20:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002df23:	89 55 dc             	mov    %edx,-0x24(%ebp)
  for (;;) 
    {
      int elapsed = timer_elapsed (start_time);
c002df26:	83 ec 08             	sub    $0x8,%esp
c002df29:	ff 75 dc             	pushl  -0x24(%ebp)
c002df2c:	ff 75 d8             	pushl  -0x28(%ebp)
c002df2f:	e8 d1 5d ff ff       	call   c0023d05 <timer_elapsed>
c002df34:	83 c4 10             	add    $0x10,%esp
c002df37:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c002df3a:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c002df3d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002df42:	89 c8                	mov    %ecx,%eax
c002df44:	f7 ea                	imul   %edx
c002df46:	c1 fa 06             	sar    $0x6,%edx
c002df49:	89 c8                	mov    %ecx,%eax
c002df4b:	c1 f8 1f             	sar    $0x1f,%eax
c002df4e:	29 c2                	sub    %eax,%edx
c002df50:	89 d0                	mov    %edx,%eax
c002df52:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c002df58:	29 c1                	sub    %eax,%ecx
c002df5a:	89 c8                	mov    %ecx,%eax
c002df5c:	85 c0                	test   %eax,%eax
c002df5e:	0f 85 c5 00 00 00    	jne    c002e029 <test_mlfqs_recent_1+0x1a3>
c002df64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002df67:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002df6a:	0f 8e b9 00 00 00    	jle    c002e029 <test_mlfqs_recent_1+0x1a3>
        {
          int recent_cpu = thread_get_recent_cpu ();
c002df70:	e8 51 2f ff ff       	call   c0020ec6 <thread_get_recent_cpu>
c002df75:	89 45 d0             	mov    %eax,-0x30(%ebp)
          int load_avg = thread_get_load_avg ();
c002df78:	e8 3f 2f ff ff       	call   c0020ebc <thread_get_load_avg>
c002df7d:	89 45 cc             	mov    %eax,-0x34(%ebp)
          int elapsed_seconds = elapsed / TIMER_FREQ;
c002df80:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c002df83:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002df88:	89 c8                	mov    %ecx,%eax
c002df8a:	f7 ea                	imul   %edx
c002df8c:	c1 fa 05             	sar    $0x5,%edx
c002df8f:	89 c8                	mov    %ecx,%eax
c002df91:	c1 f8 1f             	sar    $0x1f,%eax
c002df94:	29 c2                	sub    %eax,%edx
c002df96:	89 d0                	mov    %edx,%eax
c002df98:	89 45 c8             	mov    %eax,-0x38(%ebp)
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002df9b:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002df9e:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dfa3:	89 c8                	mov    %ecx,%eax
c002dfa5:	f7 ea                	imul   %edx
c002dfa7:	c1 fa 05             	sar    $0x5,%edx
c002dfaa:	89 c8                	mov    %ecx,%eax
c002dfac:	c1 f8 1f             	sar    $0x1f,%eax
c002dfaf:	89 d3                	mov    %edx,%ebx
c002dfb1:	29 c3                	sub    %eax,%ebx
c002dfb3:	6b c3 64             	imul   $0x64,%ebx,%eax
c002dfb6:	89 cb                	mov    %ecx,%ebx
c002dfb8:	29 c3                	sub    %eax,%ebx
c002dfba:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002dfbd:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dfc2:	89 c8                	mov    %ecx,%eax
c002dfc4:	f7 ea                	imul   %edx
c002dfc6:	c1 fa 05             	sar    $0x5,%edx
c002dfc9:	89 c8                	mov    %ecx,%eax
c002dfcb:	c1 f8 1f             	sar    $0x1f,%eax
c002dfce:	89 d7                	mov    %edx,%edi
c002dfd0:	29 c7                	sub    %eax,%edi
c002dfd2:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002dfd5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dfda:	89 f0                	mov    %esi,%eax
c002dfdc:	f7 ea                	imul   %edx
c002dfde:	c1 fa 05             	sar    $0x5,%edx
c002dfe1:	89 f0                	mov    %esi,%eax
c002dfe3:	c1 f8 1f             	sar    $0x1f,%eax
c002dfe6:	89 d1                	mov    %edx,%ecx
c002dfe8:	29 c1                	sub    %eax,%ecx
c002dfea:	6b c1 64             	imul   $0x64,%ecx,%eax
c002dfed:	29 c6                	sub    %eax,%esi
c002dfef:	89 f1                	mov    %esi,%ecx
c002dff1:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002dff4:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dff9:	89 f0                	mov    %esi,%eax
c002dffb:	f7 ea                	imul   %edx
c002dffd:	c1 fa 05             	sar    $0x5,%edx
c002e000:	89 f0                	mov    %esi,%eax
c002e002:	c1 f8 1f             	sar    $0x1f,%eax
c002e005:	29 c2                	sub    %eax,%edx
c002e007:	89 d0                	mov    %edx,%eax
c002e009:	83 ec 08             	sub    $0x8,%esp
c002e00c:	53                   	push   %ebx
c002e00d:	57                   	push   %edi
c002e00e:	51                   	push   %ecx
c002e00f:	50                   	push   %eax
c002e010:	ff 75 c8             	pushl  -0x38(%ebp)
c002e013:	68 1c 2d 03 c0       	push   $0xc0032d1c
c002e018:	e8 a5 d9 ff ff       	call   c002b9c2 <msg>
c002e01d:	83 c4 20             	add    $0x20,%esp
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c002e020:	81 7d c8 b3 00 00 00 	cmpl   $0xb3,-0x38(%ebp)
c002e027:	7f 0b                	jg     c002e034 <test_mlfqs_recent_1+0x1ae>
            break;
        } 
      last_elapsed = elapsed;
c002e029:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002e02c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
c002e02f:	e9 f2 fe ff ff       	jmp    c002df26 <test_mlfqs_recent_1+0xa0>
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
            break;
c002e034:	90                   	nop
        } 
      last_elapsed = elapsed;
    }
}
c002e035:	90                   	nop
c002e036:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002e039:	5b                   	pop    %ebx
c002e03a:	5e                   	pop    %esi
c002e03b:	5f                   	pop    %edi
c002e03c:	5d                   	pop    %ebp
c002e03d:	c3                   	ret    

c002e03e <test_mlfqs_fair_2>:

static void test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step);

void
test_mlfqs_fair_2 (void) 
{
c002e03e:	55                   	push   %ebp
c002e03f:	89 e5                	mov    %esp,%ebp
c002e041:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 0);
c002e044:	83 ec 04             	sub    $0x4,%esp
c002e047:	6a 00                	push   $0x0
c002e049:	6a 00                	push   $0x0
c002e04b:	6a 02                	push   $0x2
c002e04d:	e8 54 00 00 00       	call   c002e0a6 <test_mlfqs_fair>
c002e052:	83 c4 10             	add    $0x10,%esp
}
c002e055:	90                   	nop
c002e056:	c9                   	leave  
c002e057:	c3                   	ret    

c002e058 <test_mlfqs_fair_20>:

void
test_mlfqs_fair_20 (void) 
{
c002e058:	55                   	push   %ebp
c002e059:	89 e5                	mov    %esp,%ebp
c002e05b:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (20, 0, 0);
c002e05e:	83 ec 04             	sub    $0x4,%esp
c002e061:	6a 00                	push   $0x0
c002e063:	6a 00                	push   $0x0
c002e065:	6a 14                	push   $0x14
c002e067:	e8 3a 00 00 00       	call   c002e0a6 <test_mlfqs_fair>
c002e06c:	83 c4 10             	add    $0x10,%esp
}
c002e06f:	90                   	nop
c002e070:	c9                   	leave  
c002e071:	c3                   	ret    

c002e072 <test_mlfqs_nice_2>:

void
test_mlfqs_nice_2 (void) 
{
c002e072:	55                   	push   %ebp
c002e073:	89 e5                	mov    %esp,%ebp
c002e075:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 5);
c002e078:	83 ec 04             	sub    $0x4,%esp
c002e07b:	6a 05                	push   $0x5
c002e07d:	6a 00                	push   $0x0
c002e07f:	6a 02                	push   $0x2
c002e081:	e8 20 00 00 00       	call   c002e0a6 <test_mlfqs_fair>
c002e086:	83 c4 10             	add    $0x10,%esp
}
c002e089:	90                   	nop
c002e08a:	c9                   	leave  
c002e08b:	c3                   	ret    

c002e08c <test_mlfqs_nice_10>:

void
test_mlfqs_nice_10 (void) 
{
c002e08c:	55                   	push   %ebp
c002e08d:	89 e5                	mov    %esp,%ebp
c002e08f:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (10, 0, 1);
c002e092:	83 ec 04             	sub    $0x4,%esp
c002e095:	6a 01                	push   $0x1
c002e097:	6a 00                	push   $0x0
c002e099:	6a 0a                	push   $0xa
c002e09b:	e8 06 00 00 00       	call   c002e0a6 <test_mlfqs_fair>
c002e0a0:	83 c4 10             	add    $0x10,%esp
}
c002e0a3:	90                   	nop
c002e0a4:	c9                   	leave  
c002e0a5:	c3                   	ret    

c002e0a6 <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c002e0a6:	55                   	push   %ebp
c002e0a7:	89 e5                	mov    %esp,%ebp
c002e0a9:	81 ec 78 01 00 00    	sub    $0x178,%esp
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c002e0af:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002e0b6:	84 c0                	test   %al,%al
c002e0b8:	75 1e                	jne    c002e0d8 <test_mlfqs_fair+0x32>
c002e0ba:	83 ec 0c             	sub    $0xc,%esp
c002e0bd:	68 70 2d 03 c0       	push   $0xc0032d70
c002e0c2:	68 7d 2d 03 c0       	push   $0xc0032d7d
c002e0c7:	68 bc 2e 03 c0       	push   $0xc0032ebc
c002e0cc:	6a 49                	push   $0x49
c002e0ce:	68 94 2d 03 c0       	push   $0xc0032d94
c002e0d3:	e8 59 b5 ff ff       	call   c0029631 <debug_panic>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002e0d8:	83 7d 08 14          	cmpl   $0x14,0x8(%ebp)
c002e0dc:	7e 1e                	jle    c002e0fc <test_mlfqs_fair+0x56>
c002e0de:	83 ec 0c             	sub    $0xc,%esp
c002e0e1:	68 b5 2d 03 c0       	push   $0xc0032db5
c002e0e6:	68 7d 2d 03 c0       	push   $0xc0032d7d
c002e0eb:	68 bc 2e 03 c0       	push   $0xc0032ebc
c002e0f0:	6a 4a                	push   $0x4a
c002e0f2:	68 94 2d 03 c0       	push   $0xc0032d94
c002e0f7:	e8 35 b5 ff ff       	call   c0029631 <debug_panic>
  ASSERT (nice_min >= -10);
c002e0fc:	83 7d 0c f6          	cmpl   $0xfffffff6,0xc(%ebp)
c002e100:	7d 1e                	jge    c002e120 <test_mlfqs_fair+0x7a>
c002e102:	83 ec 0c             	sub    $0xc,%esp
c002e105:	68 d2 2d 03 c0       	push   $0xc0032dd2
c002e10a:	68 7d 2d 03 c0       	push   $0xc0032d7d
c002e10f:	68 bc 2e 03 c0       	push   $0xc0032ebc
c002e114:	6a 4b                	push   $0x4b
c002e116:	68 94 2d 03 c0       	push   $0xc0032d94
c002e11b:	e8 11 b5 ff ff       	call   c0029631 <debug_panic>
  ASSERT (nice_step >= 0);
c002e120:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e124:	79 1e                	jns    c002e144 <test_mlfqs_fair+0x9e>
c002e126:	83 ec 0c             	sub    $0xc,%esp
c002e129:	68 e2 2d 03 c0       	push   $0xc0032de2
c002e12e:	68 7d 2d 03 c0       	push   $0xc0032d7d
c002e133:	68 bc 2e 03 c0       	push   $0xc0032ebc
c002e138:	6a 4c                	push   $0x4c
c002e13a:	68 94 2d 03 c0       	push   $0xc0032d94
c002e13f:	e8 ed b4 ff ff       	call   c0029631 <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002e144:	8b 45 08             	mov    0x8(%ebp),%eax
c002e147:	83 e8 01             	sub    $0x1,%eax
c002e14a:	0f af 45 10          	imul   0x10(%ebp),%eax
c002e14e:	89 c2                	mov    %eax,%edx
c002e150:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e153:	01 d0                	add    %edx,%eax
c002e155:	83 f8 14             	cmp    $0x14,%eax
c002e158:	7e 1e                	jle    c002e178 <test_mlfqs_fair+0xd2>
c002e15a:	83 ec 0c             	sub    $0xc,%esp
c002e15d:	68 f4 2d 03 c0       	push   $0xc0032df4
c002e162:	68 7d 2d 03 c0       	push   $0xc0032d7d
c002e167:	68 bc 2e 03 c0       	push   $0xc0032ebc
c002e16c:	6a 4d                	push   $0x4d
c002e16e:	68 94 2d 03 c0       	push   $0xc0032d94
c002e173:	e8 b9 b4 ff ff       	call   c0029631 <debug_panic>

  thread_set_nice (-20);
c002e178:	83 ec 0c             	sub    $0xc,%esp
c002e17b:	6a ec                	push   $0xffffffec
c002e17d:	e8 2a 2d ff ff       	call   c0020eac <thread_set_nice>
c002e182:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002e185:	e8 46 5b ff ff       	call   c0023cd0 <timer_ticks>
c002e18a:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e18d:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg ("Starting %d threads...", thread_cnt);
c002e190:	83 ec 08             	sub    $0x8,%esp
c002e193:	ff 75 08             	pushl  0x8(%ebp)
c002e196:	68 22 2e 03 c0       	push   $0xc0032e22
c002e19b:	e8 22 d8 ff ff       	call   c002b9c2 <msg>
c002e1a0:	83 c4 10             	add    $0x10,%esp
  nice = nice_min;
c002e1a3:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e1a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c002e1a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e1b0:	eb 6e                	jmp    c002e220 <test_mlfqs_fair+0x17a>
    {
      struct thread_info *ti = &info[i];
c002e1b2:	8d 85 a4 fe ff ff    	lea    -0x15c(%ebp),%eax
c002e1b8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002e1bb:	c1 e2 04             	shl    $0x4,%edx
c002e1be:	01 d0                	add    %edx,%eax
c002e1c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      char name[16];

      ti->start_time = start_time;
c002e1c3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002e1c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e1c9:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002e1cc:	89 01                	mov    %eax,(%ecx)
c002e1ce:	89 51 04             	mov    %edx,0x4(%ecx)
      ti->tick_count = 0;
c002e1d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e1d4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      ti->nice = nice;
c002e1db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e1de:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002e1e1:	89 50 0c             	mov    %edx,0xc(%eax)

      snprintf(name, sizeof name, "load %d", i);
c002e1e4:	ff 75 f0             	pushl  -0x10(%ebp)
c002e1e7:	68 39 2e 03 c0       	push   $0xc0032e39
c002e1ec:	6a 10                	push   $0x10
c002e1ee:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002e1f4:	50                   	push   %eax
c002e1f5:	e8 db 8f ff ff       	call   c00271d5 <snprintf>
c002e1fa:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c002e1fd:	ff 75 e4             	pushl  -0x1c(%ebp)
c002e200:	68 ab e2 02 c0       	push   $0xc002e2ab
c002e205:	6a 1f                	push   $0x1f
c002e207:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002e20d:	50                   	push   %eax
c002e20e:	e8 55 28 ff ff       	call   c0020a68 <thread_create>
c002e213:	83 c4 10             	add    $0x10,%esp

      nice += nice_step;
c002e216:	8b 45 10             	mov    0x10(%ebp),%eax
c002e219:	01 45 f4             	add    %eax,-0xc(%ebp)
  thread_set_nice (-20);

  start_time = timer_ticks ();
  msg ("Starting %d threads...", thread_cnt);
  nice = nice_min;
  for (i = 0; i < thread_cnt; i++) 
c002e21c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002e220:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e223:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e226:	7c 8a                	jl     c002e1b2 <test_mlfqs_fair+0x10c>
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, ti);

      nice += nice_step;
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002e228:	83 ec 08             	sub    $0x8,%esp
c002e22b:	ff 75 ec             	pushl  -0x14(%ebp)
c002e22e:	ff 75 e8             	pushl  -0x18(%ebp)
c002e231:	e8 cf 5a ff ff       	call   c0023d05 <timer_elapsed>
c002e236:	83 c4 10             	add    $0x10,%esp
c002e239:	83 ec 04             	sub    $0x4,%esp
c002e23c:	52                   	push   %edx
c002e23d:	50                   	push   %eax
c002e23e:	68 44 2e 03 c0       	push   $0xc0032e44
c002e243:	e8 7a d7 ff ff       	call   c002b9c2 <msg>
c002e248:	83 c4 10             	add    $0x10,%esp

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002e24b:	83 ec 0c             	sub    $0xc,%esp
c002e24e:	68 68 2e 03 c0       	push   $0xc0032e68
c002e253:	e8 6a d7 ff ff       	call   c002b9c2 <msg>
c002e258:	83 c4 10             	add    $0x10,%esp
  timer_sleep (40 * TIMER_FREQ);
c002e25b:	83 ec 08             	sub    $0x8,%esp
c002e25e:	6a 00                	push   $0x0
c002e260:	68 a0 0f 00 00       	push   $0xfa0
c002e265:	e8 ba 5a ff ff       	call   c0023d24 <timer_sleep>
c002e26a:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < thread_cnt; i++)
c002e26d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e274:	eb 2a                	jmp    c002e2a0 <test_mlfqs_fair+0x1fa>
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002e276:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e279:	c1 e0 04             	shl    $0x4,%eax
c002e27c:	8d 4d f8             	lea    -0x8(%ebp),%ecx
c002e27f:	01 c8                	add    %ecx,%eax
c002e281:	2d 4c 01 00 00       	sub    $0x14c,%eax
c002e286:	8b 00                	mov    (%eax),%eax
c002e288:	83 ec 04             	sub    $0x4,%esp
c002e28b:	50                   	push   %eax
c002e28c:	ff 75 f0             	pushl  -0x10(%ebp)
c002e28f:	68 9f 2e 03 c0       	push   $0xc0032e9f
c002e294:	e8 29 d7 ff ff       	call   c002b9c2 <msg>
c002e299:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));

  msg ("Sleeping 40 seconds to let threads run, please wait...");
  timer_sleep (40 * TIMER_FREQ);
  
  for (i = 0; i < thread_cnt; i++)
c002e29c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002e2a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e2a3:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e2a6:	7c ce                	jl     c002e276 <test_mlfqs_fair+0x1d0>
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
}
c002e2a8:	90                   	nop
c002e2a9:	c9                   	leave  
c002e2aa:	c3                   	ret    

c002e2ab <load_thread>:

static void
load_thread (void *ti_) 
{
c002e2ab:	55                   	push   %ebp
c002e2ac:	89 e5                	mov    %esp,%ebp
c002e2ae:	53                   	push   %ebx
c002e2af:	83 ec 34             	sub    $0x34,%esp
  struct thread_info *ti = ti_;
c002e2b2:	8b 45 08             	mov    0x8(%ebp),%eax
c002e2b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int64_t sleep_time = 5 * TIMER_FREQ;
c002e2b8:	c7 45 e0 f4 01 00 00 	movl   $0x1f4,-0x20(%ebp)
c002e2bf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
c002e2c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e2c9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002e2cc:	05 b8 0b 00 00       	add    $0xbb8,%eax
c002e2d1:	83 d2 00             	adc    $0x0,%edx
c002e2d4:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002e2d7:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int64_t last_time = 0;
c002e2da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e2e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  thread_set_nice (ti->nice);
c002e2e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e2eb:	8b 40 0c             	mov    0xc(%eax),%eax
c002e2ee:	83 ec 0c             	sub    $0xc,%esp
c002e2f1:	50                   	push   %eax
c002e2f2:	e8 b5 2b ff ff       	call   c0020eac <thread_set_nice>
c002e2f7:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c002e2fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e2fd:	8b 50 04             	mov    0x4(%eax),%edx
c002e300:	8b 00                	mov    (%eax),%eax
c002e302:	83 ec 08             	sub    $0x8,%esp
c002e305:	52                   	push   %edx
c002e306:	50                   	push   %eax
c002e307:	e8 f9 59 ff ff       	call   c0023d05 <timer_elapsed>
c002e30c:	83 c4 10             	add    $0x10,%esp
c002e30f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002e312:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e315:	29 c1                	sub    %eax,%ecx
c002e317:	19 d3                	sbb    %edx,%ebx
c002e319:	89 c8                	mov    %ecx,%eax
c002e31b:	89 da                	mov    %ebx,%edx
c002e31d:	83 ec 08             	sub    $0x8,%esp
c002e320:	52                   	push   %edx
c002e321:	50                   	push   %eax
c002e322:	e8 fd 59 ff ff       	call   c0023d24 <timer_sleep>
c002e327:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (ti->start_time) < spin_time) 
c002e32a:	eb 3a                	jmp    c002e366 <load_thread+0xbb>
    {
      int64_t cur_time = timer_ticks ();
c002e32c:	e8 9f 59 ff ff       	call   c0023cd0 <timer_ticks>
c002e331:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002e334:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      if (cur_time != last_time)
c002e337:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e33a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e33d:	89 d1                	mov    %edx,%ecx
c002e33f:	33 4d f4             	xor    -0xc(%ebp),%ecx
c002e342:	33 45 f0             	xor    -0x10(%ebp),%eax
c002e345:	09 c8                	or     %ecx,%eax
c002e347:	85 c0                	test   %eax,%eax
c002e349:	74 0f                	je     c002e35a <load_thread+0xaf>
        ti->tick_count++;
c002e34b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e34e:	8b 40 08             	mov    0x8(%eax),%eax
c002e351:	8d 50 01             	lea    0x1(%eax),%edx
c002e354:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e357:	89 50 08             	mov    %edx,0x8(%eax)
      last_time = cur_time;
c002e35a:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e35d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e360:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e363:	89 55 f4             	mov    %edx,-0xc(%ebp)
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
  int64_t last_time = 0;

  thread_set_nice (ti->nice);
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
  while (timer_elapsed (ti->start_time) < spin_time) 
c002e366:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e369:	8b 50 04             	mov    0x4(%eax),%edx
c002e36c:	8b 00                	mov    (%eax),%eax
c002e36e:	83 ec 08             	sub    $0x8,%esp
c002e371:	52                   	push   %edx
c002e372:	50                   	push   %eax
c002e373:	e8 8d 59 ff ff       	call   c0023d05 <timer_elapsed>
c002e378:	83 c4 10             	add    $0x10,%esp
c002e37b:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c002e37e:	7c ac                	jl     c002e32c <load_thread+0x81>
c002e380:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c002e383:	7f 05                	jg     c002e38a <load_thread+0xdf>
c002e385:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c002e388:	72 a2                	jb     c002e32c <load_thread+0x81>
      int64_t cur_time = timer_ticks ();
      if (cur_time != last_time)
        ti->tick_count++;
      last_time = cur_time;
    }
}
c002e38a:	90                   	nop
c002e38b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e38e:	c9                   	leave  
c002e38f:	c3                   	ret    

c002e390 <test_mlfqs_block>:

static void block_thread (void *lock_);

void
test_mlfqs_block (void) 
{
c002e390:	55                   	push   %ebp
c002e391:	89 e5                	mov    %esp,%ebp
c002e393:	83 ec 28             	sub    $0x28,%esp
  int64_t start_time;
  struct lock lock;
  
  ASSERT (thread_mlfqs);
c002e396:	0f b6 05 84 9c 03 c0 	movzbl 0xc0039c84,%eax
c002e39d:	84 c0                	test   %al,%al
c002e39f:	75 1e                	jne    c002e3bf <test_mlfqs_block+0x2f>
c002e3a1:	83 ec 0c             	sub    $0xc,%esp
c002e3a4:	68 cc 2e 03 c0       	push   $0xc0032ecc
c002e3a9:	68 d9 2e 03 c0       	push   $0xc0032ed9
c002e3ae:	68 38 30 03 c0       	push   $0xc0033038
c002e3b3:	6a 1c                	push   $0x1c
c002e3b5:	68 f0 2e 03 c0       	push   $0xc0032ef0
c002e3ba:	e8 72 b2 ff ff       	call   c0029631 <debug_panic>

  msg ("Main thread acquiring lock.");
c002e3bf:	83 ec 0c             	sub    $0xc,%esp
c002e3c2:	68 12 2f 03 c0       	push   $0xc0032f12
c002e3c7:	e8 f6 d5 ff ff       	call   c002b9c2 <msg>
c002e3cc:	83 c4 10             	add    $0x10,%esp
  lock_init (&lock);
c002e3cf:	83 ec 0c             	sub    $0xc,%esp
c002e3d2:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e3d5:	50                   	push   %eax
c002e3d6:	e8 9a 46 ff ff       	call   c0022a75 <lock_init>
c002e3db:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002e3de:	83 ec 0c             	sub    $0xc,%esp
c002e3e1:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e3e4:	50                   	push   %eax
c002e3e5:	e8 d8 46 ff ff       	call   c0022ac2 <lock_acquire>
c002e3ea:	83 c4 10             	add    $0x10,%esp
  
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c002e3ed:	83 ec 0c             	sub    $0xc,%esp
c002e3f0:	68 30 2f 03 c0       	push   $0xc0032f30
c002e3f5:	e8 c8 d5 ff ff       	call   c002b9c2 <msg>
c002e3fa:	83 c4 10             	add    $0x10,%esp
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c002e3fd:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e400:	50                   	push   %eax
c002e401:	68 97 e4 02 c0       	push   $0xc002e497
c002e406:	6a 1f                	push   $0x1f
c002e408:	68 6a 2f 03 c0       	push   $0xc0032f6a
c002e40d:	e8 56 26 ff ff       	call   c0020a68 <thread_create>
c002e412:	83 c4 10             	add    $0x10,%esp
  timer_sleep (25 * TIMER_FREQ);
c002e415:	83 ec 08             	sub    $0x8,%esp
c002e418:	6a 00                	push   $0x0
c002e41a:	68 c4 09 00 00       	push   $0x9c4
c002e41f:	e8 00 59 ff ff       	call   c0023d24 <timer_sleep>
c002e424:	83 c4 10             	add    $0x10,%esp

  msg ("Main thread spinning for 5 seconds...");
c002e427:	83 ec 0c             	sub    $0xc,%esp
c002e42a:	68 70 2f 03 c0       	push   $0xc0032f70
c002e42f:	e8 8e d5 ff ff       	call   c002b9c2 <msg>
c002e434:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002e437:	e8 94 58 ff ff       	call   c0023cd0 <timer_ticks>
c002e43c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e43f:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002e442:	eb 01                	jmp    c002e445 <test_mlfqs_block+0xb5>
    continue;
c002e444:	90                   	nop
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
  timer_sleep (25 * TIMER_FREQ);

  msg ("Main thread spinning for 5 seconds...");
  start_time = timer_ticks ();
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002e445:	83 ec 08             	sub    $0x8,%esp
c002e448:	ff 75 f4             	pushl  -0xc(%ebp)
c002e44b:	ff 75 f0             	pushl  -0x10(%ebp)
c002e44e:	e8 b2 58 ff ff       	call   c0023d05 <timer_elapsed>
c002e453:	83 c4 10             	add    $0x10,%esp
c002e456:	85 d2                	test   %edx,%edx
c002e458:	78 ea                	js     c002e444 <test_mlfqs_block+0xb4>
c002e45a:	85 d2                	test   %edx,%edx
c002e45c:	7f 07                	jg     c002e465 <test_mlfqs_block+0xd5>
c002e45e:	3d f3 01 00 00       	cmp    $0x1f3,%eax
c002e463:	76 df                	jbe    c002e444 <test_mlfqs_block+0xb4>
    continue;

  msg ("Main thread releasing lock.");
c002e465:	83 ec 0c             	sub    $0xc,%esp
c002e468:	68 96 2f 03 c0       	push   $0xc0032f96
c002e46d:	e8 50 d5 ff ff       	call   c002b9c2 <msg>
c002e472:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002e475:	83 ec 0c             	sub    $0xc,%esp
c002e478:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e47b:	50                   	push   %eax
c002e47c:	e8 82 47 ff ff       	call   c0022c03 <lock_release>
c002e481:	83 c4 10             	add    $0x10,%esp

  msg ("Block thread should have already acquired lock.");
c002e484:	83 ec 0c             	sub    $0xc,%esp
c002e487:	68 b4 2f 03 c0       	push   $0xc0032fb4
c002e48c:	e8 31 d5 ff ff       	call   c002b9c2 <msg>
c002e491:	83 c4 10             	add    $0x10,%esp
}
c002e494:	90                   	nop
c002e495:	c9                   	leave  
c002e496:	c3                   	ret    

c002e497 <block_thread>:

static void
block_thread (void *lock_) 
{
c002e497:	55                   	push   %ebp
c002e498:	89 e5                	mov    %esp,%ebp
c002e49a:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002e49d:	8b 45 08             	mov    0x8(%ebp),%eax
c002e4a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c002e4a3:	83 ec 0c             	sub    $0xc,%esp
c002e4a6:	68 e4 2f 03 c0       	push   $0xc0032fe4
c002e4ab:	e8 12 d5 ff ff       	call   c002b9c2 <msg>
c002e4b0:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002e4b3:	e8 18 58 ff ff       	call   c0023cd0 <timer_ticks>
c002e4b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e4bb:	89 55 ec             	mov    %edx,-0x14(%ebp)
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002e4be:	eb 01                	jmp    c002e4c1 <block_thread+0x2a>
    continue;
c002e4c0:	90                   	nop
  struct lock *lock = lock_;
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
  start_time = timer_ticks ();
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002e4c1:	83 ec 08             	sub    $0x8,%esp
c002e4c4:	ff 75 ec             	pushl  -0x14(%ebp)
c002e4c7:	ff 75 e8             	pushl  -0x18(%ebp)
c002e4ca:	e8 36 58 ff ff       	call   c0023d05 <timer_elapsed>
c002e4cf:	83 c4 10             	add    $0x10,%esp
c002e4d2:	85 d2                	test   %edx,%edx
c002e4d4:	78 ea                	js     c002e4c0 <block_thread+0x29>
c002e4d6:	85 d2                	test   %edx,%edx
c002e4d8:	7f 07                	jg     c002e4e1 <block_thread+0x4a>
c002e4da:	3d cf 07 00 00       	cmp    $0x7cf,%eax
c002e4df:	76 df                	jbe    c002e4c0 <block_thread+0x29>
    continue;

  msg ("Block thread acquiring lock...");
c002e4e1:	83 ec 0c             	sub    $0xc,%esp
c002e4e4:	68 0c 30 03 c0       	push   $0xc003300c
c002e4e9:	e8 d4 d4 ff ff       	call   c002b9c2 <msg>
c002e4ee:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c002e4f1:	83 ec 0c             	sub    $0xc,%esp
c002e4f4:	ff 75 f4             	pushl  -0xc(%ebp)
c002e4f7:	e8 c6 45 ff ff       	call   c0022ac2 <lock_acquire>
c002e4fc:	83 c4 10             	add    $0x10,%esp

  msg ("...got it.");
c002e4ff:	83 ec 0c             	sub    $0xc,%esp
c002e502:	68 2b 30 03 c0       	push   $0xc003302b
c002e507:	e8 b6 d4 ff ff       	call   c002b9c2 <msg>
c002e50c:	83 c4 10             	add    $0x10,%esp
}
c002e50f:	90                   	nop
c002e510:	c9                   	leave  
c002e511:	c3                   	ret    
