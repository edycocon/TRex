
kernel.o:     formato del fichero elf32-i386


Desensamblado de la secci√≥n .text:

c0020078 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020078:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002007d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002007f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020080:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020082:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020084:	66 05 00 04          	add    $0x400,%ax
c0020088:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002008a:	66 3d 00 00          	cmp    $0x0,%ax
c002008e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020090:	76 06                	jbe    c0020098 <start+0x20>
	mov $0x10000, %eax
c0020092:	66 b8 00 00          	mov    $0x0,%ax
c0020096:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020098:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002009c:	67 66 a3 7e 01       	addr16 mov %ax,0x17e
c00200a1:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c00200a3:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200a5:	a8 02                	test   $0x2,%al
	jnz 1b
c00200a7:	75 fa                	jne    c00200a3 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c00200a9:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c00200ab:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c00200ad:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200af:	a8 02                	test   $0x2,%al
	jnz 1b
c00200b1:	75 fa                	jne    c00200ad <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c00200b3:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c00200b5:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c00200b7:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200b9:	a8 02                	test   $0x2,%al
	jnz 1b
c00200bb:	75 fa                	jne    c00200b7 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c00200bd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200c2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200c5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200c8:	66 b9 00 04          	mov    $0x400,%cx
c00200cc:	00 00                	add    %al,(%eax)
	rep stosl
c00200ce:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200d1:	66 b8 07 00          	mov    $0x7,%ax
c00200d5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200d7:	66 b9 11 00          	mov    $0x11,%cx
c00200db:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200dd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200e7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200e8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200eb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200f2:	00 e2                	add    %ah,%dl
	loop 1b
c00200f4:	eb b8                	jmp    c00200ae <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200f6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200f8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200fa:	66 b8 07 00          	mov    $0x7,%ax
c00200fe:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c0020100:	66 b9 00 40          	mov    $0x4000,%cx
c0020104:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c0020106:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020109:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020110:	66 
	addw $4, %di
	addl $0x1000, %eax
c0020111:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c0020116:	e2 f1                	loop   c0020109 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c0020118:	66 b8 00 f0          	mov    $0xf000,%ax
c002011c:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c002011e:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020121:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020122:	67 66 0f 01 15       	lgdtw  (%di)
c0020127:	78 01                	js     c002012a <start+0xb2>
c0020129:	00 00                	add    %al,(%eax)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002012b:	0f 20 c0             	mov    %cr0,%eax
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002012e:	66 0d 05 00          	or     $0x5,%ax
c0020132:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020138:	ea 3f 01 02 c0 08 00 	ljmp   $0x8,$0xc002013f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002013f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020143:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020145:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020147:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020149:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002014b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002014d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020153:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020158:	e8 79 01 00 00       	call   c00202d6 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002015d:	eb fe                	jmp    c002015d <start+0xe5>
	...

c0020160 <gdt>:
	...
c0020168:	ff                   	(bad)  
c0020169:	ff 00                	incl   (%eax)
c002016b:	00 00                	add    %al,(%eax)
c002016d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020174:	00                   	.byte 0x0
c0020175:	92                   	xchg   %eax,%edx
c0020176:	cf                   	iret   
	...

c0020178 <gdtdesc>:
c0020178:	17                   	pop    %ss
c0020179:	00 60 01             	add    %ah,0x1(%eax)
c002017c:	02 c0                	add    %al,%al

c002017e <init_ram_pages>:
c002017e:	00 00                	add    %al,(%eax)
	...

c0020182 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c0020182:	55                   	push   %ebp
c0020183:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0020185:	8b 45 08             	mov    0x8(%ebp),%eax
c0020188:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002018d:	5d                   	pop    %ebp
c002018e:	c3                   	ret    

c002018f <is_kernel_vaddr>:
}

/* Returns true if VADDR is a kernel virtual address. */
static inline bool
is_kernel_vaddr (const void *vaddr) 
{
c002018f:	55                   	push   %ebp
c0020190:	89 e5                	mov    %esp,%ebp
  return vaddr >= PHYS_BASE;
c0020192:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0020199:	0f 97 c0             	seta   %al
}
c002019c:	5d                   	pop    %ebp
c002019d:	c3                   	ret    

c002019e <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c002019e:	55                   	push   %ebp
c002019f:	89 e5                	mov    %esp,%ebp
c00201a1:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c00201a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00201a7:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00201ac:	76 1e                	jbe    c00201cc <ptov+0x2e>
c00201ae:	83 ec 0c             	sub    $0xc,%esp
c00201b1:	68 60 e6 02 c0       	push   $0xc002e660
c00201b6:	68 7b e6 02 c0       	push   $0xc002e67b
c00201bb:	68 08 ea 02 c0       	push   $0xc002ea08
c00201c0:	6a 4a                	push   $0x4a
c00201c2:	68 92 e6 02 c0       	push   $0xc002e692
c00201c7:	e8 ac 95 00 00       	call   c0029778 <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c00201cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00201cf:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00201d4:	c9                   	leave  
c00201d5:	c3                   	ret    

c00201d6 <vtop>:

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
c00201d6:	55                   	push   %ebp
c00201d7:	89 e5                	mov    %esp,%ebp
c00201d9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_kernel_vaddr (vaddr));
c00201dc:	ff 75 08             	pushl  0x8(%ebp)
c00201df:	e8 ab ff ff ff       	call   c002018f <is_kernel_vaddr>
c00201e4:	83 c4 04             	add    $0x4,%esp
c00201e7:	84 c0                	test   %al,%al
c00201e9:	75 1e                	jne    c0020209 <vtop+0x33>
c00201eb:	83 ec 0c             	sub    $0xc,%esp
c00201ee:	68 a8 e6 02 c0       	push   $0xc002e6a8
c00201f3:	68 7b e6 02 c0       	push   $0xc002e67b
c00201f8:	68 30 ea 02 c0       	push   $0xc002ea30
c00201fd:	6a 54                	push   $0x54
c00201ff:	68 92 e6 02 c0       	push   $0xc002e692
c0020204:	e8 6f 95 00 00       	call   c0029778 <debug_panic>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020209:	8b 45 08             	mov    0x8(%ebp),%eax
c002020c:	05 00 00 00 40       	add    $0x40000000,%eax
}
c0020211:	c9                   	leave  
c0020212:	c3                   	ret    

c0020213 <pt_no>:
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
c0020213:	55                   	push   %ebp
c0020214:	89 e5                	mov    %esp,%ebp
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c0020216:	8b 45 08             	mov    0x8(%ebp),%eax
c0020219:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c002021e:	c1 e8 0c             	shr    $0xc,%eax
}
c0020221:	5d                   	pop    %ebp
c0020222:	c3                   	ret    

c0020223 <pd_no>:

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va) {
c0020223:	55                   	push   %ebp
c0020224:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PDSHIFT;
c0020226:	8b 45 08             	mov    0x8(%ebp),%eax
c0020229:	c1 e8 16             	shr    $0x16,%eax
}
c002022c:	5d                   	pop    %ebp
c002022d:	c3                   	ret    

c002022e <pde_create>:
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
c002022e:	55                   	push   %ebp
c002022f:	89 e5                	mov    %esp,%ebp
c0020231:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pg_ofs (pt) == 0);
c0020234:	ff 75 08             	pushl  0x8(%ebp)
c0020237:	e8 46 ff ff ff       	call   c0020182 <pg_ofs>
c002023c:	83 c4 04             	add    $0x4,%esp
c002023f:	85 c0                	test   %eax,%eax
c0020241:	74 1e                	je     c0020261 <pde_create+0x33>
c0020243:	83 ec 0c             	sub    $0xc,%esp
c0020246:	68 c0 e6 02 c0       	push   $0xc002e6c0
c002024b:	68 7b e6 02 c0       	push   $0xc002e67b
c0020250:	68 10 ea 02 c0       	push   $0xc002ea10
c0020255:	6a 48                	push   $0x48
c0020257:	68 d1 e6 02 c0       	push   $0xc002e6d1
c002025c:	e8 17 95 00 00       	call   c0029778 <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c0020261:	83 ec 0c             	sub    $0xc,%esp
c0020264:	ff 75 08             	pushl  0x8(%ebp)
c0020267:	e8 6a ff ff ff       	call   c00201d6 <vtop>
c002026c:	83 c4 10             	add    $0x10,%esp
c002026f:	83 c8 07             	or     $0x7,%eax
}
c0020272:	c9                   	leave  
c0020273:	c3                   	ret    

c0020274 <pte_create_kernel>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c0020274:	55                   	push   %ebp
c0020275:	89 e5                	mov    %esp,%ebp
c0020277:	83 ec 18             	sub    $0x18,%esp
c002027a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002027d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c0020280:	ff 75 08             	pushl  0x8(%ebp)
c0020283:	e8 fa fe ff ff       	call   c0020182 <pg_ofs>
c0020288:	83 c4 04             	add    $0x4,%esp
c002028b:	85 c0                	test   %eax,%eax
c002028d:	74 1e                	je     c00202ad <pte_create_kernel+0x39>
c002028f:	83 ec 0c             	sub    $0xc,%esp
c0020292:	68 e5 e6 02 c0       	push   $0xc002e6e5
c0020297:	68 7b e6 02 c0       	push   $0xc002e67b
c002029c:	68 1c ea 02 c0       	push   $0xc002ea1c
c00202a1:	6a 58                	push   $0x58
c00202a3:	68 d1 e6 02 c0       	push   $0xc002e6d1
c00202a8:	e8 cb 94 00 00       	call   c0029778 <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c00202ad:	83 ec 0c             	sub    $0xc,%esp
c00202b0:	ff 75 08             	pushl  0x8(%ebp)
c00202b3:	e8 1e ff ff ff       	call   c00201d6 <vtop>
c00202b8:	83 c4 10             	add    $0x10,%esp
c00202bb:	89 c2                	mov    %eax,%edx
c00202bd:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c00202c1:	74 07                	je     c00202ca <pte_create_kernel+0x56>
c00202c3:	b8 02 00 00 00       	mov    $0x2,%eax
c00202c8:	eb 05                	jmp    c00202cf <pte_create_kernel+0x5b>
c00202ca:	b8 00 00 00 00       	mov    $0x0,%eax
c00202cf:	09 d0                	or     %edx,%eax
c00202d1:	83 c8 01             	or     $0x1,%eax
}
c00202d4:	c9                   	leave  
c00202d5:	c3                   	ret    

c00202d6 <pintos_init>:
int pintos_init (void) NO_RETURN;

/* Pintos main entry point. */
int
pintos_init (void)
{
c00202d6:	55                   	push   %ebp
c00202d7:	89 e5                	mov    %esp,%ebp
c00202d9:	83 ec 18             	sub    $0x18,%esp
  char **argv;

  /* Clear BSS. */  
  bss_init ();
c00202dc:	e8 ae 00 00 00       	call   c002038f <bss_init>

  /* Break command line into arguments and parse options. */
  argv = read_command_line ();
c00202e1:	e8 04 02 00 00       	call   c00204ea <read_command_line>
c00202e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  argv = parse_options (argv);
c00202e9:	83 ec 0c             	sub    $0xc,%esp
c00202ec:	ff 75 f4             	pushl  -0xc(%ebp)
c00202ef:	e8 2a 03 00 00       	call   c002061e <parse_options>
c00202f4:	83 c4 10             	add    $0x10,%esp
c00202f7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Initialize ourselves as a thread so we can use locks,
     then enable console locking. */
  thread_init ();
c00202fa:	e8 c8 05 00 00       	call   c00208c7 <thread_init>
  console_init ();  
c00202ff:	e8 c4 b4 00 00       	call   c002b7c8 <console_init>

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
          init_ram_pages * PGSIZE / 1024);
c0020304:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c0020309:	c1 e0 0c             	shl    $0xc,%eax
     then enable console locking. */
  thread_init ();
  console_init ();  

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c002030c:	c1 e8 0a             	shr    $0xa,%eax
c002030f:	83 ec 08             	sub    $0x8,%esp
c0020312:	50                   	push   %eax
c0020313:	68 f8 e6 02 c0       	push   $0xc002e6f8
c0020318:	e8 28 70 00 00       	call   c0027345 <printf>
c002031d:	83 c4 10             	add    $0x10,%esp
          init_ram_pages * PGSIZE / 1024);

  /* Initialize memory system. */
  palloc_init (user_page_limit);
c0020320:	a1 80 78 03 c0       	mov    0xc0037880,%eax
c0020325:	83 ec 0c             	sub    $0xc,%esp
c0020328:	50                   	push   %eax
c0020329:	e8 bd 2d 00 00       	call   c00230eb <palloc_init>
c002032e:	83 c4 10             	add    $0x10,%esp
  malloc_init ();
c0020331:	e8 c6 31 00 00       	call   c00234fc <malloc_init>
  paging_init ();
c0020336:	e8 7e 00 00 00       	call   c00203b9 <paging_init>
  tss_init ();
  gdt_init ();
#endif

  /* Initialize interrupt handlers. */
  intr_init ();
c002033b:	e8 a0 11 00 00       	call   c00214e0 <intr_init>
  timer_init ();
c0020340:	e8 65 39 00 00       	call   c0023caa <timer_init>
  kbd_init ();
c0020345:	e8 87 3f 00 00       	call   c00242d1 <kbd_init>
  input_init ();
c002034a:	e8 70 62 00 00       	call   c00265bf <input_init>
  exception_init ();
  syscall_init ();
#endif

  /* Start thread scheduler and enable interrupts. */
  thread_start ();
c002034f:	e8 22 06 00 00       	call   c0020976 <thread_start>
  serial_init_queue ();
c0020354:	e8 73 47 00 00       	call   c0024acc <serial_init_queue>
  timer_calibrate ();
c0020359:	e8 7d 39 00 00       	call   c0023cdb <timer_calibrate>
  ide_init ();
  locate_block_devices ();
  filesys_init (format_filesys);
#endif

  printf ("Boot complete.\n");
c002035e:	83 ec 0c             	sub    $0xc,%esp
c0020361:	68 1b e7 02 c0       	push   $0xc002e71b
c0020366:	e8 c0 b5 00 00       	call   c002b92b <puts>
c002036b:	83 c4 10             	add    $0x10,%esp
  
  if (*argv != NULL) {
c002036e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020371:	8b 00                	mov    (%eax),%eax
c0020373:	85 c0                	test   %eax,%eax
c0020375:	74 0e                	je     c0020385 <pintos_init+0xaf>
    /* Run actions specified on kernel command line. */
    run_actions (argv);
c0020377:	83 ec 0c             	sub    $0xc,%esp
c002037a:	ff 75 f4             	pushl  -0xc(%ebp)
c002037d:	e8 38 04 00 00       	call   c00207ba <run_actions>
c0020382:	83 c4 10             	add    $0x10,%esp
  } else {
    // TODO: no command line passed to kernel. Run interactively 
  }

  /* Finish up. */
  shutdown ();
c0020385:	e8 f3 69 00 00       	call   c0026d7d <shutdown>
  thread_exit ();
c002038a:	e8 90 0a 00 00       	call   c0020e1f <thread_exit>

c002038f <bss_init>:

   The start and end of the BSS segment is recorded by the
   linker as _start_bss and _end_bss.  See kernel.lds. */
static void
bss_init (void) 
{
c002038f:	55                   	push   %ebp
c0020390:	89 e5                	mov    %esp,%ebp
c0020392:	83 ec 08             	sub    $0x8,%esp
  extern char _start_bss, _end_bss;
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c0020395:	ba c5 9c 03 c0       	mov    $0xc0039cc5,%edx
c002039a:	b8 04 81 03 c0       	mov    $0xc0038104,%eax
c002039f:	29 c2                	sub    %eax,%edx
c00203a1:	89 d0                	mov    %edx,%eax
c00203a3:	83 ec 04             	sub    $0x4,%esp
c00203a6:	50                   	push   %eax
c00203a7:	6a 00                	push   $0x0
c00203a9:	68 04 81 03 c0       	push   $0xc0038104
c00203ae:	e8 b9 87 00 00       	call   c0028b6c <memset>
c00203b3:	83 c4 10             	add    $0x10,%esp
}
c00203b6:	90                   	nop
c00203b7:	c9                   	leave  
c00203b8:	c3                   	ret    

c00203b9 <paging_init>:
   kernel virtual mapping, and then sets up the CPU to use the
   new page directory.  Points init_page_dir to the page
   directory it creates. */
static void
paging_init (void)
{
c00203b9:	55                   	push   %ebp
c00203ba:	89 e5                	mov    %esp,%ebp
c00203bc:	53                   	push   %ebx
c00203bd:	83 ec 24             	sub    $0x24,%esp
  uint32_t *pd, *pt;
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00203c0:	83 ec 0c             	sub    $0xc,%esp
c00203c3:	6a 03                	push   $0x3
c00203c5:	e8 9d 2e 00 00       	call   c0023267 <palloc_get_page>
c00203ca:	83 c4 10             	add    $0x10,%esp
c00203cd:	a3 c0 9c 03 c0       	mov    %eax,0xc0039cc0
c00203d2:	a1 c0 9c 03 c0       	mov    0xc0039cc0,%eax
c00203d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pt = NULL;
c00203da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for (page = 0; page < init_ram_pages; page++)
c00203e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00203e8:	e9 d5 00 00 00       	jmp    c00204c2 <paging_init+0x109>
    {
      uintptr_t paddr = page * PGSIZE;
c00203ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00203f0:	c1 e0 0c             	shl    $0xc,%eax
c00203f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
      char *vaddr = ptov (paddr);
c00203f6:	83 ec 0c             	sub    $0xc,%esp
c00203f9:	ff 75 e8             	pushl  -0x18(%ebp)
c00203fc:	e8 9d fd ff ff       	call   c002019e <ptov>
c0020401:	83 c4 10             	add    $0x10,%esp
c0020404:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      size_t pde_idx = pd_no (vaddr);
c0020407:	83 ec 0c             	sub    $0xc,%esp
c002040a:	ff 75 e4             	pushl  -0x1c(%ebp)
c002040d:	e8 11 fe ff ff       	call   c0020223 <pd_no>
c0020412:	83 c4 10             	add    $0x10,%esp
c0020415:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t pte_idx = pt_no (vaddr);
c0020418:	83 ec 0c             	sub    $0xc,%esp
c002041b:	ff 75 e4             	pushl  -0x1c(%ebp)
c002041e:	e8 f0 fd ff ff       	call   c0020213 <pt_no>
c0020423:	83 c4 10             	add    $0x10,%esp
c0020426:	89 45 dc             	mov    %eax,-0x24(%ebp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020429:	81 7d e4 00 00 02 c0 	cmpl   $0xc0020000,-0x1c(%ebp)
c0020430:	72 10                	jb     c0020442 <paging_init+0x89>
c0020432:	81 7d e4 00 40 03 c0 	cmpl   $0xc0034000,-0x1c(%ebp)
c0020439:	73 07                	jae    c0020442 <paging_init+0x89>
c002043b:	b8 01 00 00 00       	mov    $0x1,%eax
c0020440:	eb 05                	jmp    c0020447 <paging_init+0x8e>
c0020442:	b8 00 00 00 00       	mov    $0x0,%eax
c0020447:	88 45 db             	mov    %al,-0x25(%ebp)
c002044a:	80 65 db 01          	andb   $0x1,-0x25(%ebp)

      if (pd[pde_idx] == 0)
c002044e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020451:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020458:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002045b:	01 d0                	add    %edx,%eax
c002045d:	8b 00                	mov    (%eax),%eax
c002045f:	85 c0                	test   %eax,%eax
c0020461:	75 30                	jne    c0020493 <paging_init+0xda>
        {
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020463:	83 ec 0c             	sub    $0xc,%esp
c0020466:	6a 03                	push   $0x3
c0020468:	e8 fa 2d 00 00       	call   c0023267 <palloc_get_page>
c002046d:	83 c4 10             	add    $0x10,%esp
c0020470:	89 45 f4             	mov    %eax,-0xc(%ebp)
          pd[pde_idx] = pde_create (pt);
c0020473:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020476:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002047d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020480:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0020483:	83 ec 0c             	sub    $0xc,%esp
c0020486:	ff 75 f4             	pushl  -0xc(%ebp)
c0020489:	e8 a0 fd ff ff       	call   c002022e <pde_create>
c002048e:	83 c4 10             	add    $0x10,%esp
c0020491:	89 03                	mov    %eax,(%ebx)
        }

      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c0020493:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0020496:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002049d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00204a0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c00204a3:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
c00204a7:	83 f0 01             	xor    $0x1,%eax
c00204aa:	0f b6 c0             	movzbl %al,%eax
c00204ad:	83 ec 08             	sub    $0x8,%esp
c00204b0:	50                   	push   %eax
c00204b1:	ff 75 e4             	pushl  -0x1c(%ebp)
c00204b4:	e8 bb fd ff ff       	call   c0020274 <pte_create_kernel>
c00204b9:	83 c4 10             	add    $0x10,%esp
c00204bc:	89 03                	mov    %eax,(%ebx)
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
  pt = NULL;
  for (page = 0; page < init_ram_pages; page++)
c00204be:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c00204c2:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c00204c7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00204ca:	0f 82 1d ff ff ff    	jb     c00203ed <paging_init+0x34>
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c00204d0:	a1 c0 9c 03 c0       	mov    0xc0039cc0,%eax
c00204d5:	83 ec 0c             	sub    $0xc,%esp
c00204d8:	50                   	push   %eax
c00204d9:	e8 f8 fc ff ff       	call   c00201d6 <vtop>
c00204de:	83 c4 10             	add    $0x10,%esp
c00204e1:	0f 22 d8             	mov    %eax,%cr3
}
c00204e4:	90                   	nop
c00204e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00204e8:	c9                   	leave  
c00204e9:	c3                   	ret    

c00204ea <read_command_line>:

/* Breaks the kernel command line into words and returns them as
   an argv-like array. */
static char **
read_command_line (void) 
{
c00204ea:	55                   	push   %ebp
c00204eb:	89 e5                	mov    %esp,%ebp
c00204ed:	83 ec 18             	sub    $0x18,%esp
  static char *argv[LOADER_ARGS_LEN / 2 + 1];
  char *p, *end;
  int argc;
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c00204f0:	83 ec 0c             	sub    $0xc,%esp
c00204f3:	68 3a 7d 00 00       	push   $0x7d3a
c00204f8:	e8 a1 fc ff ff       	call   c002019e <ptov>
c00204fd:	83 c4 10             	add    $0x10,%esp
c0020500:	8b 00                	mov    (%eax),%eax
c0020502:	89 45 ec             	mov    %eax,-0x14(%ebp)
  p = ptov (LOADER_ARGS);
c0020505:	83 ec 0c             	sub    $0xc,%esp
c0020508:	68 3e 7d 00 00       	push   $0x7d3e
c002050d:	e8 8c fc ff ff       	call   c002019e <ptov>
c0020512:	83 c4 10             	add    $0x10,%esp
c0020515:	89 45 f4             	mov    %eax,-0xc(%ebp)
  end = p + LOADER_ARGS_LEN;
c0020518:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002051b:	83 e8 80             	sub    $0xffffff80,%eax
c002051e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for (i = 0; i < argc; i++) 
c0020521:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0020528:	eb 51                	jmp    c002057b <read_command_line+0x91>
    {
      if (p >= end)
c002052a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002052d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0020530:	72 19                	jb     c002054b <read_command_line+0x61>
        PANIC ("command line arguments overflow");
c0020532:	68 2c e7 02 c0       	push   $0xc002e72c
c0020537:	68 38 ea 02 c0       	push   $0xc002ea38
c002053c:	68 d3 00 00 00       	push   $0xd3
c0020541:	68 4c e7 02 c0       	push   $0xc002e74c
c0020546:	e8 2d 92 00 00       	call   c0029778 <debug_panic>

      argv[i] = p;
c002054b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002054e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0020551:	89 14 85 20 81 03 c0 	mov    %edx,-0x3ffc7ee0(,%eax,4)
      p += strnlen (p, end - p) + 1;
c0020558:	8b 55 e8             	mov    -0x18(%ebp),%edx
c002055b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002055e:	29 c2                	sub    %eax,%edx
c0020560:	89 d0                	mov    %edx,%eax
c0020562:	83 ec 08             	sub    $0x8,%esp
c0020565:	50                   	push   %eax
c0020566:	ff 75 f4             	pushl  -0xc(%ebp)
c0020569:	e8 a6 86 00 00       	call   c0028c14 <strnlen>
c002056e:	83 c4 10             	add    $0x10,%esp
c0020571:	83 c0 01             	add    $0x1,%eax
c0020574:	01 45 f4             	add    %eax,-0xc(%ebp)
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
  p = ptov (LOADER_ARGS);
  end = p + LOADER_ARGS_LEN;
  for (i = 0; i < argc; i++) 
c0020577:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002057b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002057e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020581:	7c a7                	jl     c002052a <read_command_line+0x40>
        PANIC ("command line arguments overflow");

      argv[i] = p;
      p += strnlen (p, end - p) + 1;
    }
  argv[argc] = NULL;
c0020583:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020586:	c7 04 85 20 81 03 c0 	movl   $0x0,-0x3ffc7ee0(,%eax,4)
c002058d:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c0020591:	83 ec 0c             	sub    $0xc,%esp
c0020594:	68 61 e7 02 c0       	push   $0xc002e761
c0020599:	e8 a7 6d 00 00       	call   c0027345 <printf>
c002059e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00205a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00205a8:	eb 58                	jmp    c0020602 <read_command_line+0x118>
    if (strchr (argv[i], ' ') == NULL)
c00205aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205ad:	8b 04 85 20 81 03 c0 	mov    -0x3ffc7ee0(,%eax,4),%eax
c00205b4:	83 ec 08             	sub    $0x8,%esp
c00205b7:	6a 20                	push   $0x20
c00205b9:	50                   	push   %eax
c00205ba:	e8 bc 82 00 00       	call   c002887b <strchr>
c00205bf:	83 c4 10             	add    $0x10,%esp
c00205c2:	85 c0                	test   %eax,%eax
c00205c4:	75 1d                	jne    c00205e3 <read_command_line+0xf9>
      printf (" %s", argv[i]);
c00205c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205c9:	8b 04 85 20 81 03 c0 	mov    -0x3ffc7ee0(,%eax,4),%eax
c00205d0:	83 ec 08             	sub    $0x8,%esp
c00205d3:	50                   	push   %eax
c00205d4:	68 76 e7 02 c0       	push   $0xc002e776
c00205d9:	e8 67 6d 00 00       	call   c0027345 <printf>
c00205de:	83 c4 10             	add    $0x10,%esp
c00205e1:	eb 1b                	jmp    c00205fe <read_command_line+0x114>
    else
      printf (" '%s'", argv[i]);
c00205e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205e6:	8b 04 85 20 81 03 c0 	mov    -0x3ffc7ee0(,%eax,4),%eax
c00205ed:	83 ec 08             	sub    $0x8,%esp
c00205f0:	50                   	push   %eax
c00205f1:	68 7a e7 02 c0       	push   $0xc002e77a
c00205f6:	e8 4a 6d 00 00       	call   c0027345 <printf>
c00205fb:	83 c4 10             	add    $0x10,%esp
    }
  argv[argc] = NULL;

  /* Print kernel command line. */
  printf ("Kernel command line:");
  for (i = 0; i < argc; i++)
c00205fe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0020602:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020605:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020608:	7c a0                	jl     c00205aa <read_command_line+0xc0>
    if (strchr (argv[i], ' ') == NULL)
      printf (" %s", argv[i]);
    else
      printf (" '%s'", argv[i]);
  printf ("\n");
c002060a:	83 ec 0c             	sub    $0xc,%esp
c002060d:	6a 0a                	push   $0xa
c002060f:	e8 9f b3 00 00       	call   c002b9b3 <putchar>
c0020614:	83 c4 10             	add    $0x10,%esp

  return argv;
c0020617:	b8 20 81 03 c0       	mov    $0xc0038120,%eax
}
c002061c:	c9                   	leave  
c002061d:	c3                   	ret    

c002061e <parse_options>:

/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
c002061e:	55                   	push   %ebp
c002061f:	89 e5                	mov    %esp,%ebp
c0020621:	83 ec 18             	sub    $0x18,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c0020624:	e9 1c 01 00 00       	jmp    c0020745 <parse_options+0x127>
    {
      char *save_ptr;
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020629:	8b 45 08             	mov    0x8(%ebp),%eax
c002062c:	8b 00                	mov    (%eax),%eax
c002062e:	83 ec 04             	sub    $0x4,%esp
c0020631:	8d 55 ec             	lea    -0x14(%ebp),%edx
c0020634:	52                   	push   %edx
c0020635:	68 80 e7 02 c0       	push   $0xc002e780
c002063a:	50                   	push   %eax
c002063b:	e8 18 84 00 00       	call   c0028a58 <strtok_r>
c0020640:	83 c4 10             	add    $0x10,%esp
c0020643:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char *value = strtok_r (NULL, "", &save_ptr);
c0020646:	83 ec 04             	sub    $0x4,%esp
c0020649:	8d 45 ec             	lea    -0x14(%ebp),%eax
c002064c:	50                   	push   %eax
c002064d:	68 82 e7 02 c0       	push   $0xc002e782
c0020652:	6a 00                	push   $0x0
c0020654:	e8 ff 83 00 00       	call   c0028a58 <strtok_r>
c0020659:	83 c4 10             	add    $0x10,%esp
c002065c:	89 45 f0             	mov    %eax,-0x10(%ebp)
      
      if (!strcmp (name, "-h"))
c002065f:	83 ec 08             	sub    $0x8,%esp
c0020662:	68 83 e7 02 c0       	push   $0xc002e783
c0020667:	ff 75 f4             	pushl  -0xc(%ebp)
c002066a:	e8 ff 80 00 00       	call   c002876e <strcmp>
c002066f:	83 c4 10             	add    $0x10,%esp
c0020672:	85 c0                	test   %eax,%eax
c0020674:	75 0a                	jne    c0020680 <parse_options+0x62>
        usage ();
c0020676:	e8 24 02 00 00       	call   c002089f <usage>
c002067b:	e9 c1 00 00 00       	jmp    c0020741 <parse_options+0x123>
      else if (!strcmp (name, "-q"))
c0020680:	83 ec 08             	sub    $0x8,%esp
c0020683:	68 86 e7 02 c0       	push   $0xc002e786
c0020688:	ff 75 f4             	pushl  -0xc(%ebp)
c002068b:	e8 de 80 00 00       	call   c002876e <strcmp>
c0020690:	83 c4 10             	add    $0x10,%esp
c0020693:	85 c0                	test   %eax,%eax
c0020695:	75 12                	jne    c00206a9 <parse_options+0x8b>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c0020697:	83 ec 0c             	sub    $0xc,%esp
c002069a:	6a 01                	push   $0x1
c002069c:	e8 00 67 00 00       	call   c0026da1 <shutdown_configure>
c00206a1:	83 c4 10             	add    $0x10,%esp
c00206a4:	e9 98 00 00 00       	jmp    c0020741 <parse_options+0x123>
      else if (!strcmp (name, "-r"))
c00206a9:	83 ec 08             	sub    $0x8,%esp
c00206ac:	68 89 e7 02 c0       	push   $0xc002e789
c00206b1:	ff 75 f4             	pushl  -0xc(%ebp)
c00206b4:	e8 b5 80 00 00       	call   c002876e <strcmp>
c00206b9:	83 c4 10             	add    $0x10,%esp
c00206bc:	85 c0                	test   %eax,%eax
c00206be:	75 0f                	jne    c00206cf <parse_options+0xb1>
        shutdown_configure (SHUTDOWN_REBOOT);
c00206c0:	83 ec 0c             	sub    $0xc,%esp
c00206c3:	6a 02                	push   $0x2
c00206c5:	e8 d7 66 00 00       	call   c0026da1 <shutdown_configure>
c00206ca:	83 c4 10             	add    $0x10,%esp
c00206cd:	eb 72                	jmp    c0020741 <parse_options+0x123>
#ifdef VM
      else if (!strcmp (name, "-swap"))
        swap_bdev_name = value;
#endif
#endif
      else if (!strcmp (name, "-rs"))
c00206cf:	83 ec 08             	sub    $0x8,%esp
c00206d2:	68 8c e7 02 c0       	push   $0xc002e78c
c00206d7:	ff 75 f4             	pushl  -0xc(%ebp)
c00206da:	e8 8f 80 00 00       	call   c002876e <strcmp>
c00206df:	83 c4 10             	add    $0x10,%esp
c00206e2:	85 c0                	test   %eax,%eax
c00206e4:	75 1c                	jne    c0020702 <parse_options+0xe4>
        random_init (atoi (value));
c00206e6:	83 ec 0c             	sub    $0xc,%esp
c00206e9:	ff 75 f0             	pushl  -0x10(%ebp)
c00206ec:	e8 59 7a 00 00       	call   c002814a <atoi>
c00206f1:	83 c4 10             	add    $0x10,%esp
c00206f4:	83 ec 0c             	sub    $0xc,%esp
c00206f7:	50                   	push   %eax
c00206f8:	e8 c7 69 00 00       	call   c00270c4 <random_init>
c00206fd:	83 c4 10             	add    $0x10,%esp
c0020700:	eb 3f                	jmp    c0020741 <parse_options+0x123>
      else if (!strcmp (name, "-mlfqs"))
c0020702:	83 ec 08             	sub    $0x8,%esp
c0020705:	68 90 e7 02 c0       	push   $0xc002e790
c002070a:	ff 75 f4             	pushl  -0xc(%ebp)
c002070d:	e8 5c 80 00 00       	call   c002876e <strcmp>
c0020712:	83 c4 10             	add    $0x10,%esp
c0020715:	85 c0                	test   %eax,%eax
c0020717:	75 09                	jne    c0020722 <parse_options+0x104>
        thread_mlfqs = true;
c0020719:	c6 05 c4 9c 03 c0 01 	movb   $0x1,0xc0039cc4
c0020720:	eb 1f                	jmp    c0020741 <parse_options+0x123>
#ifdef USERPROG
      else if (!strcmp (name, "-ul"))
        user_page_limit = atoi (value);
#endif
      else
        PANIC ("unknown option `%s' (use -h for help)", name);
c0020722:	83 ec 0c             	sub    $0xc,%esp
c0020725:	ff 75 f4             	pushl  -0xc(%ebp)
c0020728:	68 98 e7 02 c0       	push   $0xc002e798
c002072d:	68 4c ea 02 c0       	push   $0xc002ea4c
c0020732:	68 0c 01 00 00       	push   $0x10c
c0020737:	68 4c e7 02 c0       	push   $0xc002e74c
c002073c:	e8 37 90 00 00       	call   c0029778 <debug_panic>
/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
  for (; *argv != NULL && **argv == '-'; argv++)
c0020741:	83 45 08 04          	addl   $0x4,0x8(%ebp)
c0020745:	8b 45 08             	mov    0x8(%ebp),%eax
c0020748:	8b 00                	mov    (%eax),%eax
c002074a:	85 c0                	test   %eax,%eax
c002074c:	74 10                	je     c002075e <parse_options+0x140>
c002074e:	8b 45 08             	mov    0x8(%ebp),%eax
c0020751:	8b 00                	mov    (%eax),%eax
c0020753:	0f b6 00             	movzbl (%eax),%eax
c0020756:	3c 2d                	cmp    $0x2d,%al
c0020758:	0f 84 cb fe ff ff    	je     c0020629 <parse_options+0xb>
     When running under Bochs, this is not enough by itself to
     get a good seed value, because the pintos script sets the
     initial time to a predictable value, not to the local time,
     for reproducibility.  To fix this, give the "-r" option to
     the pintos script to request real-time execution. */
  random_init (rtc_get_time ());
c002075e:	e8 d8 63 00 00       	call   c0026b3b <rtc_get_time>
c0020763:	83 ec 0c             	sub    $0xc,%esp
c0020766:	50                   	push   %eax
c0020767:	e8 58 69 00 00       	call   c00270c4 <random_init>
c002076c:	83 c4 10             	add    $0x10,%esp
  
  return argv;
c002076f:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0020772:	c9                   	leave  
c0020773:	c3                   	ret    

c0020774 <run_task>:

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c0020774:	55                   	push   %ebp
c0020775:	89 e5                	mov    %esp,%ebp
c0020777:	83 ec 18             	sub    $0x18,%esp
  const char *task = argv[1];
c002077a:	8b 45 08             	mov    0x8(%ebp),%eax
c002077d:	8b 40 04             	mov    0x4(%eax),%eax
c0020780:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Executing '%s':\n", task);
c0020783:	83 ec 08             	sub    $0x8,%esp
c0020786:	ff 75 f4             	pushl  -0xc(%ebp)
c0020789:	68 be e7 02 c0       	push   $0xc002e7be
c002078e:	e8 b2 6b 00 00       	call   c0027345 <printf>
c0020793:	83 c4 10             	add    $0x10,%esp
#ifdef USERPROG
  process_wait (process_execute (task));
#else
  run_test (task);
c0020796:	83 ec 0c             	sub    $0xc,%esp
c0020799:	ff 75 f4             	pushl  -0xc(%ebp)
c002079c:	e8 e3 b2 00 00       	call   c002ba84 <run_test>
c00207a1:	83 c4 10             	add    $0x10,%esp
#endif
  printf ("Execution of '%s' complete.\n", task);
c00207a4:	83 ec 08             	sub    $0x8,%esp
c00207a7:	ff 75 f4             	pushl  -0xc(%ebp)
c00207aa:	68 cf e7 02 c0       	push   $0xc002e7cf
c00207af:	e8 91 6b 00 00       	call   c0027345 <printf>
c00207b4:	83 c4 10             	add    $0x10,%esp
}
c00207b7:	90                   	nop
c00207b8:	c9                   	leave  
c00207b9:	c3                   	ret    

c00207ba <run_actions>:

/* Executes all of the actions specified in ARGV[]
   up to the null pointer sentinel. */
static void
run_actions (char **argv) 
{
c00207ba:	55                   	push   %ebp
c00207bb:	89 e5                	mov    %esp,%ebp
c00207bd:	83 ec 18             	sub    $0x18,%esp
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c00207c0:	e9 ca 00 00 00       	jmp    c002088f <run_actions+0xd5>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c00207c5:	c7 45 f4 60 ea 02 c0 	movl   $0xc002ea60,-0xc(%ebp)
        if (a->name == NULL)
c00207cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207cf:	8b 00                	mov    (%eax),%eax
c00207d1:	85 c0                	test   %eax,%eax
c00207d3:	75 22                	jne    c00207f7 <run_actions+0x3d>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c00207d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00207d8:	8b 00                	mov    (%eax),%eax
c00207da:	83 ec 0c             	sub    $0xc,%esp
c00207dd:	50                   	push   %eax
c00207de:	68 ec e7 02 c0       	push   $0xc002e7ec
c00207e3:	68 78 ea 02 c0       	push   $0xc002ea78
c00207e8:	68 4e 01 00 00       	push   $0x14e
c00207ed:	68 4c e7 02 c0       	push   $0xc002e74c
c00207f2:	e8 81 8f 00 00       	call   c0029778 <debug_panic>
        else if (!strcmp (*argv, a->name))
c00207f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207fa:	8b 10                	mov    (%eax),%edx
c00207fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00207ff:	8b 00                	mov    (%eax),%eax
c0020801:	83 ec 08             	sub    $0x8,%esp
c0020804:	52                   	push   %edx
c0020805:	50                   	push   %eax
c0020806:	e8 63 7f 00 00       	call   c002876e <strcmp>
c002080b:	83 c4 10             	add    $0x10,%esp
c002080e:	85 c0                	test   %eax,%eax
c0020810:	74 06                	je     c0020818 <run_actions+0x5e>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c0020812:	83 45 f4 0c          	addl   $0xc,-0xc(%ebp)
          PANIC ("unknown action `%s' (use -h for help)", *argv);
        else if (!strcmp (*argv, a->name))
          break;

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020816:	eb b4                	jmp    c00207cc <run_actions+0x12>
      /* Find action name. */
      for (a = actions; ; a++)
        if (a->name == NULL)
          PANIC ("unknown action `%s' (use -h for help)", *argv);
        else if (!strcmp (*argv, a->name))
          break;
c0020818:	90                   	nop

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020819:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0020820:	eb 45                	jmp    c0020867 <run_actions+0xad>
        if (argv[i] == NULL)
c0020822:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020825:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002082c:	8b 45 08             	mov    0x8(%ebp),%eax
c002082f:	01 d0                	add    %edx,%eax
c0020831:	8b 00                	mov    (%eax),%eax
c0020833:	85 c0                	test   %eax,%eax
c0020835:	75 2c                	jne    c0020863 <run_actions+0xa9>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c0020837:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002083a:	8b 40 04             	mov    0x4(%eax),%eax
c002083d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0020840:	8b 45 08             	mov    0x8(%ebp),%eax
c0020843:	8b 00                	mov    (%eax),%eax
c0020845:	83 ec 08             	sub    $0x8,%esp
c0020848:	52                   	push   %edx
c0020849:	50                   	push   %eax
c002084a:	68 14 e8 02 c0       	push   $0xc002e814
c002084f:	68 78 ea 02 c0       	push   $0xc002ea78
c0020854:	68 55 01 00 00       	push   $0x155
c0020859:	68 4c e7 02 c0       	push   $0xc002e74c
c002085e:	e8 15 8f 00 00       	call   c0029778 <debug_panic>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
        else if (!strcmp (*argv, a->name))
          break;

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020863:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0020867:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002086a:	8b 40 04             	mov    0x4(%eax),%eax
c002086d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0020870:	7f b0                	jg     c0020822 <run_actions+0x68>
        if (argv[i] == NULL)
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);

      /* Invoke action and advance. */
      a->function (argv);
c0020872:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020875:	8b 40 08             	mov    0x8(%eax),%eax
c0020878:	83 ec 0c             	sub    $0xc,%esp
c002087b:	ff 75 08             	pushl  0x8(%ebp)
c002087e:	ff d0                	call   *%eax
c0020880:	83 c4 10             	add    $0x10,%esp
      argv += a->argc;
c0020883:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020886:	8b 40 04             	mov    0x4(%eax),%eax
c0020889:	c1 e0 02             	shl    $0x2,%eax
c002088c:	01 45 08             	add    %eax,0x8(%ebp)
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c002088f:	8b 45 08             	mov    0x8(%ebp),%eax
c0020892:	8b 00                	mov    (%eax),%eax
c0020894:	85 c0                	test   %eax,%eax
c0020896:	0f 85 29 ff ff ff    	jne    c00207c5 <run_actions+0xb>
      /* Invoke action and advance. */
      a->function (argv);
      argv += a->argc;
    }
  
}
c002089c:	90                   	nop
c002089d:	c9                   	leave  
c002089e:	c3                   	ret    

c002089f <usage>:

/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
c002089f:	55                   	push   %ebp
c00208a0:	89 e5                	mov    %esp,%ebp
c00208a2:	83 ec 08             	sub    $0x8,%esp
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c00208a5:	83 ec 0c             	sub    $0xc,%esp
c00208a8:	68 38 e8 02 c0       	push   $0xc002e838
c00208ad:	e8 79 b0 00 00       	call   c002b92b <puts>
c00208b2:	83 c4 10             	add    $0x10,%esp
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c00208b5:	e8 7c 65 00 00       	call   c0026e36 <shutdown_power_off>

c00208ba <pg_round_down>:
static inline void *pg_round_up (const void *va) {
  return (void *) (((uintptr_t) va + PGSIZE - 1) & ~PGMASK);
}

/* Round down to nearest page boundary. */
static inline void *pg_round_down (const void *va) {
c00208ba:	55                   	push   %ebp
c00208bb:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c00208bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00208c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00208c5:	5d                   	pop    %ebp
c00208c6:	c3                   	ret    

c00208c7 <thread_init>:

   It is not safe to call thread_current() until this function
   finishes. */
void
thread_init (void) 
{
c00208c7:	55                   	push   %ebp
c00208c8:	89 e5                	mov    %esp,%ebp
c00208ca:	53                   	push   %ebx
c00208cb:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00208ce:	e8 84 0b 00 00       	call   c0021457 <intr_get_level>
c00208d3:	85 c0                	test   %eax,%eax
c00208d5:	74 1e                	je     c00208f5 <thread_init+0x2e>
c00208d7:	83 ec 0c             	sub    $0xc,%esp
c00208da:	68 84 ea 02 c0       	push   $0xc002ea84
c00208df:	68 a2 ea 02 c0       	push   $0xc002eaa2
c00208e4:	68 44 ec 02 c0       	push   $0xc002ec44
c00208e9:	6a 5d                	push   $0x5d
c00208eb:	68 b9 ea 02 c0       	push   $0xc002eab9
c00208f0:	e8 83 8e 00 00       	call   c0029778 <debug_panic>

  lock_init (&tid_lock);
c00208f5:	83 ec 0c             	sub    $0xc,%esp
c00208f8:	68 60 82 03 c0       	push   $0xc0038260
c00208fd:	e8 91 22 00 00       	call   c0022b93 <lock_init>
c0020902:	83 c4 10             	add    $0x10,%esp
  list_init (&ready_list);
c0020905:	83 ec 0c             	sub    $0xc,%esp
c0020908:	68 38 82 03 c0       	push   $0xc0038238
c002090d:	e8 d9 90 00 00       	call   c00299eb <list_init>
c0020912:	83 c4 10             	add    $0x10,%esp
  list_init (&all_list);
c0020915:	83 ec 0c             	sub    $0xc,%esp
c0020918:	68 48 82 03 c0       	push   $0xc0038248
c002091d:	e8 c9 90 00 00       	call   c00299eb <list_init>
c0020922:	83 c4 10             	add    $0x10,%esp
  list_init (&waiting_list);
c0020925:	83 ec 0c             	sub    $0xc,%esp
c0020928:	68 28 82 03 c0       	push   $0xc0038228
c002092d:	e8 b9 90 00 00       	call   c00299eb <list_init>
c0020932:	83 c4 10             	add    $0x10,%esp


  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread ();
c0020935:	e8 2b 07 00 00       	call   c0021065 <running_thread>
c002093a:	a3 5c 82 03 c0       	mov    %eax,0xc003825c
  init_thread (initial_thread, "main", PRI_DEFAULT);
c002093f:	a1 5c 82 03 c0       	mov    0xc003825c,%eax
c0020944:	83 ec 04             	sub    $0x4,%esp
c0020947:	6a 1f                	push   $0x1f
c0020949:	68 d0 ea 02 c0       	push   $0xc002ead0
c002094e:	50                   	push   %eax
c002094f:	e8 50 07 00 00       	call   c00210a4 <init_thread>
c0020954:	83 c4 10             	add    $0x10,%esp
  initial_thread->status = THREAD_RUNNING;
c0020957:	a1 5c 82 03 c0       	mov    0xc003825c,%eax
c002095c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  initial_thread->tid = allocate_tid ();
c0020963:	8b 1d 5c 82 03 c0    	mov    0xc003825c,%ebx
c0020969:	e8 64 0a 00 00       	call   c00213d2 <allocate_tid>
c002096e:	89 03                	mov    %eax,(%ebx)
}
c0020970:	90                   	nop
c0020971:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020974:	c9                   	leave  
c0020975:	c3                   	ret    

c0020976 <thread_start>:

/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void
thread_start (void) 
{
c0020976:	55                   	push   %ebp
c0020977:	89 e5                	mov    %esp,%ebp
c0020979:	83 ec 28             	sub    $0x28,%esp
  /* Create the idle thread. */
  struct semaphore idle_started;
  sema_init (&idle_started, 0);
c002097c:	83 ec 08             	sub    $0x8,%esp
c002097f:	6a 00                	push   $0x0
c0020981:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020984:	50                   	push   %eax
c0020985:	e8 4e 1f 00 00       	call   c00228d8 <sema_init>
c002098a:	83 c4 10             	add    $0x10,%esp
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c002098d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020990:	50                   	push   %eax
c0020991:	68 ee 0f 02 c0       	push   $0xc0020fee
c0020996:	6a 00                	push   $0x0
c0020998:	68 d5 ea 02 c0       	push   $0xc002ead5
c002099d:	e8 e4 01 00 00       	call   c0020b86 <thread_create>
c00209a2:	83 c4 10             	add    $0x10,%esp

  /* Start preemptive thread scheduling. */
  intr_enable ();
c00209a5:	e8 e4 0a 00 00       	call   c002148e <intr_enable>

  /* Wait for the idle thread to initialize idle_thread. */
  sema_down (&idle_started);
c00209aa:	83 ec 0c             	sub    $0xc,%esp
c00209ad:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c00209b0:	50                   	push   %eax
c00209b1:	e8 69 1f 00 00       	call   c002291f <sema_down>
c00209b6:	83 c4 10             	add    $0x10,%esp
}
c00209b9:	90                   	nop
c00209ba:	c9                   	leave  
c00209bb:	c3                   	ret    

c00209bc <thread_tick>:

/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void
thread_tick (void) 
{
c00209bc:	55                   	push   %ebp
c00209bd:	89 e5                	mov    %esp,%ebp
c00209bf:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current ();
c00209c2:	e8 d8 03 00 00       	call   c0020d9f <thread_current>
c00209c7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Update statistics. */
  if (t == idle_thread)
c00209ca:	a1 58 82 03 c0       	mov    0xc0038258,%eax
c00209cf:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00209d2:	75 1e                	jne    c00209f2 <thread_tick+0x36>
    idle_ticks++;
c00209d4:	a1 78 82 03 c0       	mov    0xc0038278,%eax
c00209d9:	8b 15 7c 82 03 c0    	mov    0xc003827c,%edx
c00209df:	83 c0 01             	add    $0x1,%eax
c00209e2:	83 d2 00             	adc    $0x0,%edx
c00209e5:	a3 78 82 03 c0       	mov    %eax,0xc0038278
c00209ea:	89 15 7c 82 03 c0    	mov    %edx,0xc003827c
c00209f0:	eb 1c                	jmp    c0020a0e <thread_tick+0x52>
#ifdef USERPROG
  else if (t->pagedir != NULL)
    user_ticks++;
#endif
  else
    kernel_ticks++;
c00209f2:	a1 80 82 03 c0       	mov    0xc0038280,%eax
c00209f7:	8b 15 84 82 03 c0    	mov    0xc0038284,%edx
c00209fd:	83 c0 01             	add    $0x1,%eax
c0020a00:	83 d2 00             	adc    $0x0,%edx
c0020a03:	a3 80 82 03 c0       	mov    %eax,0xc0038280
c0020a08:	89 15 84 82 03 c0    	mov    %edx,0xc0038284

  /* Enforce preemption. */
  if (++thread_ticks >= TIME_SLICE)
c0020a0e:	a1 90 82 03 c0       	mov    0xc0038290,%eax
c0020a13:	83 c0 01             	add    $0x1,%eax
c0020a16:	a3 90 82 03 c0       	mov    %eax,0xc0038290
c0020a1b:	a1 90 82 03 c0       	mov    0xc0038290,%eax
c0020a20:	83 f8 03             	cmp    $0x3,%eax
c0020a23:	76 05                	jbe    c0020a2a <thread_tick+0x6e>
    intr_yield_on_return ();
c0020a25:	e8 7d 0d 00 00       	call   c00217a7 <intr_yield_on_return>
}
c0020a2a:	90                   	nop
c0020a2b:	c9                   	leave  
c0020a2c:	c3                   	ret    

c0020a2d <insert_on_waiting_list>:

/*Funcion para insertar los threads dormidos en la lista de espera*/
void insert_on_waiting_list(int64_t ticks){
c0020a2d:	55                   	push   %ebp
c0020a2e:	89 e5                	mov    %esp,%ebp
c0020a30:	53                   	push   %ebx
c0020a31:	83 ec 24             	sub    $0x24,%esp
c0020a34:	8b 45 08             	mov    0x8(%ebp),%eax
c0020a37:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0020a3a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0020a3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	//Deshabilitamos interrupciones
	enum intr_level old_level;
	old_level = intr_disable ();
c0020a40:	e8 87 0a 00 00       	call   c00214cc <intr_disable>
c0020a45:	89 45 f4             	mov    %eax,-0xc(%ebp)

	/* Remover el thread actual de "ready_list" e insertarlo en "waiting_list"
	Cambiar su estatus a THREAD_BLOCKED, y definir su tiempo de expiracion */
	
	struct thread *thread_actual = thread_current ();
c0020a48:	e8 52 03 00 00       	call   c0020d9f <thread_current>
c0020a4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  thread_actual->mustSleep = timer_ticks() + ticks;
c0020a50:	e8 99 33 00 00       	call   c0023dee <timer_ticks>
c0020a55:	89 c1                	mov    %eax,%ecx
c0020a57:	89 c3                	mov    %eax,%ebx
c0020a59:	c1 fb 1f             	sar    $0x1f,%ebx
c0020a5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020a5f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0020a62:	01 c8                	add    %ecx,%eax
c0020a64:	11 da                	adc    %ebx,%edx
c0020a66:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c0020a69:	89 41 30             	mov    %eax,0x30(%ecx)
c0020a6c:	89 51 34             	mov    %edx,0x34(%ecx)
  
  /*mustSleep atributo definido en thread.h*/
	
  list_push_back(&waiting_list, &thread_actual->elem);
c0020a6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020a72:	83 c0 28             	add    $0x28,%eax
c0020a75:	83 ec 08             	sub    $0x8,%esp
c0020a78:	50                   	push   %eax
c0020a79:	68 28 82 03 c0       	push   $0xc0038228
c0020a7e:	e8 48 93 00 00       	call   c0029dcb <list_push_back>
c0020a83:	83 c4 10             	add    $0x10,%esp
  thread_block();
c0020a86:	e8 f4 01 00 00       	call   c0020c7f <thread_block>

  //Habilitar interrupciones
	intr_set_level (old_level);
c0020a8b:	83 ec 0c             	sub    $0xc,%esp
c0020a8e:	ff 75 f4             	pushl  -0xc(%ebp)
c0020a91:	e8 de 09 00 00       	call   c0021474 <intr_set_level>
c0020a96:	83 c4 10             	add    $0x10,%esp
}
c0020a99:	90                   	nop
c0020a9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020a9d:	c9                   	leave  
c0020a9e:	c3                   	ret    

c0020a9f <remove_sleepingThread>:

/*Funcion para remover a lso threads dormidos*/
void remove_sleepingThread(int64_t ticks){
c0020a9f:	55                   	push   %ebp
c0020aa0:	89 e5                	mov    %esp,%ebp
c0020aa2:	53                   	push   %ebx
c0020aa3:	83 ec 24             	sub    $0x24,%esp
c0020aa6:	8b 45 08             	mov    0x8(%ebp),%eax
c0020aa9:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0020aac:	8b 45 0c             	mov    0xc(%ebp),%eax
c0020aaf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	/*Cuando ocurra un timer_interrupt, si el tiempo del thread ha expirado
	Se mueve de regreso a ready_list, con la funcion thread_unblock*/
	
	//Iterar sobre "waiting_list"
	struct list_elem *iter = list_begin(&waiting_list);
c0020ab2:	83 ec 0c             	sub    $0xc,%esp
c0020ab5:	68 28 82 03 c0       	push   $0xc0038228
c0020aba:	e8 81 8f 00 00       	call   c0029a40 <list_begin>
c0020abf:	83 c4 10             	add    $0x10,%esp
c0020ac2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	while(iter != list_end(&waiting_list) ){
c0020ac5:	eb 59                	jmp    c0020b20 <remove_sleepingThread+0x81>
		struct thread *thread_waiting_list= list_entry(iter, struct thread, elem);
c0020ac7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020aca:	83 c0 04             	add    $0x4,%eax
c0020acd:	83 e8 2c             	sub    $0x2c,%eax
c0020ad0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		
		/*Si el tiempo global es mayor al tiempo que el thread permanec√≠a dormido
		  entonces su tiempo de dormir ha expirado*/
		
		if(ticks >= thread_waiting_list->mustSleep){
c0020ad3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020ad6:	8b 48 30             	mov    0x30(%eax),%ecx
c0020ad9:	8b 58 34             	mov    0x34(%eax),%ebx
c0020adc:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020adf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0020ae2:	39 d3                	cmp    %edx,%ebx
c0020ae4:	77 29                	ja     c0020b0f <remove_sleepingThread+0x70>
c0020ae6:	39 d3                	cmp    %edx,%ebx
c0020ae8:	72 04                	jb     c0020aee <remove_sleepingThread+0x4f>
c0020aea:	39 c1                	cmp    %eax,%ecx
c0020aec:	77 21                	ja     c0020b0f <remove_sleepingThread+0x70>
			//Lo removemos de "waiting_list" y lo regresamos a ready_list
			iter = list_remove(iter);
c0020aee:	83 ec 0c             	sub    $0xc,%esp
c0020af1:	ff 75 f4             	pushl  -0xc(%ebp)
c0020af4:	e8 f8 92 00 00       	call   c0029df1 <list_remove>
c0020af9:	83 c4 10             	add    $0x10,%esp
c0020afc:	89 45 f4             	mov    %eax,-0xc(%ebp)
			thread_unblock(thread_waiting_list);
c0020aff:	83 ec 0c             	sub    $0xc,%esp
c0020b02:	ff 75 f0             	pushl  -0x10(%ebp)
c0020b05:	e8 e6 01 00 00       	call   c0020cf0 <thread_unblock>
c0020b0a:	83 c4 10             	add    $0x10,%esp
c0020b0d:	eb 11                	jmp    c0020b20 <remove_sleepingThread+0x81>
		}else{
			//Sino, seguir iterando
			iter = list_next(iter);
c0020b0f:	83 ec 0c             	sub    $0xc,%esp
c0020b12:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b15:	e8 58 8f 00 00       	call   c0029a72 <list_next>
c0020b1a:	83 c4 10             	add    $0x10,%esp
c0020b1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	/*Cuando ocurra un timer_interrupt, si el tiempo del thread ha expirado
	Se mueve de regreso a ready_list, con la funcion thread_unblock*/
	
	//Iterar sobre "waiting_list"
	struct list_elem *iter = list_begin(&waiting_list);
	while(iter != list_end(&waiting_list) ){
c0020b20:	83 ec 0c             	sub    $0xc,%esp
c0020b23:	68 28 82 03 c0       	push   $0xc0038228
c0020b28:	e8 8f 8f 00 00       	call   c0029abc <list_end>
c0020b2d:	83 c4 10             	add    $0x10,%esp
c0020b30:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0020b33:	75 92                	jne    c0020ac7 <remove_sleepingThread+0x28>
		}else{
			//Sino, seguir iterando
			iter = list_next(iter);
		}
	}
}
c0020b35:	90                   	nop
c0020b36:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020b39:	c9                   	leave  
c0020b3a:	c3                   	ret    

c0020b3b <thread_print_stats>:

/* Prints thread statistics. */
void
thread_print_stats (void) 
{
c0020b3b:	55                   	push   %ebp
c0020b3c:	89 e5                	mov    %esp,%ebp
c0020b3e:	57                   	push   %edi
c0020b3f:	56                   	push   %esi
c0020b40:	53                   	push   %ebx
c0020b41:	83 ec 0c             	sub    $0xc,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020b44:	8b 35 88 82 03 c0    	mov    0xc0038288,%esi
c0020b4a:	8b 3d 8c 82 03 c0    	mov    0xc003828c,%edi
c0020b50:	8b 0d 80 82 03 c0    	mov    0xc0038280,%ecx
c0020b56:	8b 1d 84 82 03 c0    	mov    0xc0038284,%ebx
c0020b5c:	a1 78 82 03 c0       	mov    0xc0038278,%eax
c0020b61:	8b 15 7c 82 03 c0    	mov    0xc003827c,%edx
c0020b67:	83 ec 04             	sub    $0x4,%esp
c0020b6a:	57                   	push   %edi
c0020b6b:	56                   	push   %esi
c0020b6c:	53                   	push   %ebx
c0020b6d:	51                   	push   %ecx
c0020b6e:	52                   	push   %edx
c0020b6f:	50                   	push   %eax
c0020b70:	68 dc ea 02 c0       	push   $0xc002eadc
c0020b75:	e8 cb 67 00 00       	call   c0027345 <printf>
c0020b7a:	83 c4 20             	add    $0x20,%esp
          idle_ticks, kernel_ticks, user_ticks);
}
c0020b7d:	90                   	nop
c0020b7e:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0020b81:	5b                   	pop    %ebx
c0020b82:	5e                   	pop    %esi
c0020b83:	5f                   	pop    %edi
c0020b84:	5d                   	pop    %ebp
c0020b85:	c3                   	ret    

c0020b86 <thread_create>:
   PRIORITY, but no actual priority scheduling is implemented.
   Priority scheduling is the goal of Problem 1-3. */
tid_t
thread_create (const char *name, int priority,
               thread_func *function, void *aux) 
{
c0020b86:	55                   	push   %ebp
c0020b87:	89 e5                	mov    %esp,%ebp
c0020b89:	83 ec 28             	sub    $0x28,%esp
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;

  ASSERT (function != NULL);
c0020b8c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020b90:	75 21                	jne    c0020bb3 <thread_create+0x2d>
c0020b92:	83 ec 0c             	sub    $0xc,%esp
c0020b95:	68 19 eb 02 c0       	push   $0xc002eb19
c0020b9a:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0020b9f:	68 50 ec 02 c0       	push   $0xc002ec50
c0020ba4:	68 e1 00 00 00       	push   $0xe1
c0020ba9:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020bae:	e8 c5 8b 00 00       	call   c0029778 <debug_panic>

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
c0020bb3:	83 ec 0c             	sub    $0xc,%esp
c0020bb6:	6a 02                	push   $0x2
c0020bb8:	e8 aa 26 00 00       	call   c0023267 <palloc_get_page>
c0020bbd:	83 c4 10             	add    $0x10,%esp
c0020bc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (t == NULL)
c0020bc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020bc7:	75 0a                	jne    c0020bd3 <thread_create+0x4d>
    return TID_ERROR;
c0020bc9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0020bce:	e9 aa 00 00 00       	jmp    c0020c7d <thread_create+0xf7>

  /* Initialize thread. */
  init_thread (t, name, priority);
c0020bd3:	83 ec 04             	sub    $0x4,%esp
c0020bd6:	ff 75 0c             	pushl  0xc(%ebp)
c0020bd9:	ff 75 08             	pushl  0x8(%ebp)
c0020bdc:	ff 75 f4             	pushl  -0xc(%ebp)
c0020bdf:	e8 c0 04 00 00       	call   c00210a4 <init_thread>
c0020be4:	83 c4 10             	add    $0x10,%esp
  tid = t->tid = allocate_tid ();
c0020be7:	e8 e6 07 00 00       	call   c00213d2 <allocate_tid>
c0020bec:	89 c2                	mov    %eax,%edx
c0020bee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020bf1:	89 10                	mov    %edx,(%eax)
c0020bf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020bf6:	8b 00                	mov    (%eax),%eax
c0020bf8:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Stack frame for kernel_thread(). */
  kf = alloc_frame (t, sizeof *kf);
c0020bfb:	83 ec 08             	sub    $0x8,%esp
c0020bfe:	6a 0c                	push   $0xc
c0020c00:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c03:	e8 a2 05 00 00       	call   c00211aa <alloc_frame>
c0020c08:	83 c4 10             	add    $0x10,%esp
c0020c0b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  kf->eip = NULL;
c0020c0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020c11:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c0020c17:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020c1a:	8b 55 10             	mov    0x10(%ebp),%edx
c0020c1d:	89 50 04             	mov    %edx,0x4(%eax)
  kf->aux = aux;
c0020c20:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020c23:	8b 55 14             	mov    0x14(%ebp),%edx
c0020c26:	89 50 08             	mov    %edx,0x8(%eax)

  /* Stack frame for switch_entry(). */
  ef = alloc_frame (t, sizeof *ef);
c0020c29:	83 ec 08             	sub    $0x8,%esp
c0020c2c:	6a 04                	push   $0x4
c0020c2e:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c31:	e8 74 05 00 00       	call   c00211aa <alloc_frame>
c0020c36:	83 c4 10             	add    $0x10,%esp
c0020c39:	89 45 e8             	mov    %eax,-0x18(%ebp)
  ef->eip = (void (*) (void)) kernel_thread;
c0020c3c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020c3f:	c7 00 20 10 02 c0    	movl   $0xc0021020,(%eax)

  /* Stack frame for switch_threads(). */
  sf = alloc_frame (t, sizeof *sf);
c0020c45:	83 ec 08             	sub    $0x8,%esp
c0020c48:	6a 1c                	push   $0x1c
c0020c4a:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c4d:	e8 58 05 00 00       	call   c00211aa <alloc_frame>
c0020c52:	83 c4 10             	add    $0x10,%esp
c0020c55:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  sf->eip = switch_entry;
c0020c58:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020c5b:	c7 40 10 2b 14 02 c0 	movl   $0xc002142b,0x10(%eax)
  sf->ebp = 0;
c0020c62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020c65:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  /* Add to run queue. */
  thread_unblock (t);
c0020c6c:	83 ec 0c             	sub    $0xc,%esp
c0020c6f:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c72:	e8 79 00 00 00       	call   c0020cf0 <thread_unblock>
c0020c77:	83 c4 10             	add    $0x10,%esp

  return tid;
c0020c7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0020c7d:	c9                   	leave  
c0020c7e:	c3                   	ret    

c0020c7f <thread_block>:
   This function must be called with interrupts turned off.  It
   is usually a better idea to use one of the synchronization
   primitives in synch.h. */
void
thread_block (void) 
{
c0020c7f:	55                   	push   %ebp
c0020c80:	89 e5                	mov    %esp,%ebp
c0020c82:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020c85:	e8 11 0b 00 00       	call   c002179b <intr_context>
c0020c8a:	83 f0 01             	xor    $0x1,%eax
c0020c8d:	84 c0                	test   %al,%al
c0020c8f:	75 21                	jne    c0020cb2 <thread_block+0x33>
c0020c91:	83 ec 0c             	sub    $0xc,%esp
c0020c94:	68 2a eb 02 c0       	push   $0xc002eb2a
c0020c99:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0020c9e:	68 60 ec 02 c0       	push   $0xc002ec60
c0020ca3:	68 0a 01 00 00       	push   $0x10a
c0020ca8:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020cad:	e8 c6 8a 00 00       	call   c0029778 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0020cb2:	e8 a0 07 00 00       	call   c0021457 <intr_get_level>
c0020cb7:	85 c0                	test   %eax,%eax
c0020cb9:	74 21                	je     c0020cdc <thread_block+0x5d>
c0020cbb:	83 ec 0c             	sub    $0xc,%esp
c0020cbe:	68 84 ea 02 c0       	push   $0xc002ea84
c0020cc3:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0020cc8:	68 60 ec 02 c0       	push   $0xc002ec60
c0020ccd:	68 0b 01 00 00       	push   $0x10b
c0020cd2:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020cd7:	e8 9c 8a 00 00       	call   c0029778 <debug_panic>

  thread_current ()->status = THREAD_BLOCKED;
c0020cdc:	e8 be 00 00 00       	call   c0020d9f <thread_current>
c0020ce1:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c0020ce8:	e8 13 06 00 00       	call   c0021300 <schedule>
}
c0020ced:	90                   	nop
c0020cee:	c9                   	leave  
c0020cef:	c3                   	ret    

c0020cf0 <thread_unblock>:
   be important: if the caller had disabled interrupts itself,
   it may expect that it can atomically unblock a thread and
   update other data. */
void
thread_unblock (struct thread *t) 
{
c0020cf0:	55                   	push   %ebp
c0020cf1:	89 e5                	mov    %esp,%ebp
c0020cf3:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (is_thread (t));
c0020cf6:	83 ec 0c             	sub    $0xc,%esp
c0020cf9:	ff 75 08             	pushl  0x8(%ebp)
c0020cfc:	e8 7c 03 00 00       	call   c002107d <is_thread>
c0020d01:	83 c4 10             	add    $0x10,%esp
c0020d04:	84 c0                	test   %al,%al
c0020d06:	75 21                	jne    c0020d29 <thread_unblock+0x39>
c0020d08:	83 ec 0c             	sub    $0xc,%esp
c0020d0b:	68 3b eb 02 c0       	push   $0xc002eb3b
c0020d10:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0020d15:	68 70 ec 02 c0       	push   $0xc002ec70
c0020d1a:	68 1e 01 00 00       	push   $0x11e
c0020d1f:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020d24:	e8 4f 8a 00 00       	call   c0029778 <debug_panic>

  old_level = intr_disable ();
c0020d29:	e8 9e 07 00 00       	call   c00214cc <intr_disable>
c0020d2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (t->status == THREAD_BLOCKED);
c0020d31:	8b 45 08             	mov    0x8(%ebp),%eax
c0020d34:	8b 40 04             	mov    0x4(%eax),%eax
c0020d37:	83 f8 02             	cmp    $0x2,%eax
c0020d3a:	74 21                	je     c0020d5d <thread_unblock+0x6d>
c0020d3c:	83 ec 0c             	sub    $0xc,%esp
c0020d3f:	68 49 eb 02 c0       	push   $0xc002eb49
c0020d44:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0020d49:	68 70 ec 02 c0       	push   $0xc002ec70
c0020d4e:	68 21 01 00 00       	push   $0x121
c0020d53:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020d58:	e8 1b 8a 00 00       	call   c0029778 <debug_panic>
  list_push_back (&ready_list, &t->elem);
c0020d5d:	8b 45 08             	mov    0x8(%ebp),%eax
c0020d60:	83 c0 28             	add    $0x28,%eax
c0020d63:	83 ec 08             	sub    $0x8,%esp
c0020d66:	50                   	push   %eax
c0020d67:	68 38 82 03 c0       	push   $0xc0038238
c0020d6c:	e8 5a 90 00 00       	call   c0029dcb <list_push_back>
c0020d71:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_READY;
c0020d74:	8b 45 08             	mov    0x8(%ebp),%eax
c0020d77:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  intr_set_level (old_level);
c0020d7e:	83 ec 0c             	sub    $0xc,%esp
c0020d81:	ff 75 f4             	pushl  -0xc(%ebp)
c0020d84:	e8 eb 06 00 00       	call   c0021474 <intr_set_level>
c0020d89:	83 c4 10             	add    $0x10,%esp
}
c0020d8c:	90                   	nop
c0020d8d:	c9                   	leave  
c0020d8e:	c3                   	ret    

c0020d8f <thread_name>:

/* Returns the name of the running thread. */
const char *
thread_name (void) 
{
c0020d8f:	55                   	push   %ebp
c0020d90:	89 e5                	mov    %esp,%ebp
c0020d92:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->name;
c0020d95:	e8 05 00 00 00       	call   c0020d9f <thread_current>
c0020d9a:	83 c0 08             	add    $0x8,%eax
}
c0020d9d:	c9                   	leave  
c0020d9e:	c3                   	ret    

c0020d9f <thread_current>:
/* Returns the running thread.
   This is running_thread() plus a couple of sanity checks.
   See the big comment at the top of thread.h for details. */
struct thread *
thread_current (void) 
{
c0020d9f:	55                   	push   %ebp
c0020da0:	89 e5                	mov    %esp,%ebp
c0020da2:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = running_thread ();
c0020da5:	e8 bb 02 00 00       	call   c0021065 <running_thread>
c0020daa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT (is_thread (t));
c0020dad:	83 ec 0c             	sub    $0xc,%esp
c0020db0:	ff 75 f4             	pushl  -0xc(%ebp)
c0020db3:	e8 c5 02 00 00       	call   c002107d <is_thread>
c0020db8:	83 c4 10             	add    $0x10,%esp
c0020dbb:	84 c0                	test   %al,%al
c0020dbd:	75 21                	jne    c0020de0 <thread_current+0x41>
c0020dbf:	83 ec 0c             	sub    $0xc,%esp
c0020dc2:	68 3b eb 02 c0       	push   $0xc002eb3b
c0020dc7:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0020dcc:	68 80 ec 02 c0       	push   $0xc002ec80
c0020dd1:	68 3b 01 00 00       	push   $0x13b
c0020dd6:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020ddb:	e8 98 89 00 00       	call   c0029778 <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020de0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020de3:	8b 40 04             	mov    0x4(%eax),%eax
c0020de6:	85 c0                	test   %eax,%eax
c0020de8:	74 21                	je     c0020e0b <thread_current+0x6c>
c0020dea:	83 ec 0c             	sub    $0xc,%esp
c0020ded:	68 65 eb 02 c0       	push   $0xc002eb65
c0020df2:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0020df7:	68 80 ec 02 c0       	push   $0xc002ec80
c0020dfc:	68 3c 01 00 00       	push   $0x13c
c0020e01:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020e06:	e8 6d 89 00 00       	call   c0029778 <debug_panic>

  return t;
c0020e0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0020e0e:	c9                   	leave  
c0020e0f:	c3                   	ret    

c0020e10 <thread_tid>:

/* Returns the running thread's tid. */
tid_t
thread_tid (void) 
{
c0020e10:	55                   	push   %ebp
c0020e11:	89 e5                	mov    %esp,%ebp
c0020e13:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->tid;
c0020e16:	e8 84 ff ff ff       	call   c0020d9f <thread_current>
c0020e1b:	8b 00                	mov    (%eax),%eax
}
c0020e1d:	c9                   	leave  
c0020e1e:	c3                   	ret    

c0020e1f <thread_exit>:

/* Deschedules the current thread and destroys it.  Never
   returns to the caller. */
void
thread_exit (void) 
{
c0020e1f:	55                   	push   %ebp
c0020e20:	89 e5                	mov    %esp,%ebp
c0020e22:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020e25:	e8 71 09 00 00       	call   c002179b <intr_context>
c0020e2a:	83 f0 01             	xor    $0x1,%eax
c0020e2d:	84 c0                	test   %al,%al
c0020e2f:	75 21                	jne    c0020e52 <thread_exit+0x33>
c0020e31:	83 ec 0c             	sub    $0xc,%esp
c0020e34:	68 2a eb 02 c0       	push   $0xc002eb2a
c0020e39:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0020e3e:	68 90 ec 02 c0       	push   $0xc002ec90
c0020e43:	68 4d 01 00 00       	push   $0x14d
c0020e48:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020e4d:	e8 26 89 00 00       	call   c0029778 <debug_panic>
#endif

  /* Remove thread from all threads list, set our status to dying,
     and schedule another process.  That process will destroy us
     when it calls thread_schedule_tail(). */
  intr_disable ();
c0020e52:	e8 75 06 00 00       	call   c00214cc <intr_disable>
  list_remove (&thread_current()->allelem);
c0020e57:	e8 43 ff ff ff       	call   c0020d9f <thread_current>
c0020e5c:	83 c0 20             	add    $0x20,%eax
c0020e5f:	83 ec 0c             	sub    $0xc,%esp
c0020e62:	50                   	push   %eax
c0020e63:	e8 89 8f 00 00       	call   c0029df1 <list_remove>
c0020e68:	83 c4 10             	add    $0x10,%esp
  thread_current ()->status = THREAD_DYING;
c0020e6b:	e8 2f ff ff ff       	call   c0020d9f <thread_current>
c0020e70:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c0020e77:	e8 84 04 00 00       	call   c0021300 <schedule>
  NOT_REACHED ();
c0020e7c:	68 84 eb 02 c0       	push   $0xc002eb84
c0020e81:	68 90 ec 02 c0       	push   $0xc002ec90
c0020e86:	68 5a 01 00 00       	push   $0x15a
c0020e8b:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020e90:	e8 e3 88 00 00       	call   c0029778 <debug_panic>

c0020e95 <thread_yield>:

/* Yields the CPU.  The current thread is not put to sleep and
   may be scheduled again immediately at the scheduler's whim. */
void
thread_yield (void) 
{
c0020e95:	55                   	push   %ebp
c0020e96:	89 e5                	mov    %esp,%ebp
c0020e98:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = thread_current ();
c0020e9b:	e8 ff fe ff ff       	call   c0020d9f <thread_current>
c0020ea0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  enum intr_level old_level;
  
  ASSERT (!intr_context ());
c0020ea3:	e8 f3 08 00 00       	call   c002179b <intr_context>
c0020ea8:	83 f0 01             	xor    $0x1,%eax
c0020eab:	84 c0                	test   %al,%al
c0020ead:	75 21                	jne    c0020ed0 <thread_yield+0x3b>
c0020eaf:	83 ec 0c             	sub    $0xc,%esp
c0020eb2:	68 2a eb 02 c0       	push   $0xc002eb2a
c0020eb7:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0020ebc:	68 9c ec 02 c0       	push   $0xc002ec9c
c0020ec1:	68 65 01 00 00       	push   $0x165
c0020ec6:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020ecb:	e8 a8 88 00 00       	call   c0029778 <debug_panic>

  old_level = intr_disable ();
c0020ed0:	e8 f7 05 00 00       	call   c00214cc <intr_disable>
c0020ed5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (cur != idle_thread) 
c0020ed8:	a1 58 82 03 c0       	mov    0xc0038258,%eax
c0020edd:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020ee0:	74 17                	je     c0020ef9 <thread_yield+0x64>
    list_push_back (&ready_list, &cur->elem);
c0020ee2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ee5:	83 c0 28             	add    $0x28,%eax
c0020ee8:	83 ec 08             	sub    $0x8,%esp
c0020eeb:	50                   	push   %eax
c0020eec:	68 38 82 03 c0       	push   $0xc0038238
c0020ef1:	e8 d5 8e 00 00       	call   c0029dcb <list_push_back>
c0020ef6:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c0020ef9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020efc:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  schedule ();
c0020f03:	e8 f8 03 00 00       	call   c0021300 <schedule>
  intr_set_level (old_level);
c0020f08:	83 ec 0c             	sub    $0xc,%esp
c0020f0b:	ff 75 f0             	pushl  -0x10(%ebp)
c0020f0e:	e8 61 05 00 00       	call   c0021474 <intr_set_level>
c0020f13:	83 c4 10             	add    $0x10,%esp
}
c0020f16:	90                   	nop
c0020f17:	c9                   	leave  
c0020f18:	c3                   	ret    

c0020f19 <thread_foreach>:

/* Invoke function 'func' on all threads, passing along 'aux'.
   This function must be called with interrupts off. */
void
thread_foreach (thread_action_func *func, void *aux)
{
c0020f19:	55                   	push   %ebp
c0020f1a:	89 e5                	mov    %esp,%ebp
c0020f1c:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);
c0020f1f:	e8 33 05 00 00       	call   c0021457 <intr_get_level>
c0020f24:	85 c0                	test   %eax,%eax
c0020f26:	74 21                	je     c0020f49 <thread_foreach+0x30>
c0020f28:	83 ec 0c             	sub    $0xc,%esp
c0020f2b:	68 84 ea 02 c0       	push   $0xc002ea84
c0020f30:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0020f35:	68 ac ec 02 c0       	push   $0xc002ecac
c0020f3a:	68 76 01 00 00       	push   $0x176
c0020f3f:	68 b9 ea 02 c0       	push   $0xc002eab9
c0020f44:	e8 2f 88 00 00       	call   c0029778 <debug_panic>

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020f49:	83 ec 0c             	sub    $0xc,%esp
c0020f4c:	68 48 82 03 c0       	push   $0xc0038248
c0020f51:	e8 ea 8a 00 00       	call   c0029a40 <list_begin>
c0020f56:	83 c4 10             	add    $0x10,%esp
c0020f59:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0020f5c:	eb 2e                	jmp    c0020f8c <thread_foreach+0x73>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
c0020f5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020f61:	83 c0 04             	add    $0x4,%eax
c0020f64:	83 e8 24             	sub    $0x24,%eax
c0020f67:	89 45 f0             	mov    %eax,-0x10(%ebp)
      func (t, aux);
c0020f6a:	83 ec 08             	sub    $0x8,%esp
c0020f6d:	ff 75 0c             	pushl  0xc(%ebp)
c0020f70:	ff 75 f0             	pushl  -0x10(%ebp)
c0020f73:	8b 45 08             	mov    0x8(%ebp),%eax
c0020f76:	ff d0                	call   *%eax
c0020f78:	83 c4 10             	add    $0x10,%esp
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);

  for (e = list_begin (&all_list); e != list_end (&all_list);
       e = list_next (e))
c0020f7b:	83 ec 0c             	sub    $0xc,%esp
c0020f7e:	ff 75 f4             	pushl  -0xc(%ebp)
c0020f81:	e8 ec 8a 00 00       	call   c0029a72 <list_next>
c0020f86:	83 c4 10             	add    $0x10,%esp
c0020f89:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020f8c:	83 ec 0c             	sub    $0xc,%esp
c0020f8f:	68 48 82 03 c0       	push   $0xc0038248
c0020f94:	e8 23 8b 00 00       	call   c0029abc <list_end>
c0020f99:	83 c4 10             	add    $0x10,%esp
c0020f9c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0020f9f:	75 bd                	jne    c0020f5e <thread_foreach+0x45>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
      func (t, aux);
    }
}
c0020fa1:	90                   	nop
c0020fa2:	c9                   	leave  
c0020fa3:	c3                   	ret    

c0020fa4 <thread_set_priority>:

/* Sets the current thread's priority to NEW_PRIORITY. */
void
thread_set_priority (int new_priority) 
{
c0020fa4:	55                   	push   %ebp
c0020fa5:	89 e5                	mov    %esp,%ebp
c0020fa7:	83 ec 08             	sub    $0x8,%esp
  thread_current ()->priority = new_priority;
c0020faa:	e8 f0 fd ff ff       	call   c0020d9f <thread_current>
c0020faf:	89 c2                	mov    %eax,%edx
c0020fb1:	8b 45 08             	mov    0x8(%ebp),%eax
c0020fb4:	89 42 1c             	mov    %eax,0x1c(%edx)
}
c0020fb7:	90                   	nop
c0020fb8:	c9                   	leave  
c0020fb9:	c3                   	ret    

c0020fba <thread_get_priority>:

/* Returns the current thread's priority. */
int
thread_get_priority (void) 
{
c0020fba:	55                   	push   %ebp
c0020fbb:	89 e5                	mov    %esp,%ebp
c0020fbd:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->priority;
c0020fc0:	e8 da fd ff ff       	call   c0020d9f <thread_current>
c0020fc5:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0020fc8:	c9                   	leave  
c0020fc9:	c3                   	ret    

c0020fca <thread_set_nice>:

/* Sets the current thread's nice value to NICE. */
void
thread_set_nice (int nice UNUSED) 
{
c0020fca:	55                   	push   %ebp
c0020fcb:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
}
c0020fcd:	90                   	nop
c0020fce:	5d                   	pop    %ebp
c0020fcf:	c3                   	ret    

c0020fd0 <thread_get_nice>:

/* Returns the current thread's nice value. */
int
thread_get_nice (void) 
{
c0020fd0:	55                   	push   %ebp
c0020fd1:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020fd3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020fd8:	5d                   	pop    %ebp
c0020fd9:	c3                   	ret    

c0020fda <thread_get_load_avg>:

/* Returns 100 times the system load average. */
int
thread_get_load_avg (void) 
{
c0020fda:	55                   	push   %ebp
c0020fdb:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020fdd:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020fe2:	5d                   	pop    %ebp
c0020fe3:	c3                   	ret    

c0020fe4 <thread_get_recent_cpu>:

/* Returns 100 times the current thread's recent_cpu value. */
int
thread_get_recent_cpu (void) 
{
c0020fe4:	55                   	push   %ebp
c0020fe5:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020fe7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020fec:	5d                   	pop    %ebp
c0020fed:	c3                   	ret    

c0020fee <idle>:
   blocks.  After that, the idle thread never appears in the
   ready list.  It is returned by next_thread_to_run() as a
   special case when the ready list is empty. */
static void
idle (void *idle_started_ UNUSED) 
{
c0020fee:	55                   	push   %ebp
c0020fef:	89 e5                	mov    %esp,%ebp
c0020ff1:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *idle_started = idle_started_;
c0020ff4:	8b 45 08             	mov    0x8(%ebp),%eax
c0020ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  idle_thread = thread_current ();
c0020ffa:	e8 a0 fd ff ff       	call   c0020d9f <thread_current>
c0020fff:	a3 58 82 03 c0       	mov    %eax,0xc0038258
  sema_up (idle_started);
c0021004:	83 ec 0c             	sub    $0xc,%esp
c0021007:	ff 75 f4             	pushl  -0xc(%ebp)
c002100a:	e8 1b 1a 00 00       	call   c0022a2a <sema_up>
c002100f:	83 c4 10             	add    $0x10,%esp

  for (;;) 
    {
      /* Let someone else run. */
      intr_disable ();
c0021012:	e8 b5 04 00 00       	call   c00214cc <intr_disable>
      thread_block ();
c0021017:	e8 63 fc ff ff       	call   c0020c7f <thread_block>
         one to occur, wasting as much as one clock tick worth of
         time.

         See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
         7.11.1 "HLT Instruction". */
      asm volatile ("sti; hlt" : : : "memory");
c002101c:	fb                   	sti    
c002101d:	f4                   	hlt    
    }
c002101e:	eb f2                	jmp    c0021012 <idle+0x24>

c0021020 <kernel_thread>:
}

/* Function used as the basis for a kernel thread. */
static void
kernel_thread (thread_func *function, void *aux) 
{
c0021020:	55                   	push   %ebp
c0021021:	89 e5                	mov    %esp,%ebp
c0021023:	83 ec 08             	sub    $0x8,%esp
  ASSERT (function != NULL);
c0021026:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002102a:	75 21                	jne    c002104d <kernel_thread+0x2d>
c002102c:	83 ec 0c             	sub    $0xc,%esp
c002102f:	68 19 eb 02 c0       	push   $0xc002eb19
c0021034:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0021039:	68 bc ec 02 c0       	push   $0xc002ecbc
c002103e:	68 d7 01 00 00       	push   $0x1d7
c0021043:	68 b9 ea 02 c0       	push   $0xc002eab9
c0021048:	e8 2b 87 00 00       	call   c0029778 <debug_panic>

  intr_enable ();       /* The scheduler runs with interrupts off. */
c002104d:	e8 3c 04 00 00       	call   c002148e <intr_enable>
  function (aux);       /* Execute the thread function. */
c0021052:	83 ec 0c             	sub    $0xc,%esp
c0021055:	ff 75 0c             	pushl  0xc(%ebp)
c0021058:	8b 45 08             	mov    0x8(%ebp),%eax
c002105b:	ff d0                	call   *%eax
c002105d:	83 c4 10             	add    $0x10,%esp
  thread_exit ();       /* If function() returns, kill the thread. */
c0021060:	e8 ba fd ff ff       	call   c0020e1f <thread_exit>

c0021065 <running_thread>:
}

/* Returns the running thread. */
struct thread *
running_thread (void) 
{
c0021065:	55                   	push   %ebp
c0021066:	89 e5                	mov    %esp,%ebp
c0021068:	83 ec 10             	sub    $0x10,%esp

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c002106b:	89 e0                	mov    %esp,%eax
c002106d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return pg_round_down (esp);
c0021070:	ff 75 fc             	pushl  -0x4(%ebp)
c0021073:	e8 42 f8 ff ff       	call   c00208ba <pg_round_down>
c0021078:	83 c4 04             	add    $0x4,%esp
}
c002107b:	c9                   	leave  
c002107c:	c3                   	ret    

c002107d <is_thread>:

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
c002107d:	55                   	push   %ebp
c002107e:	89 e5                	mov    %esp,%ebp
  return t != NULL && t->magic == THREAD_MAGIC;
c0021080:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021084:	74 14                	je     c002109a <is_thread+0x1d>
c0021086:	8b 45 08             	mov    0x8(%ebp),%eax
c0021089:	8b 40 38             	mov    0x38(%eax),%eax
c002108c:	3d 4b bf 6a cd       	cmp    $0xcd6abf4b,%eax
c0021091:	75 07                	jne    c002109a <is_thread+0x1d>
c0021093:	b8 01 00 00 00       	mov    $0x1,%eax
c0021098:	eb 05                	jmp    c002109f <is_thread+0x22>
c002109a:	b8 00 00 00 00       	mov    $0x0,%eax
c002109f:	83 e0 01             	and    $0x1,%eax
}
c00210a2:	5d                   	pop    %ebp
c00210a3:	c3                   	ret    

c00210a4 <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c00210a4:	55                   	push   %ebp
c00210a5:	89 e5                	mov    %esp,%ebp
c00210a7:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (t != NULL);
c00210aa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00210ae:	75 21                	jne    c00210d1 <init_thread+0x2d>
c00210b0:	83 ec 0c             	sub    $0xc,%esp
c00210b3:	68 a6 eb 02 c0       	push   $0xc002eba6
c00210b8:	68 a2 ea 02 c0       	push   $0xc002eaa2
c00210bd:	68 cc ec 02 c0       	push   $0xc002eccc
c00210c2:	68 fa 01 00 00       	push   $0x1fa
c00210c7:	68 b9 ea 02 c0       	push   $0xc002eab9
c00210cc:	e8 a7 86 00 00       	call   c0029778 <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c00210d1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00210d5:	78 06                	js     c00210dd <init_thread+0x39>
c00210d7:	83 7d 10 3f          	cmpl   $0x3f,0x10(%ebp)
c00210db:	7e 21                	jle    c00210fe <init_thread+0x5a>
c00210dd:	83 ec 0c             	sub    $0xc,%esp
c00210e0:	68 b0 eb 02 c0       	push   $0xc002ebb0
c00210e5:	68 a2 ea 02 c0       	push   $0xc002eaa2
c00210ea:	68 cc ec 02 c0       	push   $0xc002eccc
c00210ef:	68 fb 01 00 00       	push   $0x1fb
c00210f4:	68 b9 ea 02 c0       	push   $0xc002eab9
c00210f9:	e8 7a 86 00 00       	call   c0029778 <debug_panic>
  ASSERT (name != NULL);
c00210fe:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0021102:	75 21                	jne    c0021125 <init_thread+0x81>
c0021104:	83 ec 0c             	sub    $0xc,%esp
c0021107:	68 db eb 02 c0       	push   $0xc002ebdb
c002110c:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0021111:	68 cc ec 02 c0       	push   $0xc002eccc
c0021116:	68 fc 01 00 00       	push   $0x1fc
c002111b:	68 b9 ea 02 c0       	push   $0xc002eab9
c0021120:	e8 53 86 00 00       	call   c0029778 <debug_panic>

  memset (t, 0, sizeof *t);
c0021125:	83 ec 04             	sub    $0x4,%esp
c0021128:	6a 3c                	push   $0x3c
c002112a:	6a 00                	push   $0x0
c002112c:	ff 75 08             	pushl  0x8(%ebp)
c002112f:	e8 38 7a 00 00       	call   c0028b6c <memset>
c0021134:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_BLOCKED;
c0021137:	8b 45 08             	mov    0x8(%ebp),%eax
c002113a:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  strlcpy (t->name, name, sizeof t->name);
c0021141:	8b 45 08             	mov    0x8(%ebp),%eax
c0021144:	83 c0 08             	add    $0x8,%eax
c0021147:	83 ec 04             	sub    $0x4,%esp
c002114a:	6a 10                	push   $0x10
c002114c:	ff 75 0c             	pushl  0xc(%ebp)
c002114f:	50                   	push   %eax
c0021150:	e8 ee 7a 00 00       	call   c0028c43 <strlcpy>
c0021155:	83 c4 10             	add    $0x10,%esp
  t->stack = (uint8_t *) t + PGSIZE;
c0021158:	8b 45 08             	mov    0x8(%ebp),%eax
c002115b:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0021161:	8b 45 08             	mov    0x8(%ebp),%eax
c0021164:	89 50 18             	mov    %edx,0x18(%eax)
  t->priority = priority;
c0021167:	8b 45 08             	mov    0x8(%ebp),%eax
c002116a:	8b 55 10             	mov    0x10(%ebp),%edx
c002116d:	89 50 1c             	mov    %edx,0x1c(%eax)
  t->magic = THREAD_MAGIC;
c0021170:	8b 45 08             	mov    0x8(%ebp),%eax
c0021173:	c7 40 38 4b bf 6a cd 	movl   $0xcd6abf4b,0x38(%eax)

  old_level = intr_disable ();
c002117a:	e8 4d 03 00 00       	call   c00214cc <intr_disable>
c002117f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_push_back (&all_list, &t->allelem);
c0021182:	8b 45 08             	mov    0x8(%ebp),%eax
c0021185:	83 c0 20             	add    $0x20,%eax
c0021188:	83 ec 08             	sub    $0x8,%esp
c002118b:	50                   	push   %eax
c002118c:	68 48 82 03 c0       	push   $0xc0038248
c0021191:	e8 35 8c 00 00       	call   c0029dcb <list_push_back>
c0021196:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0021199:	83 ec 0c             	sub    $0xc,%esp
c002119c:	ff 75 f4             	pushl  -0xc(%ebp)
c002119f:	e8 d0 02 00 00       	call   c0021474 <intr_set_level>
c00211a4:	83 c4 10             	add    $0x10,%esp
}
c00211a7:	90                   	nop
c00211a8:	c9                   	leave  
c00211a9:	c3                   	ret    

c00211aa <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c00211aa:	55                   	push   %ebp
c00211ab:	89 e5                	mov    %esp,%ebp
c00211ad:	83 ec 08             	sub    $0x8,%esp
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c00211b0:	ff 75 08             	pushl  0x8(%ebp)
c00211b3:	e8 c5 fe ff ff       	call   c002107d <is_thread>
c00211b8:	83 c4 04             	add    $0x4,%esp
c00211bb:	84 c0                	test   %al,%al
c00211bd:	75 21                	jne    c00211e0 <alloc_frame+0x36>
c00211bf:	83 ec 0c             	sub    $0xc,%esp
c00211c2:	68 3b eb 02 c0       	push   $0xc002eb3b
c00211c7:	68 a2 ea 02 c0       	push   $0xc002eaa2
c00211cc:	68 d8 ec 02 c0       	push   $0xc002ecd8
c00211d1:	68 10 02 00 00       	push   $0x210
c00211d6:	68 b9 ea 02 c0       	push   $0xc002eab9
c00211db:	e8 98 85 00 00       	call   c0029778 <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c00211e0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00211e3:	83 e0 03             	and    $0x3,%eax
c00211e6:	85 c0                	test   %eax,%eax
c00211e8:	74 21                	je     c002120b <alloc_frame+0x61>
c00211ea:	83 ec 0c             	sub    $0xc,%esp
c00211ed:	68 e8 eb 02 c0       	push   $0xc002ebe8
c00211f2:	68 a2 ea 02 c0       	push   $0xc002eaa2
c00211f7:	68 d8 ec 02 c0       	push   $0xc002ecd8
c00211fc:	68 11 02 00 00       	push   $0x211
c0021201:	68 b9 ea 02 c0       	push   $0xc002eab9
c0021206:	e8 6d 85 00 00       	call   c0029778 <debug_panic>

  t->stack -= size;
c002120b:	8b 45 08             	mov    0x8(%ebp),%eax
c002120e:	8b 40 18             	mov    0x18(%eax),%eax
c0021211:	8b 55 0c             	mov    0xc(%ebp),%edx
c0021214:	f7 da                	neg    %edx
c0021216:	01 c2                	add    %eax,%edx
c0021218:	8b 45 08             	mov    0x8(%ebp),%eax
c002121b:	89 50 18             	mov    %edx,0x18(%eax)
  return t->stack;
c002121e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021221:	8b 40 18             	mov    0x18(%eax),%eax
}
c0021224:	c9                   	leave  
c0021225:	c3                   	ret    

c0021226 <next_thread_to_run>:
   empty.  (If the running thread can continue running, then it
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run (void) 
{
c0021226:	55                   	push   %ebp
c0021227:	89 e5                	mov    %esp,%ebp
c0021229:	83 ec 08             	sub    $0x8,%esp
  if (list_empty (&ready_list))
c002122c:	83 ec 0c             	sub    $0xc,%esp
c002122f:	68 38 82 03 c0       	push   $0xc0038238
c0021234:	e8 3a 8d 00 00       	call   c0029f73 <list_empty>
c0021239:	83 c4 10             	add    $0x10,%esp
c002123c:	84 c0                	test   %al,%al
c002123e:	74 07                	je     c0021247 <next_thread_to_run+0x21>
    return idle_thread;
c0021240:	a1 58 82 03 c0       	mov    0xc0038258,%eax
c0021245:	eb 16                	jmp    c002125d <next_thread_to_run+0x37>
  else
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c0021247:	83 ec 0c             	sub    $0xc,%esp
c002124a:	68 38 82 03 c0       	push   $0xc0038238
c002124f:	e8 f6 8b 00 00       	call   c0029e4a <list_pop_front>
c0021254:	83 c4 10             	add    $0x10,%esp
c0021257:	83 c0 04             	add    $0x4,%eax
c002125a:	83 e8 2c             	sub    $0x2c,%eax
}
c002125d:	c9                   	leave  
c002125e:	c3                   	ret    

c002125f <thread_schedule_tail>:

   After this function and its caller returns, the thread switch
   is complete. */
void
thread_schedule_tail (struct thread *prev)
{
c002125f:	55                   	push   %ebp
c0021260:	89 e5                	mov    %esp,%ebp
c0021262:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c0021265:	e8 fb fd ff ff       	call   c0021065 <running_thread>
c002126a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (intr_get_level () == INTR_OFF);
c002126d:	e8 e5 01 00 00       	call   c0021457 <intr_get_level>
c0021272:	85 c0                	test   %eax,%eax
c0021274:	74 21                	je     c0021297 <thread_schedule_tail+0x38>
c0021276:	83 ec 0c             	sub    $0xc,%esp
c0021279:	68 84 ea 02 c0       	push   $0xc002ea84
c002127e:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0021283:	68 e4 ec 02 c0       	push   $0xc002ece4
c0021288:	68 3a 02 00 00       	push   $0x23a
c002128d:	68 b9 ea 02 c0       	push   $0xc002eab9
c0021292:	e8 e1 84 00 00       	call   c0029778 <debug_panic>

  /* Mark us as running. */
  cur->status = THREAD_RUNNING;
c0021297:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002129a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

  /* Start new time slice. */
  thread_ticks = 0;
c00212a1:	c7 05 90 82 03 c0 00 	movl   $0x0,0xc0038290
c00212a8:	00 00 00 
  /* If the thread we switched from is dying, destroy its struct
     thread.  This must happen late so that thread_exit() doesn't
     pull out the rug under itself.  (We don't free
     initial_thread because its memory was not obtained via
     palloc().) */
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c00212ab:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00212af:	74 4c                	je     c00212fd <thread_schedule_tail+0x9e>
c00212b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00212b4:	8b 40 04             	mov    0x4(%eax),%eax
c00212b7:	83 f8 03             	cmp    $0x3,%eax
c00212ba:	75 41                	jne    c00212fd <thread_schedule_tail+0x9e>
c00212bc:	a1 5c 82 03 c0       	mov    0xc003825c,%eax
c00212c1:	39 45 08             	cmp    %eax,0x8(%ebp)
c00212c4:	74 37                	je     c00212fd <thread_schedule_tail+0x9e>
    {
      ASSERT (prev != cur);
c00212c6:	8b 45 08             	mov    0x8(%ebp),%eax
c00212c9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00212cc:	75 21                	jne    c00212ef <thread_schedule_tail+0x90>
c00212ce:	83 ec 0c             	sub    $0xc,%esp
c00212d1:	68 06 ec 02 c0       	push   $0xc002ec06
c00212d6:	68 a2 ea 02 c0       	push   $0xc002eaa2
c00212db:	68 e4 ec 02 c0       	push   $0xc002ece4
c00212e0:	68 4e 02 00 00       	push   $0x24e
c00212e5:	68 b9 ea 02 c0       	push   $0xc002eab9
c00212ea:	e8 89 84 00 00       	call   c0029778 <debug_panic>
      palloc_free_page (prev);
c00212ef:	83 ec 0c             	sub    $0xc,%esp
c00212f2:	ff 75 08             	pushl  0x8(%ebp)
c00212f5:	e8 c5 20 00 00       	call   c00233bf <palloc_free_page>
c00212fa:	83 c4 10             	add    $0x10,%esp
    }
}
c00212fd:	90                   	nop
c00212fe:	c9                   	leave  
c00212ff:	c3                   	ret    

c0021300 <schedule>:

   It's not safe to call printf() until thread_schedule_tail()
   has completed. */
static void
schedule (void) 
{
c0021300:	55                   	push   %ebp
c0021301:	89 e5                	mov    %esp,%ebp
c0021303:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c0021306:	e8 5a fd ff ff       	call   c0021065 <running_thread>
c002130b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct thread *next = next_thread_to_run ();
c002130e:	e8 13 ff ff ff       	call   c0021226 <next_thread_to_run>
c0021313:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread *prev = NULL;
c0021316:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c002131d:	e8 35 01 00 00       	call   c0021457 <intr_get_level>
c0021322:	85 c0                	test   %eax,%eax
c0021324:	74 21                	je     c0021347 <schedule+0x47>
c0021326:	83 ec 0c             	sub    $0xc,%esp
c0021329:	68 84 ea 02 c0       	push   $0xc002ea84
c002132e:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0021333:	68 fc ec 02 c0       	push   $0xc002ecfc
c0021338:	68 61 02 00 00       	push   $0x261
c002133d:	68 b9 ea 02 c0       	push   $0xc002eab9
c0021342:	e8 31 84 00 00       	call   c0029778 <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c0021347:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002134a:	8b 40 04             	mov    0x4(%eax),%eax
c002134d:	85 c0                	test   %eax,%eax
c002134f:	75 21                	jne    c0021372 <schedule+0x72>
c0021351:	83 ec 0c             	sub    $0xc,%esp
c0021354:	68 12 ec 02 c0       	push   $0xc002ec12
c0021359:	68 a2 ea 02 c0       	push   $0xc002eaa2
c002135e:	68 fc ec 02 c0       	push   $0xc002ecfc
c0021363:	68 62 02 00 00       	push   $0x262
c0021368:	68 b9 ea 02 c0       	push   $0xc002eab9
c002136d:	e8 06 84 00 00       	call   c0029778 <debug_panic>
  ASSERT (is_thread (next));
c0021372:	83 ec 0c             	sub    $0xc,%esp
c0021375:	ff 75 ec             	pushl  -0x14(%ebp)
c0021378:	e8 00 fd ff ff       	call   c002107d <is_thread>
c002137d:	83 c4 10             	add    $0x10,%esp
c0021380:	84 c0                	test   %al,%al
c0021382:	75 21                	jne    c00213a5 <schedule+0xa5>
c0021384:	83 ec 0c             	sub    $0xc,%esp
c0021387:	68 30 ec 02 c0       	push   $0xc002ec30
c002138c:	68 a2 ea 02 c0       	push   $0xc002eaa2
c0021391:	68 fc ec 02 c0       	push   $0xc002ecfc
c0021396:	68 63 02 00 00       	push   $0x263
c002139b:	68 b9 ea 02 c0       	push   $0xc002eab9
c00213a0:	e8 d3 83 00 00       	call   c0029778 <debug_panic>

  if (cur != next)
c00213a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00213a8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00213ab:	74 14                	je     c00213c1 <schedule+0xc1>
    prev = switch_threads (cur, next);
c00213ad:	83 ec 08             	sub    $0x8,%esp
c00213b0:	ff 75 ec             	pushl  -0x14(%ebp)
c00213b3:	ff 75 f0             	pushl  -0x10(%ebp)
c00213b6:	e8 53 00 00 00       	call   c002140e <switch_threads>
c00213bb:	83 c4 10             	add    $0x10,%esp
c00213be:	89 45 f4             	mov    %eax,-0xc(%ebp)
  thread_schedule_tail (prev);
c00213c1:	83 ec 0c             	sub    $0xc,%esp
c00213c4:	ff 75 f4             	pushl  -0xc(%ebp)
c00213c7:	e8 93 fe ff ff       	call   c002125f <thread_schedule_tail>
c00213cc:	83 c4 10             	add    $0x10,%esp
}
c00213cf:	90                   	nop
c00213d0:	c9                   	leave  
c00213d1:	c3                   	ret    

c00213d2 <allocate_tid>:

/* Returns a tid to use for a new thread. */
static tid_t
allocate_tid (void) 
{
c00213d2:	55                   	push   %ebp
c00213d3:	89 e5                	mov    %esp,%ebp
c00213d5:	83 ec 18             	sub    $0x18,%esp
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c00213d8:	83 ec 0c             	sub    $0xc,%esp
c00213db:	68 60 82 03 c0       	push   $0xc0038260
c00213e0:	e8 fb 17 00 00       	call   c0022be0 <lock_acquire>
c00213e5:	83 c4 10             	add    $0x10,%esp
  tid = next_tid++;
c00213e8:	a1 88 78 03 c0       	mov    0xc0037888,%eax
c00213ed:	8d 50 01             	lea    0x1(%eax),%edx
c00213f0:	89 15 88 78 03 c0    	mov    %edx,0xc0037888
c00213f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lock_release (&tid_lock);
c00213f9:	83 ec 0c             	sub    $0xc,%esp
c00213fc:	68 60 82 03 c0       	push   $0xc0038260
c0021401:	e8 1b 19 00 00       	call   c0022d21 <lock_release>
c0021406:	83 c4 10             	add    $0x10,%esp

  return tid;
c0021409:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002140c:	c9                   	leave  
c002140d:	c3                   	ret    

c002140e <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c002140e:	53                   	push   %ebx
	pushl %ebp
c002140f:	55                   	push   %ebp
	pushl %esi
c0021410:	56                   	push   %esi
	pushl %edi
c0021411:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c0021412:	8b 15 84 78 03 c0    	mov    0xc0037884,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c0021418:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c002141c:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c002141f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c0021423:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c0021426:	5f                   	pop    %edi
	popl %esi
c0021427:	5e                   	pop    %esi
	popl %ebp
c0021428:	5d                   	pop    %ebp
	popl %ebx
c0021429:	5b                   	pop    %ebx
        ret
c002142a:	c3                   	ret    

c002142b <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c002142b:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c002142e:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c002142f:	e8 2b fe ff ff       	call   c002125f <thread_schedule_tail>
	addl $4, %esp
c0021434:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021437:	c3                   	ret    

c0021438 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0021438:	55                   	push   %ebp
c0021439:	89 e5                	mov    %esp,%ebp
c002143b:	83 ec 08             	sub    $0x8,%esp
c002143e:	8b 55 08             	mov    0x8(%ebp),%edx
c0021441:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021444:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0021448:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002144b:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c002144f:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0021453:	ee                   	out    %al,(%dx)
}
c0021454:	90                   	nop
c0021455:	c9                   	leave  
c0021456:	c3                   	ret    

c0021457 <intr_get_level>:
static void unexpected_interrupt (const struct intr_frame *);

/* Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
c0021457:	55                   	push   %ebp
c0021458:	89 e5                	mov    %esp,%ebp
c002145a:	83 ec 10             	sub    $0x10,%esp

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c002145d:	9c                   	pushf  
c002145e:	58                   	pop    %eax
c002145f:	89 45 fc             	mov    %eax,-0x4(%ebp)

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021462:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0021465:	25 00 02 00 00       	and    $0x200,%eax
c002146a:	85 c0                	test   %eax,%eax
c002146c:	0f 95 c0             	setne  %al
c002146f:	0f b6 c0             	movzbl %al,%eax
}
c0021472:	c9                   	leave  
c0021473:	c3                   	ret    

c0021474 <intr_set_level>:

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
c0021474:	55                   	push   %ebp
c0021475:	89 e5                	mov    %esp,%ebp
c0021477:	83 ec 08             	sub    $0x8,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c002147a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c002147e:	75 07                	jne    c0021487 <intr_set_level+0x13>
c0021480:	e8 09 00 00 00       	call   c002148e <intr_enable>
c0021485:	eb 05                	jmp    c002148c <intr_set_level+0x18>
c0021487:	e8 40 00 00 00       	call   c00214cc <intr_disable>
}
c002148c:	c9                   	leave  
c002148d:	c3                   	ret    

c002148e <intr_enable>:

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
c002148e:	55                   	push   %ebp
c002148f:	89 e5                	mov    %esp,%ebp
c0021491:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_get_level ();
c0021494:	e8 be ff ff ff       	call   c0021457 <intr_get_level>
c0021499:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (!intr_context ());
c002149c:	e8 fa 02 00 00       	call   c002179b <intr_context>
c00214a1:	83 f0 01             	xor    $0x1,%eax
c00214a4:	84 c0                	test   %al,%al
c00214a6:	75 1e                	jne    c00214c6 <intr_enable+0x38>
c00214a8:	83 ec 0c             	sub    $0xc,%esp
c00214ab:	68 08 ed 02 c0       	push   $0xc002ed08
c00214b0:	68 19 ed 02 c0       	push   $0xc002ed19
c00214b5:	68 18 f1 02 c0       	push   $0xc002f118
c00214ba:	6a 5b                	push   $0x5b
c00214bc:	68 30 ed 02 c0       	push   $0xc002ed30
c00214c1:	e8 b2 82 00 00       	call   c0029778 <debug_panic>

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti");
c00214c6:	fb                   	sti    

  return old_level;
c00214c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00214ca:	c9                   	leave  
c00214cb:	c3                   	ret    

c00214cc <intr_disable>:

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
c00214cc:	55                   	push   %ebp
c00214cd:	89 e5                	mov    %esp,%ebp
c00214cf:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level = intr_get_level ();
c00214d2:	e8 80 ff ff ff       	call   c0021457 <intr_get_level>
c00214d7:	89 45 fc             	mov    %eax,-0x4(%ebp)

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
c00214da:	fa                   	cli    

  return old_level;
c00214db:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00214de:	c9                   	leave  
c00214df:	c3                   	ret    

c00214e0 <intr_init>:

/* Initializes the interrupt system. */
void
intr_init (void)
{
c00214e0:	55                   	push   %ebp
c00214e1:	89 e5                	mov    %esp,%ebp
c00214e3:	83 ec 18             	sub    $0x18,%esp
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init ();
c00214e6:	e8 f6 02 00 00       	call   c00217e1 <pic_init>

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c00214eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00214f2:	eb 2d                	jmp    c0021521 <intr_init+0x41>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c00214f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00214f7:	8b 04 85 8c 78 03 c0 	mov    -0x3ffc8774(,%eax,4),%eax
c00214fe:	83 ec 08             	sub    $0x8,%esp
c0021501:	6a 00                	push   $0x0
c0021503:	50                   	push   %eax
c0021504:	e8 d1 04 00 00       	call   c00219da <make_intr_gate>
c0021509:	83 c4 10             	add    $0x10,%esp
c002150c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c002150f:	89 04 cd a0 82 03 c0 	mov    %eax,-0x3ffc7d60(,%ecx,8)
c0021516:	89 14 cd a4 82 03 c0 	mov    %edx,-0x3ffc7d5c(,%ecx,8)

  /* Initialize interrupt controller. */
  pic_init ();

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c002151d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0021521:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c0021528:	7e ca                	jle    c00214f4 <intr_init+0x14>
    idt[i] = make_intr_gate (intr_stubs[i], 0);

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
c002152a:	83 ec 08             	sub    $0x8,%esp
c002152d:	68 a0 82 03 c0       	push   $0xc00382a0
c0021532:	68 ff 07 00 00       	push   $0x7ff
c0021537:	e8 d4 04 00 00       	call   c0021a10 <make_idtr_operand>
c002153c:	83 c4 10             	add    $0x10,%esp
c002153f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0021542:	89 55 ec             	mov    %edx,-0x14(%ebp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021545:	0f 01 5d e8          	lidtl  -0x18(%ebp)

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c0021549:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0021550:	eb 12                	jmp    c0021564 <intr_init+0x84>
    intr_names[i] = "unknown";
c0021552:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021555:	c7 04 85 a0 8e 03 c0 	movl   $0xc002ed4a,-0x3ffc7160(,%eax,4)
c002155c:	4a ed 02 c0 
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
  asm volatile ("lidt %0" : : "m" (idtr_operand));

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c0021560:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0021564:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c002156b:	7e e5                	jle    c0021552 <intr_init+0x72>
    intr_names[i] = "unknown";
  intr_names[0] = "#DE Divide Error";
c002156d:	c7 05 a0 8e 03 c0 52 	movl   $0xc002ed52,0xc0038ea0
c0021574:	ed 02 c0 
  intr_names[1] = "#DB Debug Exception";
c0021577:	c7 05 a4 8e 03 c0 63 	movl   $0xc002ed63,0xc0038ea4
c002157e:	ed 02 c0 
  intr_names[2] = "NMI Interrupt";
c0021581:	c7 05 a8 8e 03 c0 77 	movl   $0xc002ed77,0xc0038ea8
c0021588:	ed 02 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c002158b:	c7 05 ac 8e 03 c0 85 	movl   $0xc002ed85,0xc0038eac
c0021592:	ed 02 c0 
  intr_names[4] = "#OF Overflow Exception";
c0021595:	c7 05 b0 8e 03 c0 9e 	movl   $0xc002ed9e,0xc0038eb0
c002159c:	ed 02 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c002159f:	c7 05 b4 8e 03 c0 b8 	movl   $0xc002edb8,0xc0038eb4
c00215a6:	ed 02 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c00215a9:	c7 05 b8 8e 03 c0 db 	movl   $0xc002eddb,0xc0038eb8
c00215b0:	ed 02 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c00215b3:	c7 05 bc 8e 03 c0 f8 	movl   $0xc002edf8,0xc0038ebc
c00215ba:	ed 02 c0 
  intr_names[8] = "#DF Double Fault Exception";
c00215bd:	c7 05 c0 8e 03 c0 1b 	movl   $0xc002ee1b,0xc0038ec0
c00215c4:	ee 02 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c00215c7:	c7 05 c4 8e 03 c0 36 	movl   $0xc002ee36,0xc0038ec4
c00215ce:	ee 02 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c00215d1:	c7 05 c8 8e 03 c0 52 	movl   $0xc002ee52,0xc0038ec8
c00215d8:	ee 02 c0 
  intr_names[11] = "#NP Segment Not Present";
c00215db:	c7 05 cc 8e 03 c0 6c 	movl   $0xc002ee6c,0xc0038ecc
c00215e2:	ee 02 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c00215e5:	c7 05 d0 8e 03 c0 84 	movl   $0xc002ee84,0xc0038ed0
c00215ec:	ee 02 c0 
  intr_names[13] = "#GP General Protection Exception";
c00215ef:	c7 05 d4 8e 03 c0 a0 	movl   $0xc002eea0,0xc0038ed4
c00215f6:	ee 02 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c00215f9:	c7 05 d8 8e 03 c0 c1 	movl   $0xc002eec1,0xc0038ed8
c0021600:	ee 02 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021603:	c7 05 e0 8e 03 c0 dc 	movl   $0xc002eedc,0xc0038ee0
c002160a:	ee 02 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c002160d:	c7 05 e4 8e 03 c0 fd 	movl   $0xc002eefd,0xc0038ee4
c0021614:	ee 02 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c0021617:	c7 05 e8 8e 03 c0 1b 	movl   $0xc002ef1b,0xc0038ee8
c002161e:	ef 02 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021621:	c7 05 ec 8e 03 c0 38 	movl   $0xc002ef38,0xc0038eec
c0021628:	ef 02 c0 
}
c002162b:	90                   	nop
c002162c:	c9                   	leave  
c002162d:	c3                   	ret    

c002162e <register_handler>:
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
c002162e:	55                   	push   %ebp
c002162f:	89 e5                	mov    %esp,%ebp
c0021631:	53                   	push   %ebx
c0021632:	83 ec 14             	sub    $0x14,%esp
c0021635:	8b 45 08             	mov    0x8(%ebp),%eax
c0021638:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_handlers[vec_no] == NULL);
c002163b:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002163f:	8b 04 85 a0 8a 03 c0 	mov    -0x3ffc7560(,%eax,4),%eax
c0021646:	85 c0                	test   %eax,%eax
c0021648:	74 21                	je     c002166b <register_handler+0x3d>
c002164a:	83 ec 0c             	sub    $0xc,%esp
c002164d:	68 5a ef 02 c0       	push   $0xc002ef5a
c0021652:	68 19 ed 02 c0       	push   $0xc002ed19
c0021657:	68 24 f1 02 c0       	push   $0xc002f124
c002165c:	68 a8 00 00 00       	push   $0xa8
c0021661:	68 30 ed 02 c0       	push   $0xc002ed30
c0021666:	e8 0d 81 00 00       	call   c0029778 <debug_panic>
  if (level == INTR_ON)
c002166b:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c002166f:	75 2e                	jne    c002169f <register_handler+0x71>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021671:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0021675:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021679:	8b 04 85 8c 78 03 c0 	mov    -0x3ffc8774(,%eax,4),%eax
c0021680:	83 ec 08             	sub    $0x8,%esp
c0021683:	ff 75 0c             	pushl  0xc(%ebp)
c0021686:	50                   	push   %eax
c0021687:	e8 69 03 00 00       	call   c00219f5 <make_trap_gate>
c002168c:	83 c4 10             	add    $0x10,%esp
c002168f:	89 04 dd a0 82 03 c0 	mov    %eax,-0x3ffc7d60(,%ebx,8)
c0021696:	89 14 dd a4 82 03 c0 	mov    %edx,-0x3ffc7d5c(,%ebx,8)
c002169d:	eb 2c                	jmp    c00216cb <register_handler+0x9d>
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c002169f:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c00216a3:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00216a7:	8b 04 85 8c 78 03 c0 	mov    -0x3ffc8774(,%eax,4),%eax
c00216ae:	83 ec 08             	sub    $0x8,%esp
c00216b1:	ff 75 0c             	pushl  0xc(%ebp)
c00216b4:	50                   	push   %eax
c00216b5:	e8 20 03 00 00       	call   c00219da <make_intr_gate>
c00216ba:	83 c4 10             	add    $0x10,%esp
c00216bd:	89 04 dd a0 82 03 c0 	mov    %eax,-0x3ffc7d60(,%ebx,8)
c00216c4:	89 14 dd a4 82 03 c0 	mov    %edx,-0x3ffc7d5c(,%ebx,8)
  intr_handlers[vec_no] = handler;
c00216cb:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00216cf:	8b 55 14             	mov    0x14(%ebp),%edx
c00216d2:	89 14 85 a0 8a 03 c0 	mov    %edx,-0x3ffc7560(,%eax,4)
  intr_names[vec_no] = name;
c00216d9:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00216dd:	8b 55 18             	mov    0x18(%ebp),%edx
c00216e0:	89 14 85 a0 8e 03 c0 	mov    %edx,-0x3ffc7160(,%eax,4)
}
c00216e7:	90                   	nop
c00216e8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00216eb:	c9                   	leave  
c00216ec:	c3                   	ret    

c00216ed <intr_register_ext>:
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
c00216ed:	55                   	push   %ebp
c00216ee:	89 e5                	mov    %esp,%ebp
c00216f0:	83 ec 18             	sub    $0x18,%esp
c00216f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00216f6:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c00216f9:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c00216fd:	76 06                	jbe    c0021705 <intr_register_ext+0x18>
c00216ff:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c0021703:	76 21                	jbe    c0021726 <intr_register_ext+0x39>
c0021705:	83 ec 0c             	sub    $0xc,%esp
c0021708:	68 78 ef 02 c0       	push   $0xc002ef78
c002170d:	68 19 ed 02 c0       	push   $0xc002ed19
c0021712:	68 38 f1 02 c0       	push   $0xc002f138
c0021717:	68 b8 00 00 00       	push   $0xb8
c002171c:	68 30 ed 02 c0       	push   $0xc002ed30
c0021721:	e8 52 80 00 00       	call   c0029778 <debug_panic>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c0021726:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002172a:	83 ec 0c             	sub    $0xc,%esp
c002172d:	ff 75 10             	pushl  0x10(%ebp)
c0021730:	ff 75 0c             	pushl  0xc(%ebp)
c0021733:	6a 00                	push   $0x0
c0021735:	6a 00                	push   $0x0
c0021737:	50                   	push   %eax
c0021738:	e8 f1 fe ff ff       	call   c002162e <register_handler>
c002173d:	83 c4 20             	add    $0x20,%esp
}
c0021740:	90                   	nop
c0021741:	c9                   	leave  
c0021742:	c3                   	ret    

c0021743 <intr_register_int>:
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
c0021743:	55                   	push   %ebp
c0021744:	89 e5                	mov    %esp,%ebp
c0021746:	83 ec 18             	sub    $0x18,%esp
c0021749:	8b 45 08             	mov    0x8(%ebp),%eax
c002174c:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c002174f:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0021753:	76 27                	jbe    c002177c <intr_register_int+0x39>
c0021755:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c0021759:	77 21                	ja     c002177c <intr_register_int+0x39>
c002175b:	83 ec 0c             	sub    $0xc,%esp
c002175e:	68 9c ef 02 c0       	push   $0xc002ef9c
c0021763:	68 19 ed 02 c0       	push   $0xc002ed19
c0021768:	68 4c f1 02 c0       	push   $0xc002f14c
c002176d:	68 cd 00 00 00       	push   $0xcd
c0021772:	68 30 ed 02 c0       	push   $0xc002ed30
c0021777:	e8 fc 7f 00 00       	call   c0029778 <debug_panic>
  register_handler (vec_no, dpl, level, handler, name);
c002177c:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021780:	83 ec 0c             	sub    $0xc,%esp
c0021783:	ff 75 18             	pushl  0x18(%ebp)
c0021786:	ff 75 14             	pushl  0x14(%ebp)
c0021789:	ff 75 10             	pushl  0x10(%ebp)
c002178c:	ff 75 0c             	pushl  0xc(%ebp)
c002178f:	50                   	push   %eax
c0021790:	e8 99 fe ff ff       	call   c002162e <register_handler>
c0021795:	83 c4 20             	add    $0x20,%esp
}
c0021798:	90                   	nop
c0021799:	c9                   	leave  
c002179a:	c3                   	ret    

c002179b <intr_context>:

/* Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
c002179b:	55                   	push   %ebp
c002179c:	89 e5                	mov    %esp,%ebp
  return in_external_intr;
c002179e:	0f b6 05 a0 96 03 c0 	movzbl 0xc00396a0,%eax
}
c00217a5:	5d                   	pop    %ebp
c00217a6:	c3                   	ret    

c00217a7 <intr_yield_on_return>:
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
c00217a7:	55                   	push   %ebp
c00217a8:	89 e5                	mov    %esp,%ebp
c00217aa:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_context ());
c00217ad:	e8 e9 ff ff ff       	call   c002179b <intr_context>
c00217b2:	84 c0                	test   %al,%al
c00217b4:	75 21                	jne    c00217d7 <intr_yield_on_return+0x30>
c00217b6:	83 ec 0c             	sub    $0xc,%esp
c00217b9:	68 bb ef 02 c0       	push   $0xc002efbb
c00217be:	68 19 ed 02 c0       	push   $0xc002ed19
c00217c3:	68 60 f1 02 c0       	push   $0xc002f160
c00217c8:	68 e0 00 00 00       	push   $0xe0
c00217cd:	68 30 ed 02 c0       	push   $0xc002ed30
c00217d2:	e8 a1 7f 00 00       	call   c0029778 <debug_panic>
  yield_on_return = true;
c00217d7:	c6 05 a1 96 03 c0 01 	movb   $0x1,0xc00396a1
}
c00217de:	90                   	nop
c00217df:	c9                   	leave  
c00217e0:	c3                   	ret    

c00217e1 <pic_init>:
   traps and exceptions, so we reprogram the PICs so that
   interrupts 0...15 are delivered to interrupt vectors 32...47
   (0x20...0x2f) instead. */
static void
pic_init (void)
{
c00217e1:	55                   	push   %ebp
c00217e2:	89 e5                	mov    %esp,%ebp
  /* Mask all interrupts on both PICs. */
  outb (PIC0_DATA, 0xff);
c00217e4:	68 ff 00 00 00       	push   $0xff
c00217e9:	6a 21                	push   $0x21
c00217eb:	e8 48 fc ff ff       	call   c0021438 <outb>
c00217f0:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0xff);
c00217f3:	68 ff 00 00 00       	push   $0xff
c00217f8:	68 a1 00 00 00       	push   $0xa1
c00217fd:	e8 36 fc ff ff       	call   c0021438 <outb>
c0021802:	83 c4 08             	add    $0x8,%esp

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021805:	6a 11                	push   $0x11
c0021807:	6a 20                	push   $0x20
c0021809:	e8 2a fc ff ff       	call   c0021438 <outb>
c002180e:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
c0021811:	6a 20                	push   $0x20
c0021813:	6a 21                	push   $0x21
c0021815:	e8 1e fc ff ff       	call   c0021438 <outb>
c002181a:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
c002181d:	6a 04                	push   $0x4
c002181f:	6a 21                	push   $0x21
c0021821:	e8 12 fc ff ff       	call   c0021438 <outb>
c0021826:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c0021829:	6a 01                	push   $0x1
c002182b:	6a 21                	push   $0x21
c002182d:	e8 06 fc ff ff       	call   c0021438 <outb>
c0021832:	83 c4 08             	add    $0x8,%esp

  /* Initialize slave. */
  outb (PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021835:	6a 11                	push   $0x11
c0021837:	68 a0 00 00 00       	push   $0xa0
c002183c:	e8 f7 fb ff ff       	call   c0021438 <outb>
c0021841:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
c0021844:	6a 28                	push   $0x28
c0021846:	68 a1 00 00 00       	push   $0xa1
c002184b:	e8 e8 fb ff ff       	call   c0021438 <outb>
c0021850:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */
c0021853:	6a 02                	push   $0x2
c0021855:	68 a1 00 00 00       	push   $0xa1
c002185a:	e8 d9 fb ff ff       	call   c0021438 <outb>
c002185f:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c0021862:	6a 01                	push   $0x1
c0021864:	68 a1 00 00 00       	push   $0xa1
c0021869:	e8 ca fb ff ff       	call   c0021438 <outb>
c002186e:	83 c4 08             	add    $0x8,%esp

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
c0021871:	6a 00                	push   $0x0
c0021873:	6a 21                	push   $0x21
c0021875:	e8 be fb ff ff       	call   c0021438 <outb>
c002187a:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x00);
c002187d:	6a 00                	push   $0x0
c002187f:	68 a1 00 00 00       	push   $0xa1
c0021884:	e8 af fb ff ff       	call   c0021438 <outb>
c0021889:	83 c4 08             	add    $0x8,%esp
}
c002188c:	90                   	nop
c002188d:	c9                   	leave  
c002188e:	c3                   	ret    

c002188f <pic_end_of_interrupt>:
/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
c002188f:	55                   	push   %ebp
c0021890:	89 e5                	mov    %esp,%ebp
c0021892:	83 ec 08             	sub    $0x8,%esp
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021895:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0021899:	7e 06                	jle    c00218a1 <pic_end_of_interrupt+0x12>
c002189b:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c002189f:	7e 21                	jle    c00218c2 <pic_end_of_interrupt+0x33>
c00218a1:	83 ec 0c             	sub    $0xc,%esp
c00218a4:	68 cb ef 02 c0       	push   $0xc002efcb
c00218a9:	68 19 ed 02 c0       	push   $0xc002ed19
c00218ae:	68 78 f1 02 c0       	push   $0xc002f178
c00218b3:	68 0b 01 00 00       	push   $0x10b
c00218b8:	68 30 ed 02 c0       	push   $0xc002ed30
c00218bd:	e8 b6 7e 00 00       	call   c0029778 <debug_panic>

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);
c00218c2:	83 ec 08             	sub    $0x8,%esp
c00218c5:	6a 20                	push   $0x20
c00218c7:	6a 20                	push   $0x20
c00218c9:	e8 6a fb ff ff       	call   c0021438 <outb>
c00218ce:	83 c4 10             	add    $0x10,%esp

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
c00218d1:	83 7d 08 27          	cmpl   $0x27,0x8(%ebp)
c00218d5:	7e 12                	jle    c00218e9 <pic_end_of_interrupt+0x5a>
    outb (0xa0, 0x20);
c00218d7:	83 ec 08             	sub    $0x8,%esp
c00218da:	6a 20                	push   $0x20
c00218dc:	68 a0 00 00 00       	push   $0xa0
c00218e1:	e8 52 fb ff ff       	call   c0021438 <outb>
c00218e6:	83 c4 10             	add    $0x10,%esp
}
c00218e9:	90                   	nop
c00218ea:	c9                   	leave  
c00218eb:	c3                   	ret    

c00218ec <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c00218ec:	55                   	push   %ebp
c00218ed:	89 e5                	mov    %esp,%ebp
c00218ef:	57                   	push   %edi
c00218f0:	56                   	push   %esi
c00218f1:	53                   	push   %ebx
c00218f2:	83 ec 2c             	sub    $0x2c,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c00218f5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00218f9:	75 21                	jne    c002191c <make_gate+0x30>
c00218fb:	83 ec 0c             	sub    $0xc,%esp
c00218fe:	68 e5 ef 02 c0       	push   $0xc002efe5
c0021903:	68 19 ed 02 c0       	push   $0xc002ed19
c0021908:	68 90 f1 02 c0       	push   $0xc002f190
c002190d:	68 2a 01 00 00       	push   $0x12a
c0021912:	68 30 ed 02 c0       	push   $0xc002ed30
c0021917:	e8 5c 7e 00 00       	call   c0029778 <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c002191c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0021920:	78 06                	js     c0021928 <make_gate+0x3c>
c0021922:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0021926:	7e 21                	jle    c0021949 <make_gate+0x5d>
c0021928:	83 ec 0c             	sub    $0xc,%esp
c002192b:	68 f6 ef 02 c0       	push   $0xc002eff6
c0021930:	68 19 ed 02 c0       	push   $0xc002ed19
c0021935:	68 90 f1 02 c0       	push   $0xc002f190
c002193a:	68 2b 01 00 00       	push   $0x12b
c002193f:	68 30 ed 02 c0       	push   $0xc002ed30
c0021944:	e8 2f 7e 00 00       	call   c0029778 <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021949:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002194d:	78 06                	js     c0021955 <make_gate+0x69>
c002194f:	83 7d 10 0f          	cmpl   $0xf,0x10(%ebp)
c0021953:	7e 21                	jle    c0021976 <make_gate+0x8a>
c0021955:	83 ec 0c             	sub    $0xc,%esp
c0021958:	68 0b f0 02 c0       	push   $0xc002f00b
c002195d:	68 19 ed 02 c0       	push   $0xc002ed19
c0021962:	68 90 f1 02 c0       	push   $0xc002f190
c0021967:	68 2c 01 00 00       	push   $0x12c
c002196c:	68 30 ed 02 c0       	push   $0xc002ed30
c0021971:	e8 02 7e 00 00       	call   c0029778 <debug_panic>

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c0021976:	8b 45 08             	mov    0x8(%ebp),%eax
c0021979:	0f b7 c0             	movzwl %ax,%eax
c002197c:	0d 00 00 08 00       	or     $0x80000,%eax
c0021981:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021984:	8b 45 08             	mov    0x8(%ebp),%eax
c0021987:	66 b8 00 00          	mov    $0x0,%ax
c002198b:	89 c2                	mov    %eax,%edx
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c002198d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021990:	c1 e0 0d             	shl    $0xd,%eax
c0021993:	09 c2                	or     %eax,%edx
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c0021995:	8b 45 10             	mov    0x10(%ebp),%eax
c0021998:	c1 e0 08             	shl    $0x8,%eax
c002199b:	09 d0                	or     %edx,%eax
  ASSERT (type >= 0 && type <= 15);

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c002199d:	80 cc 80             	or     $0x80,%ah
c00219a0:	89 45 e0             	mov    %eax,-0x20(%ebp)
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */

  return e0 | ((uint64_t) e1 << 32);
c00219a3:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c00219a6:	bf 00 00 00 00       	mov    $0x0,%edi
c00219ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00219ae:	ba 00 00 00 00       	mov    $0x0,%edx
c00219b3:	89 c2                	mov    %eax,%edx
c00219b5:	b8 00 00 00 00       	mov    $0x0,%eax
c00219ba:	89 45 d0             	mov    %eax,-0x30(%ebp)
c00219bd:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c00219c0:	89 f0                	mov    %esi,%eax
c00219c2:	0b 45 d0             	or     -0x30(%ebp),%eax
c00219c5:	89 c1                	mov    %eax,%ecx
c00219c7:	89 f8                	mov    %edi,%eax
c00219c9:	0b 45 d4             	or     -0x2c(%ebp),%eax
c00219cc:	89 c3                	mov    %eax,%ebx
c00219ce:	89 c8                	mov    %ecx,%eax
c00219d0:	89 da                	mov    %ebx,%edx
}
c00219d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00219d5:	5b                   	pop    %ebx
c00219d6:	5e                   	pop    %esi
c00219d7:	5f                   	pop    %edi
c00219d8:	5d                   	pop    %ebp
c00219d9:	c3                   	ret    

c00219da <make_intr_gate>:

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
c00219da:	55                   	push   %ebp
c00219db:	89 e5                	mov    %esp,%ebp
c00219dd:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 14);
c00219e0:	83 ec 04             	sub    $0x4,%esp
c00219e3:	6a 0e                	push   $0xe
c00219e5:	ff 75 0c             	pushl  0xc(%ebp)
c00219e8:	ff 75 08             	pushl  0x8(%ebp)
c00219eb:	e8 fc fe ff ff       	call   c00218ec <make_gate>
c00219f0:	83 c4 10             	add    $0x10,%esp
}
c00219f3:	c9                   	leave  
c00219f4:	c3                   	ret    

c00219f5 <make_trap_gate>:

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
c00219f5:	55                   	push   %ebp
c00219f6:	89 e5                	mov    %esp,%ebp
c00219f8:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 15);
c00219fb:	83 ec 04             	sub    $0x4,%esp
c00219fe:	6a 0f                	push   $0xf
c0021a00:	ff 75 0c             	pushl  0xc(%ebp)
c0021a03:	ff 75 08             	pushl  0x8(%ebp)
c0021a06:	e8 e1 fe ff ff       	call   c00218ec <make_gate>
c0021a0b:	83 c4 10             	add    $0x10,%esp
}
c0021a0e:	c9                   	leave  
c0021a0f:	c3                   	ret    

c0021a10 <make_idtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
c0021a10:	55                   	push   %ebp
c0021a11:	89 e5                	mov    %esp,%ebp
c0021a13:	57                   	push   %edi
c0021a14:	56                   	push   %esi
c0021a15:	53                   	push   %ebx
c0021a16:	83 ec 14             	sub    $0x14,%esp
c0021a19:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a1c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c0021a20:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0021a24:	89 c6                	mov    %eax,%esi
c0021a26:	bf 00 00 00 00       	mov    $0x0,%edi
c0021a2b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021a2e:	ba 00 00 00 00       	mov    $0x0,%edx
c0021a33:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021a37:	c1 e0 10             	shl    $0x10,%eax
c0021a3a:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0021a3d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0021a40:	89 f0                	mov    %esi,%eax
c0021a42:	0b 45 e0             	or     -0x20(%ebp),%eax
c0021a45:	89 c1                	mov    %eax,%ecx
c0021a47:	89 f8                	mov    %edi,%eax
c0021a49:	0b 45 e4             	or     -0x1c(%ebp),%eax
c0021a4c:	89 c3                	mov    %eax,%ebx
c0021a4e:	89 c8                	mov    %ecx,%eax
c0021a50:	89 da                	mov    %ebx,%edx
}
c0021a52:	83 c4 14             	add    $0x14,%esp
c0021a55:	5b                   	pop    %ebx
c0021a56:	5e                   	pop    %esi
c0021a57:	5f                   	pop    %edi
c0021a58:	5d                   	pop    %ebp
c0021a59:	c3                   	ret    

c0021a5a <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021a5a:	55                   	push   %ebp
c0021a5b:	89 e5                	mov    %esp,%ebp
c0021a5d:	83 ec 18             	sub    $0x18,%esp

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021a60:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a63:	8b 40 30             	mov    0x30(%eax),%eax
c0021a66:	83 f8 1f             	cmp    $0x1f,%eax
c0021a69:	76 12                	jbe    c0021a7d <intr_handler+0x23>
c0021a6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a6e:	8b 40 30             	mov    0x30(%eax),%eax
c0021a71:	83 f8 2f             	cmp    $0x2f,%eax
c0021a74:	77 07                	ja     c0021a7d <intr_handler+0x23>
c0021a76:	b8 01 00 00 00       	mov    $0x1,%eax
c0021a7b:	eb 05                	jmp    c0021a82 <intr_handler+0x28>
c0021a7d:	b8 00 00 00 00       	mov    $0x0,%eax
c0021a82:	88 45 f7             	mov    %al,-0x9(%ebp)
c0021a85:	80 65 f7 01          	andb   $0x1,-0x9(%ebp)
  if (external) 
c0021a89:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021a8d:	74 65                	je     c0021af4 <intr_handler+0x9a>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021a8f:	e8 c3 f9 ff ff       	call   c0021457 <intr_get_level>
c0021a94:	85 c0                	test   %eax,%eax
c0021a96:	74 21                	je     c0021ab9 <intr_handler+0x5f>
c0021a98:	83 ec 0c             	sub    $0xc,%esp
c0021a9b:	68 23 f0 02 c0       	push   $0xc002f023
c0021aa0:	68 19 ed 02 c0       	push   $0xc002ed19
c0021aa5:	68 9c f1 02 c0       	push   $0xc002f19c
c0021aaa:	68 65 01 00 00       	push   $0x165
c0021aaf:	68 30 ed 02 c0       	push   $0xc002ed30
c0021ab4:	e8 bf 7c 00 00       	call   c0029778 <debug_panic>
      ASSERT (!intr_context ());
c0021ab9:	e8 dd fc ff ff       	call   c002179b <intr_context>
c0021abe:	83 f0 01             	xor    $0x1,%eax
c0021ac1:	84 c0                	test   %al,%al
c0021ac3:	75 21                	jne    c0021ae6 <intr_handler+0x8c>
c0021ac5:	83 ec 0c             	sub    $0xc,%esp
c0021ac8:	68 08 ed 02 c0       	push   $0xc002ed08
c0021acd:	68 19 ed 02 c0       	push   $0xc002ed19
c0021ad2:	68 9c f1 02 c0       	push   $0xc002f19c
c0021ad7:	68 66 01 00 00       	push   $0x166
c0021adc:	68 30 ed 02 c0       	push   $0xc002ed30
c0021ae1:	e8 92 7c 00 00       	call   c0029778 <debug_panic>

      in_external_intr = true;
c0021ae6:	c6 05 a0 96 03 c0 01 	movb   $0x1,0xc00396a0
      yield_on_return = false;
c0021aed:	c6 05 a1 96 03 c0 00 	movb   $0x0,0xc00396a1
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c0021af4:	8b 45 08             	mov    0x8(%ebp),%eax
c0021af7:	8b 40 30             	mov    0x30(%eax),%eax
c0021afa:	8b 04 85 a0 8a 03 c0 	mov    -0x3ffc7560(,%eax,4),%eax
c0021b01:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (handler != NULL)
c0021b04:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0021b08:	74 10                	je     c0021b1a <intr_handler+0xc0>
    handler (frame);
c0021b0a:	83 ec 0c             	sub    $0xc,%esp
c0021b0d:	ff 75 08             	pushl  0x8(%ebp)
c0021b10:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021b13:	ff d0                	call   *%eax
c0021b15:	83 c4 10             	add    $0x10,%esp
c0021b18:	eb 24                	jmp    c0021b3e <intr_handler+0xe4>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c0021b1a:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b1d:	8b 40 30             	mov    0x30(%eax),%eax
c0021b20:	83 f8 27             	cmp    $0x27,%eax
c0021b23:	74 19                	je     c0021b3e <intr_handler+0xe4>
c0021b25:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b28:	8b 40 30             	mov    0x30(%eax),%eax
c0021b2b:	83 f8 2f             	cmp    $0x2f,%eax
c0021b2e:	74 0e                	je     c0021b3e <intr_handler+0xe4>
      /* There is no handler, but this interrupt can trigger
         spuriously due to a hardware fault or hardware race
         condition.  Ignore it. */
    }
  else
    unexpected_interrupt (frame);
c0021b30:	83 ec 0c             	sub    $0xc,%esp
c0021b33:	ff 75 08             	pushl  0x8(%ebp)
c0021b36:	e8 89 00 00 00       	call   c0021bc4 <unexpected_interrupt>
c0021b3b:	83 c4 10             	add    $0x10,%esp

  /* Complete the processing of an external interrupt. */
  if (external) 
c0021b3e:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021b42:	74 7d                	je     c0021bc1 <intr_handler+0x167>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021b44:	e8 0e f9 ff ff       	call   c0021457 <intr_get_level>
c0021b49:	85 c0                	test   %eax,%eax
c0021b4b:	74 21                	je     c0021b6e <intr_handler+0x114>
c0021b4d:	83 ec 0c             	sub    $0xc,%esp
c0021b50:	68 23 f0 02 c0       	push   $0xc002f023
c0021b55:	68 19 ed 02 c0       	push   $0xc002ed19
c0021b5a:	68 9c f1 02 c0       	push   $0xc002f19c
c0021b5f:	68 7c 01 00 00       	push   $0x17c
c0021b64:	68 30 ed 02 c0       	push   $0xc002ed30
c0021b69:	e8 0a 7c 00 00       	call   c0029778 <debug_panic>
      ASSERT (intr_context ());
c0021b6e:	e8 28 fc ff ff       	call   c002179b <intr_context>
c0021b73:	84 c0                	test   %al,%al
c0021b75:	75 21                	jne    c0021b98 <intr_handler+0x13e>
c0021b77:	83 ec 0c             	sub    $0xc,%esp
c0021b7a:	68 bb ef 02 c0       	push   $0xc002efbb
c0021b7f:	68 19 ed 02 c0       	push   $0xc002ed19
c0021b84:	68 9c f1 02 c0       	push   $0xc002f19c
c0021b89:	68 7d 01 00 00       	push   $0x17d
c0021b8e:	68 30 ed 02 c0       	push   $0xc002ed30
c0021b93:	e8 e0 7b 00 00       	call   c0029778 <debug_panic>

      in_external_intr = false;
c0021b98:	c6 05 a0 96 03 c0 00 	movb   $0x0,0xc00396a0
      pic_end_of_interrupt (frame->vec_no); 
c0021b9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ba2:	8b 40 30             	mov    0x30(%eax),%eax
c0021ba5:	83 ec 0c             	sub    $0xc,%esp
c0021ba8:	50                   	push   %eax
c0021ba9:	e8 e1 fc ff ff       	call   c002188f <pic_end_of_interrupt>
c0021bae:	83 c4 10             	add    $0x10,%esp

      if (yield_on_return) 
c0021bb1:	0f b6 05 a1 96 03 c0 	movzbl 0xc00396a1,%eax
c0021bb8:	84 c0                	test   %al,%al
c0021bba:	74 05                	je     c0021bc1 <intr_handler+0x167>
        thread_yield (); 
c0021bbc:	e8 d4 f2 ff ff       	call   c0020e95 <thread_yield>
    }
}
c0021bc1:	90                   	nop
c0021bc2:	c9                   	leave  
c0021bc3:	c3                   	ret    

c0021bc4 <unexpected_interrupt>:

/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
c0021bc4:	55                   	push   %ebp
c0021bc5:	89 e5                	mov    %esp,%ebp
c0021bc7:	83 ec 18             	sub    $0x18,%esp
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0021bca:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bcd:	8b 40 30             	mov    0x30(%eax),%eax
c0021bd0:	8b 14 85 a0 92 03 c0 	mov    -0x3ffc6d60(,%eax,4),%edx
c0021bd7:	83 c2 01             	add    $0x1,%edx
c0021bda:	89 14 85 a0 92 03 c0 	mov    %edx,-0x3ffc6d60(,%eax,4)
c0021be1:	8b 04 85 a0 92 03 c0 	mov    -0x3ffc6d60(,%eax,4),%eax
c0021be8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0021beb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021bee:	83 e8 01             	sub    $0x1,%eax
c0021bf1:	23 45 f4             	and    -0xc(%ebp),%eax
c0021bf4:	85 c0                	test   %eax,%eax
c0021bf6:	75 25                	jne    c0021c1d <unexpected_interrupt+0x59>
    printf ("Unexpected interrupt %#04x (%s)\n",
    f->vec_no, intr_names[f->vec_no]);
c0021bf8:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bfb:	8b 40 30             	mov    0x30(%eax),%eax
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
    printf ("Unexpected interrupt %#04x (%s)\n",
c0021bfe:	8b 14 85 a0 8e 03 c0 	mov    -0x3ffc7160(,%eax,4),%edx
c0021c05:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c08:	8b 40 30             	mov    0x30(%eax),%eax
c0021c0b:	83 ec 04             	sub    $0x4,%esp
c0021c0e:	52                   	push   %edx
c0021c0f:	50                   	push   %eax
c0021c10:	68 44 f0 02 c0       	push   $0xc002f044
c0021c15:	e8 2b 57 00 00       	call   c0027345 <printf>
c0021c1a:	83 c4 10             	add    $0x10,%esp
    f->vec_no, intr_names[f->vec_no]);
}
c0021c1d:	90                   	nop
c0021c1e:	c9                   	leave  
c0021c1f:	c3                   	ret    

c0021c20 <intr_dump_frame>:

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0021c20:	55                   	push   %ebp
c0021c21:	89 e5                	mov    %esp,%ebp
c0021c23:	53                   	push   %ebx
c0021c24:	83 ec 14             	sub    $0x14,%esp
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0021c27:	0f 20 d0             	mov    %cr2,%eax
c0021c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021c2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c30:	8b 48 3c             	mov    0x3c(%eax),%ecx
          f->vec_no, intr_names[f->vec_no], f->eip);
c0021c33:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c36:	8b 40 30             	mov    0x30(%eax),%eax
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021c39:	8b 14 85 a0 8e 03 c0 	mov    -0x3ffc7160(,%eax,4),%edx
c0021c40:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c43:	8b 40 30             	mov    0x30(%eax),%eax
c0021c46:	51                   	push   %ecx
c0021c47:	52                   	push   %edx
c0021c48:	50                   	push   %eax
c0021c49:	68 68 f0 02 c0       	push   $0xc002f068
c0021c4e:	e8 f2 56 00 00       	call   c0027345 <printf>
c0021c53:	83 c4 10             	add    $0x10,%esp
          f->vec_no, intr_names[f->vec_no], f->eip);
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0021c56:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c59:	8b 40 34             	mov    0x34(%eax),%eax
c0021c5c:	83 ec 04             	sub    $0x4,%esp
c0021c5f:	50                   	push   %eax
c0021c60:	ff 75 f4             	pushl  -0xc(%ebp)
c0021c63:	68 88 f0 02 c0       	push   $0xc002f088
c0021c68:	e8 d8 56 00 00       	call   c0027345 <printf>
c0021c6d:	83 c4 10             	add    $0x10,%esp
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0021c70:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c73:	8b 58 14             	mov    0x14(%eax),%ebx
c0021c76:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c79:	8b 48 18             	mov    0x18(%eax),%ecx
c0021c7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c7f:	8b 50 10             	mov    0x10(%eax),%edx
c0021c82:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c85:	8b 40 1c             	mov    0x1c(%eax),%eax
c0021c88:	83 ec 0c             	sub    $0xc,%esp
c0021c8b:	53                   	push   %ebx
c0021c8c:	51                   	push   %ecx
c0021c8d:	52                   	push   %edx
c0021c8e:	50                   	push   %eax
c0021c8f:	68 a0 f0 02 c0       	push   $0xc002f0a0
c0021c94:	e8 ac 56 00 00       	call   c0027345 <printf>
c0021c99:	83 c4 20             	add    $0x20,%esp
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021c9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c9f:	8b 48 08             	mov    0x8(%eax),%ecx
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
c0021ca2:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ca5:	8b 40 48             	mov    0x48(%eax),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021ca8:	89 c3                	mov    %eax,%ebx
c0021caa:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cad:	8b 10                	mov    (%eax),%edx
c0021caf:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cb2:	8b 40 04             	mov    0x4(%eax),%eax
c0021cb5:	83 ec 0c             	sub    $0xc,%esp
c0021cb8:	51                   	push   %ecx
c0021cb9:	53                   	push   %ebx
c0021cba:	52                   	push   %edx
c0021cbb:	50                   	push   %eax
c0021cbc:	68 c8 f0 02 c0       	push   $0xc002f0c8
c0021cc1:	e8 7f 56 00 00       	call   c0027345 <printf>
c0021cc6:	83 c4 20             	add    $0x20,%esp
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->ss);
c0021cc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ccc:	0f b7 40 4c          	movzwl 0x4c(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021cd0:	0f b7 d8             	movzwl %ax,%ebx
          f->cs, f->ds, f->es, f->ss);
c0021cd3:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cd6:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021cda:	0f b7 c8             	movzwl %ax,%ecx
          f->cs, f->ds, f->es, f->ss);
c0021cdd:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ce0:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021ce4:	0f b7 d0             	movzwl %ax,%edx
          f->cs, f->ds, f->es, f->ss);
c0021ce7:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cea:	0f b7 40 40          	movzwl 0x40(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021cee:	0f b7 c0             	movzwl %ax,%eax
c0021cf1:	83 ec 0c             	sub    $0xc,%esp
c0021cf4:	53                   	push   %ebx
c0021cf5:	51                   	push   %ecx
c0021cf6:	52                   	push   %edx
c0021cf7:	50                   	push   %eax
c0021cf8:	68 f0 f0 02 c0       	push   $0xc002f0f0
c0021cfd:	e8 43 56 00 00       	call   c0027345 <printf>
c0021d02:	83 c4 20             	add    $0x20,%esp
          f->cs, f->ds, f->es, f->ss);
}
c0021d05:	90                   	nop
c0021d06:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021d09:	c9                   	leave  
c0021d0a:	c3                   	ret    

c0021d0b <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c0021d0b:	55                   	push   %ebp
c0021d0c:	89 e5                	mov    %esp,%ebp
c0021d0e:	83 ec 04             	sub    $0x4,%esp
c0021d11:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d14:	88 45 fc             	mov    %al,-0x4(%ebp)
  return intr_names[vec];
c0021d17:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0021d1b:	8b 04 85 a0 8e 03 c0 	mov    -0x3ffc7160(,%eax,4),%eax
}
c0021d22:	c9                   	leave  
c0021d23:	c3                   	ret    

c0021d24 <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0021d24:	1e                   	push   %ds
	pushl %es
c0021d25:	06                   	push   %es
	pushl %fs
c0021d26:	0f a0                	push   %fs
	pushl %gs
c0021d28:	0f a8                	push   %gs
	pushal
c0021d2a:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c0021d2b:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c0021d2c:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c0021d31:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c0021d33:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c0021d35:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c0021d39:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0021d3a:	e8 1b fd ff ff       	call   c0021a5a <intr_handler>
	addl $4, %esp
c0021d3f:	83 c4 04             	add    $0x4,%esp

c0021d42 <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c0021d42:	61                   	popa   
	popl %gs
c0021d43:	0f a9                	pop    %gs
	popl %fs
c0021d45:	0f a1                	pop    %fs
	popl %es
c0021d47:	07                   	pop    %es
	popl %ds
c0021d48:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0021d49:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0021d4c:	cf                   	iret   

c0021d4d <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c0021d4d:	55                   	push   %ebp
c0021d4e:	6a 00                	push   $0x0
c0021d50:	6a 00                	push   $0x0
c0021d52:	eb d0                	jmp    c0021d24 <intr_entry>

c0021d54 <intr01_stub>:
c0021d54:	55                   	push   %ebp
c0021d55:	6a 00                	push   $0x0
c0021d57:	6a 01                	push   $0x1
c0021d59:	eb c9                	jmp    c0021d24 <intr_entry>

c0021d5b <intr02_stub>:
c0021d5b:	55                   	push   %ebp
c0021d5c:	6a 00                	push   $0x0
c0021d5e:	6a 02                	push   $0x2
c0021d60:	eb c2                	jmp    c0021d24 <intr_entry>

c0021d62 <intr03_stub>:
c0021d62:	55                   	push   %ebp
c0021d63:	6a 00                	push   $0x0
c0021d65:	6a 03                	push   $0x3
c0021d67:	eb bb                	jmp    c0021d24 <intr_entry>

c0021d69 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0021d69:	55                   	push   %ebp
c0021d6a:	6a 00                	push   $0x0
c0021d6c:	6a 04                	push   $0x4
c0021d6e:	eb b4                	jmp    c0021d24 <intr_entry>

c0021d70 <intr05_stub>:
c0021d70:	55                   	push   %ebp
c0021d71:	6a 00                	push   $0x0
c0021d73:	6a 05                	push   $0x5
c0021d75:	eb ad                	jmp    c0021d24 <intr_entry>

c0021d77 <intr06_stub>:
c0021d77:	55                   	push   %ebp
c0021d78:	6a 00                	push   $0x0
c0021d7a:	6a 06                	push   $0x6
c0021d7c:	eb a6                	jmp    c0021d24 <intr_entry>

c0021d7e <intr07_stub>:
c0021d7e:	55                   	push   %ebp
c0021d7f:	6a 00                	push   $0x0
c0021d81:	6a 07                	push   $0x7
c0021d83:	eb 9f                	jmp    c0021d24 <intr_entry>

c0021d85 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0021d85:	ff 34 24             	pushl  (%esp)
c0021d88:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d8c:	6a 08                	push   $0x8
c0021d8e:	eb 94                	jmp    c0021d24 <intr_entry>

c0021d90 <intr09_stub>:
c0021d90:	55                   	push   %ebp
c0021d91:	6a 00                	push   $0x0
c0021d93:	6a 09                	push   $0x9
c0021d95:	eb 8d                	jmp    c0021d24 <intr_entry>

c0021d97 <intr0a_stub>:
c0021d97:	ff 34 24             	pushl  (%esp)
c0021d9a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d9e:	6a 0a                	push   $0xa
c0021da0:	eb 82                	jmp    c0021d24 <intr_entry>

c0021da2 <intr0b_stub>:
c0021da2:	ff 34 24             	pushl  (%esp)
c0021da5:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021da9:	6a 0b                	push   $0xb
c0021dab:	e9 74 ff ff ff       	jmp    c0021d24 <intr_entry>

c0021db0 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0021db0:	55                   	push   %ebp
c0021db1:	6a 00                	push   $0x0
c0021db3:	6a 0c                	push   $0xc
c0021db5:	e9 6a ff ff ff       	jmp    c0021d24 <intr_entry>

c0021dba <intr0d_stub>:
c0021dba:	ff 34 24             	pushl  (%esp)
c0021dbd:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021dc1:	6a 0d                	push   $0xd
c0021dc3:	e9 5c ff ff ff       	jmp    c0021d24 <intr_entry>

c0021dc8 <intr0e_stub>:
c0021dc8:	ff 34 24             	pushl  (%esp)
c0021dcb:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021dcf:	6a 0e                	push   $0xe
c0021dd1:	e9 4e ff ff ff       	jmp    c0021d24 <intr_entry>

c0021dd6 <intr0f_stub>:
c0021dd6:	55                   	push   %ebp
c0021dd7:	6a 00                	push   $0x0
c0021dd9:	6a 0f                	push   $0xf
c0021ddb:	e9 44 ff ff ff       	jmp    c0021d24 <intr_entry>

c0021de0 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0021de0:	55                   	push   %ebp
c0021de1:	6a 00                	push   $0x0
c0021de3:	6a 10                	push   $0x10
c0021de5:	e9 3a ff ff ff       	jmp    c0021d24 <intr_entry>

c0021dea <intr11_stub>:
c0021dea:	ff 34 24             	pushl  (%esp)
c0021ded:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021df1:	6a 11                	push   $0x11
c0021df3:	e9 2c ff ff ff       	jmp    c0021d24 <intr_entry>

c0021df8 <intr12_stub>:
c0021df8:	55                   	push   %ebp
c0021df9:	6a 00                	push   $0x0
c0021dfb:	6a 12                	push   $0x12
c0021dfd:	e9 22 ff ff ff       	jmp    c0021d24 <intr_entry>

c0021e02 <intr13_stub>:
c0021e02:	55                   	push   %ebp
c0021e03:	6a 00                	push   $0x0
c0021e05:	6a 13                	push   $0x13
c0021e07:	e9 18 ff ff ff       	jmp    c0021d24 <intr_entry>

c0021e0c <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0021e0c:	55                   	push   %ebp
c0021e0d:	6a 00                	push   $0x0
c0021e0f:	6a 14                	push   $0x14
c0021e11:	e9 0e ff ff ff       	jmp    c0021d24 <intr_entry>

c0021e16 <intr15_stub>:
c0021e16:	55                   	push   %ebp
c0021e17:	6a 00                	push   $0x0
c0021e19:	6a 15                	push   $0x15
c0021e1b:	e9 04 ff ff ff       	jmp    c0021d24 <intr_entry>

c0021e20 <intr16_stub>:
c0021e20:	55                   	push   %ebp
c0021e21:	6a 00                	push   $0x0
c0021e23:	6a 16                	push   $0x16
c0021e25:	e9 fa fe ff ff       	jmp    c0021d24 <intr_entry>

c0021e2a <intr17_stub>:
c0021e2a:	55                   	push   %ebp
c0021e2b:	6a 00                	push   $0x0
c0021e2d:	6a 17                	push   $0x17
c0021e2f:	e9 f0 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021e34 <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c0021e34:	ff 34 24             	pushl  (%esp)
c0021e37:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e3b:	6a 18                	push   $0x18
c0021e3d:	e9 e2 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021e42 <intr19_stub>:
c0021e42:	55                   	push   %ebp
c0021e43:	6a 00                	push   $0x0
c0021e45:	6a 19                	push   $0x19
c0021e47:	e9 d8 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021e4c <intr1a_stub>:
c0021e4c:	ff 34 24             	pushl  (%esp)
c0021e4f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e53:	6a 1a                	push   $0x1a
c0021e55:	e9 ca fe ff ff       	jmp    c0021d24 <intr_entry>

c0021e5a <intr1b_stub>:
c0021e5a:	ff 34 24             	pushl  (%esp)
c0021e5d:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e61:	6a 1b                	push   $0x1b
c0021e63:	e9 bc fe ff ff       	jmp    c0021d24 <intr_entry>

c0021e68 <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0021e68:	55                   	push   %ebp
c0021e69:	6a 00                	push   $0x0
c0021e6b:	6a 1c                	push   $0x1c
c0021e6d:	e9 b2 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021e72 <intr1d_stub>:
c0021e72:	ff 34 24             	pushl  (%esp)
c0021e75:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e79:	6a 1d                	push   $0x1d
c0021e7b:	e9 a4 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021e80 <intr1e_stub>:
c0021e80:	ff 34 24             	pushl  (%esp)
c0021e83:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e87:	6a 1e                	push   $0x1e
c0021e89:	e9 96 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021e8e <intr1f_stub>:
c0021e8e:	55                   	push   %ebp
c0021e8f:	6a 00                	push   $0x0
c0021e91:	6a 1f                	push   $0x1f
c0021e93:	e9 8c fe ff ff       	jmp    c0021d24 <intr_entry>

c0021e98 <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0021e98:	55                   	push   %ebp
c0021e99:	6a 00                	push   $0x0
c0021e9b:	6a 20                	push   $0x20
c0021e9d:	e9 82 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021ea2 <intr21_stub>:
c0021ea2:	55                   	push   %ebp
c0021ea3:	6a 00                	push   $0x0
c0021ea5:	6a 21                	push   $0x21
c0021ea7:	e9 78 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021eac <intr22_stub>:
c0021eac:	55                   	push   %ebp
c0021ead:	6a 00                	push   $0x0
c0021eaf:	6a 22                	push   $0x22
c0021eb1:	e9 6e fe ff ff       	jmp    c0021d24 <intr_entry>

c0021eb6 <intr23_stub>:
c0021eb6:	55                   	push   %ebp
c0021eb7:	6a 00                	push   $0x0
c0021eb9:	6a 23                	push   $0x23
c0021ebb:	e9 64 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021ec0 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0021ec0:	55                   	push   %ebp
c0021ec1:	6a 00                	push   $0x0
c0021ec3:	6a 24                	push   $0x24
c0021ec5:	e9 5a fe ff ff       	jmp    c0021d24 <intr_entry>

c0021eca <intr25_stub>:
c0021eca:	55                   	push   %ebp
c0021ecb:	6a 00                	push   $0x0
c0021ecd:	6a 25                	push   $0x25
c0021ecf:	e9 50 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021ed4 <intr26_stub>:
c0021ed4:	55                   	push   %ebp
c0021ed5:	6a 00                	push   $0x0
c0021ed7:	6a 26                	push   $0x26
c0021ed9:	e9 46 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021ede <intr27_stub>:
c0021ede:	55                   	push   %ebp
c0021edf:	6a 00                	push   $0x0
c0021ee1:	6a 27                	push   $0x27
c0021ee3:	e9 3c fe ff ff       	jmp    c0021d24 <intr_entry>

c0021ee8 <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c0021ee8:	55                   	push   %ebp
c0021ee9:	6a 00                	push   $0x0
c0021eeb:	6a 28                	push   $0x28
c0021eed:	e9 32 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021ef2 <intr29_stub>:
c0021ef2:	55                   	push   %ebp
c0021ef3:	6a 00                	push   $0x0
c0021ef5:	6a 29                	push   $0x29
c0021ef7:	e9 28 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021efc <intr2a_stub>:
c0021efc:	55                   	push   %ebp
c0021efd:	6a 00                	push   $0x0
c0021eff:	6a 2a                	push   $0x2a
c0021f01:	e9 1e fe ff ff       	jmp    c0021d24 <intr_entry>

c0021f06 <intr2b_stub>:
c0021f06:	55                   	push   %ebp
c0021f07:	6a 00                	push   $0x0
c0021f09:	6a 2b                	push   $0x2b
c0021f0b:	e9 14 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021f10 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c0021f10:	55                   	push   %ebp
c0021f11:	6a 00                	push   $0x0
c0021f13:	6a 2c                	push   $0x2c
c0021f15:	e9 0a fe ff ff       	jmp    c0021d24 <intr_entry>

c0021f1a <intr2d_stub>:
c0021f1a:	55                   	push   %ebp
c0021f1b:	6a 00                	push   $0x0
c0021f1d:	6a 2d                	push   $0x2d
c0021f1f:	e9 00 fe ff ff       	jmp    c0021d24 <intr_entry>

c0021f24 <intr2e_stub>:
c0021f24:	55                   	push   %ebp
c0021f25:	6a 00                	push   $0x0
c0021f27:	6a 2e                	push   $0x2e
c0021f29:	e9 f6 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f2e <intr2f_stub>:
c0021f2e:	55                   	push   %ebp
c0021f2f:	6a 00                	push   $0x0
c0021f31:	6a 2f                	push   $0x2f
c0021f33:	e9 ec fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f38 <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c0021f38:	55                   	push   %ebp
c0021f39:	6a 00                	push   $0x0
c0021f3b:	6a 30                	push   $0x30
c0021f3d:	e9 e2 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f42 <intr31_stub>:
c0021f42:	55                   	push   %ebp
c0021f43:	6a 00                	push   $0x0
c0021f45:	6a 31                	push   $0x31
c0021f47:	e9 d8 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f4c <intr32_stub>:
c0021f4c:	55                   	push   %ebp
c0021f4d:	6a 00                	push   $0x0
c0021f4f:	6a 32                	push   $0x32
c0021f51:	e9 ce fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f56 <intr33_stub>:
c0021f56:	55                   	push   %ebp
c0021f57:	6a 00                	push   $0x0
c0021f59:	6a 33                	push   $0x33
c0021f5b:	e9 c4 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f60 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c0021f60:	55                   	push   %ebp
c0021f61:	6a 00                	push   $0x0
c0021f63:	6a 34                	push   $0x34
c0021f65:	e9 ba fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f6a <intr35_stub>:
c0021f6a:	55                   	push   %ebp
c0021f6b:	6a 00                	push   $0x0
c0021f6d:	6a 35                	push   $0x35
c0021f6f:	e9 b0 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f74 <intr36_stub>:
c0021f74:	55                   	push   %ebp
c0021f75:	6a 00                	push   $0x0
c0021f77:	6a 36                	push   $0x36
c0021f79:	e9 a6 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f7e <intr37_stub>:
c0021f7e:	55                   	push   %ebp
c0021f7f:	6a 00                	push   $0x0
c0021f81:	6a 37                	push   $0x37
c0021f83:	e9 9c fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f88 <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0021f88:	55                   	push   %ebp
c0021f89:	6a 00                	push   $0x0
c0021f8b:	6a 38                	push   $0x38
c0021f8d:	e9 92 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f92 <intr39_stub>:
c0021f92:	55                   	push   %ebp
c0021f93:	6a 00                	push   $0x0
c0021f95:	6a 39                	push   $0x39
c0021f97:	e9 88 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021f9c <intr3a_stub>:
c0021f9c:	55                   	push   %ebp
c0021f9d:	6a 00                	push   $0x0
c0021f9f:	6a 3a                	push   $0x3a
c0021fa1:	e9 7e fd ff ff       	jmp    c0021d24 <intr_entry>

c0021fa6 <intr3b_stub>:
c0021fa6:	55                   	push   %ebp
c0021fa7:	6a 00                	push   $0x0
c0021fa9:	6a 3b                	push   $0x3b
c0021fab:	e9 74 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021fb0 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0021fb0:	55                   	push   %ebp
c0021fb1:	6a 00                	push   $0x0
c0021fb3:	6a 3c                	push   $0x3c
c0021fb5:	e9 6a fd ff ff       	jmp    c0021d24 <intr_entry>

c0021fba <intr3d_stub>:
c0021fba:	55                   	push   %ebp
c0021fbb:	6a 00                	push   $0x0
c0021fbd:	6a 3d                	push   $0x3d
c0021fbf:	e9 60 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021fc4 <intr3e_stub>:
c0021fc4:	55                   	push   %ebp
c0021fc5:	6a 00                	push   $0x0
c0021fc7:	6a 3e                	push   $0x3e
c0021fc9:	e9 56 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021fce <intr3f_stub>:
c0021fce:	55                   	push   %ebp
c0021fcf:	6a 00                	push   $0x0
c0021fd1:	6a 3f                	push   $0x3f
c0021fd3:	e9 4c fd ff ff       	jmp    c0021d24 <intr_entry>

c0021fd8 <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c0021fd8:	55                   	push   %ebp
c0021fd9:	6a 00                	push   $0x0
c0021fdb:	6a 40                	push   $0x40
c0021fdd:	e9 42 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021fe2 <intr41_stub>:
c0021fe2:	55                   	push   %ebp
c0021fe3:	6a 00                	push   $0x0
c0021fe5:	6a 41                	push   $0x41
c0021fe7:	e9 38 fd ff ff       	jmp    c0021d24 <intr_entry>

c0021fec <intr42_stub>:
c0021fec:	55                   	push   %ebp
c0021fed:	6a 00                	push   $0x0
c0021fef:	6a 42                	push   $0x42
c0021ff1:	e9 2e fd ff ff       	jmp    c0021d24 <intr_entry>

c0021ff6 <intr43_stub>:
c0021ff6:	55                   	push   %ebp
c0021ff7:	6a 00                	push   $0x0
c0021ff9:	6a 43                	push   $0x43
c0021ffb:	e9 24 fd ff ff       	jmp    c0021d24 <intr_entry>

c0022000 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c0022000:	55                   	push   %ebp
c0022001:	6a 00                	push   $0x0
c0022003:	6a 44                	push   $0x44
c0022005:	e9 1a fd ff ff       	jmp    c0021d24 <intr_entry>

c002200a <intr45_stub>:
c002200a:	55                   	push   %ebp
c002200b:	6a 00                	push   $0x0
c002200d:	6a 45                	push   $0x45
c002200f:	e9 10 fd ff ff       	jmp    c0021d24 <intr_entry>

c0022014 <intr46_stub>:
c0022014:	55                   	push   %ebp
c0022015:	6a 00                	push   $0x0
c0022017:	6a 46                	push   $0x46
c0022019:	e9 06 fd ff ff       	jmp    c0021d24 <intr_entry>

c002201e <intr47_stub>:
c002201e:	55                   	push   %ebp
c002201f:	6a 00                	push   $0x0
c0022021:	6a 47                	push   $0x47
c0022023:	e9 fc fc ff ff       	jmp    c0021d24 <intr_entry>

c0022028 <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c0022028:	55                   	push   %ebp
c0022029:	6a 00                	push   $0x0
c002202b:	6a 48                	push   $0x48
c002202d:	e9 f2 fc ff ff       	jmp    c0021d24 <intr_entry>

c0022032 <intr49_stub>:
c0022032:	55                   	push   %ebp
c0022033:	6a 00                	push   $0x0
c0022035:	6a 49                	push   $0x49
c0022037:	e9 e8 fc ff ff       	jmp    c0021d24 <intr_entry>

c002203c <intr4a_stub>:
c002203c:	55                   	push   %ebp
c002203d:	6a 00                	push   $0x0
c002203f:	6a 4a                	push   $0x4a
c0022041:	e9 de fc ff ff       	jmp    c0021d24 <intr_entry>

c0022046 <intr4b_stub>:
c0022046:	55                   	push   %ebp
c0022047:	6a 00                	push   $0x0
c0022049:	6a 4b                	push   $0x4b
c002204b:	e9 d4 fc ff ff       	jmp    c0021d24 <intr_entry>

c0022050 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c0022050:	55                   	push   %ebp
c0022051:	6a 00                	push   $0x0
c0022053:	6a 4c                	push   $0x4c
c0022055:	e9 ca fc ff ff       	jmp    c0021d24 <intr_entry>

c002205a <intr4d_stub>:
c002205a:	55                   	push   %ebp
c002205b:	6a 00                	push   $0x0
c002205d:	6a 4d                	push   $0x4d
c002205f:	e9 c0 fc ff ff       	jmp    c0021d24 <intr_entry>

c0022064 <intr4e_stub>:
c0022064:	55                   	push   %ebp
c0022065:	6a 00                	push   $0x0
c0022067:	6a 4e                	push   $0x4e
c0022069:	e9 b6 fc ff ff       	jmp    c0021d24 <intr_entry>

c002206e <intr4f_stub>:
c002206e:	55                   	push   %ebp
c002206f:	6a 00                	push   $0x0
c0022071:	6a 4f                	push   $0x4f
c0022073:	e9 ac fc ff ff       	jmp    c0021d24 <intr_entry>

c0022078 <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0022078:	55                   	push   %ebp
c0022079:	6a 00                	push   $0x0
c002207b:	6a 50                	push   $0x50
c002207d:	e9 a2 fc ff ff       	jmp    c0021d24 <intr_entry>

c0022082 <intr51_stub>:
c0022082:	55                   	push   %ebp
c0022083:	6a 00                	push   $0x0
c0022085:	6a 51                	push   $0x51
c0022087:	e9 98 fc ff ff       	jmp    c0021d24 <intr_entry>

c002208c <intr52_stub>:
c002208c:	55                   	push   %ebp
c002208d:	6a 00                	push   $0x0
c002208f:	6a 52                	push   $0x52
c0022091:	e9 8e fc ff ff       	jmp    c0021d24 <intr_entry>

c0022096 <intr53_stub>:
c0022096:	55                   	push   %ebp
c0022097:	6a 00                	push   $0x0
c0022099:	6a 53                	push   $0x53
c002209b:	e9 84 fc ff ff       	jmp    c0021d24 <intr_entry>

c00220a0 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c00220a0:	55                   	push   %ebp
c00220a1:	6a 00                	push   $0x0
c00220a3:	6a 54                	push   $0x54
c00220a5:	e9 7a fc ff ff       	jmp    c0021d24 <intr_entry>

c00220aa <intr55_stub>:
c00220aa:	55                   	push   %ebp
c00220ab:	6a 00                	push   $0x0
c00220ad:	6a 55                	push   $0x55
c00220af:	e9 70 fc ff ff       	jmp    c0021d24 <intr_entry>

c00220b4 <intr56_stub>:
c00220b4:	55                   	push   %ebp
c00220b5:	6a 00                	push   $0x0
c00220b7:	6a 56                	push   $0x56
c00220b9:	e9 66 fc ff ff       	jmp    c0021d24 <intr_entry>

c00220be <intr57_stub>:
c00220be:	55                   	push   %ebp
c00220bf:	6a 00                	push   $0x0
c00220c1:	6a 57                	push   $0x57
c00220c3:	e9 5c fc ff ff       	jmp    c0021d24 <intr_entry>

c00220c8 <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c00220c8:	55                   	push   %ebp
c00220c9:	6a 00                	push   $0x0
c00220cb:	6a 58                	push   $0x58
c00220cd:	e9 52 fc ff ff       	jmp    c0021d24 <intr_entry>

c00220d2 <intr59_stub>:
c00220d2:	55                   	push   %ebp
c00220d3:	6a 00                	push   $0x0
c00220d5:	6a 59                	push   $0x59
c00220d7:	e9 48 fc ff ff       	jmp    c0021d24 <intr_entry>

c00220dc <intr5a_stub>:
c00220dc:	55                   	push   %ebp
c00220dd:	6a 00                	push   $0x0
c00220df:	6a 5a                	push   $0x5a
c00220e1:	e9 3e fc ff ff       	jmp    c0021d24 <intr_entry>

c00220e6 <intr5b_stub>:
c00220e6:	55                   	push   %ebp
c00220e7:	6a 00                	push   $0x0
c00220e9:	6a 5b                	push   $0x5b
c00220eb:	e9 34 fc ff ff       	jmp    c0021d24 <intr_entry>

c00220f0 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c00220f0:	55                   	push   %ebp
c00220f1:	6a 00                	push   $0x0
c00220f3:	6a 5c                	push   $0x5c
c00220f5:	e9 2a fc ff ff       	jmp    c0021d24 <intr_entry>

c00220fa <intr5d_stub>:
c00220fa:	55                   	push   %ebp
c00220fb:	6a 00                	push   $0x0
c00220fd:	6a 5d                	push   $0x5d
c00220ff:	e9 20 fc ff ff       	jmp    c0021d24 <intr_entry>

c0022104 <intr5e_stub>:
c0022104:	55                   	push   %ebp
c0022105:	6a 00                	push   $0x0
c0022107:	6a 5e                	push   $0x5e
c0022109:	e9 16 fc ff ff       	jmp    c0021d24 <intr_entry>

c002210e <intr5f_stub>:
c002210e:	55                   	push   %ebp
c002210f:	6a 00                	push   $0x0
c0022111:	6a 5f                	push   $0x5f
c0022113:	e9 0c fc ff ff       	jmp    c0021d24 <intr_entry>

c0022118 <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c0022118:	55                   	push   %ebp
c0022119:	6a 00                	push   $0x0
c002211b:	6a 60                	push   $0x60
c002211d:	e9 02 fc ff ff       	jmp    c0021d24 <intr_entry>

c0022122 <intr61_stub>:
c0022122:	55                   	push   %ebp
c0022123:	6a 00                	push   $0x0
c0022125:	6a 61                	push   $0x61
c0022127:	e9 f8 fb ff ff       	jmp    c0021d24 <intr_entry>

c002212c <intr62_stub>:
c002212c:	55                   	push   %ebp
c002212d:	6a 00                	push   $0x0
c002212f:	6a 62                	push   $0x62
c0022131:	e9 ee fb ff ff       	jmp    c0021d24 <intr_entry>

c0022136 <intr63_stub>:
c0022136:	55                   	push   %ebp
c0022137:	6a 00                	push   $0x0
c0022139:	6a 63                	push   $0x63
c002213b:	e9 e4 fb ff ff       	jmp    c0021d24 <intr_entry>

c0022140 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c0022140:	55                   	push   %ebp
c0022141:	6a 00                	push   $0x0
c0022143:	6a 64                	push   $0x64
c0022145:	e9 da fb ff ff       	jmp    c0021d24 <intr_entry>

c002214a <intr65_stub>:
c002214a:	55                   	push   %ebp
c002214b:	6a 00                	push   $0x0
c002214d:	6a 65                	push   $0x65
c002214f:	e9 d0 fb ff ff       	jmp    c0021d24 <intr_entry>

c0022154 <intr66_stub>:
c0022154:	55                   	push   %ebp
c0022155:	6a 00                	push   $0x0
c0022157:	6a 66                	push   $0x66
c0022159:	e9 c6 fb ff ff       	jmp    c0021d24 <intr_entry>

c002215e <intr67_stub>:
c002215e:	55                   	push   %ebp
c002215f:	6a 00                	push   $0x0
c0022161:	6a 67                	push   $0x67
c0022163:	e9 bc fb ff ff       	jmp    c0021d24 <intr_entry>

c0022168 <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c0022168:	55                   	push   %ebp
c0022169:	6a 00                	push   $0x0
c002216b:	6a 68                	push   $0x68
c002216d:	e9 b2 fb ff ff       	jmp    c0021d24 <intr_entry>

c0022172 <intr69_stub>:
c0022172:	55                   	push   %ebp
c0022173:	6a 00                	push   $0x0
c0022175:	6a 69                	push   $0x69
c0022177:	e9 a8 fb ff ff       	jmp    c0021d24 <intr_entry>

c002217c <intr6a_stub>:
c002217c:	55                   	push   %ebp
c002217d:	6a 00                	push   $0x0
c002217f:	6a 6a                	push   $0x6a
c0022181:	e9 9e fb ff ff       	jmp    c0021d24 <intr_entry>

c0022186 <intr6b_stub>:
c0022186:	55                   	push   %ebp
c0022187:	6a 00                	push   $0x0
c0022189:	6a 6b                	push   $0x6b
c002218b:	e9 94 fb ff ff       	jmp    c0021d24 <intr_entry>

c0022190 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0022190:	55                   	push   %ebp
c0022191:	6a 00                	push   $0x0
c0022193:	6a 6c                	push   $0x6c
c0022195:	e9 8a fb ff ff       	jmp    c0021d24 <intr_entry>

c002219a <intr6d_stub>:
c002219a:	55                   	push   %ebp
c002219b:	6a 00                	push   $0x0
c002219d:	6a 6d                	push   $0x6d
c002219f:	e9 80 fb ff ff       	jmp    c0021d24 <intr_entry>

c00221a4 <intr6e_stub>:
c00221a4:	55                   	push   %ebp
c00221a5:	6a 00                	push   $0x0
c00221a7:	6a 6e                	push   $0x6e
c00221a9:	e9 76 fb ff ff       	jmp    c0021d24 <intr_entry>

c00221ae <intr6f_stub>:
c00221ae:	55                   	push   %ebp
c00221af:	6a 00                	push   $0x0
c00221b1:	6a 6f                	push   $0x6f
c00221b3:	e9 6c fb ff ff       	jmp    c0021d24 <intr_entry>

c00221b8 <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c00221b8:	55                   	push   %ebp
c00221b9:	6a 00                	push   $0x0
c00221bb:	6a 70                	push   $0x70
c00221bd:	e9 62 fb ff ff       	jmp    c0021d24 <intr_entry>

c00221c2 <intr71_stub>:
c00221c2:	55                   	push   %ebp
c00221c3:	6a 00                	push   $0x0
c00221c5:	6a 71                	push   $0x71
c00221c7:	e9 58 fb ff ff       	jmp    c0021d24 <intr_entry>

c00221cc <intr72_stub>:
c00221cc:	55                   	push   %ebp
c00221cd:	6a 00                	push   $0x0
c00221cf:	6a 72                	push   $0x72
c00221d1:	e9 4e fb ff ff       	jmp    c0021d24 <intr_entry>

c00221d6 <intr73_stub>:
c00221d6:	55                   	push   %ebp
c00221d7:	6a 00                	push   $0x0
c00221d9:	6a 73                	push   $0x73
c00221db:	e9 44 fb ff ff       	jmp    c0021d24 <intr_entry>

c00221e0 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c00221e0:	55                   	push   %ebp
c00221e1:	6a 00                	push   $0x0
c00221e3:	6a 74                	push   $0x74
c00221e5:	e9 3a fb ff ff       	jmp    c0021d24 <intr_entry>

c00221ea <intr75_stub>:
c00221ea:	55                   	push   %ebp
c00221eb:	6a 00                	push   $0x0
c00221ed:	6a 75                	push   $0x75
c00221ef:	e9 30 fb ff ff       	jmp    c0021d24 <intr_entry>

c00221f4 <intr76_stub>:
c00221f4:	55                   	push   %ebp
c00221f5:	6a 00                	push   $0x0
c00221f7:	6a 76                	push   $0x76
c00221f9:	e9 26 fb ff ff       	jmp    c0021d24 <intr_entry>

c00221fe <intr77_stub>:
c00221fe:	55                   	push   %ebp
c00221ff:	6a 00                	push   $0x0
c0022201:	6a 77                	push   $0x77
c0022203:	e9 1c fb ff ff       	jmp    c0021d24 <intr_entry>

c0022208 <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c0022208:	55                   	push   %ebp
c0022209:	6a 00                	push   $0x0
c002220b:	6a 78                	push   $0x78
c002220d:	e9 12 fb ff ff       	jmp    c0021d24 <intr_entry>

c0022212 <intr79_stub>:
c0022212:	55                   	push   %ebp
c0022213:	6a 00                	push   $0x0
c0022215:	6a 79                	push   $0x79
c0022217:	e9 08 fb ff ff       	jmp    c0021d24 <intr_entry>

c002221c <intr7a_stub>:
c002221c:	55                   	push   %ebp
c002221d:	6a 00                	push   $0x0
c002221f:	6a 7a                	push   $0x7a
c0022221:	e9 fe fa ff ff       	jmp    c0021d24 <intr_entry>

c0022226 <intr7b_stub>:
c0022226:	55                   	push   %ebp
c0022227:	6a 00                	push   $0x0
c0022229:	6a 7b                	push   $0x7b
c002222b:	e9 f4 fa ff ff       	jmp    c0021d24 <intr_entry>

c0022230 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c0022230:	55                   	push   %ebp
c0022231:	6a 00                	push   $0x0
c0022233:	6a 7c                	push   $0x7c
c0022235:	e9 ea fa ff ff       	jmp    c0021d24 <intr_entry>

c002223a <intr7d_stub>:
c002223a:	55                   	push   %ebp
c002223b:	6a 00                	push   $0x0
c002223d:	6a 7d                	push   $0x7d
c002223f:	e9 e0 fa ff ff       	jmp    c0021d24 <intr_entry>

c0022244 <intr7e_stub>:
c0022244:	55                   	push   %ebp
c0022245:	6a 00                	push   $0x0
c0022247:	6a 7e                	push   $0x7e
c0022249:	e9 d6 fa ff ff       	jmp    c0021d24 <intr_entry>

c002224e <intr7f_stub>:
c002224e:	55                   	push   %ebp
c002224f:	6a 00                	push   $0x0
c0022251:	6a 7f                	push   $0x7f
c0022253:	e9 cc fa ff ff       	jmp    c0021d24 <intr_entry>

c0022258 <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c0022258:	55                   	push   %ebp
c0022259:	6a 00                	push   $0x0
c002225b:	68 80 00 00 00       	push   $0x80
c0022260:	e9 bf fa ff ff       	jmp    c0021d24 <intr_entry>

c0022265 <intr81_stub>:
c0022265:	55                   	push   %ebp
c0022266:	6a 00                	push   $0x0
c0022268:	68 81 00 00 00       	push   $0x81
c002226d:	e9 b2 fa ff ff       	jmp    c0021d24 <intr_entry>

c0022272 <intr82_stub>:
c0022272:	55                   	push   %ebp
c0022273:	6a 00                	push   $0x0
c0022275:	68 82 00 00 00       	push   $0x82
c002227a:	e9 a5 fa ff ff       	jmp    c0021d24 <intr_entry>

c002227f <intr83_stub>:
c002227f:	55                   	push   %ebp
c0022280:	6a 00                	push   $0x0
c0022282:	68 83 00 00 00       	push   $0x83
c0022287:	e9 98 fa ff ff       	jmp    c0021d24 <intr_entry>

c002228c <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c002228c:	55                   	push   %ebp
c002228d:	6a 00                	push   $0x0
c002228f:	68 84 00 00 00       	push   $0x84
c0022294:	e9 8b fa ff ff       	jmp    c0021d24 <intr_entry>

c0022299 <intr85_stub>:
c0022299:	55                   	push   %ebp
c002229a:	6a 00                	push   $0x0
c002229c:	68 85 00 00 00       	push   $0x85
c00222a1:	e9 7e fa ff ff       	jmp    c0021d24 <intr_entry>

c00222a6 <intr86_stub>:
c00222a6:	55                   	push   %ebp
c00222a7:	6a 00                	push   $0x0
c00222a9:	68 86 00 00 00       	push   $0x86
c00222ae:	e9 71 fa ff ff       	jmp    c0021d24 <intr_entry>

c00222b3 <intr87_stub>:
c00222b3:	55                   	push   %ebp
c00222b4:	6a 00                	push   $0x0
c00222b6:	68 87 00 00 00       	push   $0x87
c00222bb:	e9 64 fa ff ff       	jmp    c0021d24 <intr_entry>

c00222c0 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c00222c0:	55                   	push   %ebp
c00222c1:	6a 00                	push   $0x0
c00222c3:	68 88 00 00 00       	push   $0x88
c00222c8:	e9 57 fa ff ff       	jmp    c0021d24 <intr_entry>

c00222cd <intr89_stub>:
c00222cd:	55                   	push   %ebp
c00222ce:	6a 00                	push   $0x0
c00222d0:	68 89 00 00 00       	push   $0x89
c00222d5:	e9 4a fa ff ff       	jmp    c0021d24 <intr_entry>

c00222da <intr8a_stub>:
c00222da:	55                   	push   %ebp
c00222db:	6a 00                	push   $0x0
c00222dd:	68 8a 00 00 00       	push   $0x8a
c00222e2:	e9 3d fa ff ff       	jmp    c0021d24 <intr_entry>

c00222e7 <intr8b_stub>:
c00222e7:	55                   	push   %ebp
c00222e8:	6a 00                	push   $0x0
c00222ea:	68 8b 00 00 00       	push   $0x8b
c00222ef:	e9 30 fa ff ff       	jmp    c0021d24 <intr_entry>

c00222f4 <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c00222f4:	55                   	push   %ebp
c00222f5:	6a 00                	push   $0x0
c00222f7:	68 8c 00 00 00       	push   $0x8c
c00222fc:	e9 23 fa ff ff       	jmp    c0021d24 <intr_entry>

c0022301 <intr8d_stub>:
c0022301:	55                   	push   %ebp
c0022302:	6a 00                	push   $0x0
c0022304:	68 8d 00 00 00       	push   $0x8d
c0022309:	e9 16 fa ff ff       	jmp    c0021d24 <intr_entry>

c002230e <intr8e_stub>:
c002230e:	55                   	push   %ebp
c002230f:	6a 00                	push   $0x0
c0022311:	68 8e 00 00 00       	push   $0x8e
c0022316:	e9 09 fa ff ff       	jmp    c0021d24 <intr_entry>

c002231b <intr8f_stub>:
c002231b:	55                   	push   %ebp
c002231c:	6a 00                	push   $0x0
c002231e:	68 8f 00 00 00       	push   $0x8f
c0022323:	e9 fc f9 ff ff       	jmp    c0021d24 <intr_entry>

c0022328 <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c0022328:	55                   	push   %ebp
c0022329:	6a 00                	push   $0x0
c002232b:	68 90 00 00 00       	push   $0x90
c0022330:	e9 ef f9 ff ff       	jmp    c0021d24 <intr_entry>

c0022335 <intr91_stub>:
c0022335:	55                   	push   %ebp
c0022336:	6a 00                	push   $0x0
c0022338:	68 91 00 00 00       	push   $0x91
c002233d:	e9 e2 f9 ff ff       	jmp    c0021d24 <intr_entry>

c0022342 <intr92_stub>:
c0022342:	55                   	push   %ebp
c0022343:	6a 00                	push   $0x0
c0022345:	68 92 00 00 00       	push   $0x92
c002234a:	e9 d5 f9 ff ff       	jmp    c0021d24 <intr_entry>

c002234f <intr93_stub>:
c002234f:	55                   	push   %ebp
c0022350:	6a 00                	push   $0x0
c0022352:	68 93 00 00 00       	push   $0x93
c0022357:	e9 c8 f9 ff ff       	jmp    c0021d24 <intr_entry>

c002235c <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c002235c:	55                   	push   %ebp
c002235d:	6a 00                	push   $0x0
c002235f:	68 94 00 00 00       	push   $0x94
c0022364:	e9 bb f9 ff ff       	jmp    c0021d24 <intr_entry>

c0022369 <intr95_stub>:
c0022369:	55                   	push   %ebp
c002236a:	6a 00                	push   $0x0
c002236c:	68 95 00 00 00       	push   $0x95
c0022371:	e9 ae f9 ff ff       	jmp    c0021d24 <intr_entry>

c0022376 <intr96_stub>:
c0022376:	55                   	push   %ebp
c0022377:	6a 00                	push   $0x0
c0022379:	68 96 00 00 00       	push   $0x96
c002237e:	e9 a1 f9 ff ff       	jmp    c0021d24 <intr_entry>

c0022383 <intr97_stub>:
c0022383:	55                   	push   %ebp
c0022384:	6a 00                	push   $0x0
c0022386:	68 97 00 00 00       	push   $0x97
c002238b:	e9 94 f9 ff ff       	jmp    c0021d24 <intr_entry>

c0022390 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022390:	55                   	push   %ebp
c0022391:	6a 00                	push   $0x0
c0022393:	68 98 00 00 00       	push   $0x98
c0022398:	e9 87 f9 ff ff       	jmp    c0021d24 <intr_entry>

c002239d <intr99_stub>:
c002239d:	55                   	push   %ebp
c002239e:	6a 00                	push   $0x0
c00223a0:	68 99 00 00 00       	push   $0x99
c00223a5:	e9 7a f9 ff ff       	jmp    c0021d24 <intr_entry>

c00223aa <intr9a_stub>:
c00223aa:	55                   	push   %ebp
c00223ab:	6a 00                	push   $0x0
c00223ad:	68 9a 00 00 00       	push   $0x9a
c00223b2:	e9 6d f9 ff ff       	jmp    c0021d24 <intr_entry>

c00223b7 <intr9b_stub>:
c00223b7:	55                   	push   %ebp
c00223b8:	6a 00                	push   $0x0
c00223ba:	68 9b 00 00 00       	push   $0x9b
c00223bf:	e9 60 f9 ff ff       	jmp    c0021d24 <intr_entry>

c00223c4 <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c00223c4:	55                   	push   %ebp
c00223c5:	6a 00                	push   $0x0
c00223c7:	68 9c 00 00 00       	push   $0x9c
c00223cc:	e9 53 f9 ff ff       	jmp    c0021d24 <intr_entry>

c00223d1 <intr9d_stub>:
c00223d1:	55                   	push   %ebp
c00223d2:	6a 00                	push   $0x0
c00223d4:	68 9d 00 00 00       	push   $0x9d
c00223d9:	e9 46 f9 ff ff       	jmp    c0021d24 <intr_entry>

c00223de <intr9e_stub>:
c00223de:	55                   	push   %ebp
c00223df:	6a 00                	push   $0x0
c00223e1:	68 9e 00 00 00       	push   $0x9e
c00223e6:	e9 39 f9 ff ff       	jmp    c0021d24 <intr_entry>

c00223eb <intr9f_stub>:
c00223eb:	55                   	push   %ebp
c00223ec:	6a 00                	push   $0x0
c00223ee:	68 9f 00 00 00       	push   $0x9f
c00223f3:	e9 2c f9 ff ff       	jmp    c0021d24 <intr_entry>

c00223f8 <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c00223f8:	55                   	push   %ebp
c00223f9:	6a 00                	push   $0x0
c00223fb:	68 a0 00 00 00       	push   $0xa0
c0022400:	e9 1f f9 ff ff       	jmp    c0021d24 <intr_entry>

c0022405 <intra1_stub>:
c0022405:	55                   	push   %ebp
c0022406:	6a 00                	push   $0x0
c0022408:	68 a1 00 00 00       	push   $0xa1
c002240d:	e9 12 f9 ff ff       	jmp    c0021d24 <intr_entry>

c0022412 <intra2_stub>:
c0022412:	55                   	push   %ebp
c0022413:	6a 00                	push   $0x0
c0022415:	68 a2 00 00 00       	push   $0xa2
c002241a:	e9 05 f9 ff ff       	jmp    c0021d24 <intr_entry>

c002241f <intra3_stub>:
c002241f:	55                   	push   %ebp
c0022420:	6a 00                	push   $0x0
c0022422:	68 a3 00 00 00       	push   $0xa3
c0022427:	e9 f8 f8 ff ff       	jmp    c0021d24 <intr_entry>

c002242c <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c002242c:	55                   	push   %ebp
c002242d:	6a 00                	push   $0x0
c002242f:	68 a4 00 00 00       	push   $0xa4
c0022434:	e9 eb f8 ff ff       	jmp    c0021d24 <intr_entry>

c0022439 <intra5_stub>:
c0022439:	55                   	push   %ebp
c002243a:	6a 00                	push   $0x0
c002243c:	68 a5 00 00 00       	push   $0xa5
c0022441:	e9 de f8 ff ff       	jmp    c0021d24 <intr_entry>

c0022446 <intra6_stub>:
c0022446:	55                   	push   %ebp
c0022447:	6a 00                	push   $0x0
c0022449:	68 a6 00 00 00       	push   $0xa6
c002244e:	e9 d1 f8 ff ff       	jmp    c0021d24 <intr_entry>

c0022453 <intra7_stub>:
c0022453:	55                   	push   %ebp
c0022454:	6a 00                	push   $0x0
c0022456:	68 a7 00 00 00       	push   $0xa7
c002245b:	e9 c4 f8 ff ff       	jmp    c0021d24 <intr_entry>

c0022460 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c0022460:	55                   	push   %ebp
c0022461:	6a 00                	push   $0x0
c0022463:	68 a8 00 00 00       	push   $0xa8
c0022468:	e9 b7 f8 ff ff       	jmp    c0021d24 <intr_entry>

c002246d <intra9_stub>:
c002246d:	55                   	push   %ebp
c002246e:	6a 00                	push   $0x0
c0022470:	68 a9 00 00 00       	push   $0xa9
c0022475:	e9 aa f8 ff ff       	jmp    c0021d24 <intr_entry>

c002247a <intraa_stub>:
c002247a:	55                   	push   %ebp
c002247b:	6a 00                	push   $0x0
c002247d:	68 aa 00 00 00       	push   $0xaa
c0022482:	e9 9d f8 ff ff       	jmp    c0021d24 <intr_entry>

c0022487 <intrab_stub>:
c0022487:	55                   	push   %ebp
c0022488:	6a 00                	push   $0x0
c002248a:	68 ab 00 00 00       	push   $0xab
c002248f:	e9 90 f8 ff ff       	jmp    c0021d24 <intr_entry>

c0022494 <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c0022494:	55                   	push   %ebp
c0022495:	6a 00                	push   $0x0
c0022497:	68 ac 00 00 00       	push   $0xac
c002249c:	e9 83 f8 ff ff       	jmp    c0021d24 <intr_entry>

c00224a1 <intrad_stub>:
c00224a1:	55                   	push   %ebp
c00224a2:	6a 00                	push   $0x0
c00224a4:	68 ad 00 00 00       	push   $0xad
c00224a9:	e9 76 f8 ff ff       	jmp    c0021d24 <intr_entry>

c00224ae <intrae_stub>:
c00224ae:	55                   	push   %ebp
c00224af:	6a 00                	push   $0x0
c00224b1:	68 ae 00 00 00       	push   $0xae
c00224b6:	e9 69 f8 ff ff       	jmp    c0021d24 <intr_entry>

c00224bb <intraf_stub>:
c00224bb:	55                   	push   %ebp
c00224bc:	6a 00                	push   $0x0
c00224be:	68 af 00 00 00       	push   $0xaf
c00224c3:	e9 5c f8 ff ff       	jmp    c0021d24 <intr_entry>

c00224c8 <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c00224c8:	55                   	push   %ebp
c00224c9:	6a 00                	push   $0x0
c00224cb:	68 b0 00 00 00       	push   $0xb0
c00224d0:	e9 4f f8 ff ff       	jmp    c0021d24 <intr_entry>

c00224d5 <intrb1_stub>:
c00224d5:	55                   	push   %ebp
c00224d6:	6a 00                	push   $0x0
c00224d8:	68 b1 00 00 00       	push   $0xb1
c00224dd:	e9 42 f8 ff ff       	jmp    c0021d24 <intr_entry>

c00224e2 <intrb2_stub>:
c00224e2:	55                   	push   %ebp
c00224e3:	6a 00                	push   $0x0
c00224e5:	68 b2 00 00 00       	push   $0xb2
c00224ea:	e9 35 f8 ff ff       	jmp    c0021d24 <intr_entry>

c00224ef <intrb3_stub>:
c00224ef:	55                   	push   %ebp
c00224f0:	6a 00                	push   $0x0
c00224f2:	68 b3 00 00 00       	push   $0xb3
c00224f7:	e9 28 f8 ff ff       	jmp    c0021d24 <intr_entry>

c00224fc <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c00224fc:	55                   	push   %ebp
c00224fd:	6a 00                	push   $0x0
c00224ff:	68 b4 00 00 00       	push   $0xb4
c0022504:	e9 1b f8 ff ff       	jmp    c0021d24 <intr_entry>

c0022509 <intrb5_stub>:
c0022509:	55                   	push   %ebp
c002250a:	6a 00                	push   $0x0
c002250c:	68 b5 00 00 00       	push   $0xb5
c0022511:	e9 0e f8 ff ff       	jmp    c0021d24 <intr_entry>

c0022516 <intrb6_stub>:
c0022516:	55                   	push   %ebp
c0022517:	6a 00                	push   $0x0
c0022519:	68 b6 00 00 00       	push   $0xb6
c002251e:	e9 01 f8 ff ff       	jmp    c0021d24 <intr_entry>

c0022523 <intrb7_stub>:
c0022523:	55                   	push   %ebp
c0022524:	6a 00                	push   $0x0
c0022526:	68 b7 00 00 00       	push   $0xb7
c002252b:	e9 f4 f7 ff ff       	jmp    c0021d24 <intr_entry>

c0022530 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c0022530:	55                   	push   %ebp
c0022531:	6a 00                	push   $0x0
c0022533:	68 b8 00 00 00       	push   $0xb8
c0022538:	e9 e7 f7 ff ff       	jmp    c0021d24 <intr_entry>

c002253d <intrb9_stub>:
c002253d:	55                   	push   %ebp
c002253e:	6a 00                	push   $0x0
c0022540:	68 b9 00 00 00       	push   $0xb9
c0022545:	e9 da f7 ff ff       	jmp    c0021d24 <intr_entry>

c002254a <intrba_stub>:
c002254a:	55                   	push   %ebp
c002254b:	6a 00                	push   $0x0
c002254d:	68 ba 00 00 00       	push   $0xba
c0022552:	e9 cd f7 ff ff       	jmp    c0021d24 <intr_entry>

c0022557 <intrbb_stub>:
c0022557:	55                   	push   %ebp
c0022558:	6a 00                	push   $0x0
c002255a:	68 bb 00 00 00       	push   $0xbb
c002255f:	e9 c0 f7 ff ff       	jmp    c0021d24 <intr_entry>

c0022564 <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c0022564:	55                   	push   %ebp
c0022565:	6a 00                	push   $0x0
c0022567:	68 bc 00 00 00       	push   $0xbc
c002256c:	e9 b3 f7 ff ff       	jmp    c0021d24 <intr_entry>

c0022571 <intrbd_stub>:
c0022571:	55                   	push   %ebp
c0022572:	6a 00                	push   $0x0
c0022574:	68 bd 00 00 00       	push   $0xbd
c0022579:	e9 a6 f7 ff ff       	jmp    c0021d24 <intr_entry>

c002257e <intrbe_stub>:
c002257e:	55                   	push   %ebp
c002257f:	6a 00                	push   $0x0
c0022581:	68 be 00 00 00       	push   $0xbe
c0022586:	e9 99 f7 ff ff       	jmp    c0021d24 <intr_entry>

c002258b <intrbf_stub>:
c002258b:	55                   	push   %ebp
c002258c:	6a 00                	push   $0x0
c002258e:	68 bf 00 00 00       	push   $0xbf
c0022593:	e9 8c f7 ff ff       	jmp    c0021d24 <intr_entry>

c0022598 <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c0022598:	55                   	push   %ebp
c0022599:	6a 00                	push   $0x0
c002259b:	68 c0 00 00 00       	push   $0xc0
c00225a0:	e9 7f f7 ff ff       	jmp    c0021d24 <intr_entry>

c00225a5 <intrc1_stub>:
c00225a5:	55                   	push   %ebp
c00225a6:	6a 00                	push   $0x0
c00225a8:	68 c1 00 00 00       	push   $0xc1
c00225ad:	e9 72 f7 ff ff       	jmp    c0021d24 <intr_entry>

c00225b2 <intrc2_stub>:
c00225b2:	55                   	push   %ebp
c00225b3:	6a 00                	push   $0x0
c00225b5:	68 c2 00 00 00       	push   $0xc2
c00225ba:	e9 65 f7 ff ff       	jmp    c0021d24 <intr_entry>

c00225bf <intrc3_stub>:
c00225bf:	55                   	push   %ebp
c00225c0:	6a 00                	push   $0x0
c00225c2:	68 c3 00 00 00       	push   $0xc3
c00225c7:	e9 58 f7 ff ff       	jmp    c0021d24 <intr_entry>

c00225cc <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c00225cc:	55                   	push   %ebp
c00225cd:	6a 00                	push   $0x0
c00225cf:	68 c4 00 00 00       	push   $0xc4
c00225d4:	e9 4b f7 ff ff       	jmp    c0021d24 <intr_entry>

c00225d9 <intrc5_stub>:
c00225d9:	55                   	push   %ebp
c00225da:	6a 00                	push   $0x0
c00225dc:	68 c5 00 00 00       	push   $0xc5
c00225e1:	e9 3e f7 ff ff       	jmp    c0021d24 <intr_entry>

c00225e6 <intrc6_stub>:
c00225e6:	55                   	push   %ebp
c00225e7:	6a 00                	push   $0x0
c00225e9:	68 c6 00 00 00       	push   $0xc6
c00225ee:	e9 31 f7 ff ff       	jmp    c0021d24 <intr_entry>

c00225f3 <intrc7_stub>:
c00225f3:	55                   	push   %ebp
c00225f4:	6a 00                	push   $0x0
c00225f6:	68 c7 00 00 00       	push   $0xc7
c00225fb:	e9 24 f7 ff ff       	jmp    c0021d24 <intr_entry>

c0022600 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c0022600:	55                   	push   %ebp
c0022601:	6a 00                	push   $0x0
c0022603:	68 c8 00 00 00       	push   $0xc8
c0022608:	e9 17 f7 ff ff       	jmp    c0021d24 <intr_entry>

c002260d <intrc9_stub>:
c002260d:	55                   	push   %ebp
c002260e:	6a 00                	push   $0x0
c0022610:	68 c9 00 00 00       	push   $0xc9
c0022615:	e9 0a f7 ff ff       	jmp    c0021d24 <intr_entry>

c002261a <intrca_stub>:
c002261a:	55                   	push   %ebp
c002261b:	6a 00                	push   $0x0
c002261d:	68 ca 00 00 00       	push   $0xca
c0022622:	e9 fd f6 ff ff       	jmp    c0021d24 <intr_entry>

c0022627 <intrcb_stub>:
c0022627:	55                   	push   %ebp
c0022628:	6a 00                	push   $0x0
c002262a:	68 cb 00 00 00       	push   $0xcb
c002262f:	e9 f0 f6 ff ff       	jmp    c0021d24 <intr_entry>

c0022634 <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c0022634:	55                   	push   %ebp
c0022635:	6a 00                	push   $0x0
c0022637:	68 cc 00 00 00       	push   $0xcc
c002263c:	e9 e3 f6 ff ff       	jmp    c0021d24 <intr_entry>

c0022641 <intrcd_stub>:
c0022641:	55                   	push   %ebp
c0022642:	6a 00                	push   $0x0
c0022644:	68 cd 00 00 00       	push   $0xcd
c0022649:	e9 d6 f6 ff ff       	jmp    c0021d24 <intr_entry>

c002264e <intrce_stub>:
c002264e:	55                   	push   %ebp
c002264f:	6a 00                	push   $0x0
c0022651:	68 ce 00 00 00       	push   $0xce
c0022656:	e9 c9 f6 ff ff       	jmp    c0021d24 <intr_entry>

c002265b <intrcf_stub>:
c002265b:	55                   	push   %ebp
c002265c:	6a 00                	push   $0x0
c002265e:	68 cf 00 00 00       	push   $0xcf
c0022663:	e9 bc f6 ff ff       	jmp    c0021d24 <intr_entry>

c0022668 <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c0022668:	55                   	push   %ebp
c0022669:	6a 00                	push   $0x0
c002266b:	68 d0 00 00 00       	push   $0xd0
c0022670:	e9 af f6 ff ff       	jmp    c0021d24 <intr_entry>

c0022675 <intrd1_stub>:
c0022675:	55                   	push   %ebp
c0022676:	6a 00                	push   $0x0
c0022678:	68 d1 00 00 00       	push   $0xd1
c002267d:	e9 a2 f6 ff ff       	jmp    c0021d24 <intr_entry>

c0022682 <intrd2_stub>:
c0022682:	55                   	push   %ebp
c0022683:	6a 00                	push   $0x0
c0022685:	68 d2 00 00 00       	push   $0xd2
c002268a:	e9 95 f6 ff ff       	jmp    c0021d24 <intr_entry>

c002268f <intrd3_stub>:
c002268f:	55                   	push   %ebp
c0022690:	6a 00                	push   $0x0
c0022692:	68 d3 00 00 00       	push   $0xd3
c0022697:	e9 88 f6 ff ff       	jmp    c0021d24 <intr_entry>

c002269c <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c002269c:	55                   	push   %ebp
c002269d:	6a 00                	push   $0x0
c002269f:	68 d4 00 00 00       	push   $0xd4
c00226a4:	e9 7b f6 ff ff       	jmp    c0021d24 <intr_entry>

c00226a9 <intrd5_stub>:
c00226a9:	55                   	push   %ebp
c00226aa:	6a 00                	push   $0x0
c00226ac:	68 d5 00 00 00       	push   $0xd5
c00226b1:	e9 6e f6 ff ff       	jmp    c0021d24 <intr_entry>

c00226b6 <intrd6_stub>:
c00226b6:	55                   	push   %ebp
c00226b7:	6a 00                	push   $0x0
c00226b9:	68 d6 00 00 00       	push   $0xd6
c00226be:	e9 61 f6 ff ff       	jmp    c0021d24 <intr_entry>

c00226c3 <intrd7_stub>:
c00226c3:	55                   	push   %ebp
c00226c4:	6a 00                	push   $0x0
c00226c6:	68 d7 00 00 00       	push   $0xd7
c00226cb:	e9 54 f6 ff ff       	jmp    c0021d24 <intr_entry>

c00226d0 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c00226d0:	55                   	push   %ebp
c00226d1:	6a 00                	push   $0x0
c00226d3:	68 d8 00 00 00       	push   $0xd8
c00226d8:	e9 47 f6 ff ff       	jmp    c0021d24 <intr_entry>

c00226dd <intrd9_stub>:
c00226dd:	55                   	push   %ebp
c00226de:	6a 00                	push   $0x0
c00226e0:	68 d9 00 00 00       	push   $0xd9
c00226e5:	e9 3a f6 ff ff       	jmp    c0021d24 <intr_entry>

c00226ea <intrda_stub>:
c00226ea:	55                   	push   %ebp
c00226eb:	6a 00                	push   $0x0
c00226ed:	68 da 00 00 00       	push   $0xda
c00226f2:	e9 2d f6 ff ff       	jmp    c0021d24 <intr_entry>

c00226f7 <intrdb_stub>:
c00226f7:	55                   	push   %ebp
c00226f8:	6a 00                	push   $0x0
c00226fa:	68 db 00 00 00       	push   $0xdb
c00226ff:	e9 20 f6 ff ff       	jmp    c0021d24 <intr_entry>

c0022704 <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c0022704:	55                   	push   %ebp
c0022705:	6a 00                	push   $0x0
c0022707:	68 dc 00 00 00       	push   $0xdc
c002270c:	e9 13 f6 ff ff       	jmp    c0021d24 <intr_entry>

c0022711 <intrdd_stub>:
c0022711:	55                   	push   %ebp
c0022712:	6a 00                	push   $0x0
c0022714:	68 dd 00 00 00       	push   $0xdd
c0022719:	e9 06 f6 ff ff       	jmp    c0021d24 <intr_entry>

c002271e <intrde_stub>:
c002271e:	55                   	push   %ebp
c002271f:	6a 00                	push   $0x0
c0022721:	68 de 00 00 00       	push   $0xde
c0022726:	e9 f9 f5 ff ff       	jmp    c0021d24 <intr_entry>

c002272b <intrdf_stub>:
c002272b:	55                   	push   %ebp
c002272c:	6a 00                	push   $0x0
c002272e:	68 df 00 00 00       	push   $0xdf
c0022733:	e9 ec f5 ff ff       	jmp    c0021d24 <intr_entry>

c0022738 <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022738:	55                   	push   %ebp
c0022739:	6a 00                	push   $0x0
c002273b:	68 e0 00 00 00       	push   $0xe0
c0022740:	e9 df f5 ff ff       	jmp    c0021d24 <intr_entry>

c0022745 <intre1_stub>:
c0022745:	55                   	push   %ebp
c0022746:	6a 00                	push   $0x0
c0022748:	68 e1 00 00 00       	push   $0xe1
c002274d:	e9 d2 f5 ff ff       	jmp    c0021d24 <intr_entry>

c0022752 <intre2_stub>:
c0022752:	55                   	push   %ebp
c0022753:	6a 00                	push   $0x0
c0022755:	68 e2 00 00 00       	push   $0xe2
c002275a:	e9 c5 f5 ff ff       	jmp    c0021d24 <intr_entry>

c002275f <intre3_stub>:
c002275f:	55                   	push   %ebp
c0022760:	6a 00                	push   $0x0
c0022762:	68 e3 00 00 00       	push   $0xe3
c0022767:	e9 b8 f5 ff ff       	jmp    c0021d24 <intr_entry>

c002276c <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c002276c:	55                   	push   %ebp
c002276d:	6a 00                	push   $0x0
c002276f:	68 e4 00 00 00       	push   $0xe4
c0022774:	e9 ab f5 ff ff       	jmp    c0021d24 <intr_entry>

c0022779 <intre5_stub>:
c0022779:	55                   	push   %ebp
c002277a:	6a 00                	push   $0x0
c002277c:	68 e5 00 00 00       	push   $0xe5
c0022781:	e9 9e f5 ff ff       	jmp    c0021d24 <intr_entry>

c0022786 <intre6_stub>:
c0022786:	55                   	push   %ebp
c0022787:	6a 00                	push   $0x0
c0022789:	68 e6 00 00 00       	push   $0xe6
c002278e:	e9 91 f5 ff ff       	jmp    c0021d24 <intr_entry>

c0022793 <intre7_stub>:
c0022793:	55                   	push   %ebp
c0022794:	6a 00                	push   $0x0
c0022796:	68 e7 00 00 00       	push   $0xe7
c002279b:	e9 84 f5 ff ff       	jmp    c0021d24 <intr_entry>

c00227a0 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c00227a0:	55                   	push   %ebp
c00227a1:	6a 00                	push   $0x0
c00227a3:	68 e8 00 00 00       	push   $0xe8
c00227a8:	e9 77 f5 ff ff       	jmp    c0021d24 <intr_entry>

c00227ad <intre9_stub>:
c00227ad:	55                   	push   %ebp
c00227ae:	6a 00                	push   $0x0
c00227b0:	68 e9 00 00 00       	push   $0xe9
c00227b5:	e9 6a f5 ff ff       	jmp    c0021d24 <intr_entry>

c00227ba <intrea_stub>:
c00227ba:	55                   	push   %ebp
c00227bb:	6a 00                	push   $0x0
c00227bd:	68 ea 00 00 00       	push   $0xea
c00227c2:	e9 5d f5 ff ff       	jmp    c0021d24 <intr_entry>

c00227c7 <intreb_stub>:
c00227c7:	55                   	push   %ebp
c00227c8:	6a 00                	push   $0x0
c00227ca:	68 eb 00 00 00       	push   $0xeb
c00227cf:	e9 50 f5 ff ff       	jmp    c0021d24 <intr_entry>

c00227d4 <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c00227d4:	55                   	push   %ebp
c00227d5:	6a 00                	push   $0x0
c00227d7:	68 ec 00 00 00       	push   $0xec
c00227dc:	e9 43 f5 ff ff       	jmp    c0021d24 <intr_entry>

c00227e1 <intred_stub>:
c00227e1:	55                   	push   %ebp
c00227e2:	6a 00                	push   $0x0
c00227e4:	68 ed 00 00 00       	push   $0xed
c00227e9:	e9 36 f5 ff ff       	jmp    c0021d24 <intr_entry>

c00227ee <intree_stub>:
c00227ee:	55                   	push   %ebp
c00227ef:	6a 00                	push   $0x0
c00227f1:	68 ee 00 00 00       	push   $0xee
c00227f6:	e9 29 f5 ff ff       	jmp    c0021d24 <intr_entry>

c00227fb <intref_stub>:
c00227fb:	55                   	push   %ebp
c00227fc:	6a 00                	push   $0x0
c00227fe:	68 ef 00 00 00       	push   $0xef
c0022803:	e9 1c f5 ff ff       	jmp    c0021d24 <intr_entry>

c0022808 <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0022808:	55                   	push   %ebp
c0022809:	6a 00                	push   $0x0
c002280b:	68 f0 00 00 00       	push   $0xf0
c0022810:	e9 0f f5 ff ff       	jmp    c0021d24 <intr_entry>

c0022815 <intrf1_stub>:
c0022815:	55                   	push   %ebp
c0022816:	6a 00                	push   $0x0
c0022818:	68 f1 00 00 00       	push   $0xf1
c002281d:	e9 02 f5 ff ff       	jmp    c0021d24 <intr_entry>

c0022822 <intrf2_stub>:
c0022822:	55                   	push   %ebp
c0022823:	6a 00                	push   $0x0
c0022825:	68 f2 00 00 00       	push   $0xf2
c002282a:	e9 f5 f4 ff ff       	jmp    c0021d24 <intr_entry>

c002282f <intrf3_stub>:
c002282f:	55                   	push   %ebp
c0022830:	6a 00                	push   $0x0
c0022832:	68 f3 00 00 00       	push   $0xf3
c0022837:	e9 e8 f4 ff ff       	jmp    c0021d24 <intr_entry>

c002283c <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c002283c:	55                   	push   %ebp
c002283d:	6a 00                	push   $0x0
c002283f:	68 f4 00 00 00       	push   $0xf4
c0022844:	e9 db f4 ff ff       	jmp    c0021d24 <intr_entry>

c0022849 <intrf5_stub>:
c0022849:	55                   	push   %ebp
c002284a:	6a 00                	push   $0x0
c002284c:	68 f5 00 00 00       	push   $0xf5
c0022851:	e9 ce f4 ff ff       	jmp    c0021d24 <intr_entry>

c0022856 <intrf6_stub>:
c0022856:	55                   	push   %ebp
c0022857:	6a 00                	push   $0x0
c0022859:	68 f6 00 00 00       	push   $0xf6
c002285e:	e9 c1 f4 ff ff       	jmp    c0021d24 <intr_entry>

c0022863 <intrf7_stub>:
c0022863:	55                   	push   %ebp
c0022864:	6a 00                	push   $0x0
c0022866:	68 f7 00 00 00       	push   $0xf7
c002286b:	e9 b4 f4 ff ff       	jmp    c0021d24 <intr_entry>

c0022870 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022870:	55                   	push   %ebp
c0022871:	6a 00                	push   $0x0
c0022873:	68 f8 00 00 00       	push   $0xf8
c0022878:	e9 a7 f4 ff ff       	jmp    c0021d24 <intr_entry>

c002287d <intrf9_stub>:
c002287d:	55                   	push   %ebp
c002287e:	6a 00                	push   $0x0
c0022880:	68 f9 00 00 00       	push   $0xf9
c0022885:	e9 9a f4 ff ff       	jmp    c0021d24 <intr_entry>

c002288a <intrfa_stub>:
c002288a:	55                   	push   %ebp
c002288b:	6a 00                	push   $0x0
c002288d:	68 fa 00 00 00       	push   $0xfa
c0022892:	e9 8d f4 ff ff       	jmp    c0021d24 <intr_entry>

c0022897 <intrfb_stub>:
c0022897:	55                   	push   %ebp
c0022898:	6a 00                	push   $0x0
c002289a:	68 fb 00 00 00       	push   $0xfb
c002289f:	e9 80 f4 ff ff       	jmp    c0021d24 <intr_entry>

c00228a4 <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c00228a4:	55                   	push   %ebp
c00228a5:	6a 00                	push   $0x0
c00228a7:	68 fc 00 00 00       	push   $0xfc
c00228ac:	e9 73 f4 ff ff       	jmp    c0021d24 <intr_entry>

c00228b1 <intrfd_stub>:
c00228b1:	55                   	push   %ebp
c00228b2:	6a 00                	push   $0x0
c00228b4:	68 fd 00 00 00       	push   $0xfd
c00228b9:	e9 66 f4 ff ff       	jmp    c0021d24 <intr_entry>

c00228be <intrfe_stub>:
c00228be:	55                   	push   %ebp
c00228bf:	6a 00                	push   $0x0
c00228c1:	68 fe 00 00 00       	push   $0xfe
c00228c6:	e9 59 f4 ff ff       	jmp    c0021d24 <intr_entry>

c00228cb <intrff_stub>:
c00228cb:	55                   	push   %ebp
c00228cc:	6a 00                	push   $0x0
c00228ce:	68 ff 00 00 00       	push   $0xff
c00228d3:	e9 4c f4 ff ff       	jmp    c0021d24 <intr_entry>

c00228d8 <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c00228d8:	55                   	push   %ebp
c00228d9:	89 e5                	mov    %esp,%ebp
c00228db:	83 ec 08             	sub    $0x8,%esp
  ASSERT (sema != NULL);
c00228de:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00228e2:	75 1e                	jne    c0022902 <sema_init+0x2a>
c00228e4:	83 ec 0c             	sub    $0xc,%esp
c00228e7:	68 ac f1 02 c0       	push   $0xc002f1ac
c00228ec:	68 b9 f1 02 c0       	push   $0xc002f1b9
c00228f1:	68 80 f2 02 c0       	push   $0xc002f280
c00228f6:	6a 2f                	push   $0x2f
c00228f8:	68 d0 f1 02 c0       	push   $0xc002f1d0
c00228fd:	e8 76 6e 00 00       	call   c0029778 <debug_panic>

  sema->value = value;
c0022902:	8b 45 08             	mov    0x8(%ebp),%eax
c0022905:	8b 55 0c             	mov    0xc(%ebp),%edx
c0022908:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c002290a:	8b 45 08             	mov    0x8(%ebp),%eax
c002290d:	83 c0 04             	add    $0x4,%eax
c0022910:	83 ec 0c             	sub    $0xc,%esp
c0022913:	50                   	push   %eax
c0022914:	e8 d2 70 00 00       	call   c00299eb <list_init>
c0022919:	83 c4 10             	add    $0x10,%esp
}
c002291c:	90                   	nop
c002291d:	c9                   	leave  
c002291e:	c3                   	ret    

c002291f <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c002291f:	55                   	push   %ebp
c0022920:	89 e5                	mov    %esp,%ebp
c0022922:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022925:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022929:	75 1e                	jne    c0022949 <sema_down+0x2a>
c002292b:	83 ec 0c             	sub    $0xc,%esp
c002292e:	68 ac f1 02 c0       	push   $0xc002f1ac
c0022933:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022938:	68 8c f2 02 c0       	push   $0xc002f28c
c002293d:	6a 41                	push   $0x41
c002293f:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022944:	e8 2f 6e 00 00       	call   c0029778 <debug_panic>
  ASSERT (!intr_context ());
c0022949:	e8 4d ee ff ff       	call   c002179b <intr_context>
c002294e:	83 f0 01             	xor    $0x1,%eax
c0022951:	84 c0                	test   %al,%al
c0022953:	75 1e                	jne    c0022973 <sema_down+0x54>
c0022955:	83 ec 0c             	sub    $0xc,%esp
c0022958:	68 e6 f1 02 c0       	push   $0xc002f1e6
c002295d:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022962:	68 8c f2 02 c0       	push   $0xc002f28c
c0022967:	6a 42                	push   $0x42
c0022969:	68 d0 f1 02 c0       	push   $0xc002f1d0
c002296e:	e8 05 6e 00 00       	call   c0029778 <debug_panic>

  old_level = intr_disable ();
c0022973:	e8 54 eb ff ff       	call   c00214cc <intr_disable>
c0022978:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (sema->value == 0) 
c002297b:	eb 20                	jmp    c002299d <sema_down+0x7e>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
c002297d:	e8 1d e4 ff ff       	call   c0020d9f <thread_current>
c0022982:	8d 50 28             	lea    0x28(%eax),%edx
c0022985:	8b 45 08             	mov    0x8(%ebp),%eax
c0022988:	83 c0 04             	add    $0x4,%eax
c002298b:	83 ec 08             	sub    $0x8,%esp
c002298e:	52                   	push   %edx
c002298f:	50                   	push   %eax
c0022990:	e8 36 74 00 00       	call   c0029dcb <list_push_back>
c0022995:	83 c4 10             	add    $0x10,%esp
      thread_block ();
c0022998:	e8 e2 e2 ff ff       	call   c0020c7f <thread_block>

  ASSERT (sema != NULL);
  ASSERT (!intr_context ());

  old_level = intr_disable ();
  while (sema->value == 0) 
c002299d:	8b 45 08             	mov    0x8(%ebp),%eax
c00229a0:	8b 00                	mov    (%eax),%eax
c00229a2:	85 c0                	test   %eax,%eax
c00229a4:	74 d7                	je     c002297d <sema_down+0x5e>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
      thread_block ();
    }
  sema->value--;
c00229a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00229a9:	8b 00                	mov    (%eax),%eax
c00229ab:	8d 50 ff             	lea    -0x1(%eax),%edx
c00229ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00229b1:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c00229b3:	83 ec 0c             	sub    $0xc,%esp
c00229b6:	ff 75 f4             	pushl  -0xc(%ebp)
c00229b9:	e8 b6 ea ff ff       	call   c0021474 <intr_set_level>
c00229be:	83 c4 10             	add    $0x10,%esp
}
c00229c1:	90                   	nop
c00229c2:	c9                   	leave  
c00229c3:	c3                   	ret    

c00229c4 <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c00229c4:	55                   	push   %ebp
c00229c5:	89 e5                	mov    %esp,%ebp
c00229c7:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c00229ca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00229ce:	75 1e                	jne    c00229ee <sema_try_down+0x2a>
c00229d0:	83 ec 0c             	sub    $0xc,%esp
c00229d3:	68 ac f1 02 c0       	push   $0xc002f1ac
c00229d8:	68 b9 f1 02 c0       	push   $0xc002f1b9
c00229dd:	68 98 f2 02 c0       	push   $0xc002f298
c00229e2:	6a 59                	push   $0x59
c00229e4:	68 d0 f1 02 c0       	push   $0xc002f1d0
c00229e9:	e8 8a 6d 00 00       	call   c0029778 <debug_panic>

  old_level = intr_disable ();
c00229ee:	e8 d9 ea ff ff       	call   c00214cc <intr_disable>
c00229f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (sema->value > 0) 
c00229f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00229f9:	8b 00                	mov    (%eax),%eax
c00229fb:	85 c0                	test   %eax,%eax
c00229fd:	74 13                	je     c0022a12 <sema_try_down+0x4e>
    {
      sema->value--;
c00229ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a02:	8b 00                	mov    (%eax),%eax
c0022a04:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022a07:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a0a:	89 10                	mov    %edx,(%eax)
      success = true; 
c0022a0c:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
c0022a10:	eb 04                	jmp    c0022a16 <sema_try_down+0x52>
    }
  else
    success = false;
c0022a12:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  intr_set_level (old_level);
c0022a16:	83 ec 0c             	sub    $0xc,%esp
c0022a19:	ff 75 f0             	pushl  -0x10(%ebp)
c0022a1c:	e8 53 ea ff ff       	call   c0021474 <intr_set_level>
c0022a21:	83 c4 10             	add    $0x10,%esp

  return success;
c0022a24:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c0022a28:	c9                   	leave  
c0022a29:	c3                   	ret    

c0022a2a <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c0022a2a:	55                   	push   %ebp
c0022a2b:	89 e5                	mov    %esp,%ebp
c0022a2d:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022a30:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022a34:	75 1e                	jne    c0022a54 <sema_up+0x2a>
c0022a36:	83 ec 0c             	sub    $0xc,%esp
c0022a39:	68 ac f1 02 c0       	push   $0xc002f1ac
c0022a3e:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022a43:	68 a8 f2 02 c0       	push   $0xc002f2a8
c0022a48:	6a 71                	push   $0x71
c0022a4a:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022a4f:	e8 24 6d 00 00       	call   c0029778 <debug_panic>

  old_level = intr_disable ();
c0022a54:	e8 73 ea ff ff       	call   c00214cc <intr_disable>
c0022a59:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!list_empty (&sema->waiters)) 
c0022a5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a5f:	83 c0 04             	add    $0x4,%eax
c0022a62:	83 ec 0c             	sub    $0xc,%esp
c0022a65:	50                   	push   %eax
c0022a66:	e8 08 75 00 00       	call   c0029f73 <list_empty>
c0022a6b:	83 c4 10             	add    $0x10,%esp
c0022a6e:	83 f0 01             	xor    $0x1,%eax
c0022a71:	84 c0                	test   %al,%al
c0022a73:	74 24                	je     c0022a99 <sema_up+0x6f>
    thread_unblock (list_entry (list_pop_front (&sema->waiters),
c0022a75:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a78:	83 c0 04             	add    $0x4,%eax
c0022a7b:	83 ec 0c             	sub    $0xc,%esp
c0022a7e:	50                   	push   %eax
c0022a7f:	e8 c6 73 00 00       	call   c0029e4a <list_pop_front>
c0022a84:	83 c4 10             	add    $0x10,%esp
c0022a87:	83 c0 04             	add    $0x4,%eax
c0022a8a:	83 e8 2c             	sub    $0x2c,%eax
c0022a8d:	83 ec 0c             	sub    $0xc,%esp
c0022a90:	50                   	push   %eax
c0022a91:	e8 5a e2 ff ff       	call   c0020cf0 <thread_unblock>
c0022a96:	83 c4 10             	add    $0x10,%esp
                                struct thread, elem));
  sema->value++;
c0022a99:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a9c:	8b 00                	mov    (%eax),%eax
c0022a9e:	8d 50 01             	lea    0x1(%eax),%edx
c0022aa1:	8b 45 08             	mov    0x8(%ebp),%eax
c0022aa4:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022aa6:	83 ec 0c             	sub    $0xc,%esp
c0022aa9:	ff 75 f4             	pushl  -0xc(%ebp)
c0022aac:	e8 c3 e9 ff ff       	call   c0021474 <intr_set_level>
c0022ab1:	83 c4 10             	add    $0x10,%esp
}
c0022ab4:	90                   	nop
c0022ab5:	c9                   	leave  
c0022ab6:	c3                   	ret    

c0022ab7 <sema_self_test>:
/* Self-test for semaphores that makes control "ping-pong"
   between a pair of threads.  Insert calls to printf() to see
   what's going on. */
void
sema_self_test (void) 
{
c0022ab7:	55                   	push   %ebp
c0022ab8:	89 e5                	mov    %esp,%ebp
c0022aba:	83 ec 38             	sub    $0x38,%esp
  struct semaphore sema[2];
  int i;

  printf ("Testing semaphores...");
c0022abd:	83 ec 0c             	sub    $0xc,%esp
c0022ac0:	68 f7 f1 02 c0       	push   $0xc002f1f7
c0022ac5:	e8 7b 48 00 00       	call   c0027345 <printf>
c0022aca:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[0], 0);
c0022acd:	83 ec 08             	sub    $0x8,%esp
c0022ad0:	6a 00                	push   $0x0
c0022ad2:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022ad5:	50                   	push   %eax
c0022ad6:	e8 fd fd ff ff       	call   c00228d8 <sema_init>
c0022adb:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[1], 0);
c0022ade:	83 ec 08             	sub    $0x8,%esp
c0022ae1:	6a 00                	push   $0x0
c0022ae3:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022ae6:	83 c0 14             	add    $0x14,%eax
c0022ae9:	50                   	push   %eax
c0022aea:	e8 e9 fd ff ff       	call   c00228d8 <sema_init>
c0022aef:	83 c4 10             	add    $0x10,%esp
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0022af2:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022af5:	50                   	push   %eax
c0022af6:	68 51 2b 02 c0       	push   $0xc0022b51
c0022afb:	6a 1f                	push   $0x1f
c0022afd:	68 0d f2 02 c0       	push   $0xc002f20d
c0022b02:	e8 7f e0 ff ff       	call   c0020b86 <thread_create>
c0022b07:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0022b0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022b11:	eb 25                	jmp    c0022b38 <sema_self_test+0x81>
    {
      sema_up (&sema[0]);
c0022b13:	83 ec 0c             	sub    $0xc,%esp
c0022b16:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022b19:	50                   	push   %eax
c0022b1a:	e8 0b ff ff ff       	call   c0022a2a <sema_up>
c0022b1f:	83 c4 10             	add    $0x10,%esp
      sema_down (&sema[1]);
c0022b22:	83 ec 0c             	sub    $0xc,%esp
c0022b25:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022b28:	83 c0 14             	add    $0x14,%eax
c0022b2b:	50                   	push   %eax
c0022b2c:	e8 ee fd ff ff       	call   c002291f <sema_down>
c0022b31:	83 c4 10             	add    $0x10,%esp

  printf ("Testing semaphores...");
  sema_init (&sema[0], 0);
  sema_init (&sema[1], 0);
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
  for (i = 0; i < 10; i++) 
c0022b34:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0022b38:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022b3c:	7e d5                	jle    c0022b13 <sema_self_test+0x5c>
    {
      sema_up (&sema[0]);
      sema_down (&sema[1]);
    }
  printf ("done.\n");
c0022b3e:	83 ec 0c             	sub    $0xc,%esp
c0022b41:	68 17 f2 02 c0       	push   $0xc002f217
c0022b46:	e8 e0 8d 00 00       	call   c002b92b <puts>
c0022b4b:	83 c4 10             	add    $0x10,%esp
}
c0022b4e:	90                   	nop
c0022b4f:	c9                   	leave  
c0022b50:	c3                   	ret    

c0022b51 <sema_test_helper>:

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0022b51:	55                   	push   %ebp
c0022b52:	89 e5                	mov    %esp,%ebp
c0022b54:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *sema = sema_;
c0022b57:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  for (i = 0; i < 10; i++) 
c0022b5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022b64:	eb 24                	jmp    c0022b8a <sema_test_helper+0x39>
    {
      sema_down (&sema[0]);
c0022b66:	83 ec 0c             	sub    $0xc,%esp
c0022b69:	ff 75 f0             	pushl  -0x10(%ebp)
c0022b6c:	e8 ae fd ff ff       	call   c002291f <sema_down>
c0022b71:	83 c4 10             	add    $0x10,%esp
      sema_up (&sema[1]);
c0022b74:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0022b77:	83 c0 14             	add    $0x14,%eax
c0022b7a:	83 ec 0c             	sub    $0xc,%esp
c0022b7d:	50                   	push   %eax
c0022b7e:	e8 a7 fe ff ff       	call   c0022a2a <sema_up>
c0022b83:	83 c4 10             	add    $0x10,%esp
sema_test_helper (void *sema_) 
{
  struct semaphore *sema = sema_;
  int i;

  for (i = 0; i < 10; i++) 
c0022b86:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0022b8a:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022b8e:	7e d6                	jle    c0022b66 <sema_test_helper+0x15>
    {
      sema_down (&sema[0]);
      sema_up (&sema[1]);
    }
}
c0022b90:	90                   	nop
c0022b91:	c9                   	leave  
c0022b92:	c3                   	ret    

c0022b93 <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c0022b93:	55                   	push   %ebp
c0022b94:	89 e5                	mov    %esp,%ebp
c0022b96:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022b99:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022b9d:	75 21                	jne    c0022bc0 <lock_init+0x2d>
c0022b9f:	83 ec 0c             	sub    $0xc,%esp
c0022ba2:	68 1d f2 02 c0       	push   $0xc002f21d
c0022ba7:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022bac:	68 b0 f2 02 c0       	push   $0xc002f2b0
c0022bb1:	68 b2 00 00 00       	push   $0xb2
c0022bb6:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022bbb:	e8 b8 6b 00 00       	call   c0029778 <debug_panic>

  lock->holder = NULL;
c0022bc0:	8b 45 08             	mov    0x8(%ebp),%eax
c0022bc3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c0022bc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0022bcc:	83 c0 04             	add    $0x4,%eax
c0022bcf:	83 ec 08             	sub    $0x8,%esp
c0022bd2:	6a 01                	push   $0x1
c0022bd4:	50                   	push   %eax
c0022bd5:	e8 fe fc ff ff       	call   c00228d8 <sema_init>
c0022bda:	83 c4 10             	add    $0x10,%esp
}
c0022bdd:	90                   	nop
c0022bde:	c9                   	leave  
c0022bdf:	c3                   	ret    

c0022be0 <lock_acquire>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
lock_acquire (struct lock *lock)
{
c0022be0:	55                   	push   %ebp
c0022be1:	89 e5                	mov    %esp,%ebp
c0022be3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022be6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022bea:	75 21                	jne    c0022c0d <lock_acquire+0x2d>
c0022bec:	83 ec 0c             	sub    $0xc,%esp
c0022bef:	68 1d f2 02 c0       	push   $0xc002f21d
c0022bf4:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022bf9:	68 bc f2 02 c0       	push   $0xc002f2bc
c0022bfe:	68 c3 00 00 00       	push   $0xc3
c0022c03:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022c08:	e8 6b 6b 00 00       	call   c0029778 <debug_panic>
  ASSERT (!intr_context ());
c0022c0d:	e8 89 eb ff ff       	call   c002179b <intr_context>
c0022c12:	83 f0 01             	xor    $0x1,%eax
c0022c15:	84 c0                	test   %al,%al
c0022c17:	75 21                	jne    c0022c3a <lock_acquire+0x5a>
c0022c19:	83 ec 0c             	sub    $0xc,%esp
c0022c1c:	68 e6 f1 02 c0       	push   $0xc002f1e6
c0022c21:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022c26:	68 bc f2 02 c0       	push   $0xc002f2bc
c0022c2b:	68 c4 00 00 00       	push   $0xc4
c0022c30:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022c35:	e8 3e 6b 00 00       	call   c0029778 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022c3a:	83 ec 0c             	sub    $0xc,%esp
c0022c3d:	ff 75 08             	pushl  0x8(%ebp)
c0022c40:	e8 5a 01 00 00       	call   c0022d9f <lock_held_by_current_thread>
c0022c45:	83 c4 10             	add    $0x10,%esp
c0022c48:	83 f0 01             	xor    $0x1,%eax
c0022c4b:	84 c0                	test   %al,%al
c0022c4d:	75 21                	jne    c0022c70 <lock_acquire+0x90>
c0022c4f:	83 ec 0c             	sub    $0xc,%esp
c0022c52:	68 2c f2 02 c0       	push   $0xc002f22c
c0022c57:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022c5c:	68 bc f2 02 c0       	push   $0xc002f2bc
c0022c61:	68 c5 00 00 00       	push   $0xc5
c0022c66:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022c6b:	e8 08 6b 00 00       	call   c0029778 <debug_panic>

  sema_down (&lock->semaphore);
c0022c70:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c73:	83 c0 04             	add    $0x4,%eax
c0022c76:	83 ec 0c             	sub    $0xc,%esp
c0022c79:	50                   	push   %eax
c0022c7a:	e8 a0 fc ff ff       	call   c002291f <sema_down>
c0022c7f:	83 c4 10             	add    $0x10,%esp
  lock->holder = thread_current ();
c0022c82:	e8 18 e1 ff ff       	call   c0020d9f <thread_current>
c0022c87:	89 c2                	mov    %eax,%edx
c0022c89:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c8c:	89 10                	mov    %edx,(%eax)
}
c0022c8e:	90                   	nop
c0022c8f:	c9                   	leave  
c0022c90:	c3                   	ret    

c0022c91 <lock_try_acquire>:

   This function will not sleep, so it may be called within an
   interrupt handler. */
bool
lock_try_acquire (struct lock *lock)
{
c0022c91:	55                   	push   %ebp
c0022c92:	89 e5                	mov    %esp,%ebp
c0022c94:	83 ec 18             	sub    $0x18,%esp
  bool success;

  ASSERT (lock != NULL);
c0022c97:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022c9b:	75 21                	jne    c0022cbe <lock_try_acquire+0x2d>
c0022c9d:	83 ec 0c             	sub    $0xc,%esp
c0022ca0:	68 1d f2 02 c0       	push   $0xc002f21d
c0022ca5:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022caa:	68 cc f2 02 c0       	push   $0xc002f2cc
c0022caf:	68 d6 00 00 00       	push   $0xd6
c0022cb4:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022cb9:	e8 ba 6a 00 00       	call   c0029778 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022cbe:	83 ec 0c             	sub    $0xc,%esp
c0022cc1:	ff 75 08             	pushl  0x8(%ebp)
c0022cc4:	e8 d6 00 00 00       	call   c0022d9f <lock_held_by_current_thread>
c0022cc9:	83 c4 10             	add    $0x10,%esp
c0022ccc:	83 f0 01             	xor    $0x1,%eax
c0022ccf:	84 c0                	test   %al,%al
c0022cd1:	75 21                	jne    c0022cf4 <lock_try_acquire+0x63>
c0022cd3:	83 ec 0c             	sub    $0xc,%esp
c0022cd6:	68 2c f2 02 c0       	push   $0xc002f22c
c0022cdb:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022ce0:	68 cc f2 02 c0       	push   $0xc002f2cc
c0022ce5:	68 d7 00 00 00       	push   $0xd7
c0022cea:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022cef:	e8 84 6a 00 00       	call   c0029778 <debug_panic>

  success = sema_try_down (&lock->semaphore);
c0022cf4:	8b 45 08             	mov    0x8(%ebp),%eax
c0022cf7:	83 c0 04             	add    $0x4,%eax
c0022cfa:	83 ec 0c             	sub    $0xc,%esp
c0022cfd:	50                   	push   %eax
c0022cfe:	e8 c1 fc ff ff       	call   c00229c4 <sema_try_down>
c0022d03:	83 c4 10             	add    $0x10,%esp
c0022d06:	88 45 f7             	mov    %al,-0x9(%ebp)
  if (success)
c0022d09:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0022d0d:	74 0c                	je     c0022d1b <lock_try_acquire+0x8a>
    lock->holder = thread_current ();
c0022d0f:	e8 8b e0 ff ff       	call   c0020d9f <thread_current>
c0022d14:	89 c2                	mov    %eax,%edx
c0022d16:	8b 45 08             	mov    0x8(%ebp),%eax
c0022d19:	89 10                	mov    %edx,(%eax)
  return success;
c0022d1b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c0022d1f:	c9                   	leave  
c0022d20:	c3                   	ret    

c0022d21 <lock_release>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to release a lock within an interrupt
   handler. */
void
lock_release (struct lock *lock) 
{
c0022d21:	55                   	push   %ebp
c0022d22:	89 e5                	mov    %esp,%ebp
c0022d24:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022d27:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022d2b:	75 21                	jne    c0022d4e <lock_release+0x2d>
c0022d2d:	83 ec 0c             	sub    $0xc,%esp
c0022d30:	68 1d f2 02 c0       	push   $0xc002f21d
c0022d35:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022d3a:	68 e0 f2 02 c0       	push   $0xc002f2e0
c0022d3f:	68 e7 00 00 00       	push   $0xe7
c0022d44:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022d49:	e8 2a 6a 00 00       	call   c0029778 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022d4e:	83 ec 0c             	sub    $0xc,%esp
c0022d51:	ff 75 08             	pushl  0x8(%ebp)
c0022d54:	e8 46 00 00 00       	call   c0022d9f <lock_held_by_current_thread>
c0022d59:	83 c4 10             	add    $0x10,%esp
c0022d5c:	84 c0                	test   %al,%al
c0022d5e:	75 21                	jne    c0022d81 <lock_release+0x60>
c0022d60:	83 ec 0c             	sub    $0xc,%esp
c0022d63:	68 50 f2 02 c0       	push   $0xc002f250
c0022d68:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022d6d:	68 e0 f2 02 c0       	push   $0xc002f2e0
c0022d72:	68 e8 00 00 00       	push   $0xe8
c0022d77:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022d7c:	e8 f7 69 00 00       	call   c0029778 <debug_panic>

  lock->holder = NULL;
c0022d81:	8b 45 08             	mov    0x8(%ebp),%eax
c0022d84:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_up (&lock->semaphore);
c0022d8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0022d8d:	83 c0 04             	add    $0x4,%eax
c0022d90:	83 ec 0c             	sub    $0xc,%esp
c0022d93:	50                   	push   %eax
c0022d94:	e8 91 fc ff ff       	call   c0022a2a <sema_up>
c0022d99:	83 c4 10             	add    $0x10,%esp
}
c0022d9c:	90                   	nop
c0022d9d:	c9                   	leave  
c0022d9e:	c3                   	ret    

c0022d9f <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0022d9f:	55                   	push   %ebp
c0022da0:	89 e5                	mov    %esp,%ebp
c0022da2:	53                   	push   %ebx
c0022da3:	83 ec 04             	sub    $0x4,%esp
  ASSERT (lock != NULL);
c0022da6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022daa:	75 21                	jne    c0022dcd <lock_held_by_current_thread+0x2e>
c0022dac:	83 ec 0c             	sub    $0xc,%esp
c0022daf:	68 1d f2 02 c0       	push   $0xc002f21d
c0022db4:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022db9:	68 f0 f2 02 c0       	push   $0xc002f2f0
c0022dbe:	68 f4 00 00 00       	push   $0xf4
c0022dc3:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022dc8:	e8 ab 69 00 00       	call   c0029778 <debug_panic>

  return lock->holder == thread_current ();
c0022dcd:	8b 45 08             	mov    0x8(%ebp),%eax
c0022dd0:	8b 18                	mov    (%eax),%ebx
c0022dd2:	e8 c8 df ff ff       	call   c0020d9f <thread_current>
c0022dd7:	39 c3                	cmp    %eax,%ebx
c0022dd9:	0f 94 c0             	sete   %al
}
c0022ddc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0022ddf:	c9                   	leave  
c0022de0:	c3                   	ret    

c0022de1 <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c0022de1:	55                   	push   %ebp
c0022de2:	89 e5                	mov    %esp,%ebp
c0022de4:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022de7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022deb:	75 21                	jne    c0022e0e <cond_init+0x2d>
c0022ded:	83 ec 0c             	sub    $0xc,%esp
c0022df0:	68 73 f2 02 c0       	push   $0xc002f273
c0022df5:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022dfa:	68 0c f3 02 c0       	push   $0xc002f30c
c0022dff:	68 06 01 00 00       	push   $0x106
c0022e04:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022e09:	e8 6a 69 00 00       	call   c0029778 <debug_panic>

  list_init (&cond->waiters);
c0022e0e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e11:	83 ec 0c             	sub    $0xc,%esp
c0022e14:	50                   	push   %eax
c0022e15:	e8 d1 6b 00 00       	call   c00299eb <list_init>
c0022e1a:	83 c4 10             	add    $0x10,%esp
}
c0022e1d:	90                   	nop
c0022e1e:	c9                   	leave  
c0022e1f:	c3                   	ret    

c0022e20 <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c0022e20:	55                   	push   %ebp
c0022e21:	89 e5                	mov    %esp,%ebp
c0022e23:	83 ec 28             	sub    $0x28,%esp
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0022e26:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022e2a:	75 21                	jne    c0022e4d <cond_wait+0x2d>
c0022e2c:	83 ec 0c             	sub    $0xc,%esp
c0022e2f:	68 73 f2 02 c0       	push   $0xc002f273
c0022e34:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022e39:	68 18 f3 02 c0       	push   $0xc002f318
c0022e3e:	68 24 01 00 00       	push   $0x124
c0022e43:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022e48:	e8 2b 69 00 00       	call   c0029778 <debug_panic>
  ASSERT (lock != NULL);
c0022e4d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022e51:	75 21                	jne    c0022e74 <cond_wait+0x54>
c0022e53:	83 ec 0c             	sub    $0xc,%esp
c0022e56:	68 1d f2 02 c0       	push   $0xc002f21d
c0022e5b:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022e60:	68 18 f3 02 c0       	push   $0xc002f318
c0022e65:	68 25 01 00 00       	push   $0x125
c0022e6a:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022e6f:	e8 04 69 00 00       	call   c0029778 <debug_panic>
  ASSERT (!intr_context ());
c0022e74:	e8 22 e9 ff ff       	call   c002179b <intr_context>
c0022e79:	83 f0 01             	xor    $0x1,%eax
c0022e7c:	84 c0                	test   %al,%al
c0022e7e:	75 21                	jne    c0022ea1 <cond_wait+0x81>
c0022e80:	83 ec 0c             	sub    $0xc,%esp
c0022e83:	68 e6 f1 02 c0       	push   $0xc002f1e6
c0022e88:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022e8d:	68 18 f3 02 c0       	push   $0xc002f318
c0022e92:	68 26 01 00 00       	push   $0x126
c0022e97:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022e9c:	e8 d7 68 00 00       	call   c0029778 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022ea1:	83 ec 0c             	sub    $0xc,%esp
c0022ea4:	ff 75 0c             	pushl  0xc(%ebp)
c0022ea7:	e8 f3 fe ff ff       	call   c0022d9f <lock_held_by_current_thread>
c0022eac:	83 c4 10             	add    $0x10,%esp
c0022eaf:	84 c0                	test   %al,%al
c0022eb1:	75 21                	jne    c0022ed4 <cond_wait+0xb4>
c0022eb3:	83 ec 0c             	sub    $0xc,%esp
c0022eb6:	68 50 f2 02 c0       	push   $0xc002f250
c0022ebb:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022ec0:	68 18 f3 02 c0       	push   $0xc002f318
c0022ec5:	68 27 01 00 00       	push   $0x127
c0022eca:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022ecf:	e8 a4 68 00 00       	call   c0029778 <debug_panic>
  
  sema_init (&waiter.semaphore, 0);
c0022ed4:	83 ec 08             	sub    $0x8,%esp
c0022ed7:	6a 00                	push   $0x0
c0022ed9:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0022edc:	83 c0 08             	add    $0x8,%eax
c0022edf:	50                   	push   %eax
c0022ee0:	e8 f3 f9 ff ff       	call   c00228d8 <sema_init>
c0022ee5:	83 c4 10             	add    $0x10,%esp
  list_push_back (&cond->waiters, &waiter.elem);
c0022ee8:	8b 45 08             	mov    0x8(%ebp),%eax
c0022eeb:	83 ec 08             	sub    $0x8,%esp
c0022eee:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0022ef1:	52                   	push   %edx
c0022ef2:	50                   	push   %eax
c0022ef3:	e8 d3 6e 00 00       	call   c0029dcb <list_push_back>
c0022ef8:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c0022efb:	83 ec 0c             	sub    $0xc,%esp
c0022efe:	ff 75 0c             	pushl  0xc(%ebp)
c0022f01:	e8 1b fe ff ff       	call   c0022d21 <lock_release>
c0022f06:	83 c4 10             	add    $0x10,%esp
  sema_down (&waiter.semaphore);
c0022f09:	83 ec 0c             	sub    $0xc,%esp
c0022f0c:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0022f0f:	83 c0 08             	add    $0x8,%eax
c0022f12:	50                   	push   %eax
c0022f13:	e8 07 fa ff ff       	call   c002291f <sema_down>
c0022f18:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c0022f1b:	83 ec 0c             	sub    $0xc,%esp
c0022f1e:	ff 75 0c             	pushl  0xc(%ebp)
c0022f21:	e8 ba fc ff ff       	call   c0022be0 <lock_acquire>
c0022f26:	83 c4 10             	add    $0x10,%esp
}
c0022f29:	90                   	nop
c0022f2a:	c9                   	leave  
c0022f2b:	c3                   	ret    

c0022f2c <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c0022f2c:	55                   	push   %ebp
c0022f2d:	89 e5                	mov    %esp,%ebp
c0022f2f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022f32:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022f36:	75 21                	jne    c0022f59 <cond_signal+0x2d>
c0022f38:	83 ec 0c             	sub    $0xc,%esp
c0022f3b:	68 73 f2 02 c0       	push   $0xc002f273
c0022f40:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022f45:	68 24 f3 02 c0       	push   $0xc002f324
c0022f4a:	68 3a 01 00 00       	push   $0x13a
c0022f4f:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022f54:	e8 1f 68 00 00       	call   c0029778 <debug_panic>
  ASSERT (lock != NULL);
c0022f59:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022f5d:	75 21                	jne    c0022f80 <cond_signal+0x54>
c0022f5f:	83 ec 0c             	sub    $0xc,%esp
c0022f62:	68 1d f2 02 c0       	push   $0xc002f21d
c0022f67:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022f6c:	68 24 f3 02 c0       	push   $0xc002f324
c0022f71:	68 3b 01 00 00       	push   $0x13b
c0022f76:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022f7b:	e8 f8 67 00 00       	call   c0029778 <debug_panic>
  ASSERT (!intr_context ());
c0022f80:	e8 16 e8 ff ff       	call   c002179b <intr_context>
c0022f85:	83 f0 01             	xor    $0x1,%eax
c0022f88:	84 c0                	test   %al,%al
c0022f8a:	75 21                	jne    c0022fad <cond_signal+0x81>
c0022f8c:	83 ec 0c             	sub    $0xc,%esp
c0022f8f:	68 e6 f1 02 c0       	push   $0xc002f1e6
c0022f94:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022f99:	68 24 f3 02 c0       	push   $0xc002f324
c0022f9e:	68 3c 01 00 00       	push   $0x13c
c0022fa3:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022fa8:	e8 cb 67 00 00       	call   c0029778 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022fad:	83 ec 0c             	sub    $0xc,%esp
c0022fb0:	ff 75 0c             	pushl  0xc(%ebp)
c0022fb3:	e8 e7 fd ff ff       	call   c0022d9f <lock_held_by_current_thread>
c0022fb8:	83 c4 10             	add    $0x10,%esp
c0022fbb:	84 c0                	test   %al,%al
c0022fbd:	75 21                	jne    c0022fe0 <cond_signal+0xb4>
c0022fbf:	83 ec 0c             	sub    $0xc,%esp
c0022fc2:	68 50 f2 02 c0       	push   $0xc002f250
c0022fc7:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0022fcc:	68 24 f3 02 c0       	push   $0xc002f324
c0022fd1:	68 3d 01 00 00       	push   $0x13d
c0022fd6:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0022fdb:	e8 98 67 00 00       	call   c0029778 <debug_panic>

  if (!list_empty (&cond->waiters)) 
c0022fe0:	8b 45 08             	mov    0x8(%ebp),%eax
c0022fe3:	83 ec 0c             	sub    $0xc,%esp
c0022fe6:	50                   	push   %eax
c0022fe7:	e8 87 6f 00 00       	call   c0029f73 <list_empty>
c0022fec:	83 c4 10             	add    $0x10,%esp
c0022fef:	83 f0 01             	xor    $0x1,%eax
c0022ff2:	84 c0                	test   %al,%al
c0022ff4:	74 24                	je     c002301a <cond_signal+0xee>
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c0022ff6:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ff9:	83 ec 0c             	sub    $0xc,%esp
c0022ffc:	50                   	push   %eax
c0022ffd:	e8 48 6e 00 00       	call   c0029e4a <list_pop_front>
c0023002:	83 c4 10             	add    $0x10,%esp
c0023005:	83 c0 04             	add    $0x4,%eax
c0023008:	83 e8 04             	sub    $0x4,%eax
c002300b:	83 c0 08             	add    $0x8,%eax
c002300e:	83 ec 0c             	sub    $0xc,%esp
c0023011:	50                   	push   %eax
c0023012:	e8 13 fa ff ff       	call   c0022a2a <sema_up>
c0023017:	83 c4 10             	add    $0x10,%esp
                          struct semaphore_elem, elem)->semaphore);
}
c002301a:	90                   	nop
c002301b:	c9                   	leave  
c002301c:	c3                   	ret    

c002301d <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c002301d:	55                   	push   %ebp
c002301e:	89 e5                	mov    %esp,%ebp
c0023020:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0023023:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023027:	75 21                	jne    c002304a <cond_broadcast+0x2d>
c0023029:	83 ec 0c             	sub    $0xc,%esp
c002302c:	68 73 f2 02 c0       	push   $0xc002f273
c0023031:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0023036:	68 30 f3 02 c0       	push   $0xc002f330
c002303b:	68 4d 01 00 00       	push   $0x14d
c0023040:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0023045:	e8 2e 67 00 00       	call   c0029778 <debug_panic>
  ASSERT (lock != NULL);
c002304a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002304e:	75 32                	jne    c0023082 <cond_broadcast+0x65>
c0023050:	83 ec 0c             	sub    $0xc,%esp
c0023053:	68 1d f2 02 c0       	push   $0xc002f21d
c0023058:	68 b9 f1 02 c0       	push   $0xc002f1b9
c002305d:	68 30 f3 02 c0       	push   $0xc002f330
c0023062:	68 4e 01 00 00       	push   $0x14e
c0023067:	68 d0 f1 02 c0       	push   $0xc002f1d0
c002306c:	e8 07 67 00 00       	call   c0029778 <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c0023071:	83 ec 08             	sub    $0x8,%esp
c0023074:	ff 75 0c             	pushl  0xc(%ebp)
c0023077:	ff 75 08             	pushl  0x8(%ebp)
c002307a:	e8 ad fe ff ff       	call   c0022f2c <cond_signal>
c002307f:	83 c4 10             	add    $0x10,%esp
cond_broadcast (struct condition *cond, struct lock *lock) 
{
  ASSERT (cond != NULL);
  ASSERT (lock != NULL);

  while (!list_empty (&cond->waiters))
c0023082:	8b 45 08             	mov    0x8(%ebp),%eax
c0023085:	83 ec 0c             	sub    $0xc,%esp
c0023088:	50                   	push   %eax
c0023089:	e8 e5 6e 00 00       	call   c0029f73 <list_empty>
c002308e:	83 c4 10             	add    $0x10,%esp
c0023091:	83 f0 01             	xor    $0x1,%eax
c0023094:	84 c0                	test   %al,%al
c0023096:	75 d9                	jne    c0023071 <cond_broadcast+0x54>
    cond_signal (cond, lock);
}
c0023098:	90                   	nop
c0023099:	c9                   	leave  
c002309a:	c3                   	ret    

c002309b <pg_ofs>:
c002309b:	55                   	push   %ebp
c002309c:	89 e5                	mov    %esp,%ebp
c002309e:	8b 45 08             	mov    0x8(%ebp),%eax
c00230a1:	25 ff 0f 00 00       	and    $0xfff,%eax
c00230a6:	5d                   	pop    %ebp
c00230a7:	c3                   	ret    

c00230a8 <pg_no>:
c00230a8:	55                   	push   %ebp
c00230a9:	89 e5                	mov    %esp,%ebp
c00230ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00230ae:	c1 e8 0c             	shr    $0xc,%eax
c00230b1:	5d                   	pop    %ebp
c00230b2:	c3                   	ret    

c00230b3 <ptov>:
c00230b3:	55                   	push   %ebp
c00230b4:	89 e5                	mov    %esp,%ebp
c00230b6:	83 ec 08             	sub    $0x8,%esp
c00230b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00230bc:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00230c1:	76 1e                	jbe    c00230e1 <ptov+0x2e>
c00230c3:	83 ec 0c             	sub    $0xc,%esp
c00230c6:	68 40 f3 02 c0       	push   $0xc002f340
c00230cb:	68 5b f3 02 c0       	push   $0xc002f35b
c00230d0:	68 78 f4 02 c0       	push   $0xc002f478
c00230d5:	6a 4a                	push   $0x4a
c00230d7:	68 72 f3 02 c0       	push   $0xc002f372
c00230dc:	e8 97 66 00 00       	call   c0029778 <debug_panic>
c00230e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00230e4:	2d 00 00 00 40       	sub    $0x40000000,%eax
c00230e9:	c9                   	leave  
c00230ea:	c3                   	ret    

c00230eb <palloc_init>:
c00230eb:	55                   	push   %ebp
c00230ec:	89 e5                	mov    %esp,%ebp
c00230ee:	83 ec 28             	sub    $0x28,%esp
c00230f1:	83 ec 0c             	sub    $0xc,%esp
c00230f4:	68 00 00 10 00       	push   $0x100000
c00230f9:	e8 b5 ff ff ff       	call   c00230b3 <ptov>
c00230fe:	83 c4 10             	add    $0x10,%esp
c0023101:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023104:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c0023109:	c1 e0 0c             	shl    $0xc,%eax
c002310c:	83 ec 0c             	sub    $0xc,%esp
c002310f:	50                   	push   %eax
c0023110:	e8 9e ff ff ff       	call   c00230b3 <ptov>
c0023115:	83 c4 10             	add    $0x10,%esp
c0023118:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002311b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002311e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023121:	29 c2                	sub    %eax,%edx
c0023123:	89 d0                	mov    %edx,%eax
c0023125:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
c002312b:	85 c0                	test   %eax,%eax
c002312d:	0f 48 c2             	cmovs  %edx,%eax
c0023130:	c1 f8 0c             	sar    $0xc,%eax
c0023133:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0023136:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023139:	d1 e8                	shr    %eax
c002313b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002313e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023141:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023144:	76 06                	jbe    c002314c <palloc_init+0x61>
c0023146:	8b 45 08             	mov    0x8(%ebp),%eax
c0023149:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002314c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002314f:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0023152:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0023155:	68 88 f3 02 c0       	push   $0xc002f388
c002315a:	ff 75 e4             	pushl  -0x1c(%ebp)
c002315d:	ff 75 f0             	pushl  -0x10(%ebp)
c0023160:	68 c0 96 03 c0       	push   $0xc00396c0
c0023165:	e8 6e 02 00 00       	call   c00233d8 <init_pool>
c002316a:	83 c4 10             	add    $0x10,%esp
c002316d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023170:	c1 e0 0c             	shl    $0xc,%eax
c0023173:	89 c2                	mov    %eax,%edx
c0023175:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023178:	01 d0                	add    %edx,%eax
c002317a:	68 94 f3 02 c0       	push   $0xc002f394
c002317f:	ff 75 f4             	pushl  -0xc(%ebp)
c0023182:	50                   	push   %eax
c0023183:	68 e0 96 03 c0       	push   $0xc00396e0
c0023188:	e8 4b 02 00 00       	call   c00233d8 <init_pool>
c002318d:	83 c4 10             	add    $0x10,%esp
c0023190:	90                   	nop
c0023191:	c9                   	leave  
c0023192:	c3                   	ret    

c0023193 <palloc_get_multiple>:
c0023193:	55                   	push   %ebp
c0023194:	89 e5                	mov    %esp,%ebp
c0023196:	83 ec 18             	sub    $0x18,%esp
c0023199:	8b 45 08             	mov    0x8(%ebp),%eax
c002319c:	83 e0 04             	and    $0x4,%eax
c002319f:	85 c0                	test   %eax,%eax
c00231a1:	74 07                	je     c00231aa <palloc_get_multiple+0x17>
c00231a3:	b8 e0 96 03 c0       	mov    $0xc00396e0,%eax
c00231a8:	eb 05                	jmp    c00231af <palloc_get_multiple+0x1c>
c00231aa:	b8 c0 96 03 c0       	mov    $0xc00396c0,%eax
c00231af:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00231b2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00231b6:	75 0a                	jne    c00231c2 <palloc_get_multiple+0x2f>
c00231b8:	b8 00 00 00 00       	mov    $0x0,%eax
c00231bd:	e9 a3 00 00 00       	jmp    c0023265 <palloc_get_multiple+0xd2>
c00231c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00231c5:	83 ec 0c             	sub    $0xc,%esp
c00231c8:	50                   	push   %eax
c00231c9:	e8 12 fa ff ff       	call   c0022be0 <lock_acquire>
c00231ce:	83 c4 10             	add    $0x10,%esp
c00231d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00231d4:	8b 40 18             	mov    0x18(%eax),%eax
c00231d7:	6a 00                	push   $0x0
c00231d9:	ff 75 0c             	pushl  0xc(%ebp)
c00231dc:	6a 00                	push   $0x0
c00231de:	50                   	push   %eax
c00231df:	e8 c3 7c 00 00       	call   c002aea7 <bitmap_scan_and_flip>
c00231e4:	83 c4 10             	add    $0x10,%esp
c00231e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
c00231ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00231ed:	83 ec 0c             	sub    $0xc,%esp
c00231f0:	50                   	push   %eax
c00231f1:	e8 2b fb ff ff       	call   c0022d21 <lock_release>
c00231f6:	83 c4 10             	add    $0x10,%esp
c00231f9:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00231fd:	74 13                	je     c0023212 <palloc_get_multiple+0x7f>
c00231ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023202:	8b 40 1c             	mov    0x1c(%eax),%eax
c0023205:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023208:	c1 e2 0c             	shl    $0xc,%edx
c002320b:	01 d0                	add    %edx,%eax
c002320d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023210:	eb 07                	jmp    c0023219 <palloc_get_multiple+0x86>
c0023212:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023219:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002321d:	74 23                	je     c0023242 <palloc_get_multiple+0xaf>
c002321f:	8b 45 08             	mov    0x8(%ebp),%eax
c0023222:	83 e0 02             	and    $0x2,%eax
c0023225:	85 c0                	test   %eax,%eax
c0023227:	74 39                	je     c0023262 <palloc_get_multiple+0xcf>
c0023229:	8b 45 0c             	mov    0xc(%ebp),%eax
c002322c:	c1 e0 0c             	shl    $0xc,%eax
c002322f:	83 ec 04             	sub    $0x4,%esp
c0023232:	50                   	push   %eax
c0023233:	6a 00                	push   $0x0
c0023235:	ff 75 f4             	pushl  -0xc(%ebp)
c0023238:	e8 2f 59 00 00       	call   c0028b6c <memset>
c002323d:	83 c4 10             	add    $0x10,%esp
c0023240:	eb 20                	jmp    c0023262 <palloc_get_multiple+0xcf>
c0023242:	8b 45 08             	mov    0x8(%ebp),%eax
c0023245:	83 e0 01             	and    $0x1,%eax
c0023248:	85 c0                	test   %eax,%eax
c002324a:	74 16                	je     c0023262 <palloc_get_multiple+0xcf>
c002324c:	68 9e f3 02 c0       	push   $0xc002f39e
c0023251:	68 80 f4 02 c0       	push   $0xc002f480
c0023256:	6a 61                	push   $0x61
c0023258:	68 b7 f3 02 c0       	push   $0xc002f3b7
c002325d:	e8 16 65 00 00       	call   c0029778 <debug_panic>
c0023262:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023265:	c9                   	leave  
c0023266:	c3                   	ret    

c0023267 <palloc_get_page>:
c0023267:	55                   	push   %ebp
c0023268:	89 e5                	mov    %esp,%ebp
c002326a:	83 ec 08             	sub    $0x8,%esp
c002326d:	83 ec 08             	sub    $0x8,%esp
c0023270:	6a 01                	push   $0x1
c0023272:	ff 75 08             	pushl  0x8(%ebp)
c0023275:	e8 19 ff ff ff       	call   c0023193 <palloc_get_multiple>
c002327a:	83 c4 10             	add    $0x10,%esp
c002327d:	c9                   	leave  
c002327e:	c3                   	ret    

c002327f <palloc_free_multiple>:
c002327f:	55                   	push   %ebp
c0023280:	89 e5                	mov    %esp,%ebp
c0023282:	53                   	push   %ebx
c0023283:	83 ec 14             	sub    $0x14,%esp
c0023286:	ff 75 08             	pushl  0x8(%ebp)
c0023289:	e8 0d fe ff ff       	call   c002309b <pg_ofs>
c002328e:	83 c4 04             	add    $0x4,%esp
c0023291:	85 c0                	test   %eax,%eax
c0023293:	74 1e                	je     c00232b3 <palloc_free_multiple+0x34>
c0023295:	83 ec 0c             	sub    $0xc,%esp
c0023298:	68 ce f3 02 c0       	push   $0xc002f3ce
c002329d:	68 5b f3 02 c0       	push   $0xc002f35b
c00232a2:	68 94 f4 02 c0       	push   $0xc002f494
c00232a7:	6a 7b                	push   $0x7b
c00232a9:	68 b7 f3 02 c0       	push   $0xc002f3b7
c00232ae:	e8 c5 64 00 00       	call   c0029778 <debug_panic>
c00232b3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00232b7:	0f 84 fc 00 00 00    	je     c00233b9 <palloc_free_multiple+0x13a>
c00232bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00232c1:	0f 84 f2 00 00 00    	je     c00233b9 <palloc_free_multiple+0x13a>
c00232c7:	83 ec 08             	sub    $0x8,%esp
c00232ca:	ff 75 08             	pushl  0x8(%ebp)
c00232cd:	68 c0 96 03 c0       	push   $0xc00396c0
c00232d2:	e8 a8 01 00 00       	call   c002347f <page_from_pool>
c00232d7:	83 c4 10             	add    $0x10,%esp
c00232da:	84 c0                	test   %al,%al
c00232dc:	74 09                	je     c00232e7 <palloc_free_multiple+0x68>
c00232de:	c7 45 f4 c0 96 03 c0 	movl   $0xc00396c0,-0xc(%ebp)
c00232e5:	eb 39                	jmp    c0023320 <palloc_free_multiple+0xa1>
c00232e7:	83 ec 08             	sub    $0x8,%esp
c00232ea:	ff 75 08             	pushl  0x8(%ebp)
c00232ed:	68 e0 96 03 c0       	push   $0xc00396e0
c00232f2:	e8 88 01 00 00       	call   c002347f <page_from_pool>
c00232f7:	83 c4 10             	add    $0x10,%esp
c00232fa:	84 c0                	test   %al,%al
c00232fc:	74 09                	je     c0023307 <palloc_free_multiple+0x88>
c00232fe:	c7 45 f4 e0 96 03 c0 	movl   $0xc00396e0,-0xc(%ebp)
c0023305:	eb 19                	jmp    c0023320 <palloc_free_multiple+0xa1>
c0023307:	68 e4 f3 02 c0       	push   $0xc002f3e4
c002330c:	68 94 f4 02 c0       	push   $0xc002f494
c0023311:	68 84 00 00 00       	push   $0x84
c0023316:	68 b7 f3 02 c0       	push   $0xc002f3b7
c002331b:	e8 58 64 00 00       	call   c0029778 <debug_panic>
c0023320:	83 ec 0c             	sub    $0xc,%esp
c0023323:	ff 75 08             	pushl  0x8(%ebp)
c0023326:	e8 7d fd ff ff       	call   c00230a8 <pg_no>
c002332b:	83 c4 10             	add    $0x10,%esp
c002332e:	89 c3                	mov    %eax,%ebx
c0023330:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023333:	8b 40 1c             	mov    0x1c(%eax),%eax
c0023336:	83 ec 0c             	sub    $0xc,%esp
c0023339:	50                   	push   %eax
c002333a:	e8 69 fd ff ff       	call   c00230a8 <pg_no>
c002333f:	83 c4 10             	add    $0x10,%esp
c0023342:	29 c3                	sub    %eax,%ebx
c0023344:	89 d8                	mov    %ebx,%eax
c0023346:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023349:	8b 45 0c             	mov    0xc(%ebp),%eax
c002334c:	c1 e0 0c             	shl    $0xc,%eax
c002334f:	83 ec 04             	sub    $0x4,%esp
c0023352:	50                   	push   %eax
c0023353:	68 cc 00 00 00       	push   $0xcc
c0023358:	ff 75 08             	pushl  0x8(%ebp)
c002335b:	e8 0c 58 00 00       	call   c0028b6c <memset>
c0023360:	83 c4 10             	add    $0x10,%esp
c0023363:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023366:	8b 40 18             	mov    0x18(%eax),%eax
c0023369:	83 ec 04             	sub    $0x4,%esp
c002336c:	ff 75 0c             	pushl  0xc(%ebp)
c002336f:	ff 75 f0             	pushl  -0x10(%ebp)
c0023372:	50                   	push   %eax
c0023373:	e8 4d 7a 00 00       	call   c002adc5 <bitmap_all>
c0023378:	83 c4 10             	add    $0x10,%esp
c002337b:	84 c0                	test   %al,%al
c002337d:	75 21                	jne    c00233a0 <palloc_free_multiple+0x121>
c002337f:	83 ec 0c             	sub    $0xc,%esp
c0023382:	68 08 f4 02 c0       	push   $0xc002f408
c0023387:	68 5b f3 02 c0       	push   $0xc002f35b
c002338c:	68 94 f4 02 c0       	push   $0xc002f494
c0023391:	68 8c 00 00 00       	push   $0x8c
c0023396:	68 b7 f3 02 c0       	push   $0xc002f3b7
c002339b:	e8 d8 63 00 00       	call   c0029778 <debug_panic>
c00233a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00233a3:	8b 40 18             	mov    0x18(%eax),%eax
c00233a6:	6a 00                	push   $0x0
c00233a8:	ff 75 0c             	pushl  0xc(%ebp)
c00233ab:	ff 75 f0             	pushl  -0x10(%ebp)
c00233ae:	50                   	push   %eax
c00233af:	e8 66 77 00 00       	call   c002ab1a <bitmap_set_multiple>
c00233b4:	83 c4 10             	add    $0x10,%esp
c00233b7:	eb 01                	jmp    c00233ba <palloc_free_multiple+0x13b>
c00233b9:	90                   	nop
c00233ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00233bd:	c9                   	leave  
c00233be:	c3                   	ret    

c00233bf <palloc_free_page>:
c00233bf:	55                   	push   %ebp
c00233c0:	89 e5                	mov    %esp,%ebp
c00233c2:	83 ec 08             	sub    $0x8,%esp
c00233c5:	83 ec 08             	sub    $0x8,%esp
c00233c8:	6a 01                	push   $0x1
c00233ca:	ff 75 08             	pushl  0x8(%ebp)
c00233cd:	e8 ad fe ff ff       	call   c002327f <palloc_free_multiple>
c00233d2:	83 c4 10             	add    $0x10,%esp
c00233d5:	90                   	nop
c00233d6:	c9                   	leave  
c00233d7:	c3                   	ret    

c00233d8 <init_pool>:
c00233d8:	55                   	push   %ebp
c00233d9:	89 e5                	mov    %esp,%ebp
c00233db:	83 ec 18             	sub    $0x18,%esp
c00233de:	83 ec 0c             	sub    $0xc,%esp
c00233e1:	ff 75 10             	pushl  0x10(%ebp)
c00233e4:	e8 c7 74 00 00       	call   c002a8b0 <bitmap_buf_size>
c00233e9:	83 c4 10             	add    $0x10,%esp
c00233ec:	05 ff 0f 00 00       	add    $0xfff,%eax
c00233f1:	c1 e8 0c             	shr    $0xc,%eax
c00233f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00233f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00233fa:	3b 45 10             	cmp    0x10(%ebp),%eax
c00233fd:	76 1f                	jbe    c002341e <init_pool+0x46>
c00233ff:	83 ec 0c             	sub    $0xc,%esp
c0023402:	ff 75 14             	pushl  0x14(%ebp)
c0023405:	68 38 f4 02 c0       	push   $0xc002f438
c002340a:	68 ac f4 02 c0       	push   $0xc002f4ac
c002340f:	68 a1 00 00 00       	push   $0xa1
c0023414:	68 b7 f3 02 c0       	push   $0xc002f3b7
c0023419:	e8 5a 63 00 00       	call   c0029778 <debug_panic>
c002341e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023421:	29 45 10             	sub    %eax,0x10(%ebp)
c0023424:	83 ec 04             	sub    $0x4,%esp
c0023427:	ff 75 14             	pushl  0x14(%ebp)
c002342a:	ff 75 10             	pushl  0x10(%ebp)
c002342d:	68 5c f4 02 c0       	push   $0xc002f45c
c0023432:	e8 0e 3f 00 00       	call   c0027345 <printf>
c0023437:	83 c4 10             	add    $0x10,%esp
c002343a:	8b 45 08             	mov    0x8(%ebp),%eax
c002343d:	83 ec 0c             	sub    $0xc,%esp
c0023440:	50                   	push   %eax
c0023441:	e8 4d f7 ff ff       	call   c0022b93 <lock_init>
c0023446:	83 c4 10             	add    $0x10,%esp
c0023449:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002344c:	c1 e0 0c             	shl    $0xc,%eax
c002344f:	83 ec 04             	sub    $0x4,%esp
c0023452:	50                   	push   %eax
c0023453:	ff 75 0c             	pushl  0xc(%ebp)
c0023456:	ff 75 10             	pushl  0x10(%ebp)
c0023459:	e8 ec 73 00 00       	call   c002a84a <bitmap_create_in_buf>
c002345e:	83 c4 10             	add    $0x10,%esp
c0023461:	89 c2                	mov    %eax,%edx
c0023463:	8b 45 08             	mov    0x8(%ebp),%eax
c0023466:	89 50 18             	mov    %edx,0x18(%eax)
c0023469:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002346c:	c1 e0 0c             	shl    $0xc,%eax
c002346f:	89 c2                	mov    %eax,%edx
c0023471:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023474:	01 c2                	add    %eax,%edx
c0023476:	8b 45 08             	mov    0x8(%ebp),%eax
c0023479:	89 50 1c             	mov    %edx,0x1c(%eax)
c002347c:	90                   	nop
c002347d:	c9                   	leave  
c002347e:	c3                   	ret    

c002347f <page_from_pool>:
c002347f:	55                   	push   %ebp
c0023480:	89 e5                	mov    %esp,%ebp
c0023482:	83 ec 18             	sub    $0x18,%esp
c0023485:	ff 75 0c             	pushl  0xc(%ebp)
c0023488:	e8 1b fc ff ff       	call   c00230a8 <pg_no>
c002348d:	83 c4 04             	add    $0x4,%esp
c0023490:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023493:	8b 45 08             	mov    0x8(%ebp),%eax
c0023496:	8b 40 1c             	mov    0x1c(%eax),%eax
c0023499:	50                   	push   %eax
c002349a:	e8 09 fc ff ff       	call   c00230a8 <pg_no>
c002349f:	83 c4 04             	add    $0x4,%esp
c00234a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00234a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00234a8:	8b 40 18             	mov    0x18(%eax),%eax
c00234ab:	83 ec 0c             	sub    $0xc,%esp
c00234ae:	50                   	push   %eax
c00234af:	e8 3e 74 00 00       	call   c002a8f2 <bitmap_size>
c00234b4:	83 c4 10             	add    $0x10,%esp
c00234b7:	89 c2                	mov    %eax,%edx
c00234b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00234bc:	01 d0                	add    %edx,%eax
c00234be:	89 45 ec             	mov    %eax,-0x14(%ebp)
c00234c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00234c4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00234c7:	72 0f                	jb     c00234d8 <page_from_pool+0x59>
c00234c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00234cc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00234cf:	73 07                	jae    c00234d8 <page_from_pool+0x59>
c00234d1:	b8 01 00 00 00       	mov    $0x1,%eax
c00234d6:	eb 05                	jmp    c00234dd <page_from_pool+0x5e>
c00234d8:	b8 00 00 00 00       	mov    $0x0,%eax
c00234dd:	83 e0 01             	and    $0x1,%eax
c00234e0:	c9                   	leave  
c00234e1:	c3                   	ret    

c00234e2 <pg_ofs>:
c00234e2:	55                   	push   %ebp
c00234e3:	89 e5                	mov    %esp,%ebp
c00234e5:	8b 45 08             	mov    0x8(%ebp),%eax
c00234e8:	25 ff 0f 00 00       	and    $0xfff,%eax
c00234ed:	5d                   	pop    %ebp
c00234ee:	c3                   	ret    

c00234ef <pg_round_down>:
c00234ef:	55                   	push   %ebp
c00234f0:	89 e5                	mov    %esp,%ebp
c00234f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00234f5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00234fa:	5d                   	pop    %ebp
c00234fb:	c3                   	ret    

c00234fc <malloc_init>:
c00234fc:	55                   	push   %ebp
c00234fd:	89 e5                	mov    %esp,%ebp
c00234ff:	83 ec 18             	sub    $0x18,%esp
c0023502:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c0023509:	e9 8b 00 00 00       	jmp    c0023599 <malloc_init+0x9d>
c002350e:	8b 15 e0 98 03 c0    	mov    0xc00398e0,%edx
c0023514:	8d 42 01             	lea    0x1(%edx),%eax
c0023517:	a3 e0 98 03 c0       	mov    %eax,0xc00398e0
c002351c:	89 d0                	mov    %edx,%eax
c002351e:	01 c0                	add    %eax,%eax
c0023520:	01 d0                	add    %edx,%eax
c0023522:	c1 e0 04             	shl    $0x4,%eax
c0023525:	05 00 97 03 c0       	add    $0xc0039700,%eax
c002352a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002352d:	a1 e0 98 03 c0       	mov    0xc00398e0,%eax
c0023532:	83 f8 0a             	cmp    $0xa,%eax
c0023535:	76 1e                	jbe    c0023555 <malloc_init+0x59>
c0023537:	83 ec 0c             	sub    $0xc,%esp
c002353a:	68 b8 f4 02 c0       	push   $0xc002f4b8
c002353f:	68 e1 f4 02 c0       	push   $0xc002f4e1
c0023544:	68 ec f5 02 c0       	push   $0xc002f5ec
c0023549:	6a 4f                	push   $0x4f
c002354b:	68 f8 f4 02 c0       	push   $0xc002f4f8
c0023550:	e8 23 62 00 00       	call   c0029778 <debug_panic>
c0023555:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023558:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002355b:	89 10                	mov    %edx,(%eax)
c002355d:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023562:	ba 00 00 00 00       	mov    $0x0,%edx
c0023567:	f7 75 f4             	divl   -0xc(%ebp)
c002356a:	89 c2                	mov    %eax,%edx
c002356c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002356f:	89 50 04             	mov    %edx,0x4(%eax)
c0023572:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023575:	83 c0 08             	add    $0x8,%eax
c0023578:	83 ec 0c             	sub    $0xc,%esp
c002357b:	50                   	push   %eax
c002357c:	e8 6a 64 00 00       	call   c00299eb <list_init>
c0023581:	83 c4 10             	add    $0x10,%esp
c0023584:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023587:	83 c0 18             	add    $0x18,%eax
c002358a:	83 ec 0c             	sub    $0xc,%esp
c002358d:	50                   	push   %eax
c002358e:	e8 00 f6 ff ff       	call   c0022b93 <lock_init>
c0023593:	83 c4 10             	add    $0x10,%esp
c0023596:	d1 65 f4             	shll   -0xc(%ebp)
c0023599:	81 7d f4 ff 07 00 00 	cmpl   $0x7ff,-0xc(%ebp)
c00235a0:	0f 86 68 ff ff ff    	jbe    c002350e <malloc_init+0x12>
c00235a6:	90                   	nop
c00235a7:	c9                   	leave  
c00235a8:	c3                   	ret    

c00235a9 <malloc>:
c00235a9:	55                   	push   %ebp
c00235aa:	89 e5                	mov    %esp,%ebp
c00235ac:	83 ec 28             	sub    $0x28,%esp
c00235af:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00235b3:	75 0a                	jne    c00235bf <malloc+0x16>
c00235b5:	b8 00 00 00 00       	mov    $0x0,%eax
c00235ba:	e9 b2 01 00 00       	jmp    c0023771 <malloc+0x1c8>
c00235bf:	c7 45 f4 00 97 03 c0 	movl   $0xc0039700,-0xc(%ebp)
c00235c6:	eb 0e                	jmp    c00235d6 <malloc+0x2d>
c00235c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00235cb:	8b 00                	mov    (%eax),%eax
c00235cd:	3b 45 08             	cmp    0x8(%ebp),%eax
c00235d0:	73 1f                	jae    c00235f1 <malloc+0x48>
c00235d2:	83 45 f4 30          	addl   $0x30,-0xc(%ebp)
c00235d6:	8b 15 e0 98 03 c0    	mov    0xc00398e0,%edx
c00235dc:	89 d0                	mov    %edx,%eax
c00235de:	01 c0                	add    %eax,%eax
c00235e0:	01 d0                	add    %edx,%eax
c00235e2:	c1 e0 04             	shl    $0x4,%eax
c00235e5:	05 00 97 03 c0       	add    $0xc0039700,%eax
c00235ea:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00235ed:	77 d9                	ja     c00235c8 <malloc+0x1f>
c00235ef:	eb 01                	jmp    c00235f2 <malloc+0x49>
c00235f1:	90                   	nop
c00235f2:	8b 15 e0 98 03 c0    	mov    0xc00398e0,%edx
c00235f8:	89 d0                	mov    %edx,%eax
c00235fa:	01 c0                	add    %eax,%eax
c00235fc:	01 d0                	add    %edx,%eax
c00235fe:	c1 e0 04             	shl    $0x4,%eax
c0023601:	05 00 97 03 c0       	add    $0xc0039700,%eax
c0023606:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023609:	75 58                	jne    c0023663 <malloc+0xba>
c002360b:	8b 45 08             	mov    0x8(%ebp),%eax
c002360e:	05 0b 10 00 00       	add    $0x100b,%eax
c0023613:	c1 e8 0c             	shr    $0xc,%eax
c0023616:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0023619:	83 ec 08             	sub    $0x8,%esp
c002361c:	ff 75 ec             	pushl  -0x14(%ebp)
c002361f:	6a 00                	push   $0x0
c0023621:	e8 6d fb ff ff       	call   c0023193 <palloc_get_multiple>
c0023626:	83 c4 10             	add    $0x10,%esp
c0023629:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002362c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023630:	75 0a                	jne    c002363c <malloc+0x93>
c0023632:	b8 00 00 00 00       	mov    $0x0,%eax
c0023637:	e9 35 01 00 00       	jmp    c0023771 <malloc+0x1c8>
c002363c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002363f:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
c0023645:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023648:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c002364f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023652:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023655:	89 50 08             	mov    %edx,0x8(%eax)
c0023658:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002365b:	83 c0 0c             	add    $0xc,%eax
c002365e:	e9 0e 01 00 00       	jmp    c0023771 <malloc+0x1c8>
c0023663:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023666:	83 c0 18             	add    $0x18,%eax
c0023669:	83 ec 0c             	sub    $0xc,%esp
c002366c:	50                   	push   %eax
c002366d:	e8 6e f5 ff ff       	call   c0022be0 <lock_acquire>
c0023672:	83 c4 10             	add    $0x10,%esp
c0023675:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023678:	83 c0 08             	add    $0x8,%eax
c002367b:	83 ec 0c             	sub    $0xc,%esp
c002367e:	50                   	push   %eax
c002367f:	e8 ef 68 00 00       	call   c0029f73 <list_empty>
c0023684:	83 c4 10             	add    $0x10,%esp
c0023687:	84 c0                	test   %al,%al
c0023689:	0f 84 92 00 00 00    	je     c0023721 <malloc+0x178>
c002368f:	83 ec 0c             	sub    $0xc,%esp
c0023692:	6a 00                	push   $0x0
c0023694:	e8 ce fb ff ff       	call   c0023267 <palloc_get_page>
c0023699:	83 c4 10             	add    $0x10,%esp
c002369c:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002369f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00236a3:	75 1c                	jne    c00236c1 <malloc+0x118>
c00236a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00236a8:	83 c0 18             	add    $0x18,%eax
c00236ab:	83 ec 0c             	sub    $0xc,%esp
c00236ae:	50                   	push   %eax
c00236af:	e8 6d f6 ff ff       	call   c0022d21 <lock_release>
c00236b4:	83 c4 10             	add    $0x10,%esp
c00236b7:	b8 00 00 00 00       	mov    $0x0,%eax
c00236bc:	e9 b0 00 00 00       	jmp    c0023771 <malloc+0x1c8>
c00236c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00236c4:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
c00236ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00236cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00236d0:	89 50 04             	mov    %edx,0x4(%eax)
c00236d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00236d6:	8b 50 04             	mov    0x4(%eax),%edx
c00236d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00236dc:	89 50 08             	mov    %edx,0x8(%eax)
c00236df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00236e6:	eb 2e                	jmp    c0023716 <malloc+0x16d>
c00236e8:	83 ec 08             	sub    $0x8,%esp
c00236eb:	ff 75 f0             	pushl  -0x10(%ebp)
c00236ee:	ff 75 e8             	pushl  -0x18(%ebp)
c00236f1:	e8 ea 03 00 00       	call   c0023ae0 <arena_to_block>
c00236f6:	83 c4 10             	add    $0x10,%esp
c00236f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c00236fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00236ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023702:	83 c2 08             	add    $0x8,%edx
c0023705:	83 ec 08             	sub    $0x8,%esp
c0023708:	50                   	push   %eax
c0023709:	52                   	push   %edx
c002370a:	e8 bc 66 00 00       	call   c0029dcb <list_push_back>
c002370f:	83 c4 10             	add    $0x10,%esp
c0023712:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0023716:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023719:	8b 40 04             	mov    0x4(%eax),%eax
c002371c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002371f:	77 c7                	ja     c00236e8 <malloc+0x13f>
c0023721:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023724:	83 c0 08             	add    $0x8,%eax
c0023727:	83 ec 0c             	sub    $0xc,%esp
c002372a:	50                   	push   %eax
c002372b:	e8 1a 67 00 00       	call   c0029e4a <list_pop_front>
c0023730:	83 c4 10             	add    $0x10,%esp
c0023733:	83 c0 04             	add    $0x4,%eax
c0023736:	83 e8 04             	sub    $0x4,%eax
c0023739:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002373c:	83 ec 0c             	sub    $0xc,%esp
c002373f:	ff 75 e0             	pushl  -0x20(%ebp)
c0023742:	e8 9b 02 00 00       	call   c00239e2 <block_to_arena>
c0023747:	83 c4 10             	add    $0x10,%esp
c002374a:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002374d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023750:	8b 40 08             	mov    0x8(%eax),%eax
c0023753:	8d 50 ff             	lea    -0x1(%eax),%edx
c0023756:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023759:	89 50 08             	mov    %edx,0x8(%eax)
c002375c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002375f:	83 c0 18             	add    $0x18,%eax
c0023762:	83 ec 0c             	sub    $0xc,%esp
c0023765:	50                   	push   %eax
c0023766:	e8 b6 f5 ff ff       	call   c0022d21 <lock_release>
c002376b:	83 c4 10             	add    $0x10,%esp
c002376e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0023771:	c9                   	leave  
c0023772:	c3                   	ret    

c0023773 <calloc>:
c0023773:	55                   	push   %ebp
c0023774:	89 e5                	mov    %esp,%ebp
c0023776:	83 ec 18             	sub    $0x18,%esp
c0023779:	8b 45 08             	mov    0x8(%ebp),%eax
c002377c:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023780:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023783:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023786:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023789:	72 08                	jb     c0023793 <calloc+0x20>
c002378b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002378e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023791:	73 07                	jae    c002379a <calloc+0x27>
c0023793:	b8 00 00 00 00       	mov    $0x0,%eax
c0023798:	eb 2d                	jmp    c00237c7 <calloc+0x54>
c002379a:	83 ec 0c             	sub    $0xc,%esp
c002379d:	ff 75 f4             	pushl  -0xc(%ebp)
c00237a0:	e8 04 fe ff ff       	call   c00235a9 <malloc>
c00237a5:	83 c4 10             	add    $0x10,%esp
c00237a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00237ab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00237af:	74 13                	je     c00237c4 <calloc+0x51>
c00237b1:	83 ec 04             	sub    $0x4,%esp
c00237b4:	ff 75 f4             	pushl  -0xc(%ebp)
c00237b7:	6a 00                	push   $0x0
c00237b9:	ff 75 f0             	pushl  -0x10(%ebp)
c00237bc:	e8 ab 53 00 00       	call   c0028b6c <memset>
c00237c1:	83 c4 10             	add    $0x10,%esp
c00237c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00237c7:	c9                   	leave  
c00237c8:	c3                   	ret    

c00237c9 <block_size>:
c00237c9:	55                   	push   %ebp
c00237ca:	89 e5                	mov    %esp,%ebp
c00237cc:	53                   	push   %ebx
c00237cd:	83 ec 14             	sub    $0x14,%esp
c00237d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00237d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00237d6:	83 ec 0c             	sub    $0xc,%esp
c00237d9:	ff 75 f4             	pushl  -0xc(%ebp)
c00237dc:	e8 01 02 00 00       	call   c00239e2 <block_to_arena>
c00237e1:	83 c4 10             	add    $0x10,%esp
c00237e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00237e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00237ea:	8b 40 04             	mov    0x4(%eax),%eax
c00237ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
c00237f0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00237f4:	74 07                	je     c00237fd <block_size+0x34>
c00237f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00237f9:	8b 00                	mov    (%eax),%eax
c00237fb:	eb 1d                	jmp    c002381a <block_size+0x51>
c00237fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023800:	8b 40 08             	mov    0x8(%eax),%eax
c0023803:	c1 e0 0c             	shl    $0xc,%eax
c0023806:	89 c3                	mov    %eax,%ebx
c0023808:	83 ec 0c             	sub    $0xc,%esp
c002380b:	ff 75 08             	pushl  0x8(%ebp)
c002380e:	e8 cf fc ff ff       	call   c00234e2 <pg_ofs>
c0023813:	83 c4 10             	add    $0x10,%esp
c0023816:	29 c3                	sub    %eax,%ebx
c0023818:	89 d8                	mov    %ebx,%eax
c002381a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002381d:	c9                   	leave  
c002381e:	c3                   	ret    

c002381f <realloc>:
c002381f:	55                   	push   %ebp
c0023820:	89 e5                	mov    %esp,%ebp
c0023822:	83 ec 18             	sub    $0x18,%esp
c0023825:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023829:	75 15                	jne    c0023840 <realloc+0x21>
c002382b:	83 ec 0c             	sub    $0xc,%esp
c002382e:	ff 75 08             	pushl  0x8(%ebp)
c0023831:	e8 6c 00 00 00       	call   c00238a2 <free>
c0023836:	83 c4 10             	add    $0x10,%esp
c0023839:	b8 00 00 00 00       	mov    $0x0,%eax
c002383e:	eb 60                	jmp    c00238a0 <realloc+0x81>
c0023840:	83 ec 0c             	sub    $0xc,%esp
c0023843:	ff 75 0c             	pushl  0xc(%ebp)
c0023846:	e8 5e fd ff ff       	call   c00235a9 <malloc>
c002384b:	83 c4 10             	add    $0x10,%esp
c002384e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023851:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023855:	74 46                	je     c002389d <realloc+0x7e>
c0023857:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002385b:	74 40                	je     c002389d <realloc+0x7e>
c002385d:	83 ec 0c             	sub    $0xc,%esp
c0023860:	ff 75 08             	pushl  0x8(%ebp)
c0023863:	e8 61 ff ff ff       	call   c00237c9 <block_size>
c0023868:	83 c4 10             	add    $0x10,%esp
c002386b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002386e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023871:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0023874:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
c0023878:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002387b:	83 ec 04             	sub    $0x4,%esp
c002387e:	ff 75 ec             	pushl  -0x14(%ebp)
c0023881:	ff 75 08             	pushl  0x8(%ebp)
c0023884:	ff 75 f4             	pushl  -0xc(%ebp)
c0023887:	e8 da 4c 00 00       	call   c0028566 <memcpy>
c002388c:	83 c4 10             	add    $0x10,%esp
c002388f:	83 ec 0c             	sub    $0xc,%esp
c0023892:	ff 75 08             	pushl  0x8(%ebp)
c0023895:	e8 08 00 00 00       	call   c00238a2 <free>
c002389a:	83 c4 10             	add    $0x10,%esp
c002389d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00238a0:	c9                   	leave  
c00238a1:	c3                   	ret    

c00238a2 <free>:
c00238a2:	55                   	push   %ebp
c00238a3:	89 e5                	mov    %esp,%ebp
c00238a5:	83 ec 28             	sub    $0x28,%esp
c00238a8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00238ac:	0f 84 2e 01 00 00    	je     c00239e0 <free+0x13e>
c00238b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00238b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00238b8:	83 ec 0c             	sub    $0xc,%esp
c00238bb:	ff 75 f0             	pushl  -0x10(%ebp)
c00238be:	e8 1f 01 00 00       	call   c00239e2 <block_to_arena>
c00238c3:	83 c4 10             	add    $0x10,%esp
c00238c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
c00238c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00238cc:	8b 40 04             	mov    0x4(%eax),%eax
c00238cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00238d2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00238d6:	0f 84 ee 00 00 00    	je     c00239ca <free+0x128>
c00238dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00238df:	8b 00                	mov    (%eax),%eax
c00238e1:	83 ec 04             	sub    $0x4,%esp
c00238e4:	50                   	push   %eax
c00238e5:	68 cc 00 00 00       	push   $0xcc
c00238ea:	ff 75 f0             	pushl  -0x10(%ebp)
c00238ed:	e8 7a 52 00 00       	call   c0028b6c <memset>
c00238f2:	83 c4 10             	add    $0x10,%esp
c00238f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00238f8:	83 c0 18             	add    $0x18,%eax
c00238fb:	83 ec 0c             	sub    $0xc,%esp
c00238fe:	50                   	push   %eax
c00238ff:	e8 dc f2 ff ff       	call   c0022be0 <lock_acquire>
c0023904:	83 c4 10             	add    $0x10,%esp
c0023907:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002390a:	8b 55 e8             	mov    -0x18(%ebp),%edx
c002390d:	83 c2 08             	add    $0x8,%edx
c0023910:	83 ec 08             	sub    $0x8,%esp
c0023913:	50                   	push   %eax
c0023914:	52                   	push   %edx
c0023915:	e8 8b 64 00 00       	call   c0029da5 <list_push_front>
c002391a:	83 c4 10             	add    $0x10,%esp
c002391d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023920:	8b 40 08             	mov    0x8(%eax),%eax
c0023923:	8d 50 01             	lea    0x1(%eax),%edx
c0023926:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023929:	89 50 08             	mov    %edx,0x8(%eax)
c002392c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002392f:	8b 50 08             	mov    0x8(%eax),%edx
c0023932:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023935:	8b 40 04             	mov    0x4(%eax),%eax
c0023938:	39 c2                	cmp    %eax,%edx
c002393a:	72 7a                	jb     c00239b6 <free+0x114>
c002393c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002393f:	8b 50 08             	mov    0x8(%eax),%edx
c0023942:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023945:	8b 40 04             	mov    0x4(%eax),%eax
c0023948:	39 c2                	cmp    %eax,%edx
c002394a:	74 21                	je     c002396d <free+0xcb>
c002394c:	83 ec 0c             	sub    $0xc,%esp
c002394f:	68 10 f5 02 c0       	push   $0xc002f510
c0023954:	68 e1 f4 02 c0       	push   $0xc002f4e1
c0023959:	68 f8 f5 02 c0       	push   $0xc002f5f8
c002395e:	68 f6 00 00 00       	push   $0xf6
c0023963:	68 f8 f4 02 c0       	push   $0xc002f4f8
c0023968:	e8 0b 5e 00 00       	call   c0029778 <debug_panic>
c002396d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023974:	eb 27                	jmp    c002399d <free+0xfb>
c0023976:	83 ec 08             	sub    $0x8,%esp
c0023979:	ff 75 f4             	pushl  -0xc(%ebp)
c002397c:	ff 75 ec             	pushl  -0x14(%ebp)
c002397f:	e8 5c 01 00 00       	call   c0023ae0 <arena_to_block>
c0023984:	83 c4 10             	add    $0x10,%esp
c0023987:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c002398a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002398d:	83 ec 0c             	sub    $0xc,%esp
c0023990:	50                   	push   %eax
c0023991:	e8 5b 64 00 00       	call   c0029df1 <list_remove>
c0023996:	83 c4 10             	add    $0x10,%esp
c0023999:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002399d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00239a0:	8b 40 04             	mov    0x4(%eax),%eax
c00239a3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00239a6:	77 ce                	ja     c0023976 <free+0xd4>
c00239a8:	83 ec 0c             	sub    $0xc,%esp
c00239ab:	ff 75 ec             	pushl  -0x14(%ebp)
c00239ae:	e8 0c fa ff ff       	call   c00233bf <palloc_free_page>
c00239b3:	83 c4 10             	add    $0x10,%esp
c00239b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00239b9:	83 c0 18             	add    $0x18,%eax
c00239bc:	83 ec 0c             	sub    $0xc,%esp
c00239bf:	50                   	push   %eax
c00239c0:	e8 5c f3 ff ff       	call   c0022d21 <lock_release>
c00239c5:	83 c4 10             	add    $0x10,%esp
c00239c8:	eb 16                	jmp    c00239e0 <free+0x13e>
c00239ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00239cd:	8b 40 08             	mov    0x8(%eax),%eax
c00239d0:	83 ec 08             	sub    $0x8,%esp
c00239d3:	50                   	push   %eax
c00239d4:	ff 75 ec             	pushl  -0x14(%ebp)
c00239d7:	e8 a3 f8 ff ff       	call   c002327f <palloc_free_multiple>
c00239dc:	83 c4 10             	add    $0x10,%esp
c00239df:	90                   	nop
c00239e0:	c9                   	leave  
c00239e1:	c3                   	ret    

c00239e2 <block_to_arena>:
c00239e2:	55                   	push   %ebp
c00239e3:	89 e5                	mov    %esp,%ebp
c00239e5:	83 ec 18             	sub    $0x18,%esp
c00239e8:	ff 75 08             	pushl  0x8(%ebp)
c00239eb:	e8 ff fa ff ff       	call   c00234ef <pg_round_down>
c00239f0:	83 c4 04             	add    $0x4,%esp
c00239f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00239f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00239fa:	75 21                	jne    c0023a1d <block_to_arena+0x3b>
c00239fc:	83 ec 0c             	sub    $0xc,%esp
c00239ff:	68 33 f5 02 c0       	push   $0xc002f533
c0023a04:	68 e1 f4 02 c0       	push   $0xc002f4e1
c0023a09:	68 00 f6 02 c0       	push   $0xc002f600
c0023a0e:	68 11 01 00 00       	push   $0x111
c0023a13:	68 f8 f4 02 c0       	push   $0xc002f4f8
c0023a18:	e8 5b 5d 00 00       	call   c0029778 <debug_panic>
c0023a1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023a20:	8b 00                	mov    (%eax),%eax
c0023a22:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0023a27:	74 21                	je     c0023a4a <block_to_arena+0x68>
c0023a29:	83 ec 0c             	sub    $0xc,%esp
c0023a2c:	68 3d f5 02 c0       	push   $0xc002f53d
c0023a31:	68 e1 f4 02 c0       	push   $0xc002f4e1
c0023a36:	68 00 f6 02 c0       	push   $0xc002f600
c0023a3b:	68 12 01 00 00       	push   $0x112
c0023a40:	68 f8 f4 02 c0       	push   $0xc002f4f8
c0023a45:	e8 2e 5d 00 00       	call   c0029778 <debug_panic>
c0023a4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023a4d:	8b 40 04             	mov    0x4(%eax),%eax
c0023a50:	85 c0                	test   %eax,%eax
c0023a52:	74 49                	je     c0023a9d <block_to_arena+0xbb>
c0023a54:	83 ec 0c             	sub    $0xc,%esp
c0023a57:	ff 75 08             	pushl  0x8(%ebp)
c0023a5a:	e8 83 fa ff ff       	call   c00234e2 <pg_ofs>
c0023a5f:	83 c4 10             	add    $0x10,%esp
c0023a62:	8d 50 f4             	lea    -0xc(%eax),%edx
c0023a65:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023a68:	8b 40 04             	mov    0x4(%eax),%eax
c0023a6b:	8b 08                	mov    (%eax),%ecx
c0023a6d:	89 d0                	mov    %edx,%eax
c0023a6f:	ba 00 00 00 00       	mov    $0x0,%edx
c0023a74:	f7 f1                	div    %ecx
c0023a76:	89 d0                	mov    %edx,%eax
c0023a78:	85 c0                	test   %eax,%eax
c0023a7a:	74 21                	je     c0023a9d <block_to_arena+0xbb>
c0023a7c:	83 ec 0c             	sub    $0xc,%esp
c0023a7f:	68 58 f5 02 c0       	push   $0xc002f558
c0023a84:	68 e1 f4 02 c0       	push   $0xc002f4e1
c0023a89:	68 00 f6 02 c0       	push   $0xc002f600
c0023a8e:	68 16 01 00 00       	push   $0x116
c0023a93:	68 f8 f4 02 c0       	push   $0xc002f4f8
c0023a98:	e8 db 5c 00 00       	call   c0029778 <debug_panic>
c0023a9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023aa0:	8b 40 04             	mov    0x4(%eax),%eax
c0023aa3:	85 c0                	test   %eax,%eax
c0023aa5:	75 34                	jne    c0023adb <block_to_arena+0xf9>
c0023aa7:	83 ec 0c             	sub    $0xc,%esp
c0023aaa:	ff 75 08             	pushl  0x8(%ebp)
c0023aad:	e8 30 fa ff ff       	call   c00234e2 <pg_ofs>
c0023ab2:	83 c4 10             	add    $0x10,%esp
c0023ab5:	83 f8 0c             	cmp    $0xc,%eax
c0023ab8:	74 21                	je     c0023adb <block_to_arena+0xf9>
c0023aba:	83 ec 0c             	sub    $0xc,%esp
c0023abd:	68 a0 f5 02 c0       	push   $0xc002f5a0
c0023ac2:	68 e1 f4 02 c0       	push   $0xc002f4e1
c0023ac7:	68 00 f6 02 c0       	push   $0xc002f600
c0023acc:	68 17 01 00 00       	push   $0x117
c0023ad1:	68 f8 f4 02 c0       	push   $0xc002f4f8
c0023ad6:	e8 9d 5c 00 00       	call   c0029778 <debug_panic>
c0023adb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023ade:	c9                   	leave  
c0023adf:	c3                   	ret    

c0023ae0 <arena_to_block>:
c0023ae0:	55                   	push   %ebp
c0023ae1:	89 e5                	mov    %esp,%ebp
c0023ae3:	83 ec 08             	sub    $0x8,%esp
c0023ae6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023aea:	75 21                	jne    c0023b0d <arena_to_block+0x2d>
c0023aec:	83 ec 0c             	sub    $0xc,%esp
c0023aef:	68 33 f5 02 c0       	push   $0xc002f533
c0023af4:	68 e1 f4 02 c0       	push   $0xc002f4e1
c0023af9:	68 10 f6 02 c0       	push   $0xc002f610
c0023afe:	68 20 01 00 00       	push   $0x120
c0023b03:	68 f8 f4 02 c0       	push   $0xc002f4f8
c0023b08:	e8 6b 5c 00 00       	call   c0029778 <debug_panic>
c0023b0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b10:	8b 00                	mov    (%eax),%eax
c0023b12:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0023b17:	74 21                	je     c0023b3a <arena_to_block+0x5a>
c0023b19:	83 ec 0c             	sub    $0xc,%esp
c0023b1c:	68 3d f5 02 c0       	push   $0xc002f53d
c0023b21:	68 e1 f4 02 c0       	push   $0xc002f4e1
c0023b26:	68 10 f6 02 c0       	push   $0xc002f610
c0023b2b:	68 21 01 00 00       	push   $0x121
c0023b30:	68 f8 f4 02 c0       	push   $0xc002f4f8
c0023b35:	e8 3e 5c 00 00       	call   c0029778 <debug_panic>
c0023b3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b3d:	8b 40 04             	mov    0x4(%eax),%eax
c0023b40:	8b 40 04             	mov    0x4(%eax),%eax
c0023b43:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023b46:	77 21                	ja     c0023b69 <arena_to_block+0x89>
c0023b48:	83 ec 0c             	sub    $0xc,%esp
c0023b4b:	68 cc f5 02 c0       	push   $0xc002f5cc
c0023b50:	68 e1 f4 02 c0       	push   $0xc002f4e1
c0023b55:	68 10 f6 02 c0       	push   $0xc002f610
c0023b5a:	68 22 01 00 00       	push   $0x122
c0023b5f:	68 f8 f4 02 c0       	push   $0xc002f4f8
c0023b64:	e8 0f 5c 00 00       	call   c0029778 <debug_panic>
c0023b69:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b6c:	8b 40 04             	mov    0x4(%eax),%eax
c0023b6f:	8b 00                	mov    (%eax),%eax
c0023b71:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023b75:	8d 50 0c             	lea    0xc(%eax),%edx
c0023b78:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b7b:	01 d0                	add    %edx,%eax
c0023b7d:	c9                   	leave  
c0023b7e:	c3                   	ret    

c0023b7f <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0023b7f:	55                   	push   %ebp
c0023b80:	89 e5                	mov    %esp,%ebp
c0023b82:	83 ec 08             	sub    $0x8,%esp
c0023b85:	8b 55 08             	mov    0x8(%ebp),%edx
c0023b88:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023b8b:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0023b8f:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0023b92:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0023b96:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0023b9a:	ee                   	out    %al,(%dx)
}
c0023b9b:	90                   	nop
c0023b9c:	c9                   	leave  
c0023b9d:	c3                   	ret    

c0023b9e <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0023b9e:	55                   	push   %ebp
c0023b9f:	89 e5                	mov    %esp,%ebp
c0023ba1:	83 ec 18             	sub    $0x18,%esp
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0023ba4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023ba8:	74 24                	je     c0023bce <pit_configure_channel+0x30>
c0023baa:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0023bae:	74 1e                	je     c0023bce <pit_configure_channel+0x30>
c0023bb0:	83 ec 0c             	sub    $0xc,%esp
c0023bb3:	68 20 f6 02 c0       	push   $0xc002f620
c0023bb8:	68 3d f6 02 c0       	push   $0xc002f63d
c0023bbd:	68 80 f6 02 c0       	push   $0xc002f680
c0023bc2:	6a 33                	push   $0x33
c0023bc4:	68 54 f6 02 c0       	push   $0xc002f654
c0023bc9:	e8 aa 5b 00 00       	call   c0029778 <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0023bce:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
c0023bd2:	74 24                	je     c0023bf8 <pit_configure_channel+0x5a>
c0023bd4:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0023bd8:	74 1e                	je     c0023bf8 <pit_configure_channel+0x5a>
c0023bda:	83 ec 0c             	sub    $0xc,%esp
c0023bdd:	68 68 f6 02 c0       	push   $0xc002f668
c0023be2:	68 3d f6 02 c0       	push   $0xc002f63d
c0023be7:	68 80 f6 02 c0       	push   $0xc002f680
c0023bec:	6a 34                	push   $0x34
c0023bee:	68 54 f6 02 c0       	push   $0xc002f654
c0023bf3:	e8 80 5b 00 00       	call   c0029778 <debug_panic>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0023bf8:	83 7d 10 12          	cmpl   $0x12,0x10(%ebp)
c0023bfc:	7f 08                	jg     c0023c06 <pit_configure_channel+0x68>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c0023bfe:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c0023c04:	eb 2a                	jmp    c0023c30 <pit_configure_channel+0x92>
    }
  else if (frequency > PIT_HZ)
c0023c06:	81 7d 10 dc 34 12 00 	cmpl   $0x1234dc,0x10(%ebp)
c0023c0d:	7e 08                	jle    c0023c17 <pit_configure_channel+0x79>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c0023c0f:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
c0023c15:	eb 19                	jmp    c0023c30 <pit_configure_channel+0x92>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0023c17:	8b 45 10             	mov    0x10(%ebp),%eax
c0023c1a:	89 c2                	mov    %eax,%edx
c0023c1c:	c1 ea 1f             	shr    $0x1f,%edx
c0023c1f:	01 d0                	add    %edx,%eax
c0023c21:	d1 f8                	sar    %eax
c0023c23:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023c28:	99                   	cltd   
c0023c29:	f7 7d 10             	idivl  0x10(%ebp)
c0023c2c:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0023c30:	e8 97 d8 ff ff       	call   c00214cc <intr_disable>
c0023c35:	89 45 f0             	mov    %eax,-0x10(%ebp)
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023c38:	8b 45 08             	mov    0x8(%ebp),%eax
c0023c3b:	c1 e0 06             	shl    $0x6,%eax
c0023c3e:	83 c8 30             	or     $0x30,%eax
c0023c41:	89 c2                	mov    %eax,%edx
c0023c43:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023c46:	01 c0                	add    %eax,%eax
c0023c48:	09 d0                	or     %edx,%eax
c0023c4a:	0f b6 c0             	movzbl %al,%eax
c0023c4d:	83 ec 08             	sub    $0x8,%esp
c0023c50:	50                   	push   %eax
c0023c51:	6a 43                	push   $0x43
c0023c53:	e8 27 ff ff ff       	call   c0023b7f <outb>
c0023c58:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count);
c0023c5b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0023c5f:	0f b6 d0             	movzbl %al,%edx
c0023c62:	8b 45 08             	mov    0x8(%ebp),%eax
c0023c65:	83 c0 40             	add    $0x40,%eax
c0023c68:	0f b7 c0             	movzwl %ax,%eax
c0023c6b:	83 ec 08             	sub    $0x8,%esp
c0023c6e:	52                   	push   %edx
c0023c6f:	50                   	push   %eax
c0023c70:	e8 0a ff ff ff       	call   c0023b7f <outb>
c0023c75:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0023c78:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0023c7c:	66 c1 e8 08          	shr    $0x8,%ax
c0023c80:	0f b6 d0             	movzbl %al,%edx
c0023c83:	8b 45 08             	mov    0x8(%ebp),%eax
c0023c86:	83 c0 40             	add    $0x40,%eax
c0023c89:	0f b7 c0             	movzwl %ax,%eax
c0023c8c:	83 ec 08             	sub    $0x8,%esp
c0023c8f:	52                   	push   %edx
c0023c90:	50                   	push   %eax
c0023c91:	e8 e9 fe ff ff       	call   c0023b7f <outb>
c0023c96:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0023c99:	83 ec 0c             	sub    $0xc,%esp
c0023c9c:	ff 75 f0             	pushl  -0x10(%ebp)
c0023c9f:	e8 d0 d7 ff ff       	call   c0021474 <intr_set_level>
c0023ca4:	83 c4 10             	add    $0x10,%esp
}
c0023ca7:	90                   	nop
c0023ca8:	c9                   	leave  
c0023ca9:	c3                   	ret    

c0023caa <timer_init>:

/* Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */
void
timer_init (void) 
{
c0023caa:	55                   	push   %ebp
c0023cab:	89 e5                	mov    %esp,%ebp
c0023cad:	83 ec 08             	sub    $0x8,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c0023cb0:	83 ec 04             	sub    $0x4,%esp
c0023cb3:	6a 64                	push   $0x64
c0023cb5:	6a 02                	push   $0x2
c0023cb7:	6a 00                	push   $0x0
c0023cb9:	e8 e0 fe ff ff       	call   c0023b9e <pit_configure_channel>
c0023cbe:	83 c4 10             	add    $0x10,%esp
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c0023cc1:	83 ec 04             	sub    $0x4,%esp
c0023cc4:	68 98 f6 02 c0       	push   $0xc002f698
c0023cc9:	68 e2 3f 02 c0       	push   $0xc0023fe2
c0023cce:	6a 20                	push   $0x20
c0023cd0:	e8 18 da ff ff       	call   c00216ed <intr_register_ext>
c0023cd5:	83 c4 10             	add    $0x10,%esp
}
c0023cd8:	90                   	nop
c0023cd9:	c9                   	leave  
c0023cda:	c3                   	ret    

c0023cdb <timer_calibrate>:

/* Calibrates loops_per_tick, used to implement brief delays. */
void
timer_calibrate (void) 
{
c0023cdb:	55                   	push   %ebp
c0023cdc:	89 e5                	mov    %esp,%ebp
c0023cde:	53                   	push   %ebx
c0023cdf:	83 ec 14             	sub    $0x14,%esp
  unsigned high_bit, test_bit;

  ASSERT (intr_get_level () == INTR_ON);
c0023ce2:	e8 70 d7 ff ff       	call   c0021457 <intr_get_level>
c0023ce7:	83 f8 01             	cmp    $0x1,%eax
c0023cea:	74 1e                	je     c0023d0a <timer_calibrate+0x2f>
c0023cec:	83 ec 0c             	sub    $0xc,%esp
c0023cef:	68 a3 f6 02 c0       	push   $0xc002f6a3
c0023cf4:	68 c0 f6 02 c0       	push   $0xc002f6c0
c0023cf9:	68 50 f7 02 c0       	push   $0xc002f750
c0023cfe:	6a 30                	push   $0x30
c0023d00:	68 d7 f6 02 c0       	push   $0xc002f6d7
c0023d05:	e8 6e 5a 00 00       	call   c0029778 <debug_panic>
  printf ("Calibrating timer...  ");
c0023d0a:	83 ec 0c             	sub    $0xc,%esp
c0023d0d:	68 ed f6 02 c0       	push   $0xc002f6ed
c0023d12:	e8 2e 36 00 00       	call   c0027345 <printf>
c0023d17:	83 c4 10             	add    $0x10,%esp

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
c0023d1a:	c7 05 f0 98 03 c0 00 	movl   $0x400,0xc00398f0
c0023d21:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0023d24:	eb 33                	jmp    c0023d59 <timer_calibrate+0x7e>
    {
      loops_per_tick <<= 1;
c0023d26:	a1 f0 98 03 c0       	mov    0xc00398f0,%eax
c0023d2b:	01 c0                	add    %eax,%eax
c0023d2d:	a3 f0 98 03 c0       	mov    %eax,0xc00398f0
      ASSERT (loops_per_tick != 0);
c0023d32:	a1 f0 98 03 c0       	mov    0xc00398f0,%eax
c0023d37:	85 c0                	test   %eax,%eax
c0023d39:	75 1e                	jne    c0023d59 <timer_calibrate+0x7e>
c0023d3b:	83 ec 0c             	sub    $0xc,%esp
c0023d3e:	68 04 f7 02 c0       	push   $0xc002f704
c0023d43:	68 c0 f6 02 c0       	push   $0xc002f6c0
c0023d48:	68 50 f7 02 c0       	push   $0xc002f750
c0023d4d:	6a 39                	push   $0x39
c0023d4f:	68 d7 f6 02 c0       	push   $0xc002f6d7
c0023d54:	e8 1f 5a 00 00       	call   c0029778 <debug_panic>
  printf ("Calibrating timer...  ");

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
  while (!too_many_loops (loops_per_tick << 1)) 
c0023d59:	a1 f0 98 03 c0       	mov    0xc00398f0,%eax
c0023d5e:	01 c0                	add    %eax,%eax
c0023d60:	83 ec 0c             	sub    $0xc,%esp
c0023d63:	50                   	push   %eax
c0023d64:	e8 bb 02 00 00       	call   c0024024 <too_many_loops>
c0023d69:	83 c4 10             	add    $0x10,%esp
c0023d6c:	83 f0 01             	xor    $0x1,%eax
c0023d6f:	84 c0                	test   %al,%al
c0023d71:	75 b3                	jne    c0023d26 <timer_calibrate+0x4b>
      loops_per_tick <<= 1;
      ASSERT (loops_per_tick != 0);
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
c0023d73:	a1 f0 98 03 c0       	mov    0xc00398f0,%eax
c0023d78:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023d7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023d7e:	d1 e8                	shr    %eax
c0023d80:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023d83:	eb 29                	jmp    c0023dae <timer_calibrate+0xd3>
    if (!too_many_loops (high_bit | test_bit))
c0023d85:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023d88:	0b 45 f4             	or     -0xc(%ebp),%eax
c0023d8b:	83 ec 0c             	sub    $0xc,%esp
c0023d8e:	50                   	push   %eax
c0023d8f:	e8 90 02 00 00       	call   c0024024 <too_many_loops>
c0023d94:	83 c4 10             	add    $0x10,%esp
c0023d97:	83 f0 01             	xor    $0x1,%eax
c0023d9a:	84 c0                	test   %al,%al
c0023d9c:	74 0d                	je     c0023dab <timer_calibrate+0xd0>
      loops_per_tick |= test_bit;
c0023d9e:	a1 f0 98 03 c0       	mov    0xc00398f0,%eax
c0023da3:	0b 45 f4             	or     -0xc(%ebp),%eax
c0023da6:	a3 f0 98 03 c0       	mov    %eax,0xc00398f0
      ASSERT (loops_per_tick != 0);
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023dab:	d1 6d f4             	shrl   -0xc(%ebp)
c0023dae:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023db1:	c1 e8 0a             	shr    $0xa,%eax
c0023db4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023db7:	75 cc                	jne    c0023d85 <timer_calibrate+0xaa>
    if (!too_many_loops (high_bit | test_bit))
      loops_per_tick |= test_bit;

  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0023db9:	a1 f0 98 03 c0       	mov    0xc00398f0,%eax
c0023dbe:	ba 00 00 00 00       	mov    $0x0,%edx
c0023dc3:	6b da 64             	imul   $0x64,%edx,%ebx
c0023dc6:	6b c8 00             	imul   $0x0,%eax,%ecx
c0023dc9:	01 d9                	add    %ebx,%ecx
c0023dcb:	bb 64 00 00 00       	mov    $0x64,%ebx
c0023dd0:	f7 e3                	mul    %ebx
c0023dd2:	01 d1                	add    %edx,%ecx
c0023dd4:	89 ca                	mov    %ecx,%edx
c0023dd6:	83 ec 04             	sub    $0x4,%esp
c0023dd9:	52                   	push   %edx
c0023dda:	50                   	push   %eax
c0023ddb:	68 18 f7 02 c0       	push   $0xc002f718
c0023de0:	e8 60 35 00 00       	call   c0027345 <printf>
c0023de5:	83 c4 10             	add    $0x10,%esp
}
c0023de8:	90                   	nop
c0023de9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023dec:	c9                   	leave  
c0023ded:	c3                   	ret    

c0023dee <timer_ticks>:

/* Returns the number of timer ticks since the OS booted. */
int64_t
timer_ticks (void) 
{
c0023dee:	55                   	push   %ebp
c0023def:	89 e5                	mov    %esp,%ebp
c0023df1:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0023df4:	e8 d3 d6 ff ff       	call   c00214cc <intr_disable>
c0023df9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t t = ticks;
c0023dfc:	a1 e8 98 03 c0       	mov    0xc00398e8,%eax
c0023e01:	8b 15 ec 98 03 c0    	mov    0xc00398ec,%edx
c0023e07:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0023e0a:	89 55 ec             	mov    %edx,-0x14(%ebp)
  intr_set_level (old_level);
c0023e0d:	83 ec 0c             	sub    $0xc,%esp
c0023e10:	ff 75 f4             	pushl  -0xc(%ebp)
c0023e13:	e8 5c d6 ff ff       	call   c0021474 <intr_set_level>
c0023e18:	83 c4 10             	add    $0x10,%esp
  return t;
c0023e1b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023e1e:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
c0023e21:	c9                   	leave  
c0023e22:	c3                   	ret    

c0023e23 <timer_elapsed>:

/* Returns the number of timer ticks elapsed since THEN, which
   should be a value once returned by timer_ticks(). */
int64_t
timer_elapsed (int64_t then) 
{
c0023e23:	55                   	push   %ebp
c0023e24:	89 e5                	mov    %esp,%ebp
c0023e26:	83 ec 18             	sub    $0x18,%esp
c0023e29:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023e32:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return timer_ticks () - then;
c0023e35:	e8 b4 ff ff ff       	call   c0023dee <timer_ticks>
c0023e3a:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0023e3d:	1b 55 f4             	sbb    -0xc(%ebp),%edx
}
c0023e40:	c9                   	leave  
c0023e41:	c3                   	ret    

c0023e42 <timer_sleep>:

/* Sleeps for approximately TICKS timer ticks.  Interrupts must
   be turned on. */
void
timer_sleep (int64_t ticks) 
{
c0023e42:	55                   	push   %ebp
c0023e43:	89 e5                	mov    %esp,%ebp
c0023e45:	83 ec 28             	sub    $0x28,%esp
c0023e48:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e4b:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0023e4e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023e51:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  int64_t start = timer_ticks ();
c0023e54:	e8 95 ff ff ff       	call   c0023dee <timer_ticks>
c0023e59:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023e5c:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c0023e5f:	e8 f3 d5 ff ff       	call   c0021457 <intr_get_level>
c0023e64:	83 f8 01             	cmp    $0x1,%eax
c0023e67:	74 23                	je     c0023e8c <timer_sleep+0x4a>
c0023e69:	83 ec 0c             	sub    $0xc,%esp
c0023e6c:	68 a3 f6 02 c0       	push   $0xc002f6a3
c0023e71:	68 c0 f6 02 c0       	push   $0xc002f6c0
c0023e76:	68 60 f7 02 c0       	push   $0xc002f760
c0023e7b:	6a 5e                	push   $0x5e
c0023e7d:	68 d7 f6 02 c0       	push   $0xc002f6d7
c0023e82:	e8 f1 58 00 00       	call   c0029778 <debug_panic>
  while (timer_elapsed (start) < ticks) 
    thread_yield ();
c0023e87:	e8 09 d0 ff ff       	call   c0020e95 <thread_yield>
timer_sleep (int64_t ticks) 
{
  int64_t start = timer_ticks ();

  ASSERT (intr_get_level () == INTR_ON);
  while (timer_elapsed (start) < ticks) 
c0023e8c:	83 ec 08             	sub    $0x8,%esp
c0023e8f:	ff 75 f4             	pushl  -0xc(%ebp)
c0023e92:	ff 75 f0             	pushl  -0x10(%ebp)
c0023e95:	e8 89 ff ff ff       	call   c0023e23 <timer_elapsed>
c0023e9a:	83 c4 10             	add    $0x10,%esp
c0023e9d:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
c0023ea0:	7c e5                	jl     c0023e87 <timer_sleep+0x45>
c0023ea2:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
c0023ea5:	7f 05                	jg     c0023eac <timer_sleep+0x6a>
c0023ea7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0023eaa:	72 db                	jb     c0023e87 <timer_sleep+0x45>
    thread_yield ();
    
  insert_on_waiting_list(ticks);
c0023eac:	83 ec 08             	sub    $0x8,%esp
c0023eaf:	ff 75 e4             	pushl  -0x1c(%ebp)
c0023eb2:	ff 75 e0             	pushl  -0x20(%ebp)
c0023eb5:	e8 73 cb ff ff       	call   c0020a2d <insert_on_waiting_list>
c0023eba:	83 c4 10             	add    $0x10,%esp
}
c0023ebd:	90                   	nop
c0023ebe:	c9                   	leave  
c0023ebf:	c3                   	ret    

c0023ec0 <timer_msleep>:

/* Sleeps for approximately MS milliseconds.  Interrupts must be
   turned on. */
void
timer_msleep (int64_t ms) 
{
c0023ec0:	55                   	push   %ebp
c0023ec1:	89 e5                	mov    %esp,%ebp
c0023ec3:	83 ec 18             	sub    $0x18,%esp
c0023ec6:	8b 45 08             	mov    0x8(%ebp),%eax
c0023ec9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023ecf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ms, 1000);
c0023ed2:	83 ec 04             	sub    $0x4,%esp
c0023ed5:	68 e8 03 00 00       	push   $0x3e8
c0023eda:	ff 75 f4             	pushl  -0xc(%ebp)
c0023edd:	ff 75 f0             	pushl  -0x10(%ebp)
c0023ee0:	e8 01 02 00 00       	call   c00240e6 <real_time_sleep>
c0023ee5:	83 c4 10             	add    $0x10,%esp
}
c0023ee8:	90                   	nop
c0023ee9:	c9                   	leave  
c0023eea:	c3                   	ret    

c0023eeb <timer_usleep>:

/* Sleeps for approximately US microseconds.  Interrupts must be
   turned on. */
void
timer_usleep (int64_t us) 
{
c0023eeb:	55                   	push   %ebp
c0023eec:	89 e5                	mov    %esp,%ebp
c0023eee:	83 ec 18             	sub    $0x18,%esp
c0023ef1:	8b 45 08             	mov    0x8(%ebp),%eax
c0023ef4:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023ef7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023efa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (us, 1000 * 1000);
c0023efd:	83 ec 04             	sub    $0x4,%esp
c0023f00:	68 40 42 0f 00       	push   $0xf4240
c0023f05:	ff 75 f4             	pushl  -0xc(%ebp)
c0023f08:	ff 75 f0             	pushl  -0x10(%ebp)
c0023f0b:	e8 d6 01 00 00       	call   c00240e6 <real_time_sleep>
c0023f10:	83 c4 10             	add    $0x10,%esp
}
c0023f13:	90                   	nop
c0023f14:	c9                   	leave  
c0023f15:	c3                   	ret    

c0023f16 <timer_nsleep>:

/* Sleeps for approximately NS nanoseconds.  Interrupts must be
   turned on. */
void
timer_nsleep (int64_t ns) 
{
c0023f16:	55                   	push   %ebp
c0023f17:	89 e5                	mov    %esp,%ebp
c0023f19:	83 ec 18             	sub    $0x18,%esp
c0023f1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023f22:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f25:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ns, 1000 * 1000 * 1000);
c0023f28:	83 ec 04             	sub    $0x4,%esp
c0023f2b:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0023f30:	ff 75 f4             	pushl  -0xc(%ebp)
c0023f33:	ff 75 f0             	pushl  -0x10(%ebp)
c0023f36:	e8 ab 01 00 00       	call   c00240e6 <real_time_sleep>
c0023f3b:	83 c4 10             	add    $0x10,%esp
}
c0023f3e:	90                   	nop
c0023f3f:	c9                   	leave  
c0023f40:	c3                   	ret    

c0023f41 <timer_mdelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_msleep()
   instead if interrupts are enabled. */
void
timer_mdelay (int64_t ms) 
{
c0023f41:	55                   	push   %ebp
c0023f42:	89 e5                	mov    %esp,%ebp
c0023f44:	83 ec 18             	sub    $0x18,%esp
c0023f47:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023f4d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f50:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ms, 1000);
c0023f53:	83 ec 04             	sub    $0x4,%esp
c0023f56:	68 e8 03 00 00       	push   $0x3e8
c0023f5b:	ff 75 f4             	pushl  -0xc(%ebp)
c0023f5e:	ff 75 f0             	pushl  -0x10(%ebp)
c0023f61:	e8 32 02 00 00       	call   c0024198 <real_time_delay>
c0023f66:	83 c4 10             	add    $0x10,%esp
}
c0023f69:	90                   	nop
c0023f6a:	c9                   	leave  
c0023f6b:	c3                   	ret    

c0023f6c <timer_udelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_usleep()
   instead if interrupts are enabled. */
void
timer_udelay (int64_t us) 
{
c0023f6c:	55                   	push   %ebp
c0023f6d:	89 e5                	mov    %esp,%ebp
c0023f6f:	83 ec 18             	sub    $0x18,%esp
c0023f72:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f75:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023f78:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (us, 1000 * 1000);
c0023f7e:	83 ec 04             	sub    $0x4,%esp
c0023f81:	68 40 42 0f 00       	push   $0xf4240
c0023f86:	ff 75 f4             	pushl  -0xc(%ebp)
c0023f89:	ff 75 f0             	pushl  -0x10(%ebp)
c0023f8c:	e8 07 02 00 00       	call   c0024198 <real_time_delay>
c0023f91:	83 c4 10             	add    $0x10,%esp
}
c0023f94:	90                   	nop
c0023f95:	c9                   	leave  
c0023f96:	c3                   	ret    

c0023f97 <timer_ndelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_nsleep()
   instead if interrupts are enabled.*/
void
timer_ndelay (int64_t ns) 
{
c0023f97:	55                   	push   %ebp
c0023f98:	89 e5                	mov    %esp,%ebp
c0023f9a:	83 ec 18             	sub    $0x18,%esp
c0023f9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0023fa0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023fa3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023fa6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ns, 1000 * 1000 * 1000);
c0023fa9:	83 ec 04             	sub    $0x4,%esp
c0023fac:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0023fb1:	ff 75 f4             	pushl  -0xc(%ebp)
c0023fb4:	ff 75 f0             	pushl  -0x10(%ebp)
c0023fb7:	e8 dc 01 00 00       	call   c0024198 <real_time_delay>
c0023fbc:	83 c4 10             	add    $0x10,%esp
}
c0023fbf:	90                   	nop
c0023fc0:	c9                   	leave  
c0023fc1:	c3                   	ret    

c0023fc2 <timer_print_stats>:

/* Prints timer statistics. */
void
timer_print_stats (void) 
{
c0023fc2:	55                   	push   %ebp
c0023fc3:	89 e5                	mov    %esp,%ebp
c0023fc5:	83 ec 08             	sub    $0x8,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c0023fc8:	e8 21 fe ff ff       	call   c0023dee <timer_ticks>
c0023fcd:	83 ec 04             	sub    $0x4,%esp
c0023fd0:	52                   	push   %edx
c0023fd1:	50                   	push   %eax
c0023fd2:	68 28 f7 02 c0       	push   $0xc002f728
c0023fd7:	e8 69 33 00 00       	call   c0027345 <printf>
c0023fdc:	83 c4 10             	add    $0x10,%esp
}
c0023fdf:	90                   	nop
c0023fe0:	c9                   	leave  
c0023fe1:	c3                   	ret    

c0023fe2 <timer_interrupt>:

/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{
c0023fe2:	55                   	push   %ebp
c0023fe3:	89 e5                	mov    %esp,%ebp
c0023fe5:	83 ec 08             	sub    $0x8,%esp
  ticks++;
c0023fe8:	a1 e8 98 03 c0       	mov    0xc00398e8,%eax
c0023fed:	8b 15 ec 98 03 c0    	mov    0xc00398ec,%edx
c0023ff3:	83 c0 01             	add    $0x1,%eax
c0023ff6:	83 d2 00             	adc    $0x0,%edx
c0023ff9:	a3 e8 98 03 c0       	mov    %eax,0xc00398e8
c0023ffe:	89 15 ec 98 03 c0    	mov    %edx,0xc00398ec
  thread_tick ();
c0024004:	e8 b3 c9 ff ff       	call   c00209bc <thread_tick>
  
  remove_sleepingThread(ticks);
c0024009:	a1 e8 98 03 c0       	mov    0xc00398e8,%eax
c002400e:	8b 15 ec 98 03 c0    	mov    0xc00398ec,%edx
c0024014:	83 ec 08             	sub    $0x8,%esp
c0024017:	52                   	push   %edx
c0024018:	50                   	push   %eax
c0024019:	e8 81 ca ff ff       	call   c0020a9f <remove_sleepingThread>
c002401e:	83 c4 10             	add    $0x10,%esp
}
c0024021:	90                   	nop
c0024022:	c9                   	leave  
c0024023:	c3                   	ret    

c0024024 <too_many_loops>:

/* Returns true if LOOPS iterations waits for more than one timer
   tick, otherwise false. */
static bool
too_many_loops (unsigned loops) 
{
c0024024:	55                   	push   %ebp
c0024025:	89 e5                	mov    %esp,%ebp
c0024027:	56                   	push   %esi
c0024028:	53                   	push   %ebx
c0024029:	83 ec 10             	sub    $0x10,%esp
  /* Wait for a timer tick. */
  int64_t start = ticks;
c002402c:	a1 e8 98 03 c0       	mov    0xc00398e8,%eax
c0024031:	8b 15 ec 98 03 c0    	mov    0xc00398ec,%edx
c0024037:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002403a:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (ticks == start)
c002403d:	eb 00                	jmp    c002403f <too_many_loops+0x1b>
c002403f:	a1 e8 98 03 c0       	mov    0xc00398e8,%eax
c0024044:	8b 15 ec 98 03 c0    	mov    0xc00398ec,%edx
c002404a:	89 d1                	mov    %edx,%ecx
c002404c:	33 4d f4             	xor    -0xc(%ebp),%ecx
c002404f:	33 45 f0             	xor    -0x10(%ebp),%eax
c0024052:	09 c8                	or     %ecx,%eax
c0024054:	85 c0                	test   %eax,%eax
c0024056:	74 e7                	je     c002403f <too_many_loops+0x1b>
    barrier ();

  /* Run LOOPS loops. */
  start = ticks;
c0024058:	a1 e8 98 03 c0       	mov    0xc00398e8,%eax
c002405d:	8b 15 ec 98 03 c0    	mov    0xc00398ec,%edx
c0024063:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024066:	89 55 f4             	mov    %edx,-0xc(%ebp)
  busy_wait (loops);
c0024069:	8b 45 08             	mov    0x8(%ebp),%eax
c002406c:	ba 00 00 00 00       	mov    $0x0,%edx
c0024071:	83 ec 08             	sub    $0x8,%esp
c0024074:	52                   	push   %edx
c0024075:	50                   	push   %eax
c0024076:	e8 2c 00 00 00       	call   c00240a7 <busy_wait>
c002407b:	83 c4 10             	add    $0x10,%esp

  /* If the tick count changed, we iterated too long. */
  barrier ();
  return start != ticks;
c002407e:	a1 e8 98 03 c0       	mov    0xc00398e8,%eax
c0024083:	8b 15 ec 98 03 c0    	mov    0xc00398ec,%edx
c0024089:	89 c1                	mov    %eax,%ecx
c002408b:	33 4d f0             	xor    -0x10(%ebp),%ecx
c002408e:	89 cb                	mov    %ecx,%ebx
c0024090:	89 d0                	mov    %edx,%eax
c0024092:	33 45 f4             	xor    -0xc(%ebp),%eax
c0024095:	89 c6                	mov    %eax,%esi
c0024097:	89 d8                	mov    %ebx,%eax
c0024099:	09 f0                	or     %esi,%eax
c002409b:	85 c0                	test   %eax,%eax
c002409d:	0f 95 c0             	setne  %al
}
c00240a0:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00240a3:	5b                   	pop    %ebx
c00240a4:	5e                   	pop    %esi
c00240a5:	5d                   	pop    %ebp
c00240a6:	c3                   	ret    

c00240a7 <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c00240a7:	55                   	push   %ebp
c00240a8:	89 e5                	mov    %esp,%ebp
c00240aa:	53                   	push   %ebx
c00240ab:	83 ec 0c             	sub    $0xc,%esp
c00240ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00240b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00240b4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00240b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (loops-- > 0)
c00240ba:	eb 00                	jmp    c00240bc <busy_wait+0x15>
c00240bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00240bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00240c2:	89 c1                	mov    %eax,%ecx
c00240c4:	89 d3                	mov    %edx,%ebx
c00240c6:	83 c1 ff             	add    $0xffffffff,%ecx
c00240c9:	83 d3 ff             	adc    $0xffffffff,%ebx
c00240cc:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c00240cf:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c00240d2:	85 d2                	test   %edx,%edx
c00240d4:	7f e6                	jg     c00240bc <busy_wait+0x15>
c00240d6:	85 d2                	test   %edx,%edx
c00240d8:	78 05                	js     c00240df <busy_wait+0x38>
c00240da:	83 f8 00             	cmp    $0x0,%eax
c00240dd:	77 dd                	ja     c00240bc <busy_wait+0x15>
    barrier ();
}
c00240df:	90                   	nop
c00240e0:	83 c4 0c             	add    $0xc,%esp
c00240e3:	5b                   	pop    %ebx
c00240e4:	5d                   	pop    %ebp
c00240e5:	c3                   	ret    

c00240e6 <real_time_sleep>:

/* Sleep for approximately NUM/DENOM seconds. */
static void
real_time_sleep (int64_t num, int32_t denom) 
{
c00240e6:	55                   	push   %ebp
c00240e7:	89 e5                	mov    %esp,%ebp
c00240e9:	53                   	push   %ebx
c00240ea:	83 ec 24             	sub    $0x24,%esp
c00240ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00240f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00240f3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00240f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          
        (NUM / DENOM) s          
     ---------------------- = NUM * TIMER_FREQ / DENOM ticks. 
     1 s / TIMER_FREQ ticks
  */
  int64_t ticks = num * TIMER_FREQ / denom;
c00240f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00240fc:	6b d0 64             	imul   $0x64,%eax,%edx
c00240ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0024102:	6b c0 00             	imul   $0x0,%eax,%eax
c0024105:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0024108:	b8 64 00 00 00       	mov    $0x64,%eax
c002410d:	f7 65 e0             	mull   -0x20(%ebp)
c0024110:	01 d1                	add    %edx,%ecx
c0024112:	89 ca                	mov    %ecx,%edx
c0024114:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0024117:	89 cb                	mov    %ecx,%ebx
c0024119:	c1 fb 1f             	sar    $0x1f,%ebx
c002411c:	53                   	push   %ebx
c002411d:	51                   	push   %ecx
c002411e:	52                   	push   %edx
c002411f:	50                   	push   %eax
c0024120:	e8 2d 50 00 00       	call   c0029152 <__divdi3>
c0024125:	83 c4 10             	add    $0x10,%esp
c0024128:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002412b:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c002412e:	e8 24 d3 ff ff       	call   c0021457 <intr_get_level>
c0024133:	83 f8 01             	cmp    $0x1,%eax
c0024136:	74 21                	je     c0024159 <real_time_sleep+0x73>
c0024138:	83 ec 0c             	sub    $0xc,%esp
c002413b:	68 a3 f6 02 c0       	push   $0xc002f6a3
c0024140:	68 c0 f6 02 c0       	push   $0xc002f6c0
c0024145:	68 6c f7 02 c0       	push   $0xc002f76c
c002414a:	68 e2 00 00 00       	push   $0xe2
c002414f:	68 d7 f6 02 c0       	push   $0xc002f6d7
c0024154:	e8 1f 56 00 00       	call   c0029778 <debug_panic>
  if (ticks > 0)
c0024159:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002415d:	78 1f                	js     c002417e <real_time_sleep+0x98>
c002415f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024163:	7f 06                	jg     c002416b <real_time_sleep+0x85>
c0024165:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0024169:	76 13                	jbe    c002417e <real_time_sleep+0x98>
    {
      /* We're waiting for at least one full timer tick.  Use
         timer_sleep() because it will yield the CPU to other
         processes. */                
      timer_sleep (ticks); 
c002416b:	83 ec 08             	sub    $0x8,%esp
c002416e:	ff 75 f4             	pushl  -0xc(%ebp)
c0024171:	ff 75 f0             	pushl  -0x10(%ebp)
c0024174:	e8 c9 fc ff ff       	call   c0023e42 <timer_sleep>
c0024179:	83 c4 10             	add    $0x10,%esp
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
    }
}
c002417c:	eb 14                	jmp    c0024192 <real_time_sleep+0xac>
    }
  else 
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
c002417e:	83 ec 04             	sub    $0x4,%esp
c0024181:	ff 75 10             	pushl  0x10(%ebp)
c0024184:	ff 75 e4             	pushl  -0x1c(%ebp)
c0024187:	ff 75 e0             	pushl  -0x20(%ebp)
c002418a:	e8 09 00 00 00       	call   c0024198 <real_time_delay>
c002418f:	83 c4 10             	add    $0x10,%esp
    }
}
c0024192:	90                   	nop
c0024193:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024196:	c9                   	leave  
c0024197:	c3                   	ret    

c0024198 <real_time_delay>:

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c0024198:	55                   	push   %ebp
c0024199:	89 e5                	mov    %esp,%ebp
c002419b:	56                   	push   %esi
c002419c:	53                   	push   %ebx
c002419d:	83 ec 10             	sub    $0x10,%esp
c00241a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00241a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00241a6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00241a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c00241ac:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00241af:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c00241b4:	89 c8                	mov    %ecx,%eax
c00241b6:	f7 ea                	imul   %edx
c00241b8:	c1 fa 06             	sar    $0x6,%edx
c00241bb:	89 c8                	mov    %ecx,%eax
c00241bd:	c1 f8 1f             	sar    $0x1f,%eax
c00241c0:	29 c2                	sub    %eax,%edx
c00241c2:	89 d0                	mov    %edx,%eax
c00241c4:	69 c0 e8 03 00 00    	imul   $0x3e8,%eax,%eax
c00241ca:	29 c1                	sub    %eax,%ecx
c00241cc:	89 c8                	mov    %ecx,%eax
c00241ce:	85 c0                	test   %eax,%eax
c00241d0:	74 21                	je     c00241f3 <real_time_delay+0x5b>
c00241d2:	83 ec 0c             	sub    $0xc,%esp
c00241d5:	68 3b f7 02 c0       	push   $0xc002f73b
c00241da:	68 c0 f6 02 c0       	push   $0xc002f6c0
c00241df:	68 7c f7 02 c0       	push   $0xc002f77c
c00241e4:	68 f8 00 00 00       	push   $0xf8
c00241e9:	68 d7 f6 02 c0       	push   $0xc002f6d7
c00241ee:	e8 85 55 00 00       	call   c0029778 <debug_panic>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c00241f3:	a1 f0 98 03 c0       	mov    0xc00398f0,%eax
c00241f8:	ba 00 00 00 00       	mov    $0x0,%edx
c00241fd:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c0024200:	89 cb                	mov    %ecx,%ebx
c0024202:	0f af da             	imul   %edx,%ebx
c0024205:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0024208:	0f af c8             	imul   %eax,%ecx
c002420b:	01 d9                	add    %ebx,%ecx
c002420d:	f7 65 f0             	mull   -0x10(%ebp)
c0024210:	01 d1                	add    %edx,%ecx
c0024212:	89 ca                	mov    %ecx,%edx
c0024214:	6a 00                	push   $0x0
c0024216:	68 e8 03 00 00       	push   $0x3e8
c002421b:	52                   	push   %edx
c002421c:	50                   	push   %eax
c002421d:	e8 30 4f 00 00       	call   c0029152 <__divdi3>
c0024222:	83 c4 10             	add    $0x10,%esp
c0024225:	6b da 64             	imul   $0x64,%edx,%ebx
c0024228:	6b c8 00             	imul   $0x0,%eax,%ecx
c002422b:	8d 34 0b             	lea    (%ebx,%ecx,1),%esi
c002422e:	b9 64 00 00 00       	mov    $0x64,%ecx
c0024233:	f7 e1                	mul    %ecx
c0024235:	89 c1                	mov    %eax,%ecx
c0024237:	89 d3                	mov    %edx,%ebx
c0024239:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c002423c:	89 c3                	mov    %eax,%ebx
c002423e:	8b 75 10             	mov    0x10(%ebp),%esi
c0024241:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c0024246:	89 f0                	mov    %esi,%eax
c0024248:	f7 ea                	imul   %edx
c002424a:	c1 fa 06             	sar    $0x6,%edx
c002424d:	89 f0                	mov    %esi,%eax
c002424f:	c1 f8 1f             	sar    $0x1f,%eax
c0024252:	29 c2                	sub    %eax,%edx
c0024254:	89 d0                	mov    %edx,%eax
c0024256:	99                   	cltd   
c0024257:	52                   	push   %edx
c0024258:	50                   	push   %eax
c0024259:	53                   	push   %ebx
c002425a:	51                   	push   %ecx
c002425b:	e8 f2 4e 00 00       	call   c0029152 <__divdi3>
c0024260:	83 c4 10             	add    $0x10,%esp
c0024263:	83 ec 08             	sub    $0x8,%esp
c0024266:	52                   	push   %edx
c0024267:	50                   	push   %eax
c0024268:	e8 3a fe ff ff       	call   c00240a7 <busy_wait>
c002426d:	83 c4 10             	add    $0x10,%esp
}
c0024270:	90                   	nop
c0024271:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0024274:	5b                   	pop    %ebx
c0024275:	5e                   	pop    %esi
c0024276:	5d                   	pop    %ebp
c0024277:	c3                   	ret    

c0024278 <isupper>:
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c0024278:	55                   	push   %ebp
c0024279:	89 e5                	mov    %esp,%ebp
c002427b:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c002427f:	7e 0d                	jle    c002428e <isupper+0x16>
c0024281:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c0024285:	7f 07                	jg     c002428e <isupper+0x16>
c0024287:	b8 01 00 00 00       	mov    $0x1,%eax
c002428c:	eb 05                	jmp    c0024293 <isupper+0x1b>
c002428e:	b8 00 00 00 00       	mov    $0x0,%eax
c0024293:	5d                   	pop    %ebp
c0024294:	c3                   	ret    

c0024295 <tolower>:
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c0024295:	55                   	push   %ebp
c0024296:	89 e5                	mov    %esp,%ebp
c0024298:	ff 75 08             	pushl  0x8(%ebp)
c002429b:	e8 d8 ff ff ff       	call   c0024278 <isupper>
c00242a0:	83 c4 04             	add    $0x4,%esp
c00242a3:	85 c0                	test   %eax,%eax
c00242a5:	74 08                	je     c00242af <tolower+0x1a>
c00242a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00242aa:	83 c0 20             	add    $0x20,%eax
c00242ad:	eb 03                	jmp    c00242b2 <tolower+0x1d>
c00242af:	8b 45 08             	mov    0x8(%ebp),%eax
c00242b2:	c9                   	leave  
c00242b3:	c3                   	ret    

c00242b4 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c00242b4:	55                   	push   %ebp
c00242b5:	89 e5                	mov    %esp,%ebp
c00242b7:	83 ec 14             	sub    $0x14,%esp
c00242ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00242bd:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00242c1:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00242c5:	89 c2                	mov    %eax,%edx
c00242c7:	ec                   	in     (%dx),%al
c00242c8:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00242cb:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c00242cf:	c9                   	leave  
c00242d0:	c3                   	ret    

c00242d1 <kbd_init>:
static intr_handler_func keyboard_interrupt;

/* Initializes the keyboard. */
void
kbd_init (void) 
{
c00242d1:	55                   	push   %ebp
c00242d2:	89 e5                	mov    %esp,%ebp
c00242d4:	83 ec 08             	sub    $0x8,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c00242d7:	83 ec 04             	sub    $0x4,%esp
c00242da:	68 a0 f7 02 c0       	push   $0xc002f7a0
c00242df:	68 17 43 02 c0       	push   $0xc0024317
c00242e4:	6a 21                	push   $0x21
c00242e6:	e8 02 d4 ff ff       	call   c00216ed <intr_register_ext>
c00242eb:	83 c4 10             	add    $0x10,%esp
}
c00242ee:	90                   	nop
c00242ef:	c9                   	leave  
c00242f0:	c3                   	ret    

c00242f1 <kbd_print_stats>:

/* Prints keyboard statistics. */
void
kbd_print_stats (void) 
{
c00242f1:	55                   	push   %ebp
c00242f2:	89 e5                	mov    %esp,%ebp
c00242f4:	83 ec 08             	sub    $0x8,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c00242f7:	a1 00 99 03 c0       	mov    0xc0039900,%eax
c00242fc:	8b 15 04 99 03 c0    	mov    0xc0039904,%edx
c0024302:	83 ec 04             	sub    $0x4,%esp
c0024305:	52                   	push   %edx
c0024306:	50                   	push   %eax
c0024307:	68 ae f7 02 c0       	push   $0xc002f7ae
c002430c:	e8 34 30 00 00       	call   c0027345 <printf>
c0024311:	83 c4 10             	add    $0x10,%esp
}
c0024314:	90                   	nop
c0024315:	c9                   	leave  
c0024316:	c3                   	ret    

c0024317 <keyboard_interrupt>:

static bool map_key (const struct keymap[], unsigned scancode, uint8_t *);

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
c0024317:	55                   	push   %ebp
c0024318:	89 e5                	mov    %esp,%ebp
c002431a:	53                   	push   %ebx
c002431b:	83 ec 14             	sub    $0x14,%esp
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c002431e:	0f b6 05 f8 98 03 c0 	movzbl 0xc00398f8,%eax
c0024325:	84 c0                	test   %al,%al
c0024327:	75 0b                	jne    c0024334 <keyboard_interrupt+0x1d>
c0024329:	0f b6 05 f9 98 03 c0 	movzbl 0xc00398f9,%eax
c0024330:	84 c0                	test   %al,%al
c0024332:	74 07                	je     c002433b <keyboard_interrupt+0x24>
c0024334:	b8 01 00 00 00       	mov    $0x1,%eax
c0024339:	eb 05                	jmp    c0024340 <keyboard_interrupt+0x29>
c002433b:	b8 00 00 00 00       	mov    $0x0,%eax
c0024340:	88 45 ef             	mov    %al,-0x11(%ebp)
c0024343:	80 65 ef 01          	andb   $0x1,-0x11(%ebp)
  bool alt = left_alt || right_alt;
c0024347:	0f b6 05 fa 98 03 c0 	movzbl 0xc00398fa,%eax
c002434e:	84 c0                	test   %al,%al
c0024350:	75 0b                	jne    c002435d <keyboard_interrupt+0x46>
c0024352:	0f b6 05 fb 98 03 c0 	movzbl 0xc00398fb,%eax
c0024359:	84 c0                	test   %al,%al
c002435b:	74 07                	je     c0024364 <keyboard_interrupt+0x4d>
c002435d:	b8 01 00 00 00       	mov    $0x1,%eax
c0024362:	eb 05                	jmp    c0024369 <keyboard_interrupt+0x52>
c0024364:	b8 00 00 00 00       	mov    $0x0,%eax
c0024369:	88 45 ee             	mov    %al,-0x12(%ebp)
c002436c:	80 65 ee 01          	andb   $0x1,-0x12(%ebp)
  bool ctrl = left_ctrl || right_ctrl;
c0024370:	0f b6 05 fc 98 03 c0 	movzbl 0xc00398fc,%eax
c0024377:	84 c0                	test   %al,%al
c0024379:	75 0b                	jne    c0024386 <keyboard_interrupt+0x6f>
c002437b:	0f b6 05 fd 98 03 c0 	movzbl 0xc00398fd,%eax
c0024382:	84 c0                	test   %al,%al
c0024384:	74 07                	je     c002438d <keyboard_interrupt+0x76>
c0024386:	b8 01 00 00 00       	mov    $0x1,%eax
c002438b:	eb 05                	jmp    c0024392 <keyboard_interrupt+0x7b>
c002438d:	b8 00 00 00 00       	mov    $0x0,%eax
c0024392:	88 45 ed             	mov    %al,-0x13(%ebp)
c0024395:	80 65 ed 01          	andb   $0x1,-0x13(%ebp)

  /* Character that corresponds to `code'. */
  uint8_t c;

  /* Read scancode, including second byte if prefix code. */
  code = inb (DATA_REG);
c0024399:	6a 60                	push   $0x60
c002439b:	e8 14 ff ff ff       	call   c00242b4 <inb>
c00243a0:	83 c4 04             	add    $0x4,%esp
c00243a3:	0f b6 c0             	movzbl %al,%eax
c00243a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (code == 0xe0)
c00243a9:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%ebp)
c00243b0:	75 1a                	jne    c00243cc <keyboard_interrupt+0xb5>
    code = (code << 8) | inb (DATA_REG);
c00243b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00243b5:	c1 e0 08             	shl    $0x8,%eax
c00243b8:	89 c3                	mov    %eax,%ebx
c00243ba:	6a 60                	push   $0x60
c00243bc:	e8 f3 fe ff ff       	call   c00242b4 <inb>
c00243c1:	83 c4 04             	add    $0x4,%esp
c00243c4:	0f b6 c0             	movzbl %al,%eax
c00243c7:	09 d8                	or     %ebx,%eax
c00243c9:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Bit 0x80 distinguishes key press from key release
     (even if there's a prefix). */
  release = (code & 0x80) != 0;
c00243cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00243cf:	25 80 00 00 00       	and    $0x80,%eax
c00243d4:	85 c0                	test   %eax,%eax
c00243d6:	0f 95 c0             	setne  %al
c00243d9:	88 45 ec             	mov    %al,-0x14(%ebp)
  code &= ~0x80u;
c00243dc:	81 65 f4 7f ff ff ff 	andl   $0xffffff7f,-0xc(%ebp)

  /* Interpret key. */
  if (code == 0x3a) 
c00243e3:	83 7d f4 3a          	cmpl   $0x3a,-0xc(%ebp)
c00243e7:	75 31                	jne    c002441a <keyboard_interrupt+0x103>
    {
      /* Caps Lock. */
      if (!release)
c00243e9:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00243ed:	83 f0 01             	xor    $0x1,%eax
c00243f0:	84 c0                	test   %al,%al
c00243f2:	0f 84 84 01 00 00    	je     c002457c <keyboard_interrupt+0x265>
        caps_lock = !caps_lock;
c00243f8:	0f b6 05 fe 98 03 c0 	movzbl 0xc00398fe,%eax
c00243ff:	0f b6 c0             	movzbl %al,%eax
c0024402:	85 c0                	test   %eax,%eax
c0024404:	0f 95 c0             	setne  %al
c0024407:	83 f0 01             	xor    $0x1,%eax
c002440a:	0f b6 c0             	movzbl %al,%eax
c002440d:	83 e0 01             	and    $0x1,%eax
c0024410:	a2 fe 98 03 c0       	mov    %al,0xc00398fe
          {
            *key->state_var = !release;
            break;
          }
    }
}
c0024415:	e9 62 01 00 00       	jmp    c002457c <keyboard_interrupt+0x265>
    {
      /* Caps Lock. */
      if (!release)
        caps_lock = !caps_lock;
    }
  else if (map_key (invariant_keymap, code, &c)
c002441a:	83 ec 04             	sub    $0x4,%esp
c002441d:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0024420:	50                   	push   %eax
c0024421:	ff 75 f4             	pushl  -0xc(%ebp)
c0024424:	68 00 f8 02 c0       	push   $0xc002f800
c0024429:	e8 54 01 00 00       	call   c0024582 <map_key>
c002442e:	83 c4 10             	add    $0x10,%esp
c0024431:	84 c0                	test   %al,%al
c0024433:	75 4f                	jne    c0024484 <keyboard_interrupt+0x16d>
           || (!shift && map_key (unshifted_keymap, code, &c))
c0024435:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0024439:	83 f0 01             	xor    $0x1,%eax
c002443c:	84 c0                	test   %al,%al
c002443e:	74 1b                	je     c002445b <keyboard_interrupt+0x144>
c0024440:	83 ec 04             	sub    $0x4,%esp
c0024443:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0024446:	50                   	push   %eax
c0024447:	ff 75 f4             	pushl  -0xc(%ebp)
c002444a:	68 80 f8 02 c0       	push   $0xc002f880
c002444f:	e8 2e 01 00 00       	call   c0024582 <map_key>
c0024454:	83 c4 10             	add    $0x10,%esp
c0024457:	84 c0                	test   %al,%al
c0024459:	75 29                	jne    c0024484 <keyboard_interrupt+0x16d>
           || (shift && map_key (shifted_keymap, code, &c)))
c002445b:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c002445f:	0f 84 d8 00 00 00    	je     c002453d <keyboard_interrupt+0x226>
c0024465:	83 ec 04             	sub    $0x4,%esp
c0024468:	8d 45 eb             	lea    -0x15(%ebp),%eax
c002446b:	50                   	push   %eax
c002446c:	ff 75 f4             	pushl  -0xc(%ebp)
c002446f:	68 e0 f8 02 c0       	push   $0xc002f8e0
c0024474:	e8 09 01 00 00       	call   c0024582 <map_key>
c0024479:	83 c4 10             	add    $0x10,%esp
c002447c:	84 c0                	test   %al,%al
c002447e:	0f 84 b9 00 00 00    	je     c002453d <keyboard_interrupt+0x226>
    {
      /* Ordinary character. */
      if (!release) 
c0024484:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0024488:	83 f0 01             	xor    $0x1,%eax
c002448b:	84 c0                	test   %al,%al
c002448d:	0f 84 e8 00 00 00    	je     c002457b <keyboard_interrupt+0x264>
        {
          /* Reboot if Ctrl+Alt+Del pressed. */
          if (c == 0177 && ctrl && alt)
c0024493:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0024497:	3c 7f                	cmp    $0x7f,%al
c0024499:	75 11                	jne    c00244ac <keyboard_interrupt+0x195>
c002449b:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c002449f:	74 0b                	je     c00244ac <keyboard_interrupt+0x195>
c00244a1:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c00244a5:	74 05                	je     c00244ac <keyboard_interrupt+0x195>
            shutdown_reboot ();
c00244a7:	e8 03 29 00 00       	call   c0026daf <shutdown_reboot>

          /* Handle Ctrl, Shift.
             Note that Ctrl overrides Shift. */
          if (ctrl && c >= 0x40 && c < 0x60) 
c00244ac:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c00244b0:	74 1c                	je     c00244ce <keyboard_interrupt+0x1b7>
c00244b2:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c00244b6:	3c 3f                	cmp    $0x3f,%al
c00244b8:	76 14                	jbe    c00244ce <keyboard_interrupt+0x1b7>
c00244ba:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c00244be:	3c 5f                	cmp    $0x5f,%al
c00244c0:	77 0c                	ja     c00244ce <keyboard_interrupt+0x1b7>
            {
              /* A is 0x41, Ctrl+A is 0x01, etc. */
              c -= 0x40; 
c00244c2:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c00244c6:	83 e8 40             	sub    $0x40,%eax
c00244c9:	88 45 eb             	mov    %al,-0x15(%ebp)
c00244cc:	eb 22                	jmp    c00244f0 <keyboard_interrupt+0x1d9>
            }
          else if (shift == caps_lock)
c00244ce:	0f b6 05 fe 98 03 c0 	movzbl 0xc00398fe,%eax
c00244d5:	38 45 ef             	cmp    %al,-0x11(%ebp)
c00244d8:	75 16                	jne    c00244f0 <keyboard_interrupt+0x1d9>
            c = tolower (c);
c00244da:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c00244de:	0f b6 c0             	movzbl %al,%eax
c00244e1:	83 ec 0c             	sub    $0xc,%esp
c00244e4:	50                   	push   %eax
c00244e5:	e8 ab fd ff ff       	call   c0024295 <tolower>
c00244ea:	83 c4 10             	add    $0x10,%esp
c00244ed:	88 45 eb             	mov    %al,-0x15(%ebp)

          /* Handle Alt by setting the high bit.
             This 0x80 is unrelated to the one used to
             distinguish key press from key release. */
          if (alt)
c00244f0:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c00244f4:	74 0a                	je     c0024500 <keyboard_interrupt+0x1e9>
            c += 0x80;
c00244f6:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c00244fa:	83 c0 80             	add    $0xffffff80,%eax
c00244fd:	88 45 eb             	mov    %al,-0x15(%ebp)

          /* Append to keyboard buffer. */
          if (!input_full ())
c0024500:	e8 92 21 00 00       	call   c0026697 <input_full>
c0024505:	83 f0 01             	xor    $0x1,%eax
c0024508:	84 c0                	test   %al,%al
c002450a:	74 6f                	je     c002457b <keyboard_interrupt+0x264>
            {
              key_cnt++;
c002450c:	a1 00 99 03 c0       	mov    0xc0039900,%eax
c0024511:	8b 15 04 99 03 c0    	mov    0xc0039904,%edx
c0024517:	83 c0 01             	add    $0x1,%eax
c002451a:	83 d2 00             	adc    $0x0,%edx
c002451d:	a3 00 99 03 c0       	mov    %eax,0xc0039900
c0024522:	89 15 04 99 03 c0    	mov    %edx,0xc0039904
              input_putc (c);
c0024528:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002452c:	0f b6 c0             	movzbl %al,%eax
c002452f:	83 ec 0c             	sub    $0xc,%esp
c0024532:	50                   	push   %eax
c0024533:	e8 a0 20 00 00       	call   c00265d8 <input_putc>
c0024538:	83 c4 10             	add    $0x10,%esp
  else if (map_key (invariant_keymap, code, &c)
           || (!shift && map_key (unshifted_keymap, code, &c))
           || (shift && map_key (shifted_keymap, code, &c)))
    {
      /* Ordinary character. */
      if (!release) 
c002453b:	eb 3e                	jmp    c002457b <keyboard_interrupt+0x264>
        };
  
      const struct shift_key *key;

      /* Scan the table. */
      for (key = shift_keys; key->scancode != 0; key++) 
c002453d:	c7 45 f0 20 f9 02 c0 	movl   $0xc002f920,-0x10(%ebp)
c0024544:	eb 2a                	jmp    c0024570 <keyboard_interrupt+0x259>
        if (key->scancode == code)
c0024546:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024549:	8b 00                	mov    (%eax),%eax
c002454b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002454e:	75 1c                	jne    c002456c <keyboard_interrupt+0x255>
          {
            *key->state_var = !release;
c0024550:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024553:	8b 50 04             	mov    0x4(%eax),%edx
c0024556:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c002455a:	85 c0                	test   %eax,%eax
c002455c:	0f 95 c0             	setne  %al
c002455f:	83 f0 01             	xor    $0x1,%eax
c0024562:	0f b6 c0             	movzbl %al,%eax
c0024565:	83 e0 01             	and    $0x1,%eax
c0024568:	88 02                	mov    %al,(%edx)
            break;
c002456a:	eb 10                	jmp    c002457c <keyboard_interrupt+0x265>
        };
  
      const struct shift_key *key;

      /* Scan the table. */
      for (key = shift_keys; key->scancode != 0; key++) 
c002456c:	83 45 f0 08          	addl   $0x8,-0x10(%ebp)
c0024570:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024573:	8b 00                	mov    (%eax),%eax
c0024575:	85 c0                	test   %eax,%eax
c0024577:	75 cd                	jne    c0024546 <keyboard_interrupt+0x22f>
          {
            *key->state_var = !release;
            break;
          }
    }
}
c0024579:	eb 01                	jmp    c002457c <keyboard_interrupt+0x265>
  else if (map_key (invariant_keymap, code, &c)
           || (!shift && map_key (unshifted_keymap, code, &c))
           || (shift && map_key (shifted_keymap, code, &c)))
    {
      /* Ordinary character. */
      if (!release) 
c002457b:	90                   	nop
          {
            *key->state_var = !release;
            break;
          }
    }
}
c002457c:	90                   	nop
c002457d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024580:	c9                   	leave  
c0024581:	c3                   	ret    

c0024582 <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c0024582:	55                   	push   %ebp
c0024583:	89 e5                	mov    %esp,%ebp
c0024585:	53                   	push   %ebx
c0024586:	83 ec 04             	sub    $0x4,%esp
  for (; k->first_scancode != 0; k++)
c0024589:	eb 5d                	jmp    c00245e8 <map_key+0x66>
    if (scancode >= k->first_scancode
c002458b:	8b 45 08             	mov    0x8(%ebp),%eax
c002458e:	0f b6 00             	movzbl (%eax),%eax
c0024591:	0f b6 c0             	movzbl %al,%eax
c0024594:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024597:	77 4b                	ja     c00245e4 <map_key+0x62>
        && scancode < k->first_scancode + strlen (k->chars)) 
c0024599:	8b 45 08             	mov    0x8(%ebp),%eax
c002459c:	0f b6 00             	movzbl (%eax),%eax
c002459f:	0f b6 d8             	movzbl %al,%ebx
c00245a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00245a5:	8b 40 04             	mov    0x4(%eax),%eax
c00245a8:	83 ec 0c             	sub    $0xc,%esp
c00245ab:	50                   	push   %eax
c00245ac:	e8 14 46 00 00       	call   c0028bc5 <strlen>
c00245b1:	83 c4 10             	add    $0x10,%esp
c00245b4:	01 d8                	add    %ebx,%eax
c00245b6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00245b9:	76 29                	jbe    c00245e4 <map_key+0x62>
      {
        *c = k->chars[scancode - k->first_scancode];
c00245bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00245be:	8b 50 04             	mov    0x4(%eax),%edx
c00245c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00245c4:	0f b6 00             	movzbl (%eax),%eax
c00245c7:	0f b6 c0             	movzbl %al,%eax
c00245ca:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00245cd:	29 c1                	sub    %eax,%ecx
c00245cf:	89 c8                	mov    %ecx,%eax
c00245d1:	01 d0                	add    %edx,%eax
c00245d3:	0f b6 00             	movzbl (%eax),%eax
c00245d6:	89 c2                	mov    %eax,%edx
c00245d8:	8b 45 10             	mov    0x10(%ebp),%eax
c00245db:	88 10                	mov    %dl,(%eax)
        return true; 
c00245dd:	b8 01 00 00 00       	mov    $0x1,%eax
c00245e2:	eb 13                	jmp    c00245f7 <map_key+0x75>
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
  for (; k->first_scancode != 0; k++)
c00245e4:	83 45 08 08          	addl   $0x8,0x8(%ebp)
c00245e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00245eb:	0f b6 00             	movzbl (%eax),%eax
c00245ee:	84 c0                	test   %al,%al
c00245f0:	75 99                	jne    c002458b <map_key+0x9>
      {
        *c = k->chars[scancode - k->first_scancode];
        return true; 
      }

  return false;
c00245f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00245f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00245fa:	c9                   	leave  
c00245fb:	c3                   	ret    

c00245fc <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c00245fc:	55                   	push   %ebp
c00245fd:	89 e5                	mov    %esp,%ebp
c00245ff:	83 ec 14             	sub    $0x14,%esp
c0024602:	8b 45 08             	mov    0x8(%ebp),%eax
c0024605:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024609:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c002460d:	89 c2                	mov    %eax,%edx
c002460f:	ec                   	in     (%dx),%al
c0024610:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024613:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0024617:	c9                   	leave  
c0024618:	c3                   	ret    

c0024619 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0024619:	55                   	push   %ebp
c002461a:	89 e5                	mov    %esp,%ebp
c002461c:	83 ec 08             	sub    $0x8,%esp
c002461f:	8b 55 08             	mov    0x8(%ebp),%edx
c0024622:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024625:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0024629:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002462c:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0024630:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0024634:	ee                   	out    %al,(%dx)
}
c0024635:	90                   	nop
c0024636:	c9                   	leave  
c0024637:	c3                   	ret    

c0024638 <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c0024638:	55                   	push   %ebp
c0024639:	89 e5                	mov    %esp,%ebp
c002463b:	83 ec 08             	sub    $0x8,%esp
c002463e:	8b 55 08             	mov    0x8(%ebp),%edx
c0024641:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024644:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0024648:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c002464c:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c0024650:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0024654:	66 ef                	out    %ax,(%dx)
}
c0024656:	90                   	nop
c0024657:	c9                   	leave  
c0024658:	c3                   	ret    

c0024659 <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c0024659:	55                   	push   %ebp
c002465a:	89 e5                	mov    %esp,%ebp
c002465c:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c002465f:	8b 45 08             	mov    0x8(%ebp),%eax
c0024662:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0024667:	76 1e                	jbe    c0024687 <ptov+0x2e>
c0024669:	83 ec 0c             	sub    $0xc,%esp
c002466c:	68 58 f9 02 c0       	push   $0xc002f958
c0024671:	68 73 f9 02 c0       	push   $0xc002f973
c0024676:	68 bc f9 02 c0       	push   $0xc002f9bc
c002467b:	6a 4a                	push   $0x4a
c002467d:	68 8a f9 02 c0       	push   $0xc002f98a
c0024682:	e8 f1 50 00 00       	call   c0029778 <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c0024687:	8b 45 08             	mov    0x8(%ebp),%eax
c002468a:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c002468f:	c9                   	leave  
c0024690:	c3                   	ret    

c0024691 <init>:
static void find_cursor (size_t *x, size_t *y);

/* Initializes the VGA text display. */
static void
init (void)
{
c0024691:	55                   	push   %ebp
c0024692:	89 e5                	mov    %esp,%ebp
c0024694:	83 ec 08             	sub    $0x8,%esp
  /* Already initialized? */
  static bool inited;
  if (!inited)
c0024697:	0f b6 05 14 99 03 c0 	movzbl 0xc0039914,%eax
c002469e:	83 f0 01             	xor    $0x1,%eax
c00246a1:	84 c0                	test   %al,%al
c00246a3:	74 31                	je     c00246d6 <init+0x45>
    {
      fb = ptov (0xb8000);
c00246a5:	83 ec 0c             	sub    $0xc,%esp
c00246a8:	68 00 80 0b 00       	push   $0xb8000
c00246ad:	e8 a7 ff ff ff       	call   c0024659 <ptov>
c00246b2:	83 c4 10             	add    $0x10,%esp
c00246b5:	a3 10 99 03 c0       	mov    %eax,0xc0039910
      find_cursor (&cx, &cy);
c00246ba:	83 ec 08             	sub    $0x8,%esp
c00246bd:	68 0c 99 03 c0       	push   $0xc003990c
c00246c2:	68 08 99 03 c0       	push   $0xc0039908
c00246c7:	e8 9a 02 00 00       	call   c0024966 <find_cursor>
c00246cc:	83 c4 10             	add    $0x10,%esp
      inited = true; 
c00246cf:	c6 05 14 99 03 c0 01 	movb   $0x1,0xc0039914
    }
}
c00246d6:	90                   	nop
c00246d7:	c9                   	leave  
c00246d8:	c3                   	ret    

c00246d9 <vga_putc>:

/* Writes C to the VGA text display, interpreting control
   characters in the conventional ways.  */
void
vga_putc (int c)
{
c00246d9:	55                   	push   %ebp
c00246da:	89 e5                	mov    %esp,%ebp
c00246dc:	83 ec 18             	sub    $0x18,%esp
  /* Disable interrupts to lock out interrupt handlers
     that might write to the console. */
  enum intr_level old_level = intr_disable ();
c00246df:	e8 e8 cd ff ff       	call   c00214cc <intr_disable>
c00246e4:	89 45 f4             	mov    %eax,-0xc(%ebp)

  init ();
c00246e7:	e8 a5 ff ff ff       	call   c0024691 <init>
  
  switch (c) 
c00246ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00246ef:	83 e8 07             	sub    $0x7,%eax
c00246f2:	83 f8 06             	cmp    $0x6,%eax
c00246f5:	0f 87 90 00 00 00    	ja     c002478b <vga_putc+0xb2>
c00246fb:	8b 04 85 a0 f9 02 c0 	mov    -0x3ffd0660(,%eax,4),%eax
c0024702:	ff e0                	jmp    *%eax
    {
    case '\n':
      newline ();
c0024704:	e8 9e 01 00 00       	call   c00248a7 <newline>
      break;
c0024709:	e9 e9 00 00 00       	jmp    c00247f7 <vga_putc+0x11e>

    case '\f':
      cls ();
c002470e:	e8 fa 00 00 00       	call   c002480d <cls>
      break;
c0024713:	e9 df 00 00 00       	jmp    c00247f7 <vga_putc+0x11e>

    case '\b':
      if (cx > 0)
c0024718:	a1 08 99 03 c0       	mov    0xc0039908,%eax
c002471d:	85 c0                	test   %eax,%eax
c002471f:	0f 84 cb 00 00 00    	je     c00247f0 <vga_putc+0x117>
        cx--;
c0024725:	a1 08 99 03 c0       	mov    0xc0039908,%eax
c002472a:	83 e8 01             	sub    $0x1,%eax
c002472d:	a3 08 99 03 c0       	mov    %eax,0xc0039908
      break;
c0024732:	e9 b9 00 00 00       	jmp    c00247f0 <vga_putc+0x117>
      
    case '\r':
      cx = 0;
c0024737:	c7 05 08 99 03 c0 00 	movl   $0x0,0xc0039908
c002473e:	00 00 00 
      break;
c0024741:	e9 b1 00 00 00       	jmp    c00247f7 <vga_putc+0x11e>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
c0024746:	a1 08 99 03 c0       	mov    0xc0039908,%eax
c002474b:	83 c0 08             	add    $0x8,%eax
c002474e:	c1 e8 03             	shr    $0x3,%eax
c0024751:	c1 e0 03             	shl    $0x3,%eax
c0024754:	a3 08 99 03 c0       	mov    %eax,0xc0039908
      if (cx >= COL_CNT)
c0024759:	a1 08 99 03 c0       	mov    0xc0039908,%eax
c002475e:	83 f8 4f             	cmp    $0x4f,%eax
c0024761:	0f 86 8c 00 00 00    	jbe    c00247f3 <vga_putc+0x11a>
        newline ();
c0024767:	e8 3b 01 00 00       	call   c00248a7 <newline>
      break;
c002476c:	e9 82 00 00 00       	jmp    c00247f3 <vga_putc+0x11a>

    case '\a':
      intr_set_level (old_level);
c0024771:	83 ec 0c             	sub    $0xc,%esp
c0024774:	ff 75 f4             	pushl  -0xc(%ebp)
c0024777:	e8 f8 cc ff ff       	call   c0021474 <intr_set_level>
c002477c:	83 c4 10             	add    $0x10,%esp
      speaker_beep ();
c002477f:	e8 52 28 00 00       	call   c0026fd6 <speaker_beep>
      intr_disable ();
c0024784:	e8 43 cd ff ff       	call   c00214cc <intr_disable>
      break;
c0024789:	eb 6c                	jmp    c00247f7 <vga_putc+0x11e>
      
    default:
      fb[cy][cx][0] = c;
c002478b:	8b 0d 10 99 03 c0    	mov    0xc0039910,%ecx
c0024791:	8b 15 0c 99 03 c0    	mov    0xc003990c,%edx
c0024797:	89 d0                	mov    %edx,%eax
c0024799:	c1 e0 02             	shl    $0x2,%eax
c002479c:	01 d0                	add    %edx,%eax
c002479e:	c1 e0 05             	shl    $0x5,%eax
c00247a1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00247a4:	a1 08 99 03 c0       	mov    0xc0039908,%eax
c00247a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00247ac:	88 0c 42             	mov    %cl,(%edx,%eax,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c00247af:	8b 0d 10 99 03 c0    	mov    0xc0039910,%ecx
c00247b5:	8b 15 0c 99 03 c0    	mov    0xc003990c,%edx
c00247bb:	89 d0                	mov    %edx,%eax
c00247bd:	c1 e0 02             	shl    $0x2,%eax
c00247c0:	01 d0                	add    %edx,%eax
c00247c2:	c1 e0 05             	shl    $0x5,%eax
c00247c5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00247c8:	a1 08 99 03 c0       	mov    0xc0039908,%eax
c00247cd:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c00247d2:	a1 08 99 03 c0       	mov    0xc0039908,%eax
c00247d7:	83 c0 01             	add    $0x1,%eax
c00247da:	a3 08 99 03 c0       	mov    %eax,0xc0039908
c00247df:	a1 08 99 03 c0       	mov    0xc0039908,%eax
c00247e4:	83 f8 4f             	cmp    $0x4f,%eax
c00247e7:	76 0d                	jbe    c00247f6 <vga_putc+0x11d>
        newline ();
c00247e9:	e8 b9 00 00 00       	call   c00248a7 <newline>
      break;
c00247ee:	eb 06                	jmp    c00247f6 <vga_putc+0x11d>
      break;

    case '\b':
      if (cx > 0)
        cx--;
      break;
c00247f0:	90                   	nop
c00247f1:	eb 04                	jmp    c00247f7 <vga_putc+0x11e>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
      if (cx >= COL_CNT)
        newline ();
      break;
c00247f3:	90                   	nop
c00247f4:	eb 01                	jmp    c00247f7 <vga_putc+0x11e>
    default:
      fb[cy][cx][0] = c;
      fb[cy][cx][1] = GRAY_ON_BLACK;
      if (++cx >= COL_CNT)
        newline ();
      break;
c00247f6:	90                   	nop
    }

  /* Update cursor position. */
  move_cursor ();
c00247f7:	e8 0e 01 00 00       	call   c002490a <move_cursor>

  intr_set_level (old_level);
c00247fc:	83 ec 0c             	sub    $0xc,%esp
c00247ff:	ff 75 f4             	pushl  -0xc(%ebp)
c0024802:	e8 6d cc ff ff       	call   c0021474 <intr_set_level>
c0024807:	83 c4 10             	add    $0x10,%esp
}
c002480a:	90                   	nop
c002480b:	c9                   	leave  
c002480c:	c3                   	ret    

c002480d <cls>:

/* Clears the screen and moves the cursor to the upper left. */
static void
cls (void)
{
c002480d:	55                   	push   %ebp
c002480e:	89 e5                	mov    %esp,%ebp
c0024810:	83 ec 18             	sub    $0x18,%esp
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c0024813:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002481a:	eb 12                	jmp    c002482e <cls+0x21>
    clear_row (y);
c002481c:	83 ec 0c             	sub    $0xc,%esp
c002481f:	ff 75 f4             	pushl  -0xc(%ebp)
c0024822:	e8 29 00 00 00       	call   c0024850 <clear_row>
c0024827:	83 c4 10             	add    $0x10,%esp
static void
cls (void)
{
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c002482a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002482e:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0024832:	76 e8                	jbe    c002481c <cls+0xf>
    clear_row (y);

  cx = cy = 0;
c0024834:	c7 05 0c 99 03 c0 00 	movl   $0x0,0xc003990c
c002483b:	00 00 00 
c002483e:	a1 0c 99 03 c0       	mov    0xc003990c,%eax
c0024843:	a3 08 99 03 c0       	mov    %eax,0xc0039908
  move_cursor ();
c0024848:	e8 bd 00 00 00       	call   c002490a <move_cursor>
}
c002484d:	90                   	nop
c002484e:	c9                   	leave  
c002484f:	c3                   	ret    

c0024850 <clear_row>:

/* Clears row Y to spaces. */
static void
clear_row (size_t y) 
{
c0024850:	55                   	push   %ebp
c0024851:	89 e5                	mov    %esp,%ebp
c0024853:	83 ec 10             	sub    $0x10,%esp
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c0024856:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002485d:	eb 3f                	jmp    c002489e <clear_row+0x4e>
    {
      fb[y][x][0] = ' ';
c002485f:	8b 0d 10 99 03 c0    	mov    0xc0039910,%ecx
c0024865:	8b 55 08             	mov    0x8(%ebp),%edx
c0024868:	89 d0                	mov    %edx,%eax
c002486a:	c1 e0 02             	shl    $0x2,%eax
c002486d:	01 d0                	add    %edx,%eax
c002486f:	c1 e0 05             	shl    $0x5,%eax
c0024872:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024875:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0024878:	c6 04 42 20          	movb   $0x20,(%edx,%eax,2)
      fb[y][x][1] = GRAY_ON_BLACK;
c002487c:	8b 0d 10 99 03 c0    	mov    0xc0039910,%ecx
c0024882:	8b 55 08             	mov    0x8(%ebp),%edx
c0024885:	89 d0                	mov    %edx,%eax
c0024887:	c1 e0 02             	shl    $0x2,%eax
c002488a:	01 d0                	add    %edx,%eax
c002488c:	c1 e0 05             	shl    $0x5,%eax
c002488f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024892:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0024895:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
static void
clear_row (size_t y) 
{
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c002489a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c002489e:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
c00248a2:	76 bb                	jbe    c002485f <clear_row+0xf>
    {
      fb[y][x][0] = ' ';
      fb[y][x][1] = GRAY_ON_BLACK;
    }
}
c00248a4:	90                   	nop
c00248a5:	c9                   	leave  
c00248a6:	c3                   	ret    

c00248a7 <newline>:
/* Advances the cursor to the first column in the next line on
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
c00248a7:	55                   	push   %ebp
c00248a8:	89 e5                	mov    %esp,%ebp
c00248aa:	83 ec 08             	sub    $0x8,%esp
  cx = 0;
c00248ad:	c7 05 08 99 03 c0 00 	movl   $0x0,0xc0039908
c00248b4:	00 00 00 
  cy++;
c00248b7:	a1 0c 99 03 c0       	mov    0xc003990c,%eax
c00248bc:	83 c0 01             	add    $0x1,%eax
c00248bf:	a3 0c 99 03 c0       	mov    %eax,0xc003990c
  if (cy >= ROW_CNT)
c00248c4:	a1 0c 99 03 c0       	mov    0xc003990c,%eax
c00248c9:	83 f8 18             	cmp    $0x18,%eax
c00248cc:	76 39                	jbe    c0024907 <newline+0x60>
    {
      cy = ROW_CNT - 1;
c00248ce:	c7 05 0c 99 03 c0 18 	movl   $0x18,0xc003990c
c00248d5:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c00248d8:	a1 10 99 03 c0       	mov    0xc0039910,%eax
c00248dd:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c00248e3:	a1 10 99 03 c0       	mov    0xc0039910,%eax
c00248e8:	83 ec 04             	sub    $0x4,%esp
c00248eb:	68 00 0f 00 00       	push   $0xf00
c00248f0:	52                   	push   %edx
c00248f1:	50                   	push   %eax
c00248f2:	e8 fe 3c 00 00       	call   c00285f5 <memmove>
c00248f7:	83 c4 10             	add    $0x10,%esp
      clear_row (ROW_CNT - 1);
c00248fa:	83 ec 0c             	sub    $0xc,%esp
c00248fd:	6a 18                	push   $0x18
c00248ff:	e8 4c ff ff ff       	call   c0024850 <clear_row>
c0024904:	83 c4 10             	add    $0x10,%esp
    }
}
c0024907:	90                   	nop
c0024908:	c9                   	leave  
c0024909:	c3                   	ret    

c002490a <move_cursor>:

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c002490a:	55                   	push   %ebp
c002490b:	89 e5                	mov    %esp,%ebp
c002490d:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0024910:	a1 0c 99 03 c0       	mov    0xc003990c,%eax
c0024915:	89 c2                	mov    %eax,%edx
c0024917:	89 d0                	mov    %edx,%eax
c0024919:	c1 e0 02             	shl    $0x2,%eax
c002491c:	01 d0                	add    %edx,%eax
c002491e:	c1 e0 04             	shl    $0x4,%eax
c0024921:	89 c2                	mov    %eax,%edx
c0024923:	a1 08 99 03 c0       	mov    0xc0039908,%eax
c0024928:	01 d0                	add    %edx,%eax
c002492a:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  outw (0x3d4, 0x0e | (cp & 0xff00));
c002492e:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0024932:	b0 00                	mov    $0x0,%al
c0024934:	83 c8 0e             	or     $0xe,%eax
c0024937:	0f b7 c0             	movzwl %ax,%eax
c002493a:	50                   	push   %eax
c002493b:	68 d4 03 00 00       	push   $0x3d4
c0024940:	e8 f3 fc ff ff       	call   c0024638 <outw>
c0024945:	83 c4 08             	add    $0x8,%esp
  outw (0x3d4, 0x0f | (cp << 8));
c0024948:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c002494c:	c1 e0 08             	shl    $0x8,%eax
c002494f:	83 c8 0f             	or     $0xf,%eax
c0024952:	0f b7 c0             	movzwl %ax,%eax
c0024955:	50                   	push   %eax
c0024956:	68 d4 03 00 00       	push   $0x3d4
c002495b:	e8 d8 fc ff ff       	call   c0024638 <outw>
c0024960:	83 c4 08             	add    $0x8,%esp
}
c0024963:	90                   	nop
c0024964:	c9                   	leave  
c0024965:	c3                   	ret    

c0024966 <find_cursor>:

/* Reads the current hardware cursor position into (*X,*Y). */
static void
find_cursor (size_t *x, size_t *y) 
{
c0024966:	55                   	push   %ebp
c0024967:	89 e5                	mov    %esp,%ebp
c0024969:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
c002496c:	6a 0e                	push   $0xe
c002496e:	68 d4 03 00 00       	push   $0x3d4
c0024973:	e8 a1 fc ff ff       	call   c0024619 <outb>
c0024978:	83 c4 08             	add    $0x8,%esp
  cp = inb (0x3d5) << 8;
c002497b:	68 d5 03 00 00       	push   $0x3d5
c0024980:	e8 77 fc ff ff       	call   c00245fc <inb>
c0024985:	83 c4 04             	add    $0x4,%esp
c0024988:	0f b6 c0             	movzbl %al,%eax
c002498b:	c1 e0 08             	shl    $0x8,%eax
c002498e:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

  outb (0x3d4, 0x0f);
c0024992:	6a 0f                	push   $0xf
c0024994:	68 d4 03 00 00       	push   $0x3d4
c0024999:	e8 7b fc ff ff       	call   c0024619 <outb>
c002499e:	83 c4 08             	add    $0x8,%esp
  cp |= inb (0x3d5);
c00249a1:	68 d5 03 00 00       	push   $0x3d5
c00249a6:	e8 51 fc ff ff       	call   c00245fc <inb>
c00249ab:	83 c4 04             	add    $0x4,%esp
c00249ae:	0f b6 c0             	movzbl %al,%eax
c00249b1:	66 09 45 fe          	or     %ax,-0x2(%ebp)

  *x = cp % COL_CNT;
c00249b5:	0f b7 4d fe          	movzwl -0x2(%ebp),%ecx
c00249b9:	0f b7 c1             	movzwl %cx,%eax
c00249bc:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c00249c2:	c1 e8 10             	shr    $0x10,%eax
c00249c5:	89 c2                	mov    %eax,%edx
c00249c7:	66 c1 ea 06          	shr    $0x6,%dx
c00249cb:	89 d0                	mov    %edx,%eax
c00249cd:	c1 e0 02             	shl    $0x2,%eax
c00249d0:	01 d0                	add    %edx,%eax
c00249d2:	c1 e0 04             	shl    $0x4,%eax
c00249d5:	29 c1                	sub    %eax,%ecx
c00249d7:	89 ca                	mov    %ecx,%edx
c00249d9:	0f b7 d2             	movzwl %dx,%edx
c00249dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00249df:	89 10                	mov    %edx,(%eax)
  *y = cp / COL_CNT;
c00249e1:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00249e5:	0f b7 c0             	movzwl %ax,%eax
c00249e8:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c00249ee:	c1 e8 10             	shr    $0x10,%eax
c00249f1:	66 c1 e8 06          	shr    $0x6,%ax
c00249f5:	0f b7 d0             	movzwl %ax,%edx
c00249f8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00249fb:	89 10                	mov    %edx,(%eax)
}
c00249fd:	90                   	nop
c00249fe:	c9                   	leave  
c00249ff:	c3                   	ret    

c0024a00 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0024a00:	55                   	push   %ebp
c0024a01:	89 e5                	mov    %esp,%ebp
c0024a03:	83 ec 14             	sub    $0x14,%esp
c0024a06:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a09:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024a0d:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0024a11:	89 c2                	mov    %eax,%edx
c0024a13:	ec                   	in     (%dx),%al
c0024a14:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024a17:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0024a1b:	c9                   	leave  
c0024a1c:	c3                   	ret    

c0024a1d <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0024a1d:	55                   	push   %ebp
c0024a1e:	89 e5                	mov    %esp,%ebp
c0024a20:	83 ec 08             	sub    $0x8,%esp
c0024a23:	8b 55 08             	mov    0x8(%ebp),%edx
c0024a26:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024a29:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0024a2d:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024a30:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0024a34:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0024a38:	ee                   	out    %al,(%dx)
}
c0024a39:	90                   	nop
c0024a3a:	c9                   	leave  
c0024a3b:	c3                   	ret    

c0024a3c <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c0024a3c:	55                   	push   %ebp
c0024a3d:	89 e5                	mov    %esp,%ebp
c0024a3f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (mode == UNINIT);
c0024a42:	a1 20 99 03 c0       	mov    0xc0039920,%eax
c0024a47:	85 c0                	test   %eax,%eax
c0024a49:	74 1e                	je     c0024a69 <init_poll+0x2d>
c0024a4b:	83 ec 0c             	sub    $0xc,%esp
c0024a4e:	68 c4 f9 02 c0       	push   $0xc002f9c4
c0024a53:	68 d3 f9 02 c0       	push   $0xc002f9d3
c0024a58:	68 50 fa 02 c0       	push   $0xc002fa50
c0024a5d:	6a 45                	push   $0x45
c0024a5f:	68 ea f9 02 c0       	push   $0xc002f9ea
c0024a64:	e8 0f 4d 00 00       	call   c0029778 <debug_panic>
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
c0024a69:	83 ec 08             	sub    $0x8,%esp
c0024a6c:	6a 00                	push   $0x0
c0024a6e:	68 f9 03 00 00       	push   $0x3f9
c0024a73:	e8 a5 ff ff ff       	call   c0024a1d <outb>
c0024a78:	83 c4 10             	add    $0x10,%esp
  outb (FCR_REG, 0);                    /* Disable FIFO. */
c0024a7b:	83 ec 08             	sub    $0x8,%esp
c0024a7e:	6a 00                	push   $0x0
c0024a80:	68 fa 03 00 00       	push   $0x3fa
c0024a85:	e8 93 ff ff ff       	call   c0024a1d <outb>
c0024a8a:	83 c4 10             	add    $0x10,%esp
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
c0024a8d:	83 ec 0c             	sub    $0xc,%esp
c0024a90:	68 80 25 00 00       	push   $0x2580
c0024a95:	e8 e8 01 00 00       	call   c0024c82 <set_serial>
c0024a9a:	83 c4 10             	add    $0x10,%esp
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
c0024a9d:	83 ec 08             	sub    $0x8,%esp
c0024aa0:	6a 08                	push   $0x8
c0024aa2:	68 fc 03 00 00       	push   $0x3fc
c0024aa7:	e8 71 ff ff ff       	call   c0024a1d <outb>
c0024aac:	83 c4 10             	add    $0x10,%esp
  intq_init (&txq);
c0024aaf:	83 ec 0c             	sub    $0xc,%esp
c0024ab2:	68 40 99 03 c0       	push   $0xc0039940
c0024ab7:	e8 1a 1c 00 00       	call   c00266d6 <intq_init>
c0024abc:	83 c4 10             	add    $0x10,%esp
  mode = POLL;
c0024abf:	c7 05 20 99 03 c0 01 	movl   $0x1,0xc0039920
c0024ac6:	00 00 00 
} 
c0024ac9:	90                   	nop
c0024aca:	c9                   	leave  
c0024acb:	c3                   	ret    

c0024acc <serial_init_queue>:
/* Initializes the serial port device for queued interrupt-driven
   I/O.  With interrupt-driven I/O we don't waste CPU time
   waiting for the serial device to become ready. */
void
serial_init_queue (void) 
{
c0024acc:	55                   	push   %ebp
c0024acd:	89 e5                	mov    %esp,%ebp
c0024acf:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  if (mode == UNINIT)
c0024ad2:	a1 20 99 03 c0       	mov    0xc0039920,%eax
c0024ad7:	85 c0                	test   %eax,%eax
c0024ad9:	75 05                	jne    c0024ae0 <serial_init_queue+0x14>
    init_poll ();
c0024adb:	e8 5c ff ff ff       	call   c0024a3c <init_poll>
  ASSERT (mode == POLL);
c0024ae0:	a1 20 99 03 c0       	mov    0xc0039920,%eax
c0024ae5:	83 f8 01             	cmp    $0x1,%eax
c0024ae8:	74 1e                	je     c0024b08 <serial_init_queue+0x3c>
c0024aea:	83 ec 0c             	sub    $0xc,%esp
c0024aed:	68 01 fa 02 c0       	push   $0xc002fa01
c0024af2:	68 d3 f9 02 c0       	push   $0xc002f9d3
c0024af7:	68 5c fa 02 c0       	push   $0xc002fa5c
c0024afc:	6a 58                	push   $0x58
c0024afe:	68 ea f9 02 c0       	push   $0xc002f9ea
c0024b03:	e8 70 4c 00 00       	call   c0029778 <debug_panic>

  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c0024b08:	83 ec 04             	sub    $0x4,%esp
c0024b0b:	68 0e fa 02 c0       	push   $0xc002fa0e
c0024b10:	68 0b 4e 02 c0       	push   $0xc0024e0b
c0024b15:	6a 24                	push   $0x24
c0024b17:	e8 d1 cb ff ff       	call   c00216ed <intr_register_ext>
c0024b1c:	83 c4 10             	add    $0x10,%esp
  mode = QUEUE;
c0024b1f:	c7 05 20 99 03 c0 02 	movl   $0x2,0xc0039920
c0024b26:	00 00 00 
  old_level = intr_disable ();
c0024b29:	e8 9e c9 ff ff       	call   c00214cc <intr_disable>
c0024b2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  write_ier ();
c0024b31:	e8 f5 01 00 00       	call   c0024d2b <write_ier>
  intr_set_level (old_level);
c0024b36:	83 ec 0c             	sub    $0xc,%esp
c0024b39:	ff 75 f4             	pushl  -0xc(%ebp)
c0024b3c:	e8 33 c9 ff ff       	call   c0021474 <intr_set_level>
c0024b41:	83 c4 10             	add    $0x10,%esp
}
c0024b44:	90                   	nop
c0024b45:	c9                   	leave  
c0024b46:	c3                   	ret    

c0024b47 <serial_putc>:

/* Sends BYTE to the serial port. */
void
serial_putc (uint8_t byte) 
{
c0024b47:	55                   	push   %ebp
c0024b48:	89 e5                	mov    %esp,%ebp
c0024b4a:	83 ec 28             	sub    $0x28,%esp
c0024b4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024b50:	88 45 e4             	mov    %al,-0x1c(%ebp)
  enum intr_level old_level = intr_disable ();
c0024b53:	e8 74 c9 ff ff       	call   c00214cc <intr_disable>
c0024b58:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (mode != QUEUE)
c0024b5b:	a1 20 99 03 c0       	mov    0xc0039920,%eax
c0024b60:	83 f8 02             	cmp    $0x2,%eax
c0024b63:	74 20                	je     c0024b85 <serial_putc+0x3e>
    {
      /* If we're not set up for interrupt-driven I/O yet,
         use dumb polling to transmit a byte. */
      if (mode == UNINIT)
c0024b65:	a1 20 99 03 c0       	mov    0xc0039920,%eax
c0024b6a:	85 c0                	test   %eax,%eax
c0024b6c:	75 05                	jne    c0024b73 <serial_putc+0x2c>
        init_poll ();
c0024b6e:	e8 c9 fe ff ff       	call   c0024a3c <init_poll>
      putc_poll (byte); 
c0024b73:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0024b77:	83 ec 0c             	sub    $0xc,%esp
c0024b7a:	50                   	push   %eax
c0024b7b:	e8 22 02 00 00       	call   c0024da2 <putc_poll>
c0024b80:	83 c4 10             	add    $0x10,%esp
c0024b83:	eb 53                	jmp    c0024bd8 <serial_putc+0x91>
    }
  else 
    {
      /* Otherwise, queue a byte and update the interrupt enable
         register. */
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024b85:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024b89:	75 33                	jne    c0024bbe <serial_putc+0x77>
c0024b8b:	83 ec 0c             	sub    $0xc,%esp
c0024b8e:	68 40 99 03 c0       	push   $0xc0039940
c0024b93:	e8 c2 1b 00 00       	call   c002675a <intq_full>
c0024b98:	83 c4 10             	add    $0x10,%esp
c0024b9b:	84 c0                	test   %al,%al
c0024b9d:	74 1f                	je     c0024bbe <serial_putc+0x77>
          /* Interrupts are off and the transmit queue is full.
             If we wanted to wait for the queue to empty,
             we'd have to reenable interrupts.
             That's impolite, so we'll send a character via
             polling instead. */
          putc_poll (intq_getc (&txq)); 
c0024b9f:	83 ec 0c             	sub    $0xc,%esp
c0024ba2:	68 40 99 03 c0       	push   $0xc0039940
c0024ba7:	e8 fc 1b 00 00       	call   c00267a8 <intq_getc>
c0024bac:	83 c4 10             	add    $0x10,%esp
c0024baf:	0f b6 c0             	movzbl %al,%eax
c0024bb2:	83 ec 0c             	sub    $0xc,%esp
c0024bb5:	50                   	push   %eax
c0024bb6:	e8 e7 01 00 00       	call   c0024da2 <putc_poll>
c0024bbb:	83 c4 10             	add    $0x10,%esp
        }

      intq_putc (&txq, byte); 
c0024bbe:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0024bc2:	83 ec 08             	sub    $0x8,%esp
c0024bc5:	50                   	push   %eax
c0024bc6:	68 40 99 03 c0       	push   $0xc0039940
c0024bcb:	e8 ba 1c 00 00       	call   c002688a <intq_putc>
c0024bd0:	83 c4 10             	add    $0x10,%esp
      write_ier ();
c0024bd3:	e8 53 01 00 00       	call   c0024d2b <write_ier>
    }
  
  intr_set_level (old_level);
c0024bd8:	83 ec 0c             	sub    $0xc,%esp
c0024bdb:	ff 75 f4             	pushl  -0xc(%ebp)
c0024bde:	e8 91 c8 ff ff       	call   c0021474 <intr_set_level>
c0024be3:	83 c4 10             	add    $0x10,%esp
}
c0024be6:	90                   	nop
c0024be7:	c9                   	leave  
c0024be8:	c3                   	ret    

c0024be9 <serial_flush>:

/* Flushes anything in the serial buffer out the port in polling
   mode. */
void
serial_flush (void) 
{
c0024be9:	55                   	push   %ebp
c0024bea:	89 e5                	mov    %esp,%ebp
c0024bec:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0024bef:	e8 d8 c8 ff ff       	call   c00214cc <intr_disable>
c0024bf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!intq_empty (&txq))
c0024bf7:	eb 1f                	jmp    c0024c18 <serial_flush+0x2f>
    putc_poll (intq_getc (&txq));
c0024bf9:	83 ec 0c             	sub    $0xc,%esp
c0024bfc:	68 40 99 03 c0       	push   $0xc0039940
c0024c01:	e8 a2 1b 00 00       	call   c00267a8 <intq_getc>
c0024c06:	83 c4 10             	add    $0x10,%esp
c0024c09:	0f b6 c0             	movzbl %al,%eax
c0024c0c:	83 ec 0c             	sub    $0xc,%esp
c0024c0f:	50                   	push   %eax
c0024c10:	e8 8d 01 00 00       	call   c0024da2 <putc_poll>
c0024c15:	83 c4 10             	add    $0x10,%esp
   mode. */
void
serial_flush (void) 
{
  enum intr_level old_level = intr_disable ();
  while (!intq_empty (&txq))
c0024c18:	83 ec 0c             	sub    $0xc,%esp
c0024c1b:	68 40 99 03 c0       	push   $0xc0039940
c0024c20:	e8 f5 1a 00 00       	call   c002671a <intq_empty>
c0024c25:	83 c4 10             	add    $0x10,%esp
c0024c28:	83 f0 01             	xor    $0x1,%eax
c0024c2b:	84 c0                	test   %al,%al
c0024c2d:	75 ca                	jne    c0024bf9 <serial_flush+0x10>
    putc_poll (intq_getc (&txq));
  intr_set_level (old_level);
c0024c2f:	83 ec 0c             	sub    $0xc,%esp
c0024c32:	ff 75 f4             	pushl  -0xc(%ebp)
c0024c35:	e8 3a c8 ff ff       	call   c0021474 <intr_set_level>
c0024c3a:	83 c4 10             	add    $0x10,%esp
}
c0024c3d:	90                   	nop
c0024c3e:	c9                   	leave  
c0024c3f:	c3                   	ret    

c0024c40 <serial_notify>:
   whether we should block receive interrupts.
   Called by the input buffer routines when characters are added
   to or removed from the buffer. */
void
serial_notify (void) 
{
c0024c40:	55                   	push   %ebp
c0024c41:	89 e5                	mov    %esp,%ebp
c0024c43:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0024c46:	e8 0c c8 ff ff       	call   c0021457 <intr_get_level>
c0024c4b:	85 c0                	test   %eax,%eax
c0024c4d:	74 21                	je     c0024c70 <serial_notify+0x30>
c0024c4f:	83 ec 0c             	sub    $0xc,%esp
c0024c52:	68 15 fa 02 c0       	push   $0xc002fa15
c0024c57:	68 d3 f9 02 c0       	push   $0xc002f9d3
c0024c5c:	68 70 fa 02 c0       	push   $0xc002fa70
c0024c61:	68 96 00 00 00       	push   $0x96
c0024c66:	68 ea f9 02 c0       	push   $0xc002f9ea
c0024c6b:	e8 08 4b 00 00       	call   c0029778 <debug_panic>
  if (mode == QUEUE)
c0024c70:	a1 20 99 03 c0       	mov    0xc0039920,%eax
c0024c75:	83 f8 02             	cmp    $0x2,%eax
c0024c78:	75 05                	jne    c0024c7f <serial_notify+0x3f>
    write_ier ();
c0024c7a:	e8 ac 00 00 00       	call   c0024d2b <write_ier>
}
c0024c7f:	90                   	nop
c0024c80:	c9                   	leave  
c0024c81:	c3                   	ret    

c0024c82 <set_serial>:

/* Configures the serial port for BPS bits per second. */
static void
set_serial (int bps)
{
c0024c82:	55                   	push   %ebp
c0024c83:	89 e5                	mov    %esp,%ebp
c0024c85:	83 ec 18             	sub    $0x18,%esp
  int base_rate = 1843200 / 16;         /* Base rate of 16550A, in Hz. */
c0024c88:	c7 45 f4 00 c2 01 00 	movl   $0x1c200,-0xc(%ebp)
  uint16_t divisor = base_rate / bps;   /* Clock rate divisor. */
c0024c8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024c92:	99                   	cltd   
c0024c93:	f7 7d 08             	idivl  0x8(%ebp)
c0024c96:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

  ASSERT (bps >= 300 && bps <= 115200);
c0024c9a:	81 7d 08 2b 01 00 00 	cmpl   $0x12b,0x8(%ebp)
c0024ca1:	7e 09                	jle    c0024cac <set_serial+0x2a>
c0024ca3:	81 7d 08 00 c2 01 00 	cmpl   $0x1c200,0x8(%ebp)
c0024caa:	7e 21                	jle    c0024ccd <set_serial+0x4b>
c0024cac:	83 ec 0c             	sub    $0xc,%esp
c0024caf:	68 33 fa 02 c0       	push   $0xc002fa33
c0024cb4:	68 d3 f9 02 c0       	push   $0xc002f9d3
c0024cb9:	68 80 fa 02 c0       	push   $0xc002fa80
c0024cbe:	68 a2 00 00 00       	push   $0xa2
c0024cc3:	68 ea f9 02 c0       	push   $0xc002f9ea
c0024cc8:	e8 ab 4a 00 00       	call   c0029778 <debug_panic>

  /* Enable DLAB. */
  outb (LCR_REG, LCR_N81 | LCR_DLAB);
c0024ccd:	83 ec 08             	sub    $0x8,%esp
c0024cd0:	68 83 00 00 00       	push   $0x83
c0024cd5:	68 fb 03 00 00       	push   $0x3fb
c0024cda:	e8 3e fd ff ff       	call   c0024a1d <outb>
c0024cdf:	83 c4 10             	add    $0x10,%esp

  /* Set data rate. */
  outb (LS_REG, divisor & 0xff);
c0024ce2:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c0024ce6:	0f b6 c0             	movzbl %al,%eax
c0024ce9:	83 ec 08             	sub    $0x8,%esp
c0024cec:	50                   	push   %eax
c0024ced:	68 f8 03 00 00       	push   $0x3f8
c0024cf2:	e8 26 fd ff ff       	call   c0024a1d <outb>
c0024cf7:	83 c4 10             	add    $0x10,%esp
  outb (MS_REG, divisor >> 8);
c0024cfa:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c0024cfe:	66 c1 e8 08          	shr    $0x8,%ax
c0024d02:	0f b6 c0             	movzbl %al,%eax
c0024d05:	83 ec 08             	sub    $0x8,%esp
c0024d08:	50                   	push   %eax
c0024d09:	68 f9 03 00 00       	push   $0x3f9
c0024d0e:	e8 0a fd ff ff       	call   c0024a1d <outb>
c0024d13:	83 c4 10             	add    $0x10,%esp
  
  /* Reset DLAB. */
  outb (LCR_REG, LCR_N81);
c0024d16:	83 ec 08             	sub    $0x8,%esp
c0024d19:	6a 03                	push   $0x3
c0024d1b:	68 fb 03 00 00       	push   $0x3fb
c0024d20:	e8 f8 fc ff ff       	call   c0024a1d <outb>
c0024d25:	83 c4 10             	add    $0x10,%esp
}
c0024d28:	90                   	nop
c0024d29:	c9                   	leave  
c0024d2a:	c3                   	ret    

c0024d2b <write_ier>:

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0024d2b:	55                   	push   %ebp
c0024d2c:	89 e5                	mov    %esp,%ebp
c0024d2e:	83 ec 18             	sub    $0x18,%esp
  uint8_t ier = 0;
c0024d31:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c0024d35:	e8 1d c7 ff ff       	call   c0021457 <intr_get_level>
c0024d3a:	85 c0                	test   %eax,%eax
c0024d3c:	74 21                	je     c0024d5f <write_ier+0x34>
c0024d3e:	83 ec 0c             	sub    $0xc,%esp
c0024d41:	68 15 fa 02 c0       	push   $0xc002fa15
c0024d46:	68 d3 f9 02 c0       	push   $0xc002f9d3
c0024d4b:	68 8c fa 02 c0       	push   $0xc002fa8c
c0024d50:	68 b5 00 00 00       	push   $0xb5
c0024d55:	68 ea f9 02 c0       	push   $0xc002f9ea
c0024d5a:	e8 19 4a 00 00       	call   c0029778 <debug_panic>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0024d5f:	83 ec 0c             	sub    $0xc,%esp
c0024d62:	68 40 99 03 c0       	push   $0xc0039940
c0024d67:	e8 ae 19 00 00       	call   c002671a <intq_empty>
c0024d6c:	83 c4 10             	add    $0x10,%esp
c0024d6f:	83 f0 01             	xor    $0x1,%eax
c0024d72:	84 c0                	test   %al,%al
c0024d74:	74 04                	je     c0024d7a <write_ier+0x4f>
    ier |= IER_XMIT;
c0024d76:	80 4d f7 02          	orb    $0x2,-0x9(%ebp)

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c0024d7a:	e8 18 19 00 00       	call   c0026697 <input_full>
c0024d7f:	83 f0 01             	xor    $0x1,%eax
c0024d82:	84 c0                	test   %al,%al
c0024d84:	74 04                	je     c0024d8a <write_ier+0x5f>
    ier |= IER_RECV;
c0024d86:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
  
  outb (IER_REG, ier);
c0024d8a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0024d8e:	83 ec 08             	sub    $0x8,%esp
c0024d91:	50                   	push   %eax
c0024d92:	68 f9 03 00 00       	push   $0x3f9
c0024d97:	e8 81 fc ff ff       	call   c0024a1d <outb>
c0024d9c:	83 c4 10             	add    $0x10,%esp
}
c0024d9f:	90                   	nop
c0024da0:	c9                   	leave  
c0024da1:	c3                   	ret    

c0024da2 <putc_poll>:

/* Polls the serial port until it's ready,
   and then transmits BYTE. */
static void
putc_poll (uint8_t byte) 
{
c0024da2:	55                   	push   %ebp
c0024da3:	89 e5                	mov    %esp,%ebp
c0024da5:	83 ec 18             	sub    $0x18,%esp
c0024da8:	8b 45 08             	mov    0x8(%ebp),%eax
c0024dab:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0024dae:	e8 a4 c6 ff ff       	call   c0021457 <intr_get_level>
c0024db3:	85 c0                	test   %eax,%eax
c0024db5:	74 22                	je     c0024dd9 <putc_poll+0x37>
c0024db7:	83 ec 0c             	sub    $0xc,%esp
c0024dba:	68 15 fa 02 c0       	push   $0xc002fa15
c0024dbf:	68 d3 f9 02 c0       	push   $0xc002f9d3
c0024dc4:	68 98 fa 02 c0       	push   $0xc002fa98
c0024dc9:	68 c9 00 00 00       	push   $0xc9
c0024dce:	68 ea f9 02 c0       	push   $0xc002f9ea
c0024dd3:	e8 a0 49 00 00       	call   c0029778 <debug_panic>

  while ((inb (LSR_REG) & LSR_THRE) == 0)
    continue;
c0024dd8:	90                   	nop
static void
putc_poll (uint8_t byte) 
{
  ASSERT (intr_get_level () == INTR_OFF);

  while ((inb (LSR_REG) & LSR_THRE) == 0)
c0024dd9:	83 ec 0c             	sub    $0xc,%esp
c0024ddc:	68 fd 03 00 00       	push   $0x3fd
c0024de1:	e8 1a fc ff ff       	call   c0024a00 <inb>
c0024de6:	83 c4 10             	add    $0x10,%esp
c0024de9:	0f b6 c0             	movzbl %al,%eax
c0024dec:	83 e0 20             	and    $0x20,%eax
c0024def:	85 c0                	test   %eax,%eax
c0024df1:	74 e5                	je     c0024dd8 <putc_poll+0x36>
    continue;
  outb (THR_REG, byte);
c0024df3:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0024df7:	83 ec 08             	sub    $0x8,%esp
c0024dfa:	50                   	push   %eax
c0024dfb:	68 f8 03 00 00       	push   $0x3f8
c0024e00:	e8 18 fc ff ff       	call   c0024a1d <outb>
c0024e05:	83 c4 10             	add    $0x10,%esp
}
c0024e08:	90                   	nop
c0024e09:	c9                   	leave  
c0024e0a:	c3                   	ret    

c0024e0b <serial_interrupt>:

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c0024e0b:	55                   	push   %ebp
c0024e0c:	89 e5                	mov    %esp,%ebp
c0024e0e:	83 ec 08             	sub    $0x8,%esp
  /* Inquire about interrupt in UART.  Without this, we can
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);
c0024e11:	68 fa 03 00 00       	push   $0x3fa
c0024e16:	e8 e5 fb ff ff       	call   c0024a00 <inb>
c0024e1b:	83 c4 04             	add    $0x4,%esp

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024e1e:	eb 1c                	jmp    c0024e3c <serial_interrupt+0x31>
    input_putc (inb (RBR_REG));
c0024e20:	68 f8 03 00 00       	push   $0x3f8
c0024e25:	e8 d6 fb ff ff       	call   c0024a00 <inb>
c0024e2a:	83 c4 04             	add    $0x4,%esp
c0024e2d:	0f b6 c0             	movzbl %al,%eax
c0024e30:	83 ec 0c             	sub    $0xc,%esp
c0024e33:	50                   	push   %eax
c0024e34:	e8 9f 17 00 00       	call   c00265d8 <input_putc>
c0024e39:	83 c4 10             	add    $0x10,%esp
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024e3c:	e8 56 18 00 00       	call   c0026697 <input_full>
c0024e41:	83 f0 01             	xor    $0x1,%eax
c0024e44:	84 c0                	test   %al,%al
c0024e46:	74 40                	je     c0024e88 <serial_interrupt+0x7d>
c0024e48:	83 ec 0c             	sub    $0xc,%esp
c0024e4b:	68 fd 03 00 00       	push   $0x3fd
c0024e50:	e8 ab fb ff ff       	call   c0024a00 <inb>
c0024e55:	83 c4 10             	add    $0x10,%esp
c0024e58:	0f b6 c0             	movzbl %al,%eax
c0024e5b:	83 e0 01             	and    $0x1,%eax
c0024e5e:	85 c0                	test   %eax,%eax
c0024e60:	75 be                	jne    c0024e20 <serial_interrupt+0x15>
    input_putc (inb (RBR_REG));

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024e62:	eb 24                	jmp    c0024e88 <serial_interrupt+0x7d>
    outb (THR_REG, intq_getc (&txq));
c0024e64:	83 ec 0c             	sub    $0xc,%esp
c0024e67:	68 40 99 03 c0       	push   $0xc0039940
c0024e6c:	e8 37 19 00 00       	call   c00267a8 <intq_getc>
c0024e71:	83 c4 10             	add    $0x10,%esp
c0024e74:	0f b6 c0             	movzbl %al,%eax
c0024e77:	83 ec 08             	sub    $0x8,%esp
c0024e7a:	50                   	push   %eax
c0024e7b:	68 f8 03 00 00       	push   $0x3f8
c0024e80:	e8 98 fb ff ff       	call   c0024a1d <outb>
c0024e85:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
    input_putc (inb (RBR_REG));

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024e88:	83 ec 0c             	sub    $0xc,%esp
c0024e8b:	68 40 99 03 c0       	push   $0xc0039940
c0024e90:	e8 85 18 00 00       	call   c002671a <intq_empty>
c0024e95:	83 c4 10             	add    $0x10,%esp
c0024e98:	83 f0 01             	xor    $0x1,%eax
c0024e9b:	84 c0                	test   %al,%al
c0024e9d:	74 1a                	je     c0024eb9 <serial_interrupt+0xae>
c0024e9f:	83 ec 0c             	sub    $0xc,%esp
c0024ea2:	68 fd 03 00 00       	push   $0x3fd
c0024ea7:	e8 54 fb ff ff       	call   c0024a00 <inb>
c0024eac:	83 c4 10             	add    $0x10,%esp
c0024eaf:	0f b6 c0             	movzbl %al,%eax
c0024eb2:	83 e0 20             	and    $0x20,%eax
c0024eb5:	85 c0                	test   %eax,%eax
c0024eb7:	75 ab                	jne    c0024e64 <serial_interrupt+0x59>
    outb (THR_REG, intq_getc (&txq));

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024eb9:	e8 6d fe ff ff       	call   c0024d2b <write_ier>
}
c0024ebe:	90                   	nop
c0024ebf:	c9                   	leave  
c0024ec0:	c3                   	ret    

c0024ec1 <block_type_name>:

/* Returns a human-readable name for the given block device
   TYPE. */
const char *
block_type_name (enum block_type type)
{
c0024ec1:	55                   	push   %ebp
c0024ec2:	89 e5                	mov    %esp,%ebp
c0024ec4:	83 ec 08             	sub    $0x8,%esp
      "swap",
      "raw",
      "foreign",
    };

  ASSERT (type < BLOCK_CNT);
c0024ec7:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
c0024ecb:	76 1e                	jbe    c0024eeb <block_type_name+0x2a>
c0024ecd:	83 ec 0c             	sub    $0xc,%esp
c0024ed0:	68 a4 fa 02 c0       	push   $0xc002faa4
c0024ed5:	68 b5 fa 02 c0       	push   $0xc002fab5
c0024eda:	68 bc fb 02 c0       	push   $0xc002fbbc
c0024edf:	6a 2f                	push   $0x2f
c0024ee1:	68 cc fa 02 c0       	push   $0xc002facc
c0024ee6:	e8 8d 48 00 00       	call   c0029778 <debug_panic>
  return block_type_names[type];
c0024eeb:	8b 45 08             	mov    0x8(%ebp),%eax
c0024eee:	8b 04 85 9c 7c 03 c0 	mov    -0x3ffc8364(,%eax,4),%eax
}
c0024ef5:	c9                   	leave  
c0024ef6:	c3                   	ret    

c0024ef7 <block_get_role>:

/* Returns the block device fulfilling the given ROLE, or a null
   pointer if no block device has been assigned that role. */
struct block *
block_get_role (enum block_type role)
{
c0024ef7:	55                   	push   %ebp
c0024ef8:	89 e5                	mov    %esp,%ebp
c0024efa:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0024efd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0024f01:	76 1e                	jbe    c0024f21 <block_get_role+0x2a>
c0024f03:	83 ec 0c             	sub    $0xc,%esp
c0024f06:	68 e2 fa 02 c0       	push   $0xc002fae2
c0024f0b:	68 b5 fa 02 c0       	push   $0xc002fab5
c0024f10:	68 f4 fb 02 c0       	push   $0xc002fbf4
c0024f15:	6a 38                	push   $0x38
c0024f17:	68 cc fa 02 c0       	push   $0xc002facc
c0024f1c:	e8 57 48 00 00       	call   c0029778 <debug_panic>
  return block_by_role[role];
c0024f21:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f24:	8b 04 85 a8 99 03 c0 	mov    -0x3ffc6658(,%eax,4),%eax
}
c0024f2b:	c9                   	leave  
c0024f2c:	c3                   	ret    

c0024f2d <block_set_role>:

/* Assigns BLOCK the given ROLE. */
void
block_set_role (enum block_type role, struct block *block)
{
c0024f2d:	55                   	push   %ebp
c0024f2e:	89 e5                	mov    %esp,%ebp
c0024f30:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0024f33:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0024f37:	76 1e                	jbe    c0024f57 <block_set_role+0x2a>
c0024f39:	83 ec 0c             	sub    $0xc,%esp
c0024f3c:	68 e2 fa 02 c0       	push   $0xc002fae2
c0024f41:	68 b5 fa 02 c0       	push   $0xc002fab5
c0024f46:	68 04 fc 02 c0       	push   $0xc002fc04
c0024f4b:	6a 40                	push   $0x40
c0024f4d:	68 cc fa 02 c0       	push   $0xc002facc
c0024f52:	e8 21 48 00 00       	call   c0029778 <debug_panic>
  block_by_role[role] = block;
c0024f57:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f5a:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024f5d:	89 14 85 a8 99 03 c0 	mov    %edx,-0x3ffc6658(,%eax,4)
}
c0024f64:	90                   	nop
c0024f65:	c9                   	leave  
c0024f66:	c3                   	ret    

c0024f67 <block_first>:

/* Returns the first block device in kernel probe order, or a
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
c0024f67:	55                   	push   %ebp
c0024f68:	89 e5                	mov    %esp,%ebp
c0024f6a:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c0024f6d:	83 ec 0c             	sub    $0xc,%esp
c0024f70:	68 8c 7c 03 c0       	push   $0xc0037c8c
c0024f75:	e8 c6 4a 00 00       	call   c0029a40 <list_begin>
c0024f7a:	83 c4 10             	add    $0x10,%esp
c0024f7d:	83 ec 0c             	sub    $0xc,%esp
c0024f80:	50                   	push   %eax
c0024f81:	e8 6d 03 00 00       	call   c00252f3 <list_elem_to_block>
c0024f86:	83 c4 10             	add    $0x10,%esp
}
c0024f89:	c9                   	leave  
c0024f8a:	c3                   	ret    

c0024f8b <block_next>:

/* Returns the block device following BLOCK in kernel probe
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
c0024f8b:	55                   	push   %ebp
c0024f8c:	89 e5                	mov    %esp,%ebp
c0024f8e:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c0024f91:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f94:	83 ec 0c             	sub    $0xc,%esp
c0024f97:	50                   	push   %eax
c0024f98:	e8 d5 4a 00 00       	call   c0029a72 <list_next>
c0024f9d:	83 c4 10             	add    $0x10,%esp
c0024fa0:	83 ec 0c             	sub    $0xc,%esp
c0024fa3:	50                   	push   %eax
c0024fa4:	e8 4a 03 00 00       	call   c00252f3 <list_elem_to_block>
c0024fa9:	83 c4 10             	add    $0x10,%esp
}
c0024fac:	c9                   	leave  
c0024fad:	c3                   	ret    

c0024fae <block_get_by_name>:

/* Returns the block device with the given NAME, or a null
   pointer if no block device has that name. */
struct block *
block_get_by_name (const char *name)
{
c0024fae:	55                   	push   %ebp
c0024faf:	89 e5                	mov    %esp,%ebp
c0024fb1:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024fb4:	83 ec 0c             	sub    $0xc,%esp
c0024fb7:	68 8c 7c 03 c0       	push   $0xc0037c8c
c0024fbc:	e8 7f 4a 00 00       	call   c0029a40 <list_begin>
c0024fc1:	83 c4 10             	add    $0x10,%esp
c0024fc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0024fc7:	eb 3b                	jmp    c0025004 <block_get_by_name+0x56>
       e = list_next (e))
    {
      struct block *block = list_entry (e, struct block, list_elem);
c0024fc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024fcc:	83 c0 04             	add    $0x4,%eax
c0024fcf:	83 e8 04             	sub    $0x4,%eax
c0024fd2:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!strcmp (name, block->name))
c0024fd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024fd8:	83 c0 08             	add    $0x8,%eax
c0024fdb:	83 ec 08             	sub    $0x8,%esp
c0024fde:	50                   	push   %eax
c0024fdf:	ff 75 08             	pushl  0x8(%ebp)
c0024fe2:	e8 87 37 00 00       	call   c002876e <strcmp>
c0024fe7:	83 c4 10             	add    $0x10,%esp
c0024fea:	85 c0                	test   %eax,%eax
c0024fec:	75 05                	jne    c0024ff3 <block_get_by_name+0x45>
        return block;
c0024fee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024ff1:	eb 2b                	jmp    c002501e <block_get_by_name+0x70>
block_get_by_name (const char *name)
{
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
       e = list_next (e))
c0024ff3:	83 ec 0c             	sub    $0xc,%esp
c0024ff6:	ff 75 f4             	pushl  -0xc(%ebp)
c0024ff9:	e8 74 4a 00 00       	call   c0029a72 <list_next>
c0024ffe:	83 c4 10             	add    $0x10,%esp
c0025001:	89 45 f4             	mov    %eax,-0xc(%ebp)
struct block *
block_get_by_name (const char *name)
{
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0025004:	83 ec 0c             	sub    $0xc,%esp
c0025007:	68 8c 7c 03 c0       	push   $0xc0037c8c
c002500c:	e8 ab 4a 00 00       	call   c0029abc <list_end>
c0025011:	83 c4 10             	add    $0x10,%esp
c0025014:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0025017:	75 b0                	jne    c0024fc9 <block_get_by_name+0x1b>
      struct block *block = list_entry (e, struct block, list_elem);
      if (!strcmp (name, block->name))
        return block;
    }

  return NULL;
c0025019:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002501e:	c9                   	leave  
c002501f:	c3                   	ret    

c0025020 <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c0025020:	55                   	push   %ebp
c0025021:	89 e5                	mov    %esp,%ebp
c0025023:	53                   	push   %ebx
c0025024:	83 ec 04             	sub    $0x4,%esp
  if (sector >= block->size)
c0025027:	8b 45 08             	mov    0x8(%ebp),%eax
c002502a:	8b 40 1c             	mov    0x1c(%eax),%eax
c002502d:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0025030:	77 32                	ja     c0025064 <check_sector+0x44>
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0025032:	8b 45 08             	mov    0x8(%ebp),%eax
c0025035:	8b 58 1c             	mov    0x1c(%eax),%ebx
c0025038:	83 ec 0c             	sub    $0xc,%esp
c002503b:	ff 75 08             	pushl  0x8(%ebp)
c002503e:	e8 fd 00 00 00       	call   c0025140 <block_name>
c0025043:	83 c4 10             	add    $0x10,%esp
c0025046:	83 ec 04             	sub    $0x4,%esp
c0025049:	53                   	push   %ebx
c002504a:	ff 75 0c             	pushl  0xc(%ebp)
c002504d:	50                   	push   %eax
c002504e:	68 f8 fa 02 c0       	push   $0xc002faf8
c0025053:	68 14 fc 02 c0       	push   $0xc002fc14
c0025058:	6a 70                	push   $0x70
c002505a:	68 cc fa 02 c0       	push   $0xc002facc
c002505f:	e8 14 47 00 00       	call   c0029778 <debug_panic>
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c0025064:	90                   	nop
c0025065:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025068:	c9                   	leave  
c0025069:	c3                   	ret    

c002506a <block_read>:
   have room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_read (struct block *block, block_sector_t sector, void *buffer)
{
c002506a:	55                   	push   %ebp
c002506b:	89 e5                	mov    %esp,%ebp
c002506d:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0025070:	83 ec 08             	sub    $0x8,%esp
c0025073:	ff 75 0c             	pushl  0xc(%ebp)
c0025076:	ff 75 08             	pushl  0x8(%ebp)
c0025079:	e8 a2 ff ff ff       	call   c0025020 <check_sector>
c002507e:	83 c4 10             	add    $0x10,%esp
  block->ops->read (block->aux, sector, buffer);
c0025081:	8b 45 08             	mov    0x8(%ebp),%eax
c0025084:	8b 40 20             	mov    0x20(%eax),%eax
c0025087:	8b 00                	mov    (%eax),%eax
c0025089:	8b 55 08             	mov    0x8(%ebp),%edx
c002508c:	8b 52 24             	mov    0x24(%edx),%edx
c002508f:	83 ec 04             	sub    $0x4,%esp
c0025092:	ff 75 10             	pushl  0x10(%ebp)
c0025095:	ff 75 0c             	pushl  0xc(%ebp)
c0025098:	52                   	push   %edx
c0025099:	ff d0                	call   *%eax
c002509b:	83 c4 10             	add    $0x10,%esp
  block->read_cnt++;
c002509e:	8b 45 08             	mov    0x8(%ebp),%eax
c00250a1:	8b 50 2c             	mov    0x2c(%eax),%edx
c00250a4:	8b 40 28             	mov    0x28(%eax),%eax
c00250a7:	83 c0 01             	add    $0x1,%eax
c00250aa:	83 d2 00             	adc    $0x0,%edx
c00250ad:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00250b0:	89 41 28             	mov    %eax,0x28(%ecx)
c00250b3:	89 51 2c             	mov    %edx,0x2c(%ecx)
}
c00250b6:	90                   	nop
c00250b7:	c9                   	leave  
c00250b8:	c3                   	ret    

c00250b9 <block_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_write (struct block *block, block_sector_t sector, const void *buffer)
{
c00250b9:	55                   	push   %ebp
c00250ba:	89 e5                	mov    %esp,%ebp
c00250bc:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c00250bf:	83 ec 08             	sub    $0x8,%esp
c00250c2:	ff 75 0c             	pushl  0xc(%ebp)
c00250c5:	ff 75 08             	pushl  0x8(%ebp)
c00250c8:	e8 53 ff ff ff       	call   c0025020 <check_sector>
c00250cd:	83 c4 10             	add    $0x10,%esp
  ASSERT (block->type != BLOCK_FOREIGN);
c00250d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00250d3:	8b 40 18             	mov    0x18(%eax),%eax
c00250d6:	83 f8 05             	cmp    $0x5,%eax
c00250d9:	75 21                	jne    c00250fc <block_write+0x43>
c00250db:	83 ec 0c             	sub    $0xc,%esp
c00250de:	68 2b fb 02 c0       	push   $0xc002fb2b
c00250e3:	68 b5 fa 02 c0       	push   $0xc002fab5
c00250e8:	68 24 fc 02 c0       	push   $0xc002fc24
c00250ed:	68 89 00 00 00       	push   $0x89
c00250f2:	68 cc fa 02 c0       	push   $0xc002facc
c00250f7:	e8 7c 46 00 00       	call   c0029778 <debug_panic>
  block->ops->write (block->aux, sector, buffer);
c00250fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00250ff:	8b 40 20             	mov    0x20(%eax),%eax
c0025102:	8b 40 04             	mov    0x4(%eax),%eax
c0025105:	8b 55 08             	mov    0x8(%ebp),%edx
c0025108:	8b 52 24             	mov    0x24(%edx),%edx
c002510b:	83 ec 04             	sub    $0x4,%esp
c002510e:	ff 75 10             	pushl  0x10(%ebp)
c0025111:	ff 75 0c             	pushl  0xc(%ebp)
c0025114:	52                   	push   %edx
c0025115:	ff d0                	call   *%eax
c0025117:	83 c4 10             	add    $0x10,%esp
  block->write_cnt++;
c002511a:	8b 45 08             	mov    0x8(%ebp),%eax
c002511d:	8b 50 34             	mov    0x34(%eax),%edx
c0025120:	8b 40 30             	mov    0x30(%eax),%eax
c0025123:	83 c0 01             	add    $0x1,%eax
c0025126:	83 d2 00             	adc    $0x0,%edx
c0025129:	8b 4d 08             	mov    0x8(%ebp),%ecx
c002512c:	89 41 30             	mov    %eax,0x30(%ecx)
c002512f:	89 51 34             	mov    %edx,0x34(%ecx)
}
c0025132:	90                   	nop
c0025133:	c9                   	leave  
c0025134:	c3                   	ret    

c0025135 <block_size>:

/* Returns the number of sectors in BLOCK. */
block_sector_t
block_size (struct block *block)
{
c0025135:	55                   	push   %ebp
c0025136:	89 e5                	mov    %esp,%ebp
  return block->size;
c0025138:	8b 45 08             	mov    0x8(%ebp),%eax
c002513b:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c002513e:	5d                   	pop    %ebp
c002513f:	c3                   	ret    

c0025140 <block_name>:

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
c0025140:	55                   	push   %ebp
c0025141:	89 e5                	mov    %esp,%ebp
  return block->name;
c0025143:	8b 45 08             	mov    0x8(%ebp),%eax
c0025146:	83 c0 08             	add    $0x8,%eax
}
c0025149:	5d                   	pop    %ebp
c002514a:	c3                   	ret    

c002514b <block_type>:

/* Returns BLOCK's type. */
enum block_type
block_type (struct block *block)
{
c002514b:	55                   	push   %ebp
c002514c:	89 e5                	mov    %esp,%ebp
  return block->type;
c002514e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025151:	8b 40 18             	mov    0x18(%eax),%eax
}
c0025154:	5d                   	pop    %ebp
c0025155:	c3                   	ret    

c0025156 <block_print_stats>:

/* Prints statistics for each block device used for a Pintos role. */
void
block_print_stats (void)
{
c0025156:	55                   	push   %ebp
c0025157:	89 e5                	mov    %esp,%ebp
c0025159:	56                   	push   %esi
c002515a:	53                   	push   %ebx
c002515b:	83 ec 20             	sub    $0x20,%esp
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c002515e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025165:	eb 63                	jmp    c00251ca <block_print_stats+0x74>
    {
      struct block *block = block_by_role[i];
c0025167:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002516a:	8b 04 85 a8 99 03 c0 	mov    -0x3ffc6658(,%eax,4),%eax
c0025171:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (block != NULL)
c0025174:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025178:	74 4c                	je     c00251c6 <block_print_stats+0x70>
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c002517a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002517d:	8b 50 34             	mov    0x34(%eax),%edx
c0025180:	8b 40 30             	mov    0x30(%eax),%eax
c0025183:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0025186:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0025189:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002518c:	8b 58 28             	mov    0x28(%eax),%ebx
c002518f:	8b 70 2c             	mov    0x2c(%eax),%esi
c0025192:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025195:	8b 40 18             	mov    0x18(%eax),%eax
c0025198:	83 ec 0c             	sub    $0xc,%esp
c002519b:	50                   	push   %eax
c002519c:	e8 20 fd ff ff       	call   c0024ec1 <block_type_name>
c00251a1:	83 c4 10             	add    $0x10,%esp
c00251a4:	89 c2                	mov    %eax,%edx
                  block->name, block_type_name (block->type),
c00251a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00251a9:	83 c0 08             	add    $0x8,%eax
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
    {
      struct block *block = block_by_role[i];
      if (block != NULL)
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c00251ac:	83 ec 04             	sub    $0x4,%esp
c00251af:	ff 75 e4             	pushl  -0x1c(%ebp)
c00251b2:	ff 75 e0             	pushl  -0x20(%ebp)
c00251b5:	56                   	push   %esi
c00251b6:	53                   	push   %ebx
c00251b7:	52                   	push   %edx
c00251b8:	50                   	push   %eax
c00251b9:	68 48 fb 02 c0       	push   $0xc002fb48
c00251be:	e8 82 21 00 00       	call   c0027345 <printf>
c00251c3:	83 c4 20             	add    $0x20,%esp
void
block_print_stats (void)
{
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c00251c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00251ca:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c00251ce:	7e 97                	jle    c0025167 <block_print_stats+0x11>
          printf ("%s (%s): %llu reads, %llu writes\n",
                  block->name, block_type_name (block->type),
                  block->read_cnt, block->write_cnt);
        }
    }
}
c00251d0:	90                   	nop
c00251d1:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00251d4:	5b                   	pop    %ebx
c00251d5:	5e                   	pop    %esi
c00251d6:	5d                   	pop    %ebp
c00251d7:	c3                   	ret    

c00251d8 <block_register>:
   will be passed AUX in each function call. */
struct block *
block_register (const char *name, enum block_type type,
                const char *extra_info, block_sector_t size,
                const struct block_operations *ops, void *aux)
{
c00251d8:	55                   	push   %ebp
c00251d9:	89 e5                	mov    %esp,%ebp
c00251db:	83 ec 18             	sub    $0x18,%esp
  struct block *block = malloc (sizeof *block);
c00251de:	83 ec 0c             	sub    $0xc,%esp
c00251e1:	6a 38                	push   $0x38
c00251e3:	e8 c1 e3 ff ff       	call   c00235a9 <malloc>
c00251e8:	83 c4 10             	add    $0x10,%esp
c00251eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (block == NULL)
c00251ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00251f2:	75 19                	jne    c002520d <block_register+0x35>
    PANIC ("Failed to allocate memory for block device descriptor");
c00251f4:	68 6c fb 02 c0       	push   $0xc002fb6c
c00251f9:	68 30 fc 02 c0       	push   $0xc002fc30
c00251fe:	68 c1 00 00 00       	push   $0xc1
c0025203:	68 cc fa 02 c0       	push   $0xc002facc
c0025208:	e8 6b 45 00 00       	call   c0029778 <debug_panic>

  list_push_back (&all_blocks, &block->list_elem);
c002520d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025210:	83 ec 08             	sub    $0x8,%esp
c0025213:	50                   	push   %eax
c0025214:	68 8c 7c 03 c0       	push   $0xc0037c8c
c0025219:	e8 ad 4b 00 00       	call   c0029dcb <list_push_back>
c002521e:	83 c4 10             	add    $0x10,%esp
  strlcpy (block->name, name, sizeof block->name);
c0025221:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025224:	83 c0 08             	add    $0x8,%eax
c0025227:	83 ec 04             	sub    $0x4,%esp
c002522a:	6a 10                	push   $0x10
c002522c:	ff 75 08             	pushl  0x8(%ebp)
c002522f:	50                   	push   %eax
c0025230:	e8 0e 3a 00 00       	call   c0028c43 <strlcpy>
c0025235:	83 c4 10             	add    $0x10,%esp
  block->type = type;
c0025238:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002523b:	8b 55 0c             	mov    0xc(%ebp),%edx
c002523e:	89 50 18             	mov    %edx,0x18(%eax)
  block->size = size;
c0025241:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025244:	8b 55 14             	mov    0x14(%ebp),%edx
c0025247:	89 50 1c             	mov    %edx,0x1c(%eax)
  block->ops = ops;
c002524a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002524d:	8b 55 18             	mov    0x18(%ebp),%edx
c0025250:	89 50 20             	mov    %edx,0x20(%eax)
  block->aux = aux;
c0025253:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025256:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0025259:	89 50 24             	mov    %edx,0x24(%eax)
  block->read_cnt = 0;
c002525c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002525f:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0025266:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  block->write_cnt = 0;
c002526d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025270:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
c0025277:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c002527e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025281:	8b 40 1c             	mov    0x1c(%eax),%eax
c0025284:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025287:	83 c2 08             	add    $0x8,%edx
c002528a:	83 ec 04             	sub    $0x4,%esp
c002528d:	50                   	push   %eax
c002528e:	52                   	push   %edx
c002528f:	68 a2 fb 02 c0       	push   $0xc002fba2
c0025294:	e8 ac 20 00 00       	call   c0027345 <printf>
c0025299:	83 c4 10             	add    $0x10,%esp
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c002529c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002529f:	8b 40 1c             	mov    0x1c(%eax),%eax
c00252a2:	ba 00 00 00 00       	mov    $0x0,%edx
c00252a7:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c00252ab:	c1 e0 09             	shl    $0x9,%eax
c00252ae:	83 ec 08             	sub    $0x8,%esp
c00252b1:	52                   	push   %edx
c00252b2:	50                   	push   %eax
c00252b3:	e8 b2 2d 00 00       	call   c002806a <print_human_readable_size>
c00252b8:	83 c4 10             	add    $0x10,%esp
  printf (")");
c00252bb:	83 ec 0c             	sub    $0xc,%esp
c00252be:	6a 29                	push   $0x29
c00252c0:	e8 ee 66 00 00       	call   c002b9b3 <putchar>
c00252c5:	83 c4 10             	add    $0x10,%esp
  if (extra_info != NULL)
c00252c8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00252cc:	74 13                	je     c00252e1 <block_register+0x109>
    printf (", %s", extra_info);
c00252ce:	83 ec 08             	sub    $0x8,%esp
c00252d1:	ff 75 10             	pushl  0x10(%ebp)
c00252d4:	68 b4 fb 02 c0       	push   $0xc002fbb4
c00252d9:	e8 67 20 00 00       	call   c0027345 <printf>
c00252de:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c00252e1:	83 ec 0c             	sub    $0xc,%esp
c00252e4:	6a 0a                	push   $0xa
c00252e6:	e8 c8 66 00 00       	call   c002b9b3 <putchar>
c00252eb:	83 c4 10             	add    $0x10,%esp

  return block;
c00252ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00252f1:	c9                   	leave  
c00252f2:	c3                   	ret    

c00252f3 <list_elem_to_block>:

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
c00252f3:	55                   	push   %ebp
c00252f4:	89 e5                	mov    %esp,%ebp
c00252f6:	83 ec 08             	sub    $0x8,%esp
  return (list_elem != list_end (&all_blocks)
c00252f9:	83 ec 0c             	sub    $0xc,%esp
c00252fc:	68 8c 7c 03 c0       	push   $0xc0037c8c
c0025301:	e8 b6 47 00 00       	call   c0029abc <list_end>
c0025306:	83 c4 10             	add    $0x10,%esp
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0025309:	3b 45 08             	cmp    0x8(%ebp),%eax
c002530c:	74 0b                	je     c0025319 <list_elem_to_block+0x26>
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
          ? list_entry (list_elem, struct block, list_elem)
c002530e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025311:	83 c0 04             	add    $0x4,%eax
          : NULL);
c0025314:	83 e8 04             	sub    $0x4,%eax
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
c0025317:	eb 05                	jmp    c002531e <list_elem_to_block+0x2b>
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0025319:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002531e:	c9                   	leave  
c002531f:	c3                   	ret    

c0025320 <partition_scan>:
static const char *partition_type_name (uint8_t);

/* Scans BLOCK for partitions of interest to Pintos. */
void
partition_scan (struct block *block)
{
c0025320:	55                   	push   %ebp
c0025321:	89 e5                	mov    %esp,%ebp
c0025323:	83 ec 18             	sub    $0x18,%esp
  int part_nr = 0;
c0025326:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  read_partition_table (block, 0, 0, &part_nr);
c002532d:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0025330:	50                   	push   %eax
c0025331:	6a 00                	push   $0x0
c0025333:	6a 00                	push   $0x0
c0025335:	ff 75 08             	pushl  0x8(%ebp)
c0025338:	e8 2c 00 00 00       	call   c0025369 <read_partition_table>
c002533d:	83 c4 10             	add    $0x10,%esp
  if (part_nr == 0)
c0025340:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025343:	85 c0                	test   %eax,%eax
c0025345:	75 1f                	jne    c0025366 <partition_scan+0x46>
    printf ("%s: Device contains no partitions\n", block_name (block));
c0025347:	83 ec 0c             	sub    $0xc,%esp
c002534a:	ff 75 08             	pushl  0x8(%ebp)
c002534d:	e8 ee fd ff ff       	call   c0025140 <block_name>
c0025352:	83 c4 10             	add    $0x10,%esp
c0025355:	83 ec 08             	sub    $0x8,%esp
c0025358:	50                   	push   %eax
c0025359:	68 40 fc 02 c0       	push   $0xc002fc40
c002535e:	e8 e2 1f 00 00       	call   c0027345 <printf>
c0025363:	83 c4 10             	add    $0x10,%esp
}
c0025366:	90                   	nop
c0025367:	c9                   	leave  
c0025368:	c3                   	ret    

c0025369 <read_partition_table>:
   partitions are found. */
static void
read_partition_table (struct block *block, block_sector_t sector,
                      block_sector_t primary_extended_sector,
                      int *part_nr)
{
c0025369:	55                   	push   %ebp
c002536a:	89 e5                	mov    %esp,%ebp
c002536c:	53                   	push   %ebx
c002536d:	83 ec 14             	sub    $0x14,%esp

  struct partition_table *pt;
  size_t i;

  /* Check SECTOR validity. */
  if (sector >= block_size (block))
c0025370:	83 ec 0c             	sub    $0xc,%esp
c0025373:	ff 75 08             	pushl  0x8(%ebp)
c0025376:	e8 ba fd ff ff       	call   c0025135 <block_size>
c002537b:	83 c4 10             	add    $0x10,%esp
c002537e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0025381:	77 27                	ja     c00253aa <read_partition_table+0x41>
    {
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0025383:	83 ec 0c             	sub    $0xc,%esp
c0025386:	ff 75 08             	pushl  0x8(%ebp)
c0025389:	e8 b2 fd ff ff       	call   c0025140 <block_name>
c002538e:	83 c4 10             	add    $0x10,%esp
c0025391:	83 ec 04             	sub    $0x4,%esp
c0025394:	ff 75 0c             	pushl  0xc(%ebp)
c0025397:	50                   	push   %eax
c0025398:	68 64 fc 02 c0       	push   $0xc002fc64
c002539d:	e8 a3 1f 00 00       	call   c0027345 <printf>
c00253a2:	83 c4 10             	add    $0x10,%esp
              block_name (block), sector);
      return;
c00253a5:	e9 d9 01 00 00       	jmp    c0025583 <read_partition_table+0x21a>
    }

  /* Read sector. */
  ASSERT (sizeof *pt == BLOCK_SECTOR_SIZE);
  pt = malloc (sizeof *pt);
c00253aa:	83 ec 0c             	sub    $0xc,%esp
c00253ad:	68 00 02 00 00       	push   $0x200
c00253b2:	e8 f2 e1 ff ff       	call   c00235a9 <malloc>
c00253b7:	83 c4 10             	add    $0x10,%esp
c00253ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pt == NULL)
c00253bd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00253c1:	75 16                	jne    c00253d9 <read_partition_table+0x70>
    PANIC ("Failed to allocate memory for partition table.");
c00253c3:	68 9c fc 02 c0       	push   $0xc002fc9c
c00253c8:	68 24 fe 02 c0       	push   $0xc002fe24
c00253cd:	6a 5a                	push   $0x5a
c00253cf:	68 cb fc 02 c0       	push   $0xc002fccb
c00253d4:	e8 9f 43 00 00       	call   c0029778 <debug_panic>
  block_read (block, 0, pt);
c00253d9:	83 ec 04             	sub    $0x4,%esp
c00253dc:	ff 75 f0             	pushl  -0x10(%ebp)
c00253df:	6a 00                	push   $0x0
c00253e1:	ff 75 08             	pushl  0x8(%ebp)
c00253e4:	e8 81 fc ff ff       	call   c002506a <block_read>
c00253e9:	83 c4 10             	add    $0x10,%esp

  /* Check signature. */
  if (pt->signature != 0xaa55)
c00253ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00253ef:	0f b7 80 fe 01 00 00 	movzwl 0x1fe(%eax),%eax
c00253f6:	66 3d 55 aa          	cmp    $0xaa55,%ax
c00253fa:	74 5c                	je     c0025458 <read_partition_table+0xef>
    {
      if (primary_extended_sector == 0)
c00253fc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0025400:	75 21                	jne    c0025423 <read_partition_table+0xba>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c0025402:	83 ec 0c             	sub    $0xc,%esp
c0025405:	ff 75 08             	pushl  0x8(%ebp)
c0025408:	e8 33 fd ff ff       	call   c0025140 <block_name>
c002540d:	83 c4 10             	add    $0x10,%esp
c0025410:	83 ec 08             	sub    $0x8,%esp
c0025413:	50                   	push   %eax
c0025414:	68 e8 fc 02 c0       	push   $0xc002fce8
c0025419:	e8 27 1f 00 00       	call   c0027345 <printf>
c002541e:	83 c4 10             	add    $0x10,%esp
c0025421:	eb 22                	jmp    c0025445 <read_partition_table+0xdc>
      else
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c0025423:	83 ec 0c             	sub    $0xc,%esp
c0025426:	ff 75 08             	pushl  0x8(%ebp)
c0025429:	e8 12 fd ff ff       	call   c0025140 <block_name>
c002542e:	83 c4 10             	add    $0x10,%esp
c0025431:	83 ec 04             	sub    $0x4,%esp
c0025434:	ff 75 0c             	pushl  0xc(%ebp)
c0025437:	50                   	push   %eax
c0025438:	68 10 fd 02 c0       	push   $0xc002fd10
c002543d:	e8 03 1f 00 00       	call   c0027345 <printf>
c0025442:	83 c4 10             	add    $0x10,%esp
                block_name (block), sector);
      free (pt);
c0025445:	83 ec 0c             	sub    $0xc,%esp
c0025448:	ff 75 f0             	pushl  -0x10(%ebp)
c002544b:	e8 52 e4 ff ff       	call   c00238a2 <free>
c0025450:	83 c4 10             	add    $0x10,%esp
      return;
c0025453:	e9 2b 01 00 00       	jmp    c0025583 <read_partition_table+0x21a>
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0025458:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002545f:	e9 07 01 00 00       	jmp    c002556b <read_partition_table+0x202>
    {
      struct partition_table_entry *e = &pt->partitions[i];
c0025464:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025467:	83 c0 1b             	add    $0x1b,%eax
c002546a:	c1 e0 04             	shl    $0x4,%eax
c002546d:	89 c2                	mov    %eax,%edx
c002546f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025472:	01 d0                	add    %edx,%eax
c0025474:	83 c0 0e             	add    $0xe,%eax
c0025477:	89 45 ec             	mov    %eax,-0x14(%ebp)

      if (e->size == 0 || e->type == 0)
c002547a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002547d:	8b 40 0c             	mov    0xc(%eax),%eax
c0025480:	85 c0                	test   %eax,%eax
c0025482:	0f 84 df 00 00 00    	je     c0025567 <read_partition_table+0x1fe>
c0025488:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002548b:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c002548f:	84 c0                	test   %al,%al
c0025491:	0f 84 d0 00 00 00    	je     c0025567 <read_partition_table+0x1fe>
        {
          /* Ignore empty partition. */
        }
      else if (e->type == 0x05       /* Extended partition. */
c0025497:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002549a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c002549e:	3c 05                	cmp    $0x5,%al
c00254a0:	74 21                	je     c00254c3 <read_partition_table+0x15a>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c00254a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00254a5:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c00254a9:	3c 0f                	cmp    $0xf,%al
c00254ab:	74 16                	je     c00254c3 <read_partition_table+0x15a>
               || e->type == 0x85    /* Linux extended partition. */
c00254ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00254b0:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c00254b4:	3c 85                	cmp    $0x85,%al
c00254b6:	74 0b                	je     c00254c3 <read_partition_table+0x15a>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c00254b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00254bb:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c00254bf:	3c c5                	cmp    $0xc5,%al
c00254c1:	75 65                	jne    c0025528 <read_partition_table+0x1bf>
        {
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c00254c3:	83 ec 0c             	sub    $0xc,%esp
c00254c6:	ff 75 08             	pushl  0x8(%ebp)
c00254c9:	e8 72 fc ff ff       	call   c0025140 <block_name>
c00254ce:	83 c4 10             	add    $0x10,%esp
c00254d1:	83 ec 04             	sub    $0x4,%esp
c00254d4:	ff 75 0c             	pushl  0xc(%ebp)
c00254d7:	50                   	push   %eax
c00254d8:	68 44 fd 02 c0       	push   $0xc002fd44
c00254dd:	e8 63 1e 00 00       	call   c0027345 <printf>
c00254e2:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c00254e5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00254e9:	75 1e                	jne    c0025509 <read_partition_table+0x1a0>
            read_partition_table (block, e->offset, e->offset, part_nr);
c00254eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00254ee:	8b 50 08             	mov    0x8(%eax),%edx
c00254f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00254f4:	8b 40 08             	mov    0x8(%eax),%eax
c00254f7:	ff 75 14             	pushl  0x14(%ebp)
c00254fa:	52                   	push   %edx
c00254fb:	50                   	push   %eax
c00254fc:	ff 75 08             	pushl  0x8(%ebp)
c00254ff:	e8 65 fe ff ff       	call   c0025369 <read_partition_table>
c0025504:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c0025507:	eb 5e                	jmp    c0025567 <read_partition_table+0x1fe>
            read_partition_table (block, e->offset, e->offset, part_nr);
          else
            read_partition_table (block, e->offset + primary_extended_sector,
c0025509:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002550c:	8b 50 08             	mov    0x8(%eax),%edx
c002550f:	8b 45 10             	mov    0x10(%ebp),%eax
c0025512:	01 d0                	add    %edx,%eax
c0025514:	ff 75 14             	pushl  0x14(%ebp)
c0025517:	ff 75 10             	pushl  0x10(%ebp)
c002551a:	50                   	push   %eax
c002551b:	ff 75 08             	pushl  0x8(%ebp)
c002551e:	e8 46 fe ff ff       	call   c0025369 <read_partition_table>
c0025523:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c0025526:	eb 3f                	jmp    c0025567 <read_partition_table+0x1fe>
            read_partition_table (block, e->offset + primary_extended_sector,
                                  primary_extended_sector, part_nr);
        }
      else
        {
          ++*part_nr;
c0025528:	8b 45 14             	mov    0x14(%ebp),%eax
c002552b:	8b 00                	mov    (%eax),%eax
c002552d:	8d 50 01             	lea    0x1(%eax),%edx
c0025530:	8b 45 14             	mov    0x14(%ebp),%eax
c0025533:	89 10                	mov    %edx,(%eax)

          found_partition (block, e->type, e->offset + sector,
c0025535:	8b 45 14             	mov    0x14(%ebp),%eax
c0025538:	8b 08                	mov    (%eax),%ecx
c002553a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002553d:	8b 50 0c             	mov    0xc(%eax),%edx
c0025540:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025543:	8b 58 08             	mov    0x8(%eax),%ebx
c0025546:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025549:	01 c3                	add    %eax,%ebx
c002554b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002554e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0025552:	0f b6 c0             	movzbl %al,%eax
c0025555:	83 ec 0c             	sub    $0xc,%esp
c0025558:	51                   	push   %ecx
c0025559:	52                   	push   %edx
c002555a:	53                   	push   %ebx
c002555b:	50                   	push   %eax
c002555c:	ff 75 08             	pushl  0x8(%ebp)
c002555f:	e8 24 00 00 00       	call   c0025588 <found_partition>
c0025564:	83 c4 20             	add    $0x20,%esp
      free (pt);
      return;
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0025567:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002556b:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002556f:	0f 86 ef fe ff ff    	jbe    c0025464 <read_partition_table+0xfb>
          found_partition (block, e->type, e->offset + sector,
                           e->size, *part_nr);
        }
    }

  free (pt);
c0025575:	83 ec 0c             	sub    $0xc,%esp
c0025578:	ff 75 f0             	pushl  -0x10(%ebp)
c002557b:	e8 22 e3 ff ff       	call   c00238a2 <free>
c0025580:	83 c4 10             	add    $0x10,%esp
}
c0025583:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025586:	c9                   	leave  
c0025587:	c3                   	ret    

c0025588 <found_partition>:
   if so then add it to the proper element of partitions[]. */
static void
found_partition (struct block *block, uint8_t part_type,
                 block_sector_t start, block_sector_t size,
                 int part_nr)
{
c0025588:	55                   	push   %ebp
c0025589:	89 e5                	mov    %esp,%ebp
c002558b:	56                   	push   %esi
c002558c:	53                   	push   %ebx
c002558d:	81 ec b0 00 00 00    	sub    $0xb0,%esp
c0025593:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025596:	88 85 54 ff ff ff    	mov    %al,-0xac(%ebp)
  if (start >= block_size (block))
c002559c:	83 ec 0c             	sub    $0xc,%esp
c002559f:	ff 75 08             	pushl  0x8(%ebp)
c00255a2:	e8 8e fb ff ff       	call   c0025135 <block_size>
c00255a7:	83 c4 10             	add    $0x10,%esp
c00255aa:	3b 45 10             	cmp    0x10(%ebp),%eax
c00255ad:	77 27                	ja     c00255d6 <found_partition+0x4e>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c00255af:	83 ec 0c             	sub    $0xc,%esp
c00255b2:	ff 75 08             	pushl  0x8(%ebp)
c00255b5:	e8 86 fb ff ff       	call   c0025140 <block_name>
c00255ba:	83 c4 10             	add    $0x10,%esp
c00255bd:	ff 75 10             	pushl  0x10(%ebp)
c00255c0:	ff 75 18             	pushl  0x18(%ebp)
c00255c3:	50                   	push   %eax
c00255c4:	68 6c fd 02 c0       	push   $0xc002fd6c
c00255c9:	e8 77 1d 00 00       	call   c0027345 <printf>
c00255ce:	83 c4 10             	add    $0x10,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c00255d1:	e9 76 01 00 00       	jmp    c002574c <found_partition+0x1c4>
                 int part_nr)
{
  if (start >= block_size (block))
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
            block_name (block), part_nr, start);
  else if (start + size < start || start + size > block_size (block))
c00255d6:	8b 55 10             	mov    0x10(%ebp),%edx
c00255d9:	8b 45 14             	mov    0x14(%ebp),%eax
c00255dc:	01 d0                	add    %edx,%eax
c00255de:	3b 45 10             	cmp    0x10(%ebp),%eax
c00255e1:	72 1b                	jb     c00255fe <found_partition+0x76>
c00255e3:	8b 55 10             	mov    0x10(%ebp),%edx
c00255e6:	8b 45 14             	mov    0x14(%ebp),%eax
c00255e9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c00255ec:	83 ec 0c             	sub    $0xc,%esp
c00255ef:	ff 75 08             	pushl  0x8(%ebp)
c00255f2:	e8 3e fb ff ff       	call   c0025135 <block_size>
c00255f7:	83 c4 10             	add    $0x10,%esp
c00255fa:	39 c3                	cmp    %eax,%ebx
c00255fc:	76 42                	jbe    c0025640 <found_partition+0xb8>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c00255fe:	83 ec 0c             	sub    $0xc,%esp
c0025601:	ff 75 08             	pushl  0x8(%ebp)
c0025604:	e8 2c fb ff ff       	call   c0025135 <block_size>
c0025609:	83 c4 10             	add    $0x10,%esp
c002560c:	89 c6                	mov    %eax,%esi
c002560e:	8b 55 10             	mov    0x10(%ebp),%edx
c0025611:	8b 45 14             	mov    0x14(%ebp),%eax
c0025614:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0025617:	83 ec 0c             	sub    $0xc,%esp
c002561a:	ff 75 08             	pushl  0x8(%ebp)
c002561d:	e8 1e fb ff ff       	call   c0025140 <block_name>
c0025622:	83 c4 10             	add    $0x10,%esp
c0025625:	83 ec 0c             	sub    $0xc,%esp
c0025628:	56                   	push   %esi
c0025629:	53                   	push   %ebx
c002562a:	ff 75 18             	pushl  0x18(%ebp)
c002562d:	50                   	push   %eax
c002562e:	68 a4 fd 02 c0       	push   $0xc002fda4
c0025633:	e8 0d 1d 00 00       	call   c0027345 <printf>
c0025638:	83 c4 20             	add    $0x20,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c002563b:	e9 0c 01 00 00       	jmp    c002574c <found_partition+0x1c4>
  else if (start + size < start || start + size > block_size (block))
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
            block_name (block), part_nr, start + size, block_size (block));
  else
    {
      enum block_type type = (part_type == 0x20 ? BLOCK_KERNEL
c0025640:	80 bd 54 ff ff ff 20 	cmpb   $0x20,-0xac(%ebp)
c0025647:	74 37                	je     c0025680 <found_partition+0xf8>
c0025649:	80 bd 54 ff ff ff 21 	cmpb   $0x21,-0xac(%ebp)
c0025650:	74 27                	je     c0025679 <found_partition+0xf1>
c0025652:	80 bd 54 ff ff ff 22 	cmpb   $0x22,-0xac(%ebp)
c0025659:	74 17                	je     c0025672 <found_partition+0xea>
c002565b:	80 bd 54 ff ff ff 23 	cmpb   $0x23,-0xac(%ebp)
c0025662:	75 07                	jne    c002566b <found_partition+0xe3>
c0025664:	b8 03 00 00 00       	mov    $0x3,%eax
c0025669:	eb 1a                	jmp    c0025685 <found_partition+0xfd>
c002566b:	b8 05 00 00 00       	mov    $0x5,%eax
c0025670:	eb 13                	jmp    c0025685 <found_partition+0xfd>
c0025672:	b8 02 00 00 00       	mov    $0x2,%eax
c0025677:	eb 0c                	jmp    c0025685 <found_partition+0xfd>
c0025679:	b8 01 00 00 00       	mov    $0x1,%eax
c002567e:	eb 05                	jmp    c0025685 <found_partition+0xfd>
c0025680:	b8 00 00 00 00       	mov    $0x0,%eax
c0025685:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              : BLOCK_FOREIGN);
      struct partition *p;
      char extra_info[128];
      char name[16];

      p = malloc (sizeof *p);
c0025688:	83 ec 0c             	sub    $0xc,%esp
c002568b:	6a 08                	push   $0x8
c002568d:	e8 17 df ff ff       	call   c00235a9 <malloc>
c0025692:	83 c4 10             	add    $0x10,%esp
c0025695:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (p == NULL)
c0025698:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002569c:	75 19                	jne    c00256b7 <found_partition+0x12f>
        PANIC ("Failed to allocate memory for partition descriptor");
c002569e:	68 d8 fd 02 c0       	push   $0xc002fdd8
c00256a3:	68 3c fe 02 c0       	push   $0xc002fe3c
c00256a8:	68 b1 00 00 00       	push   $0xb1
c00256ad:	68 cb fc 02 c0       	push   $0xc002fccb
c00256b2:	e8 c1 40 00 00       	call   c0029778 <debug_panic>
      p->block = block;
c00256b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00256ba:	8b 55 08             	mov    0x8(%ebp),%edx
c00256bd:	89 10                	mov    %edx,(%eax)
      p->start = start;
c00256bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00256c2:	8b 55 10             	mov    0x10(%ebp),%edx
c00256c5:	89 50 04             	mov    %edx,0x4(%eax)

      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c00256c8:	83 ec 0c             	sub    $0xc,%esp
c00256cb:	ff 75 08             	pushl  0x8(%ebp)
c00256ce:	e8 6d fa ff ff       	call   c0025140 <block_name>
c00256d3:	83 c4 10             	add    $0x10,%esp
c00256d6:	83 ec 0c             	sub    $0xc,%esp
c00256d9:	ff 75 18             	pushl  0x18(%ebp)
c00256dc:	50                   	push   %eax
c00256dd:	68 0b fe 02 c0       	push   $0xc002fe0b
c00256e2:	6a 10                	push   $0x10
c00256e4:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00256e7:	50                   	push   %eax
c00256e8:	e8 2f 1c 00 00       	call   c002731c <snprintf>
c00256ed:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c00256f0:	0f b6 9d 54 ff ff ff 	movzbl -0xac(%ebp),%ebx
c00256f7:	0f b6 85 54 ff ff ff 	movzbl -0xac(%ebp),%eax
c00256fe:	83 ec 0c             	sub    $0xc,%esp
c0025701:	50                   	push   %eax
c0025702:	e8 4d 00 00 00       	call   c0025754 <partition_type_name>
c0025707:	83 c4 10             	add    $0x10,%esp
c002570a:	83 ec 0c             	sub    $0xc,%esp
c002570d:	53                   	push   %ebx
c002570e:	50                   	push   %eax
c002570f:	68 10 fe 02 c0       	push   $0xc002fe10
c0025714:	68 80 00 00 00       	push   $0x80
c0025719:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c002571f:	50                   	push   %eax
c0025720:	e8 f7 1b 00 00       	call   c002731c <snprintf>
c0025725:	83 c4 20             	add    $0x20,%esp
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
c0025728:	83 ec 08             	sub    $0x8,%esp
c002572b:	ff 75 f0             	pushl  -0x10(%ebp)
c002572e:	68 c0 7c 03 c0       	push   $0xc0037cc0
c0025733:	ff 75 14             	pushl  0x14(%ebp)
c0025736:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c002573c:	50                   	push   %eax
c002573d:	ff 75 f4             	pushl  -0xc(%ebp)
c0025740:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025743:	50                   	push   %eax
c0025744:	e8 8f fa ff ff       	call   c00251d8 <block_register>
c0025749:	83 c4 20             	add    $0x20,%esp
    }
}
c002574c:	90                   	nop
c002574d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025750:	5b                   	pop    %ebx
c0025751:	5e                   	pop    %esi
c0025752:	5d                   	pop    %ebp
c0025753:	c3                   	ret    

c0025754 <partition_type_name>:

/* Returns a human-readable name for the given partition TYPE. */
static const char *
partition_type_name (uint8_t type)
{
c0025754:	55                   	push   %ebp
c0025755:	89 e5                	mov    %esp,%ebp
c0025757:	83 ec 04             	sub    $0x4,%esp
c002575a:	8b 45 08             	mov    0x8(%ebp),%eax
c002575d:	88 45 fc             	mov    %al,-0x4(%ebp)
      [0xfd] = "Linux raid autodetect",
      [0xfe] = "LANstep",
      [0xff] = "BBT",
    };

  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025760:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0025764:	8b 04 85 e0 7c 03 c0 	mov    -0x3ffc8320(,%eax,4),%eax
c002576b:	85 c0                	test   %eax,%eax
c002576d:	74 0d                	je     c002577c <partition_type_name+0x28>
c002576f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0025773:	8b 04 85 e0 7c 03 c0 	mov    -0x3ffc8320(,%eax,4),%eax
c002577a:	eb 05                	jmp    c0025781 <partition_type_name+0x2d>
c002577c:	b8 1a fe 02 c0       	mov    $0xc002fe1a,%eax
}
c0025781:	c9                   	leave  
c0025782:	c3                   	ret    

c0025783 <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c0025783:	55                   	push   %ebp
c0025784:	89 e5                	mov    %esp,%ebp
c0025786:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025789:	8b 45 08             	mov    0x8(%ebp),%eax
c002578c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_read (p->block, p->start + sector, buffer);
c002578f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025792:	8b 50 04             	mov    0x4(%eax),%edx
c0025795:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025798:	01 c2                	add    %eax,%edx
c002579a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002579d:	8b 00                	mov    (%eax),%eax
c002579f:	83 ec 04             	sub    $0x4,%esp
c00257a2:	ff 75 10             	pushl  0x10(%ebp)
c00257a5:	52                   	push   %edx
c00257a6:	50                   	push   %eax
c00257a7:	e8 be f8 ff ff       	call   c002506a <block_read>
c00257ac:	83 c4 10             	add    $0x10,%esp
}
c00257af:	90                   	nop
c00257b0:	c9                   	leave  
c00257b1:	c3                   	ret    

c00257b2 <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c00257b2:	55                   	push   %ebp
c00257b3:	89 e5                	mov    %esp,%ebp
c00257b5:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c00257b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00257bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_write (p->block, p->start + sector, buffer);
c00257be:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00257c1:	8b 50 04             	mov    0x4(%eax),%edx
c00257c4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00257c7:	01 c2                	add    %eax,%edx
c00257c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00257cc:	8b 00                	mov    (%eax),%eax
c00257ce:	83 ec 04             	sub    $0x4,%esp
c00257d1:	ff 75 10             	pushl  0x10(%ebp)
c00257d4:	52                   	push   %edx
c00257d5:	50                   	push   %eax
c00257d6:	e8 de f8 ff ff       	call   c00250b9 <block_write>
c00257db:	83 c4 10             	add    $0x10,%esp
}
c00257de:	90                   	nop
c00257df:	c9                   	leave  
c00257e0:	c3                   	ret    

c00257e1 <isspace>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
c00257e1:	55                   	push   %ebp
c00257e2:	89 e5                	mov    %esp,%ebp
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
c00257e4:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c00257e8:	74 1e                	je     c0025808 <isspace+0x27>
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
  return (c == ' ' || c == '\f' || c == '\n'
c00257ea:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c00257ee:	74 18                	je     c0025808 <isspace+0x27>
c00257f0:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c00257f4:	74 12                	je     c0025808 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c00257f6:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c00257fa:	74 0c                	je     c0025808 <isspace+0x27>
c00257fc:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0025800:	74 06                	je     c0025808 <isspace+0x27>
c0025802:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0025806:	75 07                	jne    c002580f <isspace+0x2e>
c0025808:	b8 01 00 00 00       	mov    $0x1,%eax
c002580d:	eb 05                	jmp    c0025814 <isspace+0x33>
c002580f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0025814:	5d                   	pop    %ebp
c0025815:	c3                   	ret    

c0025816 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0025816:	55                   	push   %ebp
c0025817:	89 e5                	mov    %esp,%ebp
c0025819:	83 ec 14             	sub    $0x14,%esp
c002581c:	8b 45 08             	mov    0x8(%ebp),%eax
c002581f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025823:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0025827:	89 c2                	mov    %eax,%edx
c0025829:	ec                   	in     (%dx),%al
c002582a:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c002582d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0025831:	c9                   	leave  
c0025832:	c3                   	ret    

c0025833 <insw>:

/* Reads CNT 16-bit (halfword) units from PORT, one after
   another, and stores them into the buffer starting at ADDR. */
static inline void
insw (uint16_t port, void *addr, size_t cnt)
{
c0025833:	55                   	push   %ebp
c0025834:	89 e5                	mov    %esp,%ebp
c0025836:	57                   	push   %edi
c0025837:	53                   	push   %ebx
c0025838:	83 ec 04             	sub    $0x4,%esp
c002583b:	8b 45 08             	mov    0x8(%ebp),%eax
c002583e:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2a] "INS". */
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025842:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c0025846:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0025849:	8b 45 10             	mov    0x10(%ebp),%eax
c002584c:	89 cb                	mov    %ecx,%ebx
c002584e:	89 df                	mov    %ebx,%edi
c0025850:	89 c1                	mov    %eax,%ecx
c0025852:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c0025855:	89 c8                	mov    %ecx,%eax
c0025857:	89 fb                	mov    %edi,%ebx
c0025859:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c002585c:	89 45 10             	mov    %eax,0x10(%ebp)
}
c002585f:	90                   	nop
c0025860:	83 c4 04             	add    $0x4,%esp
c0025863:	5b                   	pop    %ebx
c0025864:	5f                   	pop    %edi
c0025865:	5d                   	pop    %ebp
c0025866:	c3                   	ret    

c0025867 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0025867:	55                   	push   %ebp
c0025868:	89 e5                	mov    %esp,%ebp
c002586a:	83 ec 08             	sub    $0x8,%esp
c002586d:	8b 55 08             	mov    0x8(%ebp),%edx
c0025870:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025873:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0025877:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002587a:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c002587e:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0025882:	ee                   	out    %al,(%dx)
}
c0025883:	90                   	nop
c0025884:	c9                   	leave  
c0025885:	c3                   	ret    

c0025886 <outsw>:

/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
c0025886:	55                   	push   %ebp
c0025887:	89 e5                	mov    %esp,%ebp
c0025889:	56                   	push   %esi
c002588a:	53                   	push   %ebx
c002588b:	83 ec 04             	sub    $0x4,%esp
c002588e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025891:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025895:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c0025899:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002589c:	8b 45 10             	mov    0x10(%ebp),%eax
c002589f:	89 cb                	mov    %ecx,%ebx
c00258a1:	89 de                	mov    %ebx,%esi
c00258a3:	89 c1                	mov    %eax,%ecx
c00258a5:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c00258a8:	89 c8                	mov    %ecx,%eax
c00258aa:	89 f3                	mov    %esi,%ebx
c00258ac:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c00258af:	89 45 10             	mov    %eax,0x10(%ebp)
}
c00258b2:	90                   	nop
c00258b3:	83 c4 04             	add    $0x4,%esp
c00258b6:	5b                   	pop    %ebx
c00258b7:	5e                   	pop    %esi
c00258b8:	5d                   	pop    %ebp
c00258b9:	c3                   	ret    

c00258ba <ide_init>:
static void interrupt_handler (struct intr_frame *);

/* Initialize the disk subsystem and detect disks. */
void
ide_init (void) 
{
c00258ba:	55                   	push   %ebp
c00258bb:	89 e5                	mov    %esp,%ebp
c00258bd:	83 ec 18             	sub    $0x18,%esp
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c00258c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00258c7:	e9 ae 01 00 00       	jmp    c0025a7a <ide_init+0x1c0>
    {
      struct channel *c = &channels[chan_no];
c00258cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00258cf:	6b c0 64             	imul   $0x64,%eax,%eax
c00258d2:	05 c0 99 03 c0       	add    $0xc00399c0,%eax
c00258d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
      int dev_no;

      /* Initialize channel. */
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c00258da:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00258dd:	ff 75 f4             	pushl  -0xc(%ebp)
c00258e0:	68 10 03 03 c0       	push   $0xc0030310
c00258e5:	6a 08                	push   $0x8
c00258e7:	50                   	push   %eax
c00258e8:	e8 2f 1a 00 00       	call   c002731c <snprintf>
c00258ed:	83 c4 10             	add    $0x10,%esp
      switch (chan_no) 
c00258f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00258f3:	85 c0                	test   %eax,%eax
c00258f5:	74 07                	je     c00258fe <ide_init+0x44>
c00258f7:	83 f8 01             	cmp    $0x1,%eax
c00258fa:	74 14                	je     c0025910 <ide_init+0x56>
c00258fc:	eb 24                	jmp    c0025922 <ide_init+0x68>
        {
        case 0:
          c->reg_base = 0x1f0;
c00258fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025901:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
          c->irq = 14 + 0x20;
c0025907:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002590a:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
          break;
c002590e:	eb 28                	jmp    c0025938 <ide_init+0x7e>
        case 1:
          c->reg_base = 0x170;
c0025910:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025913:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
          c->irq = 15 + 0x20;
c0025919:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002591c:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
          break;
c0025920:	eb 16                	jmp    c0025938 <ide_init+0x7e>
        default:
          NOT_REACHED ();
c0025922:	68 18 03 03 c0       	push   $0xc0030318
c0025927:	68 6c 04 03 c0       	push   $0xc003046c
c002592c:	6a 7c                	push   $0x7c
c002592e:	68 3a 03 03 c0       	push   $0xc003033a
c0025933:	e8 40 3e 00 00       	call   c0029778 <debug_panic>
        }
      lock_init (&c->lock);
c0025938:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002593b:	83 c0 0c             	add    $0xc,%eax
c002593e:	83 ec 0c             	sub    $0xc,%esp
c0025941:	50                   	push   %eax
c0025942:	e8 4c d2 ff ff       	call   c0022b93 <lock_init>
c0025947:	83 c4 10             	add    $0x10,%esp
      c->expecting_interrupt = false;
c002594a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002594d:	c6 40 24 00          	movb   $0x0,0x24(%eax)
      sema_init (&c->completion_wait, 0);
c0025951:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025954:	83 c0 28             	add    $0x28,%eax
c0025957:	83 ec 08             	sub    $0x8,%esp
c002595a:	6a 00                	push   $0x0
c002595c:	50                   	push   %eax
c002595d:	e8 76 cf ff ff       	call   c00228d8 <sema_init>
c0025962:	83 c4 10             	add    $0x10,%esp
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025965:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002596c:	eb 5a                	jmp    c00259c8 <ide_init+0x10e>
        {
          struct ata_disk *d = &c->devices[dev_no];
c002596e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025971:	89 d0                	mov    %edx,%eax
c0025973:	c1 e0 02             	shl    $0x2,%eax
c0025976:	01 d0                	add    %edx,%eax
c0025978:	c1 e0 02             	shl    $0x2,%eax
c002597b:	8d 50 30             	lea    0x30(%eax),%edx
c002597e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025981:	01 d0                	add    %edx,%eax
c0025983:	83 c0 0c             	add    $0xc,%eax
c0025986:	89 45 e8             	mov    %eax,-0x18(%ebp)
          snprintf (d->name, sizeof d->name,
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
c0025989:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002598c:	8d 14 00             	lea    (%eax,%eax,1),%edx
c002598f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025992:	01 d0                	add    %edx,%eax
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        {
          struct ata_disk *d = &c->devices[dev_no];
          snprintf (d->name, sizeof d->name,
c0025994:	8d 50 61             	lea    0x61(%eax),%edx
c0025997:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002599a:	52                   	push   %edx
c002599b:	68 4e 03 03 c0       	push   $0xc003034e
c00259a0:	6a 08                	push   $0x8
c00259a2:	50                   	push   %eax
c00259a3:	e8 74 19 00 00       	call   c002731c <snprintf>
c00259a8:	83 c4 10             	add    $0x10,%esp
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
          d->channel = c;
c00259ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00259ae:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00259b1:	89 50 08             	mov    %edx,0x8(%eax)
          d->dev_no = dev_no;
c00259b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00259b7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00259ba:	89 50 0c             	mov    %edx,0xc(%eax)
          d->is_ata = false;
c00259bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00259c0:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      lock_init (&c->lock);
      c->expecting_interrupt = false;
      sema_init (&c->completion_wait, 0);
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c00259c4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c00259c8:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c00259cc:	7e a0                	jle    c002596e <ide_init+0xb4>
          d->dev_no = dev_no;
          d->is_ata = false;
        }

      /* Register interrupt handler. */
      intr_register_ext (c->irq, interrupt_handler, c->name);
c00259ce:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00259d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259d4:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c00259d8:	0f b6 c0             	movzbl %al,%eax
c00259db:	83 ec 04             	sub    $0x4,%esp
c00259de:	52                   	push   %edx
c00259df:	68 28 65 02 c0       	push   $0xc0026528
c00259e4:	50                   	push   %eax
c00259e5:	e8 03 bd ff ff       	call   c00216ed <intr_register_ext>
c00259ea:	83 c4 10             	add    $0x10,%esp

      /* Reset hardware. */
      reset_channel (c);
c00259ed:	83 ec 0c             	sub    $0xc,%esp
c00259f0:	ff 75 ec             	pushl  -0x14(%ebp)
c00259f3:	e8 8f 00 00 00       	call   c0025a87 <reset_channel>
c00259f8:	83 c4 10             	add    $0x10,%esp

      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
c00259fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259fe:	83 c0 3c             	add    $0x3c,%eax
c0025a01:	83 ec 0c             	sub    $0xc,%esp
c0025a04:	50                   	push   %eax
c0025a05:	e8 09 03 00 00       	call   c0025d13 <check_device_type>
c0025a0a:	83 c4 10             	add    $0x10,%esp
c0025a0d:	84 c0                	test   %al,%al
c0025a0f:	74 12                	je     c0025a23 <ide_init+0x169>
        check_device_type (&c->devices[1]);
c0025a11:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025a14:	83 c0 50             	add    $0x50,%eax
c0025a17:	83 ec 0c             	sub    $0xc,%esp
c0025a1a:	50                   	push   %eax
c0025a1b:	e8 f3 02 00 00       	call   c0025d13 <check_device_type>
c0025a20:	83 c4 10             	add    $0x10,%esp

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025a23:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025a2a:	eb 44                	jmp    c0025a70 <ide_init+0x1b6>
        if (c->devices[dev_no].is_ata)
c0025a2c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0025a2f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025a32:	89 d0                	mov    %edx,%eax
c0025a34:	c1 e0 02             	shl    $0x2,%eax
c0025a37:	01 d0                	add    %edx,%eax
c0025a39:	c1 e0 02             	shl    $0x2,%eax
c0025a3c:	01 c8                	add    %ecx,%eax
c0025a3e:	83 c0 4c             	add    $0x4c,%eax
c0025a41:	0f b6 00             	movzbl (%eax),%eax
c0025a44:	84 c0                	test   %al,%al
c0025a46:	74 24                	je     c0025a6c <ide_init+0x1b2>
          identify_ata_device (&c->devices[dev_no]);
c0025a48:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025a4b:	89 d0                	mov    %edx,%eax
c0025a4d:	c1 e0 02             	shl    $0x2,%eax
c0025a50:	01 d0                	add    %edx,%eax
c0025a52:	c1 e0 02             	shl    $0x2,%eax
c0025a55:	8d 50 30             	lea    0x30(%eax),%edx
c0025a58:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025a5b:	01 d0                	add    %edx,%eax
c0025a5d:	83 c0 0c             	add    $0xc,%eax
c0025a60:	83 ec 0c             	sub    $0xc,%esp
c0025a63:	50                   	push   %eax
c0025a64:	e8 a5 03 00 00       	call   c0025e0e <identify_ata_device>
c0025a69:	83 c4 10             	add    $0x10,%esp
      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
        check_device_type (&c->devices[1]);

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025a6c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0025a70:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c0025a74:	7e b6                	jle    c0025a2c <ide_init+0x172>
void
ide_init (void) 
{
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c0025a76:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0025a7a:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025a7e:	0f 86 48 fe ff ff    	jbe    c00258cc <ide_init+0x12>
      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        if (c->devices[dev_no].is_ata)
          identify_ata_device (&c->devices[dev_no]);
    }
}
c0025a84:	90                   	nop
c0025a85:	c9                   	leave  
c0025a86:	c3                   	ret    

c0025a87 <reset_channel>:

/* Resets an ATA channel and waits for any devices present on it
   to finish the reset. */
static void
reset_channel (struct channel *c) 
{
c0025a87:	55                   	push   %ebp
c0025a88:	89 e5                	mov    %esp,%ebp
c0025a8a:	83 ec 18             	sub    $0x18,%esp
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025a8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025a94:	e9 2b 01 00 00       	jmp    c0025bc4 <reset_channel+0x13d>
    {
      struct ata_disk *d = &c->devices[dev_no];
c0025a99:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025a9c:	89 d0                	mov    %edx,%eax
c0025a9e:	c1 e0 02             	shl    $0x2,%eax
c0025aa1:	01 d0                	add    %edx,%eax
c0025aa3:	c1 e0 02             	shl    $0x2,%eax
c0025aa6:	8d 50 30             	lea    0x30(%eax),%edx
c0025aa9:	8b 45 08             	mov    0x8(%ebp),%eax
c0025aac:	01 d0                	add    %edx,%eax
c0025aae:	83 c0 0c             	add    $0xc,%eax
c0025ab1:	89 45 ec             	mov    %eax,-0x14(%ebp)

      select_device (d);
c0025ab4:	83 ec 0c             	sub    $0xc,%esp
c0025ab7:	ff 75 ec             	pushl  -0x14(%ebp)
c0025aba:	e8 cd 09 00 00       	call   c002648c <select_device>
c0025abf:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c0025ac2:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ac5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025ac9:	83 c0 02             	add    $0x2,%eax
c0025acc:	0f b7 c0             	movzwl %ax,%eax
c0025acf:	83 ec 08             	sub    $0x8,%esp
c0025ad2:	6a 55                	push   $0x55
c0025ad4:	50                   	push   %eax
c0025ad5:	e8 8d fd ff ff       	call   c0025867 <outb>
c0025ada:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025add:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ae0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025ae4:	83 c0 03             	add    $0x3,%eax
c0025ae7:	0f b7 c0             	movzwl %ax,%eax
c0025aea:	83 ec 08             	sub    $0x8,%esp
c0025aed:	68 aa 00 00 00       	push   $0xaa
c0025af2:	50                   	push   %eax
c0025af3:	e8 6f fd ff ff       	call   c0025867 <outb>
c0025af8:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0xaa);
c0025afb:	8b 45 08             	mov    0x8(%ebp),%eax
c0025afe:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025b02:	83 c0 02             	add    $0x2,%eax
c0025b05:	0f b7 c0             	movzwl %ax,%eax
c0025b08:	83 ec 08             	sub    $0x8,%esp
c0025b0b:	68 aa 00 00 00       	push   $0xaa
c0025b10:	50                   	push   %eax
c0025b11:	e8 51 fd ff ff       	call   c0025867 <outb>
c0025b16:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0x55);
c0025b19:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b1c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025b20:	83 c0 03             	add    $0x3,%eax
c0025b23:	0f b7 c0             	movzwl %ax,%eax
c0025b26:	83 ec 08             	sub    $0x8,%esp
c0025b29:	6a 55                	push   $0x55
c0025b2b:	50                   	push   %eax
c0025b2c:	e8 36 fd ff ff       	call   c0025867 <outb>
c0025b31:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c0025b34:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b37:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025b3b:	83 c0 02             	add    $0x2,%eax
c0025b3e:	0f b7 c0             	movzwl %ax,%eax
c0025b41:	83 ec 08             	sub    $0x8,%esp
c0025b44:	6a 55                	push   $0x55
c0025b46:	50                   	push   %eax
c0025b47:	e8 1b fd ff ff       	call   c0025867 <outb>
c0025b4c:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025b4f:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b52:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025b56:	83 c0 03             	add    $0x3,%eax
c0025b59:	0f b7 c0             	movzwl %ax,%eax
c0025b5c:	83 ec 08             	sub    $0x8,%esp
c0025b5f:	68 aa 00 00 00       	push   $0xaa
c0025b64:	50                   	push   %eax
c0025b65:	e8 fd fc ff ff       	call   c0025867 <outb>
c0025b6a:	83 c4 10             	add    $0x10,%esp

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025b6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b70:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025b74:	83 c0 02             	add    $0x2,%eax
c0025b77:	0f b7 c0             	movzwl %ax,%eax
c0025b7a:	83 ec 0c             	sub    $0xc,%esp
c0025b7d:	50                   	push   %eax
c0025b7e:	e8 93 fc ff ff       	call   c0025816 <inb>
c0025b83:	83 c4 10             	add    $0x10,%esp
                         && inb (reg_lbal (c)) == 0xaa);
c0025b86:	3c 55                	cmp    $0x55,%al
c0025b88:	75 24                	jne    c0025bae <reset_channel+0x127>
c0025b8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b8d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025b91:	83 c0 03             	add    $0x3,%eax
c0025b94:	0f b7 c0             	movzwl %ax,%eax
c0025b97:	83 ec 0c             	sub    $0xc,%esp
c0025b9a:	50                   	push   %eax
c0025b9b:	e8 76 fc ff ff       	call   c0025816 <inb>
c0025ba0:	83 c4 10             	add    $0x10,%esp
c0025ba3:	3c aa                	cmp    $0xaa,%al
c0025ba5:	75 07                	jne    c0025bae <reset_channel+0x127>
c0025ba7:	b8 01 00 00 00       	mov    $0x1,%eax
c0025bac:	eb 05                	jmp    c0025bb3 <reset_channel+0x12c>
c0025bae:	b8 00 00 00 00       	mov    $0x0,%eax
c0025bb3:	83 e0 01             	and    $0x1,%eax
      outb (reg_lbal (c), 0x55);

      outb (reg_nsect (c), 0x55);
      outb (reg_lbal (c), 0xaa);

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025bb6:	8d 4d ea             	lea    -0x16(%ebp),%ecx
c0025bb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025bbc:	01 ca                	add    %ecx,%edx
c0025bbe:	88 02                	mov    %al,(%edx)
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025bc0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0025bc4:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025bc8:	0f 8e cb fe ff ff    	jle    c0025a99 <reset_channel+0x12>
                         && inb (reg_lbal (c)) == 0xaa);
    }

  /* Issue soft reset sequence, which selects device 0 as a side effect.
     Also enable interrupts. */
  outb (reg_ctl (c), 0);
c0025bce:	8b 45 08             	mov    0x8(%ebp),%eax
c0025bd1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025bd5:	66 05 06 02          	add    $0x206,%ax
c0025bd9:	0f b7 c0             	movzwl %ax,%eax
c0025bdc:	83 ec 08             	sub    $0x8,%esp
c0025bdf:	6a 00                	push   $0x0
c0025be1:	50                   	push   %eax
c0025be2:	e8 80 fc ff ff       	call   c0025867 <outb>
c0025be7:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0025bea:	83 ec 08             	sub    $0x8,%esp
c0025bed:	6a 00                	push   $0x0
c0025bef:	6a 0a                	push   $0xa
c0025bf1:	e8 f5 e2 ff ff       	call   c0023eeb <timer_usleep>
c0025bf6:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), CTL_SRST);
c0025bf9:	8b 45 08             	mov    0x8(%ebp),%eax
c0025bfc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025c00:	66 05 06 02          	add    $0x206,%ax
c0025c04:	0f b7 c0             	movzwl %ax,%eax
c0025c07:	83 ec 08             	sub    $0x8,%esp
c0025c0a:	6a 04                	push   $0x4
c0025c0c:	50                   	push   %eax
c0025c0d:	e8 55 fc ff ff       	call   c0025867 <outb>
c0025c12:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0025c15:	83 ec 08             	sub    $0x8,%esp
c0025c18:	6a 00                	push   $0x0
c0025c1a:	6a 0a                	push   $0xa
c0025c1c:	e8 ca e2 ff ff       	call   c0023eeb <timer_usleep>
c0025c21:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), 0);
c0025c24:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c27:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025c2b:	66 05 06 02          	add    $0x206,%ax
c0025c2f:	0f b7 c0             	movzwl %ax,%eax
c0025c32:	83 ec 08             	sub    $0x8,%esp
c0025c35:	6a 00                	push   $0x0
c0025c37:	50                   	push   %eax
c0025c38:	e8 2a fc ff ff       	call   c0025867 <outb>
c0025c3d:	83 c4 10             	add    $0x10,%esp

  timer_msleep (150);
c0025c40:	83 ec 08             	sub    $0x8,%esp
c0025c43:	6a 00                	push   $0x0
c0025c45:	68 96 00 00 00       	push   $0x96
c0025c4a:	e8 71 e2 ff ff       	call   c0023ec0 <timer_msleep>
c0025c4f:	83 c4 10             	add    $0x10,%esp

  /* Wait for device 0 to clear BSY. */
  if (present[0]) 
c0025c52:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
c0025c56:	84 c0                	test   %al,%al
c0025c58:	74 24                	je     c0025c7e <reset_channel+0x1f7>
    {
      select_device (&c->devices[0]);
c0025c5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c5d:	83 c0 3c             	add    $0x3c,%eax
c0025c60:	83 ec 0c             	sub    $0xc,%esp
c0025c63:	50                   	push   %eax
c0025c64:	e8 23 08 00 00       	call   c002648c <select_device>
c0025c69:	83 c4 10             	add    $0x10,%esp
      wait_while_busy (&c->devices[0]); 
c0025c6c:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c6f:	83 c0 3c             	add    $0x3c,%eax
c0025c72:	83 ec 0c             	sub    $0xc,%esp
c0025c75:	50                   	push   %eax
c0025c76:	e8 44 07 00 00       	call   c00263bf <wait_while_busy>
c0025c7b:	83 c4 10             	add    $0x10,%esp
    }

  /* Wait for device 1 to clear BSY. */
  if (present[1])
c0025c7e:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0025c82:	84 c0                	test   %al,%al
c0025c84:	0f 84 86 00 00 00    	je     c0025d10 <reset_channel+0x289>
    {
      int i;

      select_device (&c->devices[1]);
c0025c8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c8d:	83 c0 50             	add    $0x50,%eax
c0025c90:	83 ec 0c             	sub    $0xc,%esp
c0025c93:	50                   	push   %eax
c0025c94:	e8 f3 07 00 00       	call   c002648c <select_device>
c0025c99:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c0025c9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025ca3:	eb 4d                	jmp    c0025cf2 <reset_channel+0x26b>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0025ca5:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ca8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025cac:	83 c0 02             	add    $0x2,%eax
c0025caf:	0f b7 c0             	movzwl %ax,%eax
c0025cb2:	83 ec 0c             	sub    $0xc,%esp
c0025cb5:	50                   	push   %eax
c0025cb6:	e8 5b fb ff ff       	call   c0025816 <inb>
c0025cbb:	83 c4 10             	add    $0x10,%esp
c0025cbe:	3c 01                	cmp    $0x1,%al
c0025cc0:	75 1d                	jne    c0025cdf <reset_channel+0x258>
c0025cc2:	8b 45 08             	mov    0x8(%ebp),%eax
c0025cc5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025cc9:	83 c0 03             	add    $0x3,%eax
c0025ccc:	0f b7 c0             	movzwl %ax,%eax
c0025ccf:	83 ec 0c             	sub    $0xc,%esp
c0025cd2:	50                   	push   %eax
c0025cd3:	e8 3e fb ff ff       	call   c0025816 <inb>
c0025cd8:	83 c4 10             	add    $0x10,%esp
c0025cdb:	3c 01                	cmp    $0x1,%al
c0025cdd:	74 1e                	je     c0025cfd <reset_channel+0x276>
            break;
          timer_msleep (10);
c0025cdf:	83 ec 08             	sub    $0x8,%esp
c0025ce2:	6a 00                	push   $0x0
c0025ce4:	6a 0a                	push   $0xa
c0025ce6:	e8 d5 e1 ff ff       	call   c0023ec0 <timer_msleep>
c0025ceb:	83 c4 10             	add    $0x10,%esp
  if (present[1])
    {
      int i;

      select_device (&c->devices[1]);
      for (i = 0; i < 3000; i++) 
c0025cee:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0025cf2:	81 7d f0 b7 0b 00 00 	cmpl   $0xbb7,-0x10(%ebp)
c0025cf9:	7e aa                	jle    c0025ca5 <reset_channel+0x21e>
c0025cfb:	eb 01                	jmp    c0025cfe <reset_channel+0x277>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
            break;
c0025cfd:	90                   	nop
          timer_msleep (10);
        }
      wait_while_busy (&c->devices[1]);
c0025cfe:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d01:	83 c0 50             	add    $0x50,%eax
c0025d04:	83 ec 0c             	sub    $0xc,%esp
c0025d07:	50                   	push   %eax
c0025d08:	e8 b2 06 00 00       	call   c00263bf <wait_while_busy>
c0025d0d:	83 c4 10             	add    $0x10,%esp
    }
}
c0025d10:	90                   	nop
c0025d11:	c9                   	leave  
c0025d12:	c3                   	ret    

c0025d13 <check_device_type>:
   if it's possible that a slave (device 1) exists on this
   channel.  If D is device 1 (slave), the return value is not
   meaningful. */
static bool
check_device_type (struct ata_disk *d) 
{
c0025d13:	55                   	push   %ebp
c0025d14:	89 e5                	mov    %esp,%ebp
c0025d16:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0025d19:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d1c:	8b 40 08             	mov    0x8(%eax),%eax
c0025d1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint8_t error, lbam, lbah, status;

  select_device (d);
c0025d22:	83 ec 0c             	sub    $0xc,%esp
c0025d25:	ff 75 08             	pushl  0x8(%ebp)
c0025d28:	e8 5f 07 00 00       	call   c002648c <select_device>
c0025d2d:	83 c4 10             	add    $0x10,%esp

  error = inb (reg_error (c));
c0025d30:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025d33:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025d37:	83 c0 01             	add    $0x1,%eax
c0025d3a:	0f b7 c0             	movzwl %ax,%eax
c0025d3d:	83 ec 0c             	sub    $0xc,%esp
c0025d40:	50                   	push   %eax
c0025d41:	e8 d0 fa ff ff       	call   c0025816 <inb>
c0025d46:	83 c4 10             	add    $0x10,%esp
c0025d49:	88 45 f3             	mov    %al,-0xd(%ebp)
  lbam = inb (reg_lbam (c));
c0025d4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025d4f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025d53:	83 c0 04             	add    $0x4,%eax
c0025d56:	0f b7 c0             	movzwl %ax,%eax
c0025d59:	83 ec 0c             	sub    $0xc,%esp
c0025d5c:	50                   	push   %eax
c0025d5d:	e8 b4 fa ff ff       	call   c0025816 <inb>
c0025d62:	83 c4 10             	add    $0x10,%esp
c0025d65:	88 45 f2             	mov    %al,-0xe(%ebp)
  lbah = inb (reg_lbah (c));
c0025d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025d6b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025d6f:	83 c0 05             	add    $0x5,%eax
c0025d72:	0f b7 c0             	movzwl %ax,%eax
c0025d75:	83 ec 0c             	sub    $0xc,%esp
c0025d78:	50                   	push   %eax
c0025d79:	e8 98 fa ff ff       	call   c0025816 <inb>
c0025d7e:	83 c4 10             	add    $0x10,%esp
c0025d81:	88 45 f1             	mov    %al,-0xf(%ebp)
  status = inb (reg_status (c));
c0025d84:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025d87:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025d8b:	83 c0 07             	add    $0x7,%eax
c0025d8e:	0f b7 c0             	movzwl %ax,%eax
c0025d91:	83 ec 0c             	sub    $0xc,%esp
c0025d94:	50                   	push   %eax
c0025d95:	e8 7c fa ff ff       	call   c0025816 <inb>
c0025d9a:	83 c4 10             	add    $0x10,%esp
c0025d9d:	88 45 f0             	mov    %al,-0x10(%ebp)

  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025da0:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
c0025da4:	74 11                	je     c0025db7 <check_device_type+0xa4>
c0025da6:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0025daa:	75 1e                	jne    c0025dca <check_device_type+0xb7>
c0025dac:	8b 45 08             	mov    0x8(%ebp),%eax
c0025daf:	8b 40 0c             	mov    0xc(%eax),%eax
c0025db2:	83 f8 01             	cmp    $0x1,%eax
c0025db5:	74 13                	je     c0025dca <check_device_type+0xb7>
      || (status & STA_DRDY) == 0
c0025db7:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0025dbb:	83 e0 40             	and    $0x40,%eax
c0025dbe:	85 c0                	test   %eax,%eax
c0025dc0:	74 08                	je     c0025dca <check_device_type+0xb7>
      || (status & STA_BSY) != 0)
c0025dc2:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0025dc6:	84 c0                	test   %al,%al
c0025dc8:	79 10                	jns    c0025dda <check_device_type+0xc7>
    {
      d->is_ata = false;
c0025dca:	8b 45 08             	mov    0x8(%ebp),%eax
c0025dcd:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return error != 0x81;      
c0025dd1:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0025dd5:	0f 95 c0             	setne  %al
c0025dd8:	eb 32                	jmp    c0025e0c <check_device_type+0xf9>
    }
  else 
    {
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025dda:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c0025dde:	75 06                	jne    c0025de6 <check_device_type+0xd3>
c0025de0:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c0025de4:	74 0c                	je     c0025df2 <check_device_type+0xdf>
c0025de6:	80 7d f2 3c          	cmpb   $0x3c,-0xe(%ebp)
c0025dea:	75 0d                	jne    c0025df9 <check_device_type+0xe6>
c0025dec:	80 7d f1 c3          	cmpb   $0xc3,-0xf(%ebp)
c0025df0:	75 07                	jne    c0025df9 <check_device_type+0xe6>
c0025df2:	b8 01 00 00 00       	mov    $0x1,%eax
c0025df7:	eb 05                	jmp    c0025dfe <check_device_type+0xeb>
c0025df9:	b8 00 00 00 00       	mov    $0x0,%eax
c0025dfe:	83 e0 01             	and    $0x1,%eax
c0025e01:	8b 55 08             	mov    0x8(%ebp),%edx
c0025e04:	88 42 10             	mov    %al,0x10(%edx)
      return true; 
c0025e07:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
c0025e0c:	c9                   	leave  
c0025e0d:	c3                   	ret    

c0025e0e <identify_ata_device>:
/* Sends an IDENTIFY DEVICE command to disk D and reads the
   response.  Registers the disk with the block device
   layer. */
static void
identify_ata_device (struct ata_disk *d) 
{
c0025e0e:	55                   	push   %ebp
c0025e0f:	89 e5                	mov    %esp,%ebp
c0025e11:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
  struct channel *c = d->channel;
c0025e17:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e1a:	8b 40 08             	mov    0x8(%eax),%eax
c0025e1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_sector_t capacity;
  char *model, *serial;
  char extra_info[128];
  struct block *block;

  ASSERT (d->is_ata);
c0025e20:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e23:	0f b6 40 10          	movzbl 0x10(%eax),%eax
c0025e27:	84 c0                	test   %al,%al
c0025e29:	75 21                	jne    c0025e4c <identify_ata_device+0x3e>
c0025e2b:	83 ec 0c             	sub    $0xc,%esp
c0025e2e:	68 53 03 03 c0       	push   $0xc0030353
c0025e33:	68 5d 03 03 c0       	push   $0xc003035d
c0025e38:	68 78 04 03 c0       	push   $0xc0030478
c0025e3d:	68 0d 01 00 00       	push   $0x10d
c0025e42:	68 3a 03 03 c0       	push   $0xc003033a
c0025e47:	e8 2c 39 00 00       	call   c0029778 <debug_panic>

  /* Send the IDENTIFY DEVICE command, wait for an interrupt
     indicating the device's response is ready, and read the data
     into our buffer. */
  select_device_wait (d);
c0025e4c:	83 ec 0c             	sub    $0xc,%esp
c0025e4f:	ff 75 08             	pushl  0x8(%ebp)
c0025e52:	e8 9e 06 00 00       	call   c00264f5 <select_device_wait>
c0025e57:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0025e5a:	83 ec 08             	sub    $0x8,%esp
c0025e5d:	68 ec 00 00 00       	push   $0xec
c0025e62:	ff 75 f4             	pushl  -0xc(%ebp)
c0025e65:	e8 4b 04 00 00       	call   c00262b5 <issue_pio_command>
c0025e6a:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0025e6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025e70:	83 c0 28             	add    $0x28,%eax
c0025e73:	83 ec 0c             	sub    $0xc,%esp
c0025e76:	50                   	push   %eax
c0025e77:	e8 a3 ca ff ff       	call   c002291f <sema_down>
c0025e7c:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025e7f:	83 ec 0c             	sub    $0xc,%esp
c0025e82:	ff 75 08             	pushl  0x8(%ebp)
c0025e85:	e8 35 05 00 00       	call   c00263bf <wait_while_busy>
c0025e8a:	83 c4 10             	add    $0x10,%esp
c0025e8d:	83 f0 01             	xor    $0x1,%eax
c0025e90:	84 c0                	test   %al,%al
c0025e92:	74 0c                	je     c0025ea0 <identify_ata_device+0x92>
    {
      d->is_ata = false;
c0025e94:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e97:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0025e9b:	e9 fb 00 00 00       	jmp    c0025f9b <identify_ata_device+0x18d>
    }
  input_sector (c, id);
c0025ea0:	83 ec 08             	sub    $0x8,%esp
c0025ea3:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025ea9:	50                   	push   %eax
c0025eaa:	ff 75 f4             	pushl  -0xc(%ebp)
c0025ead:	e8 62 04 00 00       	call   c0026314 <input_sector>
c0025eb2:	83 c4 10             	add    $0x10,%esp

  /* Calculate capacity.
     Read model name and serial number. */
  capacity = *(uint32_t *) &id[60 * 2];
c0025eb5:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025ebb:	83 c0 78             	add    $0x78,%eax
c0025ebe:	8b 00                	mov    (%eax),%eax
c0025ec0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  model = descramble_ata_string (&id[10 * 2], 20);
c0025ec3:	83 ec 08             	sub    $0x8,%esp
c0025ec6:	6a 14                	push   $0x14
c0025ec8:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025ece:	83 c0 14             	add    $0x14,%eax
c0025ed1:	50                   	push   %eax
c0025ed2:	e8 c6 00 00 00       	call   c0025f9d <descramble_ata_string>
c0025ed7:	83 c4 10             	add    $0x10,%esp
c0025eda:	89 45 ec             	mov    %eax,-0x14(%ebp)
  serial = descramble_ata_string (&id[27 * 2], 40);
c0025edd:	83 ec 08             	sub    $0x8,%esp
c0025ee0:	6a 28                	push   $0x28
c0025ee2:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025ee8:	83 c0 36             	add    $0x36,%eax
c0025eeb:	50                   	push   %eax
c0025eec:	e8 ac 00 00 00       	call   c0025f9d <descramble_ata_string>
c0025ef1:	83 c4 10             	add    $0x10,%esp
c0025ef4:	89 45 e8             	mov    %eax,-0x18(%ebp)
  snprintf (extra_info, sizeof extra_info,
c0025ef7:	83 ec 0c             	sub    $0xc,%esp
c0025efa:	ff 75 e8             	pushl  -0x18(%ebp)
c0025efd:	ff 75 ec             	pushl  -0x14(%ebp)
c0025f00:	68 74 03 03 c0       	push   $0xc0030374
c0025f05:	68 80 00 00 00       	push   $0x80
c0025f0a:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c0025f10:	50                   	push   %eax
c0025f11:	e8 06 14 00 00       	call   c002731c <snprintf>
c0025f16:	83 c4 20             	add    $0x20,%esp
  /* Disable access to IDE disks over 1 GB, which are likely
     physical IDE disks rather than virtual ones.  If we don't
     allow access to those, we're less likely to scribble on
     someone's important data.  You can disable this check by
     hand if you really want to do so. */
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c0025f19:	81 7d f0 ff ff 1f 00 	cmpl   $0x1fffff,-0x10(%ebp)
c0025f20:	76 45                	jbe    c0025f67 <identify_ata_device+0x159>
    {
      printf ("%s: ignoring ", d->name);
c0025f22:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f25:	83 ec 08             	sub    $0x8,%esp
c0025f28:	50                   	push   %eax
c0025f29:	68 8c 03 03 c0       	push   $0xc003038c
c0025f2e:	e8 12 14 00 00       	call   c0027345 <printf>
c0025f33:	83 c4 10             	add    $0x10,%esp
      print_human_readable_size (capacity * 512);
c0025f36:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025f39:	c1 e0 09             	shl    $0x9,%eax
c0025f3c:	ba 00 00 00 00       	mov    $0x0,%edx
c0025f41:	83 ec 08             	sub    $0x8,%esp
c0025f44:	52                   	push   %edx
c0025f45:	50                   	push   %eax
c0025f46:	e8 1f 21 00 00       	call   c002806a <print_human_readable_size>
c0025f4b:	83 c4 10             	add    $0x10,%esp
      printf ("disk for safety\n");
c0025f4e:	83 ec 0c             	sub    $0xc,%esp
c0025f51:	68 9a 03 03 c0       	push   $0xc003039a
c0025f56:	e8 d0 59 00 00       	call   c002b92b <puts>
c0025f5b:	83 c4 10             	add    $0x10,%esp
      d->is_ata = false;
c0025f5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f61:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0025f65:	eb 34                	jmp    c0025f9b <identify_ata_device+0x18d>
    }

  /* Register. */
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c0025f67:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f6a:	83 ec 08             	sub    $0x8,%esp
c0025f6d:	ff 75 08             	pushl  0x8(%ebp)
c0025f70:	68 e0 80 03 c0       	push   $0xc00380e0
c0025f75:	ff 75 f0             	pushl  -0x10(%ebp)
c0025f78:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c0025f7e:	52                   	push   %edx
c0025f7f:	6a 04                	push   $0x4
c0025f81:	50                   	push   %eax
c0025f82:	e8 51 f2 ff ff       	call   c00251d8 <block_register>
c0025f87:	83 c4 20             	add    $0x20,%esp
c0025f8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                          &ide_operations, d);
  partition_scan (block);
c0025f8d:	83 ec 0c             	sub    $0xc,%esp
c0025f90:	ff 75 e4             	pushl  -0x1c(%ebp)
c0025f93:	e8 88 f3 ff ff       	call   c0025320 <partition_scan>
c0025f98:	83 c4 10             	add    $0x10,%esp
}
c0025f9b:	c9                   	leave  
c0025f9c:	c3                   	ret    

c0025f9d <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0025f9d:	55                   	push   %ebp
c0025f9e:	89 e5                	mov    %esp,%ebp
c0025fa0:	83 ec 10             	sub    $0x10,%esp
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0025fa3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0025faa:	eb 3b                	jmp    c0025fe7 <descramble_ata_string+0x4a>
    {
      char tmp = string[i];
c0025fac:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0025faf:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fb2:	01 d0                	add    %edx,%eax
c0025fb4:	0f b6 00             	movzbl (%eax),%eax
c0025fb7:	88 45 fb             	mov    %al,-0x5(%ebp)
      string[i] = string[i + 1];
c0025fba:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0025fbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fc0:	01 c2                	add    %eax,%edx
c0025fc2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025fc5:	8d 48 01             	lea    0x1(%eax),%ecx
c0025fc8:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fcb:	01 c8                	add    %ecx,%eax
c0025fcd:	0f b6 00             	movzbl (%eax),%eax
c0025fd0:	88 02                	mov    %al,(%edx)
      string[i + 1] = tmp;
c0025fd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025fd5:	8d 50 01             	lea    0x1(%eax),%edx
c0025fd8:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fdb:	01 c2                	add    %eax,%edx
c0025fdd:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0025fe1:	88 02                	mov    %al,(%edx)
descramble_ata_string (char *string, int size) 
{
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0025fe3:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
c0025fe7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025fea:	83 c0 01             	add    $0x1,%eax
c0025fed:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0025ff0:	7c ba                	jl     c0025fac <descramble_ata_string+0xf>
      string[i] = string[i + 1];
      string[i + 1] = tmp;
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0025ff2:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0025ff6:	eb 2d                	jmp    c0026025 <descramble_ata_string+0x88>
    {
      int c = string[size - 1];
c0025ff8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025ffb:	8d 50 ff             	lea    -0x1(%eax),%edx
c0025ffe:	8b 45 08             	mov    0x8(%ebp),%eax
c0026001:	01 d0                	add    %edx,%eax
c0026003:	0f b6 00             	movzbl (%eax),%eax
c0026006:	0f be c0             	movsbl %al,%eax
c0026009:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (c != '\0' && !isspace (c))
c002600c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0026010:	74 0f                	je     c0026021 <descramble_ata_string+0x84>
c0026012:	ff 75 f4             	pushl  -0xc(%ebp)
c0026015:	e8 c7 f7 ff ff       	call   c00257e1 <isspace>
c002601a:	83 c4 04             	add    $0x4,%esp
c002601d:	85 c0                	test   %eax,%eax
c002601f:	74 0c                	je     c002602d <descramble_ata_string+0x90>
      string[i] = string[i + 1];
      string[i + 1] = tmp;
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0026021:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0026025:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0026029:	7f cd                	jg     c0025ff8 <descramble_ata_string+0x5b>
c002602b:	eb 01                	jmp    c002602e <descramble_ata_string+0x91>
    {
      int c = string[size - 1];
      if (c != '\0' && !isspace (c))
        break; 
c002602d:	90                   	nop
    }
  string[size] = '\0';
c002602e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026031:	8b 45 08             	mov    0x8(%ebp),%eax
c0026034:	01 d0                	add    %edx,%eax
c0026036:	c6 00 00             	movb   $0x0,(%eax)

  return string;
c0026039:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002603c:	c9                   	leave  
c002603d:	c3                   	ret    

c002603e <ide_read>:
   room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_read (void *d_, block_sector_t sec_no, void *buffer)
{
c002603e:	55                   	push   %ebp
c002603f:	89 e5                	mov    %esp,%ebp
c0026041:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c0026044:	8b 45 08             	mov    0x8(%ebp),%eax
c0026047:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c002604a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002604d:	8b 40 08             	mov    0x8(%eax),%eax
c0026050:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0026053:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026056:	83 c0 0c             	add    $0xc,%eax
c0026059:	83 ec 0c             	sub    $0xc,%esp
c002605c:	50                   	push   %eax
c002605d:	e8 7e cb ff ff       	call   c0022be0 <lock_acquire>
c0026062:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c0026065:	83 ec 08             	sub    $0x8,%esp
c0026068:	ff 75 0c             	pushl  0xc(%ebp)
c002606b:	ff 75 f4             	pushl  -0xc(%ebp)
c002606e:	e8 3b 01 00 00       	call   c00261ae <select_sector>
c0026073:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c0026076:	83 ec 08             	sub    $0x8,%esp
c0026079:	6a 20                	push   $0x20
c002607b:	ff 75 f0             	pushl  -0x10(%ebp)
c002607e:	e8 32 02 00 00       	call   c00262b5 <issue_pio_command>
c0026083:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026086:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026089:	83 c0 28             	add    $0x28,%eax
c002608c:	83 ec 0c             	sub    $0xc,%esp
c002608f:	50                   	push   %eax
c0026090:	e8 8a c8 ff ff       	call   c002291f <sema_down>
c0026095:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0026098:	83 ec 0c             	sub    $0xc,%esp
c002609b:	ff 75 f4             	pushl  -0xc(%ebp)
c002609e:	e8 1c 03 00 00       	call   c00263bf <wait_while_busy>
c00260a3:	83 c4 10             	add    $0x10,%esp
c00260a6:	83 f0 01             	xor    $0x1,%eax
c00260a9:	84 c0                	test   %al,%al
c00260ab:	74 23                	je     c00260d0 <ide_read+0x92>
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c00260ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00260b0:	83 ec 08             	sub    $0x8,%esp
c00260b3:	ff 75 0c             	pushl  0xc(%ebp)
c00260b6:	50                   	push   %eax
c00260b7:	68 ac 03 03 c0       	push   $0xc00303ac
c00260bc:	68 8c 04 03 c0       	push   $0xc003048c
c00260c1:	68 62 01 00 00       	push   $0x162
c00260c6:	68 3a 03 03 c0       	push   $0xc003033a
c00260cb:	e8 a8 36 00 00       	call   c0029778 <debug_panic>
  input_sector (c, buffer);
c00260d0:	83 ec 08             	sub    $0x8,%esp
c00260d3:	ff 75 10             	pushl  0x10(%ebp)
c00260d6:	ff 75 f0             	pushl  -0x10(%ebp)
c00260d9:	e8 36 02 00 00       	call   c0026314 <input_sector>
c00260de:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c00260e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00260e4:	83 c0 0c             	add    $0xc,%eax
c00260e7:	83 ec 0c             	sub    $0xc,%esp
c00260ea:	50                   	push   %eax
c00260eb:	e8 31 cc ff ff       	call   c0022d21 <lock_release>
c00260f0:	83 c4 10             	add    $0x10,%esp
}
c00260f3:	90                   	nop
c00260f4:	c9                   	leave  
c00260f5:	c3                   	ret    

c00260f6 <ide_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_write (void *d_, block_sector_t sec_no, const void *buffer)
{
c00260f6:	55                   	push   %ebp
c00260f7:	89 e5                	mov    %esp,%ebp
c00260f9:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c00260fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00260ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0026102:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026105:	8b 40 08             	mov    0x8(%eax),%eax
c0026108:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c002610b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002610e:	83 c0 0c             	add    $0xc,%eax
c0026111:	83 ec 0c             	sub    $0xc,%esp
c0026114:	50                   	push   %eax
c0026115:	e8 c6 ca ff ff       	call   c0022be0 <lock_acquire>
c002611a:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c002611d:	83 ec 08             	sub    $0x8,%esp
c0026120:	ff 75 0c             	pushl  0xc(%ebp)
c0026123:	ff 75 f4             	pushl  -0xc(%ebp)
c0026126:	e8 83 00 00 00       	call   c00261ae <select_sector>
c002612b:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c002612e:	83 ec 08             	sub    $0x8,%esp
c0026131:	6a 30                	push   $0x30
c0026133:	ff 75 f0             	pushl  -0x10(%ebp)
c0026136:	e8 7a 01 00 00       	call   c00262b5 <issue_pio_command>
c002613b:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c002613e:	83 ec 0c             	sub    $0xc,%esp
c0026141:	ff 75 f4             	pushl  -0xc(%ebp)
c0026144:	e8 76 02 00 00       	call   c00263bf <wait_while_busy>
c0026149:	83 c4 10             	add    $0x10,%esp
c002614c:	83 f0 01             	xor    $0x1,%eax
c002614f:	84 c0                	test   %al,%al
c0026151:	74 23                	je     c0026176 <ide_write+0x80>
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c0026153:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026156:	83 ec 08             	sub    $0x8,%esp
c0026159:	ff 75 0c             	pushl  0xc(%ebp)
c002615c:	50                   	push   %eax
c002615d:	68 cc 03 03 c0       	push   $0xc00303cc
c0026162:	68 98 04 03 c0       	push   $0xc0030498
c0026167:	68 75 01 00 00       	push   $0x175
c002616c:	68 3a 03 03 c0       	push   $0xc003033a
c0026171:	e8 02 36 00 00       	call   c0029778 <debug_panic>
  output_sector (c, buffer);
c0026176:	83 ec 08             	sub    $0x8,%esp
c0026179:	ff 75 10             	pushl  0x10(%ebp)
c002617c:	ff 75 f0             	pushl  -0x10(%ebp)
c002617f:	e8 b1 01 00 00       	call   c0026335 <output_sector>
c0026184:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026187:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002618a:	83 c0 28             	add    $0x28,%eax
c002618d:	83 ec 0c             	sub    $0xc,%esp
c0026190:	50                   	push   %eax
c0026191:	e8 89 c7 ff ff       	call   c002291f <sema_down>
c0026196:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c0026199:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002619c:	83 c0 0c             	add    $0xc,%eax
c002619f:	83 ec 0c             	sub    $0xc,%esp
c00261a2:	50                   	push   %eax
c00261a3:	e8 79 cb ff ff       	call   c0022d21 <lock_release>
c00261a8:	83 c4 10             	add    $0x10,%esp
}
c00261ab:	90                   	nop
c00261ac:	c9                   	leave  
c00261ad:	c3                   	ret    

c00261ae <select_sector>:
/* Selects device D, waiting for it to become ready, and then
   writes SEC_NO to the disk's sector selection registers.  (We
   use LBA mode.) */
static void
select_sector (struct ata_disk *d, block_sector_t sec_no)
{
c00261ae:	55                   	push   %ebp
c00261af:	89 e5                	mov    %esp,%ebp
c00261b1:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c00261b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00261b7:	8b 40 08             	mov    0x8(%eax),%eax
c00261ba:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sec_no < (1UL << 28));
c00261bd:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
c00261c4:	76 21                	jbe    c00261e7 <select_sector+0x39>
c00261c6:	83 ec 0c             	sub    $0xc,%esp
c00261c9:	68 ed 03 03 c0       	push   $0xc00303ed
c00261ce:	68 5d 03 03 c0       	push   $0xc003035d
c00261d3:	68 a4 04 03 c0       	push   $0xc00304a4
c00261d8:	68 89 01 00 00       	push   $0x189
c00261dd:	68 3a 03 03 c0       	push   $0xc003033a
c00261e2:	e8 91 35 00 00       	call   c0029778 <debug_panic>
  
  select_device_wait (d);
c00261e7:	83 ec 0c             	sub    $0xc,%esp
c00261ea:	ff 75 08             	pushl  0x8(%ebp)
c00261ed:	e8 03 03 00 00       	call   c00264f5 <select_device_wait>
c00261f2:	83 c4 10             	add    $0x10,%esp
  outb (reg_nsect (c), 1);
c00261f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00261f8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00261fc:	83 c0 02             	add    $0x2,%eax
c00261ff:	0f b7 c0             	movzwl %ax,%eax
c0026202:	83 ec 08             	sub    $0x8,%esp
c0026205:	6a 01                	push   $0x1
c0026207:	50                   	push   %eax
c0026208:	e8 5a f6 ff ff       	call   c0025867 <outb>
c002620d:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbal (c), sec_no);
c0026210:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026213:	0f b6 d0             	movzbl %al,%edx
c0026216:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026219:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002621d:	83 c0 03             	add    $0x3,%eax
c0026220:	0f b7 c0             	movzwl %ax,%eax
c0026223:	83 ec 08             	sub    $0x8,%esp
c0026226:	52                   	push   %edx
c0026227:	50                   	push   %eax
c0026228:	e8 3a f6 ff ff       	call   c0025867 <outb>
c002622d:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbam (c), sec_no >> 8);
c0026230:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026233:	c1 e8 08             	shr    $0x8,%eax
c0026236:	0f b6 d0             	movzbl %al,%edx
c0026239:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002623c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026240:	83 c0 04             	add    $0x4,%eax
c0026243:	0f b7 c0             	movzwl %ax,%eax
c0026246:	83 ec 08             	sub    $0x8,%esp
c0026249:	52                   	push   %edx
c002624a:	50                   	push   %eax
c002624b:	e8 17 f6 ff ff       	call   c0025867 <outb>
c0026250:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbah (c), (sec_no >> 16));
c0026253:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026256:	c1 e8 10             	shr    $0x10,%eax
c0026259:	0f b6 d0             	movzbl %al,%edx
c002625c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002625f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026263:	83 c0 05             	add    $0x5,%eax
c0026266:	0f b7 c0             	movzwl %ax,%eax
c0026269:	83 ec 08             	sub    $0x8,%esp
c002626c:	52                   	push   %edx
c002626d:	50                   	push   %eax
c002626e:	e8 f4 f5 ff ff       	call   c0025867 <outb>
c0026273:	83 c4 10             	add    $0x10,%esp
  outb (reg_device (c),
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0026276:	8b 45 08             	mov    0x8(%ebp),%eax
c0026279:	8b 40 0c             	mov    0xc(%eax),%eax
  select_device_wait (d);
  outb (reg_nsect (c), 1);
  outb (reg_lbal (c), sec_no);
  outb (reg_lbam (c), sec_no >> 8);
  outb (reg_lbah (c), (sec_no >> 16));
  outb (reg_device (c),
c002627c:	83 f8 01             	cmp    $0x1,%eax
c002627f:	75 07                	jne    c0026288 <select_sector+0xda>
c0026281:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
c0026286:	eb 05                	jmp    c002628d <select_sector+0xdf>
c0026288:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c002628d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026290:	c1 e8 18             	shr    $0x18,%eax
  select_device_wait (d);
  outb (reg_nsect (c), 1);
  outb (reg_lbal (c), sec_no);
  outb (reg_lbam (c), sec_no >> 8);
  outb (reg_lbah (c), (sec_no >> 16));
  outb (reg_device (c),
c0026293:	09 d0                	or     %edx,%eax
c0026295:	0f b6 d0             	movzbl %al,%edx
c0026298:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002629b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002629f:	83 c0 06             	add    $0x6,%eax
c00262a2:	0f b7 c0             	movzwl %ax,%eax
c00262a5:	83 ec 08             	sub    $0x8,%esp
c00262a8:	52                   	push   %edx
c00262a9:	50                   	push   %eax
c00262aa:	e8 b8 f5 ff ff       	call   c0025867 <outb>
c00262af:	83 c4 10             	add    $0x10,%esp
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
}
c00262b2:	90                   	nop
c00262b3:	c9                   	leave  
c00262b4:	c3                   	ret    

c00262b5 <issue_pio_command>:

/* Writes COMMAND to channel C and prepares for receiving a
   completion interrupt. */
static void
issue_pio_command (struct channel *c, uint8_t command) 
{
c00262b5:	55                   	push   %ebp
c00262b6:	89 e5                	mov    %esp,%ebp
c00262b8:	83 ec 18             	sub    $0x18,%esp
c00262bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00262be:	88 45 f4             	mov    %al,-0xc(%ebp)
  /* Interrupts must be enabled or our semaphore will never be
     up'd by the completion handler. */
  ASSERT (intr_get_level () == INTR_ON);
c00262c1:	e8 91 b1 ff ff       	call   c0021457 <intr_get_level>
c00262c6:	83 f8 01             	cmp    $0x1,%eax
c00262c9:	74 21                	je     c00262ec <issue_pio_command+0x37>
c00262cb:	83 ec 0c             	sub    $0xc,%esp
c00262ce:	68 02 04 03 c0       	push   $0xc0030402
c00262d3:	68 5d 03 03 c0       	push   $0xc003035d
c00262d8:	68 b4 04 03 c0       	push   $0xc00304b4
c00262dd:	68 9b 01 00 00       	push   $0x19b
c00262e2:	68 3a 03 03 c0       	push   $0xc003033a
c00262e7:	e8 8c 34 00 00       	call   c0029778 <debug_panic>

  c->expecting_interrupt = true;
c00262ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00262ef:	c6 40 24 01          	movb   $0x1,0x24(%eax)
  outb (reg_command (c), command);
c00262f3:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c00262f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00262fa:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00262fe:	83 c0 07             	add    $0x7,%eax
c0026301:	0f b7 c0             	movzwl %ax,%eax
c0026304:	83 ec 08             	sub    $0x8,%esp
c0026307:	52                   	push   %edx
c0026308:	50                   	push   %eax
c0026309:	e8 59 f5 ff ff       	call   c0025867 <outb>
c002630e:	83 c4 10             	add    $0x10,%esp
}
c0026311:	90                   	nop
c0026312:	c9                   	leave  
c0026313:	c3                   	ret    

c0026314 <input_sector>:

/* Reads a sector from channel C's data register in PIO mode into
   SECTOR, which must have room for BLOCK_SECTOR_SIZE bytes. */
static void
input_sector (struct channel *c, void *sector) 
{
c0026314:	55                   	push   %ebp
c0026315:	89 e5                	mov    %esp,%ebp
  insw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026317:	8b 45 08             	mov    0x8(%ebp),%eax
c002631a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002631e:	0f b7 c0             	movzwl %ax,%eax
c0026321:	68 00 01 00 00       	push   $0x100
c0026326:	ff 75 0c             	pushl  0xc(%ebp)
c0026329:	50                   	push   %eax
c002632a:	e8 04 f5 ff ff       	call   c0025833 <insw>
c002632f:	83 c4 0c             	add    $0xc,%esp
}
c0026332:	90                   	nop
c0026333:	c9                   	leave  
c0026334:	c3                   	ret    

c0026335 <output_sector>:

/* Writes SECTOR to channel C's data register in PIO mode.
   SECTOR must contain BLOCK_SECTOR_SIZE bytes. */
static void
output_sector (struct channel *c, const void *sector) 
{
c0026335:	55                   	push   %ebp
c0026336:	89 e5                	mov    %esp,%ebp
  outsw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026338:	8b 45 08             	mov    0x8(%ebp),%eax
c002633b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002633f:	0f b7 c0             	movzwl %ax,%eax
c0026342:	68 00 01 00 00       	push   $0x100
c0026347:	ff 75 0c             	pushl  0xc(%ebp)
c002634a:	50                   	push   %eax
c002634b:	e8 36 f5 ff ff       	call   c0025886 <outsw>
c0026350:	83 c4 0c             	add    $0xc,%esp
}
c0026353:	90                   	nop
c0026354:	c9                   	leave  
c0026355:	c3                   	ret    

c0026356 <wait_until_idle>:

   As a side effect, reading the status register clears any
   pending interrupt. */
static void
wait_until_idle (const struct ata_disk *d) 
{
c0026356:	55                   	push   %ebp
c0026357:	89 e5                	mov    %esp,%ebp
c0026359:	83 ec 18             	sub    $0x18,%esp
  int i;

  for (i = 0; i < 1000; i++) 
c002635c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026363:	eb 38                	jmp    c002639d <wait_until_idle+0x47>
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0026365:	8b 45 08             	mov    0x8(%ebp),%eax
c0026368:	8b 40 08             	mov    0x8(%eax),%eax
c002636b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002636f:	83 c0 07             	add    $0x7,%eax
c0026372:	0f b7 c0             	movzwl %ax,%eax
c0026375:	50                   	push   %eax
c0026376:	e8 9b f4 ff ff       	call   c0025816 <inb>
c002637b:	83 c4 04             	add    $0x4,%esp
c002637e:	0f b6 c0             	movzbl %al,%eax
c0026381:	25 88 00 00 00       	and    $0x88,%eax
c0026386:	85 c0                	test   %eax,%eax
c0026388:	74 32                	je     c00263bc <wait_until_idle+0x66>
        return;
      timer_usleep (10);
c002638a:	83 ec 08             	sub    $0x8,%esp
c002638d:	6a 00                	push   $0x0
c002638f:	6a 0a                	push   $0xa
c0026391:	e8 55 db ff ff       	call   c0023eeb <timer_usleep>
c0026396:	83 c4 10             	add    $0x10,%esp
static void
wait_until_idle (const struct ata_disk *d) 
{
  int i;

  for (i = 0; i < 1000; i++) 
c0026399:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002639d:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c00263a4:	7e bf                	jle    c0026365 <wait_until_idle+0xf>
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
        return;
      timer_usleep (10);
    }

  printf ("%s: idle timeout\n", d->name);
c00263a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00263a9:	83 ec 08             	sub    $0x8,%esp
c00263ac:	50                   	push   %eax
c00263ad:	68 1f 04 03 c0       	push   $0xc003041f
c00263b2:	e8 8e 0f 00 00       	call   c0027345 <printf>
c00263b7:	83 c4 10             	add    $0x10,%esp
c00263ba:	eb 01                	jmp    c00263bd <wait_until_idle+0x67>
  int i;

  for (i = 0; i < 1000; i++) 
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
        return;
c00263bc:	90                   	nop
      timer_usleep (10);
    }

  printf ("%s: idle timeout\n", d->name);
}
c00263bd:	c9                   	leave  
c00263be:	c3                   	ret    

c00263bf <wait_while_busy>:
   and then return the status of the DRQ bit.
   The ATA standards say that a disk may take as long as that to
   complete its reset. */
static bool
wait_while_busy (const struct ata_disk *d) 
{
c00263bf:	55                   	push   %ebp
c00263c0:	89 e5                	mov    %esp,%ebp
c00263c2:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c00263c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00263c8:	8b 40 08             	mov    0x8(%eax),%eax
c00263cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < 3000; i++)
c00263ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00263d5:	e9 8e 00 00 00       	jmp    c0026468 <wait_while_busy+0xa9>
    {
      if (i == 700)
c00263da:	81 7d f4 bc 02 00 00 	cmpl   $0x2bc,-0xc(%ebp)
c00263e1:	75 14                	jne    c00263f7 <wait_while_busy+0x38>
        printf ("%s: busy, waiting...", d->name);
c00263e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00263e6:	83 ec 08             	sub    $0x8,%esp
c00263e9:	50                   	push   %eax
c00263ea:	68 31 04 03 c0       	push   $0xc0030431
c00263ef:	e8 51 0f 00 00       	call   c0027345 <printf>
c00263f4:	83 c4 10             	add    $0x10,%esp
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c00263f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00263fa:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00263fe:	66 05 06 02          	add    $0x206,%ax
c0026402:	0f b7 c0             	movzwl %ax,%eax
c0026405:	83 ec 0c             	sub    $0xc,%esp
c0026408:	50                   	push   %eax
c0026409:	e8 08 f4 ff ff       	call   c0025816 <inb>
c002640e:	83 c4 10             	add    $0x10,%esp
c0026411:	84 c0                	test   %al,%al
c0026413:	78 40                	js     c0026455 <wait_while_busy+0x96>
        {
          if (i >= 700)
c0026415:	81 7d f4 bb 02 00 00 	cmpl   $0x2bb,-0xc(%ebp)
c002641c:	7e 10                	jle    c002642e <wait_while_busy+0x6f>
            printf ("ok\n");
c002641e:	83 ec 0c             	sub    $0xc,%esp
c0026421:	68 46 04 03 c0       	push   $0xc0030446
c0026426:	e8 00 55 00 00       	call   c002b92b <puts>
c002642b:	83 c4 10             	add    $0x10,%esp
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c002642e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026431:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026435:	66 05 06 02          	add    $0x206,%ax
c0026439:	0f b7 c0             	movzwl %ax,%eax
c002643c:	83 ec 0c             	sub    $0xc,%esp
c002643f:	50                   	push   %eax
c0026440:	e8 d1 f3 ff ff       	call   c0025816 <inb>
c0026445:	83 c4 10             	add    $0x10,%esp
c0026448:	0f b6 c0             	movzbl %al,%eax
c002644b:	83 e0 08             	and    $0x8,%eax
c002644e:	85 c0                	test   %eax,%eax
c0026450:	0f 95 c0             	setne  %al
c0026453:	eb 35                	jmp    c002648a <wait_while_busy+0xcb>
        }
      timer_msleep (10);
c0026455:	83 ec 08             	sub    $0x8,%esp
c0026458:	6a 00                	push   $0x0
c002645a:	6a 0a                	push   $0xa
c002645c:	e8 5f da ff ff       	call   c0023ec0 <timer_msleep>
c0026461:	83 c4 10             	add    $0x10,%esp
wait_while_busy (const struct ata_disk *d) 
{
  struct channel *c = d->channel;
  int i;
  
  for (i = 0; i < 3000; i++)
c0026464:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0026468:	81 7d f4 b7 0b 00 00 	cmpl   $0xbb7,-0xc(%ebp)
c002646f:	0f 8e 65 ff ff ff    	jle    c00263da <wait_while_busy+0x1b>
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
        }
      timer_msleep (10);
    }

  printf ("failed\n");
c0026475:	83 ec 0c             	sub    $0xc,%esp
c0026478:	68 49 04 03 c0       	push   $0xc0030449
c002647d:	e8 a9 54 00 00       	call   c002b92b <puts>
c0026482:	83 c4 10             	add    $0x10,%esp
  return false;
c0026485:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002648a:	c9                   	leave  
c002648b:	c3                   	ret    

c002648c <select_device>:

/* Program D's channel so that D is now the selected disk. */
static void
select_device (const struct ata_disk *d)
{
c002648c:	55                   	push   %ebp
c002648d:	89 e5                	mov    %esp,%ebp
c002648f:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0026492:	8b 45 08             	mov    0x8(%ebp),%eax
c0026495:	8b 40 08             	mov    0x8(%eax),%eax
c0026498:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t dev = DEV_MBS;
c002649b:	c6 45 f7 a0          	movb   $0xa0,-0x9(%ebp)
  if (d->dev_no == 1)
c002649f:	8b 45 08             	mov    0x8(%ebp),%eax
c00264a2:	8b 40 0c             	mov    0xc(%eax),%eax
c00264a5:	83 f8 01             	cmp    $0x1,%eax
c00264a8:	75 04                	jne    c00264ae <select_device+0x22>
    dev |= DEV_DEV;
c00264aa:	80 4d f7 10          	orb    $0x10,-0x9(%ebp)
  outb (reg_device (c), dev);
c00264ae:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c00264b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00264b5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00264b9:	83 c0 06             	add    $0x6,%eax
c00264bc:	0f b7 c0             	movzwl %ax,%eax
c00264bf:	52                   	push   %edx
c00264c0:	50                   	push   %eax
c00264c1:	e8 a1 f3 ff ff       	call   c0025867 <outb>
c00264c6:	83 c4 08             	add    $0x8,%esp
  inb (reg_alt_status (c));
c00264c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00264cc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00264d0:	66 05 06 02          	add    $0x206,%ax
c00264d4:	0f b7 c0             	movzwl %ax,%eax
c00264d7:	50                   	push   %eax
c00264d8:	e8 39 f3 ff ff       	call   c0025816 <inb>
c00264dd:	83 c4 04             	add    $0x4,%esp
  timer_nsleep (400);
c00264e0:	83 ec 08             	sub    $0x8,%esp
c00264e3:	6a 00                	push   $0x0
c00264e5:	68 90 01 00 00       	push   $0x190
c00264ea:	e8 27 da ff ff       	call   c0023f16 <timer_nsleep>
c00264ef:	83 c4 10             	add    $0x10,%esp
}
c00264f2:	90                   	nop
c00264f3:	c9                   	leave  
c00264f4:	c3                   	ret    

c00264f5 <select_device_wait>:

/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
c00264f5:	55                   	push   %ebp
c00264f6:	89 e5                	mov    %esp,%ebp
c00264f8:	83 ec 08             	sub    $0x8,%esp
  wait_until_idle (d);
c00264fb:	83 ec 0c             	sub    $0xc,%esp
c00264fe:	ff 75 08             	pushl  0x8(%ebp)
c0026501:	e8 50 fe ff ff       	call   c0026356 <wait_until_idle>
c0026506:	83 c4 10             	add    $0x10,%esp
  select_device (d);
c0026509:	83 ec 0c             	sub    $0xc,%esp
c002650c:	ff 75 08             	pushl  0x8(%ebp)
c002650f:	e8 78 ff ff ff       	call   c002648c <select_device>
c0026514:	83 c4 10             	add    $0x10,%esp
  wait_until_idle (d);
c0026517:	83 ec 0c             	sub    $0xc,%esp
c002651a:	ff 75 08             	pushl  0x8(%ebp)
c002651d:	e8 34 fe ff ff       	call   c0026356 <wait_until_idle>
c0026522:	83 c4 10             	add    $0x10,%esp
}
c0026525:	90                   	nop
c0026526:	c9                   	leave  
c0026527:	c3                   	ret    

c0026528 <interrupt_handler>:

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c0026528:	55                   	push   %ebp
c0026529:	89 e5                	mov    %esp,%ebp
c002652b:	83 ec 18             	sub    $0x18,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c002652e:	c7 45 f4 c0 99 03 c0 	movl   $0xc00399c0,-0xc(%ebp)
c0026535:	eb 63                	jmp    c002659a <interrupt_handler+0x72>
    if (f->vec_no == c->irq)
c0026537:	8b 45 08             	mov    0x8(%ebp),%eax
c002653a:	8b 50 30             	mov    0x30(%eax),%edx
c002653d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026540:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c0026544:	0f b6 c0             	movzbl %al,%eax
c0026547:	39 c2                	cmp    %eax,%edx
c0026549:	75 4b                	jne    c0026596 <interrupt_handler+0x6e>
      {
        if (c->expecting_interrupt) 
c002654b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002654e:	0f b6 40 24          	movzbl 0x24(%eax),%eax
c0026552:	84 c0                	test   %al,%al
c0026554:	74 2a                	je     c0026580 <interrupt_handler+0x58>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
c0026556:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026559:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002655d:	83 c0 07             	add    $0x7,%eax
c0026560:	0f b7 c0             	movzwl %ax,%eax
c0026563:	50                   	push   %eax
c0026564:	e8 ad f2 ff ff       	call   c0025816 <inb>
c0026569:	83 c4 04             	add    $0x4,%esp
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c002656c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002656f:	83 c0 28             	add    $0x28,%eax
c0026572:	83 ec 0c             	sub    $0xc,%esp
c0026575:	50                   	push   %eax
c0026576:	e8 af c4 ff ff       	call   c0022a2a <sema_up>
c002657b:	83 c4 10             	add    $0x10,%esp
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
c002657e:	eb 3d                	jmp    c00265bd <interrupt_handler+0x95>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
            sema_up (&c->completion_wait);      /* Wake up waiter. */
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
c0026580:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026583:	83 ec 08             	sub    $0x8,%esp
c0026586:	50                   	push   %eax
c0026587:	68 50 04 03 c0       	push   $0xc0030450
c002658c:	e8 b4 0d 00 00       	call   c0027345 <printf>
c0026591:	83 c4 10             	add    $0x10,%esp
        return;
c0026594:	eb 27                	jmp    c00265bd <interrupt_handler+0x95>
static void
interrupt_handler (struct intr_frame *f) 
{
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0026596:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
c002659a:	b8 88 9a 03 c0       	mov    $0xc0039a88,%eax
c002659f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00265a2:	72 93                	jb     c0026537 <interrupt_handler+0xf>
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
      }

  NOT_REACHED ();
c00265a4:	68 18 03 03 c0       	push   $0xc0030318
c00265a9:	68 c8 04 03 c0       	push   $0xc00304c8
c00265ae:	68 0c 02 00 00       	push   $0x20c
c00265b3:	68 3a 03 03 c0       	push   $0xc003033a
c00265b8:	e8 bb 31 00 00       	call   c0029778 <debug_panic>
}
c00265bd:	c9                   	leave  
c00265be:	c3                   	ret    

c00265bf <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c00265bf:	55                   	push   %ebp
c00265c0:	89 e5                	mov    %esp,%ebp
c00265c2:	83 ec 08             	sub    $0x8,%esp
  intq_init (&buffer);
c00265c5:	83 ec 0c             	sub    $0xc,%esp
c00265c8:	68 a0 9a 03 c0       	push   $0xc0039aa0
c00265cd:	e8 04 01 00 00       	call   c00266d6 <intq_init>
c00265d2:	83 c4 10             	add    $0x10,%esp
}
c00265d5:	90                   	nop
c00265d6:	c9                   	leave  
c00265d7:	c3                   	ret    

c00265d8 <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c00265d8:	55                   	push   %ebp
c00265d9:	89 e5                	mov    %esp,%ebp
c00265db:	83 ec 18             	sub    $0x18,%esp
c00265de:	8b 45 08             	mov    0x8(%ebp),%eax
c00265e1:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c00265e4:	e8 6e ae ff ff       	call   c0021457 <intr_get_level>
c00265e9:	85 c0                	test   %eax,%eax
c00265eb:	74 1e                	je     c002660b <input_putc+0x33>
c00265ed:	83 ec 0c             	sub    $0xc,%esp
c00265f0:	68 dc 04 03 c0       	push   $0xc00304dc
c00265f5:	68 fa 04 03 c0       	push   $0xc00304fa
c00265fa:	68 3c 05 03 c0       	push   $0xc003053c
c00265ff:	6a 15                	push   $0x15
c0026601:	68 11 05 03 c0       	push   $0xc0030511
c0026606:	e8 6d 31 00 00       	call   c0029778 <debug_panic>
  ASSERT (!intq_full (&buffer));
c002660b:	83 ec 0c             	sub    $0xc,%esp
c002660e:	68 a0 9a 03 c0       	push   $0xc0039aa0
c0026613:	e8 42 01 00 00       	call   c002675a <intq_full>
c0026618:	83 c4 10             	add    $0x10,%esp
c002661b:	83 f0 01             	xor    $0x1,%eax
c002661e:	84 c0                	test   %al,%al
c0026620:	75 1e                	jne    c0026640 <input_putc+0x68>
c0026622:	83 ec 0c             	sub    $0xc,%esp
c0026625:	68 27 05 03 c0       	push   $0xc0030527
c002662a:	68 fa 04 03 c0       	push   $0xc00304fa
c002662f:	68 3c 05 03 c0       	push   $0xc003053c
c0026634:	6a 16                	push   $0x16
c0026636:	68 11 05 03 c0       	push   $0xc0030511
c002663b:	e8 38 31 00 00       	call   c0029778 <debug_panic>

  intq_putc (&buffer, key);
c0026640:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0026644:	83 ec 08             	sub    $0x8,%esp
c0026647:	50                   	push   %eax
c0026648:	68 a0 9a 03 c0       	push   $0xc0039aa0
c002664d:	e8 38 02 00 00       	call   c002688a <intq_putc>
c0026652:	83 c4 10             	add    $0x10,%esp
  serial_notify ();
c0026655:	e8 e6 e5 ff ff       	call   c0024c40 <serial_notify>
}
c002665a:	90                   	nop
c002665b:	c9                   	leave  
c002665c:	c3                   	ret    

c002665d <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c002665d:	55                   	push   %ebp
c002665e:	89 e5                	mov    %esp,%ebp
c0026660:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c0026663:	e8 64 ae ff ff       	call   c00214cc <intr_disable>
c0026668:	89 45 f4             	mov    %eax,-0xc(%ebp)
  key = intq_getc (&buffer);
c002666b:	83 ec 0c             	sub    $0xc,%esp
c002666e:	68 a0 9a 03 c0       	push   $0xc0039aa0
c0026673:	e8 30 01 00 00       	call   c00267a8 <intq_getc>
c0026678:	83 c4 10             	add    $0x10,%esp
c002667b:	88 45 f3             	mov    %al,-0xd(%ebp)
  serial_notify ();
c002667e:	e8 bd e5 ff ff       	call   c0024c40 <serial_notify>
  intr_set_level (old_level);
c0026683:	83 ec 0c             	sub    $0xc,%esp
c0026686:	ff 75 f4             	pushl  -0xc(%ebp)
c0026689:	e8 e6 ad ff ff       	call   c0021474 <intr_set_level>
c002668e:	83 c4 10             	add    $0x10,%esp
  
  return key;
c0026691:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
}
c0026695:	c9                   	leave  
c0026696:	c3                   	ret    

c0026697 <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c0026697:	55                   	push   %ebp
c0026698:	89 e5                	mov    %esp,%ebp
c002669a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c002669d:	e8 b5 ad ff ff       	call   c0021457 <intr_get_level>
c00266a2:	85 c0                	test   %eax,%eax
c00266a4:	74 1e                	je     c00266c4 <input_full+0x2d>
c00266a6:	83 ec 0c             	sub    $0xc,%esp
c00266a9:	68 dc 04 03 c0       	push   $0xc00304dc
c00266ae:	68 fa 04 03 c0       	push   $0xc00304fa
c00266b3:	68 48 05 03 c0       	push   $0xc0030548
c00266b8:	6a 32                	push   $0x32
c00266ba:	68 11 05 03 c0       	push   $0xc0030511
c00266bf:	e8 b4 30 00 00       	call   c0029778 <debug_panic>
  return intq_full (&buffer);
c00266c4:	83 ec 0c             	sub    $0xc,%esp
c00266c7:	68 a0 9a 03 c0       	push   $0xc0039aa0
c00266cc:	e8 89 00 00 00       	call   c002675a <intq_full>
c00266d1:	83 c4 10             	add    $0x10,%esp
}
c00266d4:	c9                   	leave  
c00266d5:	c3                   	ret    

c00266d6 <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c00266d6:	55                   	push   %ebp
c00266d7:	89 e5                	mov    %esp,%ebp
c00266d9:	83 ec 08             	sub    $0x8,%esp
  lock_init (&q->lock);
c00266dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00266df:	83 ec 0c             	sub    $0xc,%esp
c00266e2:	50                   	push   %eax
c00266e3:	e8 ab c4 ff ff       	call   c0022b93 <lock_init>
c00266e8:	83 c4 10             	add    $0x10,%esp
  q->not_full = q->not_empty = NULL;
c00266eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00266ee:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
c00266f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00266f8:	8b 50 1c             	mov    0x1c(%eax),%edx
c00266fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00266fe:	89 50 18             	mov    %edx,0x18(%eax)
  q->head = q->tail = 0;
c0026701:	8b 45 08             	mov    0x8(%ebp),%eax
c0026704:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
c002670b:	8b 45 08             	mov    0x8(%ebp),%eax
c002670e:	8b 50 64             	mov    0x64(%eax),%edx
c0026711:	8b 45 08             	mov    0x8(%ebp),%eax
c0026714:	89 50 60             	mov    %edx,0x60(%eax)
}
c0026717:	90                   	nop
c0026718:	c9                   	leave  
c0026719:	c3                   	ret    

c002671a <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c002671a:	55                   	push   %ebp
c002671b:	89 e5                	mov    %esp,%ebp
c002671d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026720:	e8 32 ad ff ff       	call   c0021457 <intr_get_level>
c0026725:	85 c0                	test   %eax,%eax
c0026727:	74 1e                	je     c0026747 <intq_empty+0x2d>
c0026729:	83 ec 0c             	sub    $0xc,%esp
c002672c:	68 54 05 03 c0       	push   $0xc0030554
c0026731:	68 72 05 03 c0       	push   $0xc0030572
c0026736:	68 68 06 03 c0       	push   $0xc0030668
c002673b:	6a 16                	push   $0x16
c002673d:	68 89 05 03 c0       	push   $0xc0030589
c0026742:	e8 31 30 00 00       	call   c0029778 <debug_panic>
  return q->head == q->tail;
c0026747:	8b 45 08             	mov    0x8(%ebp),%eax
c002674a:	8b 50 60             	mov    0x60(%eax),%edx
c002674d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026750:	8b 40 64             	mov    0x64(%eax),%eax
c0026753:	39 c2                	cmp    %eax,%edx
c0026755:	0f 94 c0             	sete   %al
}
c0026758:	c9                   	leave  
c0026759:	c3                   	ret    

c002675a <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c002675a:	55                   	push   %ebp
c002675b:	89 e5                	mov    %esp,%ebp
c002675d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026760:	e8 f2 ac ff ff       	call   c0021457 <intr_get_level>
c0026765:	85 c0                	test   %eax,%eax
c0026767:	74 1e                	je     c0026787 <intq_full+0x2d>
c0026769:	83 ec 0c             	sub    $0xc,%esp
c002676c:	68 54 05 03 c0       	push   $0xc0030554
c0026771:	68 72 05 03 c0       	push   $0xc0030572
c0026776:	68 74 06 03 c0       	push   $0xc0030674
c002677b:	6a 1e                	push   $0x1e
c002677d:	68 89 05 03 c0       	push   $0xc0030589
c0026782:	e8 f1 2f 00 00       	call   c0029778 <debug_panic>
  return next (q->head) == q->tail;
c0026787:	8b 45 08             	mov    0x8(%ebp),%eax
c002678a:	8b 40 60             	mov    0x60(%eax),%eax
c002678d:	83 ec 0c             	sub    $0xc,%esp
c0026790:	50                   	push   %eax
c0026791:	e8 d9 01 00 00       	call   c002696f <next>
c0026796:	83 c4 10             	add    $0x10,%esp
c0026799:	89 c2                	mov    %eax,%edx
c002679b:	8b 45 08             	mov    0x8(%ebp),%eax
c002679e:	8b 40 64             	mov    0x64(%eax),%eax
c00267a1:	39 c2                	cmp    %eax,%edx
c00267a3:	0f 94 c0             	sete   %al
}
c00267a6:	c9                   	leave  
c00267a7:	c3                   	ret    

c00267a8 <intq_getc>:
/* Removes a byte from Q and returns it.
   If Q is empty, sleeps until a byte is added.
   When called from an interrupt handler, Q must not be empty. */
uint8_t
intq_getc (struct intq *q) 
{
c00267a8:	55                   	push   %ebp
c00267a9:	89 e5                	mov    %esp,%ebp
c00267ab:	83 ec 18             	sub    $0x18,%esp
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
c00267ae:	e8 a4 ac ff ff       	call   c0021457 <intr_get_level>
c00267b3:	85 c0                	test   %eax,%eax
c00267b5:	74 7b                	je     c0026832 <intq_getc+0x8a>
c00267b7:	83 ec 0c             	sub    $0xc,%esp
c00267ba:	68 54 05 03 c0       	push   $0xc0030554
c00267bf:	68 72 05 03 c0       	push   $0xc0030572
c00267c4:	68 80 06 03 c0       	push   $0xc0030680
c00267c9:	6a 2a                	push   $0x2a
c00267cb:	68 89 05 03 c0       	push   $0xc0030589
c00267d0:	e8 a3 2f 00 00       	call   c0029778 <debug_panic>
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
c00267d5:	e8 c1 af ff ff       	call   c002179b <intr_context>
c00267da:	83 f0 01             	xor    $0x1,%eax
c00267dd:	84 c0                	test   %al,%al
c00267df:	75 1e                	jne    c00267ff <intq_getc+0x57>
c00267e1:	83 ec 0c             	sub    $0xc,%esp
c00267e4:	68 9e 05 03 c0       	push   $0xc003059e
c00267e9:	68 72 05 03 c0       	push   $0xc0030572
c00267ee:	68 80 06 03 c0       	push   $0xc0030680
c00267f3:	6a 2d                	push   $0x2d
c00267f5:	68 89 05 03 c0       	push   $0xc0030589
c00267fa:	e8 79 2f 00 00       	call   c0029778 <debug_panic>
      lock_acquire (&q->lock);
c00267ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0026802:	83 ec 0c             	sub    $0xc,%esp
c0026805:	50                   	push   %eax
c0026806:	e8 d5 c3 ff ff       	call   c0022be0 <lock_acquire>
c002680b:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_empty);
c002680e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026811:	83 c0 1c             	add    $0x1c,%eax
c0026814:	83 ec 08             	sub    $0x8,%esp
c0026817:	50                   	push   %eax
c0026818:	ff 75 08             	pushl  0x8(%ebp)
c002681b:	e8 6b 01 00 00       	call   c002698b <wait>
c0026820:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0026823:	8b 45 08             	mov    0x8(%ebp),%eax
c0026826:	83 ec 0c             	sub    $0xc,%esp
c0026829:	50                   	push   %eax
c002682a:	e8 f2 c4 ff ff       	call   c0022d21 <lock_release>
c002682f:	83 c4 10             	add    $0x10,%esp
intq_getc (struct intq *q) 
{
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
  while (intq_empty (q)) 
c0026832:	83 ec 0c             	sub    $0xc,%esp
c0026835:	ff 75 08             	pushl  0x8(%ebp)
c0026838:	e8 dd fe ff ff       	call   c002671a <intq_empty>
c002683d:	83 c4 10             	add    $0x10,%esp
c0026840:	84 c0                	test   %al,%al
c0026842:	75 91                	jne    c00267d5 <intq_getc+0x2d>
      lock_acquire (&q->lock);
      wait (q, &q->not_empty);
      lock_release (&q->lock);
    }
  
  byte = q->buf[q->tail];
c0026844:	8b 45 08             	mov    0x8(%ebp),%eax
c0026847:	8b 40 64             	mov    0x64(%eax),%eax
c002684a:	8b 55 08             	mov    0x8(%ebp),%edx
c002684d:	0f b6 44 02 20       	movzbl 0x20(%edx,%eax,1),%eax
c0026852:	88 45 f7             	mov    %al,-0x9(%ebp)
  q->tail = next (q->tail);
c0026855:	8b 45 08             	mov    0x8(%ebp),%eax
c0026858:	8b 40 64             	mov    0x64(%eax),%eax
c002685b:	83 ec 0c             	sub    $0xc,%esp
c002685e:	50                   	push   %eax
c002685f:	e8 0b 01 00 00       	call   c002696f <next>
c0026864:	83 c4 10             	add    $0x10,%esp
c0026867:	89 c2                	mov    %eax,%edx
c0026869:	8b 45 08             	mov    0x8(%ebp),%eax
c002686c:	89 50 64             	mov    %edx,0x64(%eax)
  signal (q, &q->not_full);
c002686f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026872:	83 c0 18             	add    $0x18,%eax
c0026875:	83 ec 08             	sub    $0x8,%esp
c0026878:	50                   	push   %eax
c0026879:	ff 75 08             	pushl  0x8(%ebp)
c002687c:	e8 cd 01 00 00       	call   c0026a4e <signal>
c0026881:	83 c4 10             	add    $0x10,%esp
  return byte;
c0026884:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c0026888:	c9                   	leave  
c0026889:	c3                   	ret    

c002688a <intq_putc>:
/* Adds BYTE to the end of Q.
   If Q is full, sleeps until a byte is removed.
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
c002688a:	55                   	push   %ebp
c002688b:	89 e5                	mov    %esp,%ebp
c002688d:	83 ec 18             	sub    $0x18,%esp
c0026890:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026893:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0026896:	e8 bc ab ff ff       	call   c0021457 <intr_get_level>
c002689b:	85 c0                	test   %eax,%eax
c002689d:	74 7b                	je     c002691a <intq_putc+0x90>
c002689f:	83 ec 0c             	sub    $0xc,%esp
c00268a2:	68 54 05 03 c0       	push   $0xc0030554
c00268a7:	68 72 05 03 c0       	push   $0xc0030572
c00268ac:	68 8c 06 03 c0       	push   $0xc003068c
c00268b1:	6a 3f                	push   $0x3f
c00268b3:	68 89 05 03 c0       	push   $0xc0030589
c00268b8:	e8 bb 2e 00 00       	call   c0029778 <debug_panic>
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
c00268bd:	e8 d9 ae ff ff       	call   c002179b <intr_context>
c00268c2:	83 f0 01             	xor    $0x1,%eax
c00268c5:	84 c0                	test   %al,%al
c00268c7:	75 1e                	jne    c00268e7 <intq_putc+0x5d>
c00268c9:	83 ec 0c             	sub    $0xc,%esp
c00268cc:	68 9e 05 03 c0       	push   $0xc003059e
c00268d1:	68 72 05 03 c0       	push   $0xc0030572
c00268d6:	68 8c 06 03 c0       	push   $0xc003068c
c00268db:	6a 42                	push   $0x42
c00268dd:	68 89 05 03 c0       	push   $0xc0030589
c00268e2:	e8 91 2e 00 00       	call   c0029778 <debug_panic>
      lock_acquire (&q->lock);
c00268e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00268ea:	83 ec 0c             	sub    $0xc,%esp
c00268ed:	50                   	push   %eax
c00268ee:	e8 ed c2 ff ff       	call   c0022be0 <lock_acquire>
c00268f3:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_full);
c00268f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00268f9:	83 c0 18             	add    $0x18,%eax
c00268fc:	83 ec 08             	sub    $0x8,%esp
c00268ff:	50                   	push   %eax
c0026900:	ff 75 08             	pushl  0x8(%ebp)
c0026903:	e8 83 00 00 00       	call   c002698b <wait>
c0026908:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c002690b:	8b 45 08             	mov    0x8(%ebp),%eax
c002690e:	83 ec 0c             	sub    $0xc,%esp
c0026911:	50                   	push   %eax
c0026912:	e8 0a c4 ff ff       	call   c0022d21 <lock_release>
c0026917:	83 c4 10             	add    $0x10,%esp
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
  ASSERT (intr_get_level () == INTR_OFF);
  while (intq_full (q))
c002691a:	83 ec 0c             	sub    $0xc,%esp
c002691d:	ff 75 08             	pushl  0x8(%ebp)
c0026920:	e8 35 fe ff ff       	call   c002675a <intq_full>
c0026925:	83 c4 10             	add    $0x10,%esp
c0026928:	84 c0                	test   %al,%al
c002692a:	75 91                	jne    c00268bd <intq_putc+0x33>
      lock_acquire (&q->lock);
      wait (q, &q->not_full);
      lock_release (&q->lock);
    }

  q->buf[q->head] = byte;
c002692c:	8b 45 08             	mov    0x8(%ebp),%eax
c002692f:	8b 40 60             	mov    0x60(%eax),%eax
c0026932:	8b 55 08             	mov    0x8(%ebp),%edx
c0026935:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c0026939:	88 4c 02 20          	mov    %cl,0x20(%edx,%eax,1)
  q->head = next (q->head);
c002693d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026940:	8b 40 60             	mov    0x60(%eax),%eax
c0026943:	83 ec 0c             	sub    $0xc,%esp
c0026946:	50                   	push   %eax
c0026947:	e8 23 00 00 00       	call   c002696f <next>
c002694c:	83 c4 10             	add    $0x10,%esp
c002694f:	89 c2                	mov    %eax,%edx
c0026951:	8b 45 08             	mov    0x8(%ebp),%eax
c0026954:	89 50 60             	mov    %edx,0x60(%eax)
  signal (q, &q->not_empty);
c0026957:	8b 45 08             	mov    0x8(%ebp),%eax
c002695a:	83 c0 1c             	add    $0x1c,%eax
c002695d:	83 ec 08             	sub    $0x8,%esp
c0026960:	50                   	push   %eax
c0026961:	ff 75 08             	pushl  0x8(%ebp)
c0026964:	e8 e5 00 00 00       	call   c0026a4e <signal>
c0026969:	83 c4 10             	add    $0x10,%esp
}
c002696c:	90                   	nop
c002696d:	c9                   	leave  
c002696e:	c3                   	ret    

c002696f <next>:

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
c002696f:	55                   	push   %ebp
c0026970:	89 e5                	mov    %esp,%ebp
  return (pos + 1) % INTQ_BUFSIZE;
c0026972:	8b 45 08             	mov    0x8(%ebp),%eax
c0026975:	8d 50 01             	lea    0x1(%eax),%edx
c0026978:	89 d0                	mov    %edx,%eax
c002697a:	c1 f8 1f             	sar    $0x1f,%eax
c002697d:	c1 e8 1a             	shr    $0x1a,%eax
c0026980:	01 c2                	add    %eax,%edx
c0026982:	83 e2 3f             	and    $0x3f,%edx
c0026985:	29 c2                	sub    %eax,%edx
c0026987:	89 d0                	mov    %edx,%eax
}
c0026989:	5d                   	pop    %ebp
c002698a:	c3                   	ret    

c002698b <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c002698b:	55                   	push   %ebp
c002698c:	89 e5                	mov    %esp,%ebp
c002698e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0026991:	e8 05 ae ff ff       	call   c002179b <intr_context>
c0026996:	83 f0 01             	xor    $0x1,%eax
c0026999:	84 c0                	test   %al,%al
c002699b:	75 1e                	jne    c00269bb <wait+0x30>
c002699d:	83 ec 0c             	sub    $0xc,%esp
c00269a0:	68 9e 05 03 c0       	push   $0xc003059e
c00269a5:	68 72 05 03 c0       	push   $0xc0030572
c00269aa:	68 98 06 03 c0       	push   $0xc0030698
c00269af:	6a 59                	push   $0x59
c00269b1:	68 89 05 03 c0       	push   $0xc0030589
c00269b6:	e8 bd 2d 00 00       	call   c0029778 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c00269bb:	e8 97 aa ff ff       	call   c0021457 <intr_get_level>
c00269c0:	85 c0                	test   %eax,%eax
c00269c2:	74 1e                	je     c00269e2 <wait+0x57>
c00269c4:	83 ec 0c             	sub    $0xc,%esp
c00269c7:	68 54 05 03 c0       	push   $0xc0030554
c00269cc:	68 72 05 03 c0       	push   $0xc0030572
c00269d1:	68 98 06 03 c0       	push   $0xc0030698
c00269d6:	6a 5a                	push   $0x5a
c00269d8:	68 89 05 03 c0       	push   $0xc0030589
c00269dd:	e8 96 2d 00 00       	call   c0029778 <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c00269e2:	8b 45 08             	mov    0x8(%ebp),%eax
c00269e5:	83 c0 1c             	add    $0x1c,%eax
c00269e8:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00269eb:	75 12                	jne    c00269ff <wait+0x74>
c00269ed:	83 ec 0c             	sub    $0xc,%esp
c00269f0:	ff 75 08             	pushl  0x8(%ebp)
c00269f3:	e8 22 fd ff ff       	call   c002671a <intq_empty>
c00269f8:	83 c4 10             	add    $0x10,%esp
c00269fb:	84 c0                	test   %al,%al
c00269fd:	75 3b                	jne    c0026a3a <wait+0xaf>
c00269ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0026a02:	83 c0 18             	add    $0x18,%eax
c0026a05:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026a08:	75 12                	jne    c0026a1c <wait+0x91>
c0026a0a:	83 ec 0c             	sub    $0xc,%esp
c0026a0d:	ff 75 08             	pushl  0x8(%ebp)
c0026a10:	e8 45 fd ff ff       	call   c002675a <intq_full>
c0026a15:	83 c4 10             	add    $0x10,%esp
c0026a18:	84 c0                	test   %al,%al
c0026a1a:	75 1e                	jne    c0026a3a <wait+0xaf>
c0026a1c:	83 ec 0c             	sub    $0xc,%esp
c0026a1f:	68 b0 05 03 c0       	push   $0xc00305b0
c0026a24:	68 72 05 03 c0       	push   $0xc0030572
c0026a29:	68 98 06 03 c0       	push   $0xc0030698
c0026a2e:	6a 5c                	push   $0x5c
c0026a30:	68 89 05 03 c0       	push   $0xc0030589
c0026a35:	e8 3e 2d 00 00       	call   c0029778 <debug_panic>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0026a3a:	e8 60 a3 ff ff       	call   c0020d9f <thread_current>
c0026a3f:	89 c2                	mov    %eax,%edx
c0026a41:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026a44:	89 10                	mov    %edx,(%eax)
  thread_block ();
c0026a46:	e8 34 a2 ff ff       	call   c0020c7f <thread_block>
}
c0026a4b:	90                   	nop
c0026a4c:	c9                   	leave  
c0026a4d:	c3                   	ret    

c0026a4e <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c0026a4e:	55                   	push   %ebp
c0026a4f:	89 e5                	mov    %esp,%ebp
c0026a51:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026a54:	e8 fe a9 ff ff       	call   c0021457 <intr_get_level>
c0026a59:	85 c0                	test   %eax,%eax
c0026a5b:	74 1e                	je     c0026a7b <signal+0x2d>
c0026a5d:	83 ec 0c             	sub    $0xc,%esp
c0026a60:	68 54 05 03 c0       	push   $0xc0030554
c0026a65:	68 72 05 03 c0       	push   $0xc0030572
c0026a6a:	68 a0 06 03 c0       	push   $0xc00306a0
c0026a6f:	6a 69                	push   $0x69
c0026a71:	68 89 05 03 c0       	push   $0xc0030589
c0026a76:	e8 fd 2c 00 00       	call   c0029778 <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0026a7b:	8b 45 08             	mov    0x8(%ebp),%eax
c0026a7e:	83 c0 1c             	add    $0x1c,%eax
c0026a81:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026a84:	75 15                	jne    c0026a9b <signal+0x4d>
c0026a86:	83 ec 0c             	sub    $0xc,%esp
c0026a89:	ff 75 08             	pushl  0x8(%ebp)
c0026a8c:	e8 89 fc ff ff       	call   c002671a <intq_empty>
c0026a91:	83 c4 10             	add    $0x10,%esp
c0026a94:	83 f0 01             	xor    $0x1,%eax
c0026a97:	84 c0                	test   %al,%al
c0026a99:	75 3e                	jne    c0026ad9 <signal+0x8b>
c0026a9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0026a9e:	83 c0 18             	add    $0x18,%eax
c0026aa1:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026aa4:	75 15                	jne    c0026abb <signal+0x6d>
c0026aa6:	83 ec 0c             	sub    $0xc,%esp
c0026aa9:	ff 75 08             	pushl  0x8(%ebp)
c0026aac:	e8 a9 fc ff ff       	call   c002675a <intq_full>
c0026ab1:	83 c4 10             	add    $0x10,%esp
c0026ab4:	83 f0 01             	xor    $0x1,%eax
c0026ab7:	84 c0                	test   %al,%al
c0026ab9:	75 1e                	jne    c0026ad9 <signal+0x8b>
c0026abb:	83 ec 0c             	sub    $0xc,%esp
c0026abe:	68 0c 06 03 c0       	push   $0xc003060c
c0026ac3:	68 72 05 03 c0       	push   $0xc0030572
c0026ac8:	68 a0 06 03 c0       	push   $0xc00306a0
c0026acd:	6a 6b                	push   $0x6b
c0026acf:	68 89 05 03 c0       	push   $0xc0030589
c0026ad4:	e8 9f 2c 00 00       	call   c0029778 <debug_panic>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c0026ad9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026adc:	8b 00                	mov    (%eax),%eax
c0026ade:	85 c0                	test   %eax,%eax
c0026ae0:	74 1a                	je     c0026afc <signal+0xae>
    {
      thread_unblock (*waiter);
c0026ae2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026ae5:	8b 00                	mov    (%eax),%eax
c0026ae7:	83 ec 0c             	sub    $0xc,%esp
c0026aea:	50                   	push   %eax
c0026aeb:	e8 00 a2 ff ff       	call   c0020cf0 <thread_unblock>
c0026af0:	83 c4 10             	add    $0x10,%esp
      *waiter = NULL;
c0026af3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026af6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c0026afc:	90                   	nop
c0026afd:	c9                   	leave  
c0026afe:	c3                   	ret    

c0026aff <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0026aff:	55                   	push   %ebp
c0026b00:	89 e5                	mov    %esp,%ebp
c0026b02:	83 ec 14             	sub    $0x14,%esp
c0026b05:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b08:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b0c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0026b10:	89 c2                	mov    %eax,%edx
c0026b12:	ec                   	in     (%dx),%al
c0026b13:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026b16:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0026b1a:	c9                   	leave  
c0026b1b:	c3                   	ret    

c0026b1c <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0026b1c:	55                   	push   %ebp
c0026b1d:	89 e5                	mov    %esp,%ebp
c0026b1f:	83 ec 08             	sub    $0x8,%esp
c0026b22:	8b 55 08             	mov    0x8(%ebp),%edx
c0026b25:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026b28:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026b2c:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b2f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0026b33:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0026b37:	ee                   	out    %al,(%dx)
}
c0026b38:	90                   	nop
c0026b39:	c9                   	leave  
c0026b3a:	c3                   	ret    

c0026b3b <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c0026b3b:	55                   	push   %ebp
c0026b3c:	89 e5                	mov    %esp,%ebp
c0026b3e:	83 ec 28             	sub    $0x28,%esp
     but for historical reasons everyone always uses BCD format
     except on obscure non-PC platforms, so we don't bother
     trying to detect the format in use. */
  do
    {
      sec = bcd_to_bin (cmos_read (RTC_REG_SEC));
c0026b41:	83 ec 0c             	sub    $0xc,%esp
c0026b44:	6a 00                	push   $0x0
c0026b46:	e8 ae 01 00 00       	call   c0026cf9 <cmos_read>
c0026b4b:	83 c4 10             	add    $0x10,%esp
c0026b4e:	0f b6 c0             	movzbl %al,%eax
c0026b51:	83 ec 0c             	sub    $0xc,%esp
c0026b54:	50                   	push   %eax
c0026b55:	e8 73 01 00 00       	call   c0026ccd <bcd_to_bin>
c0026b5a:	83 c4 10             	add    $0x10,%esp
c0026b5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
      min = bcd_to_bin (cmos_read (RTC_REG_MIN));
c0026b60:	83 ec 0c             	sub    $0xc,%esp
c0026b63:	6a 02                	push   $0x2
c0026b65:	e8 8f 01 00 00       	call   c0026cf9 <cmos_read>
c0026b6a:	83 c4 10             	add    $0x10,%esp
c0026b6d:	0f b6 c0             	movzbl %al,%eax
c0026b70:	83 ec 0c             	sub    $0xc,%esp
c0026b73:	50                   	push   %eax
c0026b74:	e8 54 01 00 00       	call   c0026ccd <bcd_to_bin>
c0026b79:	83 c4 10             	add    $0x10,%esp
c0026b7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      hour = bcd_to_bin (cmos_read (RTC_REG_HOUR));
c0026b7f:	83 ec 0c             	sub    $0xc,%esp
c0026b82:	6a 04                	push   $0x4
c0026b84:	e8 70 01 00 00       	call   c0026cf9 <cmos_read>
c0026b89:	83 c4 10             	add    $0x10,%esp
c0026b8c:	0f b6 c0             	movzbl %al,%eax
c0026b8f:	83 ec 0c             	sub    $0xc,%esp
c0026b92:	50                   	push   %eax
c0026b93:	e8 35 01 00 00       	call   c0026ccd <bcd_to_bin>
c0026b98:	83 c4 10             	add    $0x10,%esp
c0026b9b:	89 45 e0             	mov    %eax,-0x20(%ebp)
      mday = bcd_to_bin (cmos_read (RTC_REG_MDAY));
c0026b9e:	83 ec 0c             	sub    $0xc,%esp
c0026ba1:	6a 07                	push   $0x7
c0026ba3:	e8 51 01 00 00       	call   c0026cf9 <cmos_read>
c0026ba8:	83 c4 10             	add    $0x10,%esp
c0026bab:	0f b6 c0             	movzbl %al,%eax
c0026bae:	83 ec 0c             	sub    $0xc,%esp
c0026bb1:	50                   	push   %eax
c0026bb2:	e8 16 01 00 00       	call   c0026ccd <bcd_to_bin>
c0026bb7:	83 c4 10             	add    $0x10,%esp
c0026bba:	89 45 dc             	mov    %eax,-0x24(%ebp)
      mon = bcd_to_bin (cmos_read (RTC_REG_MON));
c0026bbd:	83 ec 0c             	sub    $0xc,%esp
c0026bc0:	6a 08                	push   $0x8
c0026bc2:	e8 32 01 00 00       	call   c0026cf9 <cmos_read>
c0026bc7:	83 c4 10             	add    $0x10,%esp
c0026bca:	0f b6 c0             	movzbl %al,%eax
c0026bcd:	83 ec 0c             	sub    $0xc,%esp
c0026bd0:	50                   	push   %eax
c0026bd1:	e8 f7 00 00 00       	call   c0026ccd <bcd_to_bin>
c0026bd6:	83 c4 10             	add    $0x10,%esp
c0026bd9:	89 45 d8             	mov    %eax,-0x28(%ebp)
      year = bcd_to_bin (cmos_read (RTC_REG_YEAR));
c0026bdc:	83 ec 0c             	sub    $0xc,%esp
c0026bdf:	6a 09                	push   $0x9
c0026be1:	e8 13 01 00 00       	call   c0026cf9 <cmos_read>
c0026be6:	83 c4 10             	add    $0x10,%esp
c0026be9:	0f b6 c0             	movzbl %al,%eax
c0026bec:	83 ec 0c             	sub    $0xc,%esp
c0026bef:	50                   	push   %eax
c0026bf0:	e8 d8 00 00 00       	call   c0026ccd <bcd_to_bin>
c0026bf5:	83 c4 10             	add    $0x10,%esp
c0026bf8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c0026bfb:	83 ec 0c             	sub    $0xc,%esp
c0026bfe:	6a 00                	push   $0x0
c0026c00:	e8 f4 00 00 00       	call   c0026cf9 <cmos_read>
c0026c05:	83 c4 10             	add    $0x10,%esp
c0026c08:	0f b6 c0             	movzbl %al,%eax
c0026c0b:	83 ec 0c             	sub    $0xc,%esp
c0026c0e:	50                   	push   %eax
c0026c0f:	e8 b9 00 00 00       	call   c0026ccd <bcd_to_bin>
c0026c14:	83 c4 10             	add    $0x10,%esp
c0026c17:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0026c1a:	0f 85 21 ff ff ff    	jne    c0026b41 <rtc_get_time+0x6>

  /* Translate years-since-1900 into years-since-1970.
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
c0026c20:	83 7d f4 45          	cmpl   $0x45,-0xc(%ebp)
c0026c24:	7f 04                	jg     c0026c2a <rtc_get_time+0xef>
    year += 100;
c0026c26:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
  year -= 70;
c0026c2a:	83 6d f4 46          	subl   $0x46,-0xc(%ebp)

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0026c2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026c31:	69 d0 6d 01 00 00    	imul   $0x16d,%eax,%edx
c0026c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026c3a:	83 e8 01             	sub    $0x1,%eax
c0026c3d:	8d 48 03             	lea    0x3(%eax),%ecx
c0026c40:	85 c0                	test   %eax,%eax
c0026c42:	0f 48 c1             	cmovs  %ecx,%eax
c0026c45:	c1 f8 02             	sar    $0x2,%eax
c0026c48:	01 d0                	add    %edx,%eax
c0026c4a:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c0026c50:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c0026c53:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c0026c5a:	eb 1a                	jmp    c0026c76 <rtc_get_time+0x13b>
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0026c5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026c5f:	83 e8 01             	sub    $0x1,%eax
c0026c62:	8b 04 85 c0 06 03 c0 	mov    -0x3ffcf940(,%eax,4),%eax
c0026c69:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c0026c6f:	01 45 f0             	add    %eax,-0x10(%ebp)
    year += 100;
  year -= 70;

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
  for (i = 1; i <= mon; i++)
c0026c72:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0026c76:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026c79:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0026c7c:	7e de                	jle    c0026c5c <rtc_get_time+0x121>
    time += days_per_month[i - 1] * 24 * 60 * 60;
  if (mon > 2 && year % 4 == 0)
c0026c7e:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
c0026c82:	7e 11                	jle    c0026c95 <rtc_get_time+0x15a>
c0026c84:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026c87:	83 e0 03             	and    $0x3,%eax
c0026c8a:	85 c0                	test   %eax,%eax
c0026c8c:	75 07                	jne    c0026c95 <rtc_get_time+0x15a>
    time += 24 * 60 * 60;
c0026c8e:	81 45 f0 80 51 01 00 	addl   $0x15180,-0x10(%ebp)
  time += (mday - 1) * 24 * 60 * 60;
c0026c95:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0026c98:	83 e8 01             	sub    $0x1,%eax
c0026c9b:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c0026ca1:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += hour * 60 * 60;
c0026ca4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0026ca7:	69 c0 10 0e 00 00    	imul   $0xe10,%eax,%eax
c0026cad:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += min * 60;
c0026cb0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0026cb3:	c1 e0 02             	shl    $0x2,%eax
c0026cb6:	89 c2                	mov    %eax,%edx
c0026cb8:	c1 e2 04             	shl    $0x4,%edx
c0026cbb:	29 c2                	sub    %eax,%edx
c0026cbd:	89 d0                	mov    %edx,%eax
c0026cbf:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += sec;
c0026cc2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0026cc5:	01 45 f0             	add    %eax,-0x10(%ebp)

  return time;
c0026cc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0026ccb:	c9                   	leave  
c0026ccc:	c3                   	ret    

c0026ccd <bcd_to_bin>:

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
c0026ccd:	55                   	push   %ebp
c0026cce:	89 e5                	mov    %esp,%ebp
c0026cd0:	83 ec 04             	sub    $0x4,%esp
c0026cd3:	8b 45 08             	mov    0x8(%ebp),%eax
c0026cd6:	88 45 fc             	mov    %al,-0x4(%ebp)
  return (x & 0x0f) + ((x >> 4) * 10);
c0026cd9:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026cdd:	83 e0 0f             	and    $0xf,%eax
c0026ce0:	89 c1                	mov    %eax,%ecx
c0026ce2:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026ce6:	c0 e8 04             	shr    $0x4,%al
c0026ce9:	0f b6 d0             	movzbl %al,%edx
c0026cec:	89 d0                	mov    %edx,%eax
c0026cee:	c1 e0 02             	shl    $0x2,%eax
c0026cf1:	01 d0                	add    %edx,%eax
c0026cf3:	01 c0                	add    %eax,%eax
c0026cf5:	01 c8                	add    %ecx,%eax
}
c0026cf7:	c9                   	leave  
c0026cf8:	c3                   	ret    

c0026cf9 <cmos_read>:

/* Reads a byte from the CMOS register with the given INDEX and
   returns the byte read. */
static uint8_t
cmos_read (uint8_t index)
{
c0026cf9:	55                   	push   %ebp
c0026cfa:	89 e5                	mov    %esp,%ebp
c0026cfc:	83 ec 04             	sub    $0x4,%esp
c0026cff:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d02:	88 45 fc             	mov    %al,-0x4(%ebp)
  outb (CMOS_REG_SET, index);
c0026d05:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026d09:	50                   	push   %eax
c0026d0a:	6a 70                	push   $0x70
c0026d0c:	e8 0b fe ff ff       	call   c0026b1c <outb>
c0026d11:	83 c4 08             	add    $0x8,%esp
  return inb (CMOS_REG_IO);
c0026d14:	6a 71                	push   $0x71
c0026d16:	e8 e4 fd ff ff       	call   c0026aff <inb>
c0026d1b:	83 c4 04             	add    $0x4,%esp
}
c0026d1e:	c9                   	leave  
c0026d1f:	c3                   	ret    

c0026d20 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0026d20:	55                   	push   %ebp
c0026d21:	89 e5                	mov    %esp,%ebp
c0026d23:	83 ec 14             	sub    $0x14,%esp
c0026d26:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d29:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026d2d:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0026d31:	89 c2                	mov    %eax,%edx
c0026d33:	ec                   	in     (%dx),%al
c0026d34:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026d37:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0026d3b:	c9                   	leave  
c0026d3c:	c3                   	ret    

c0026d3d <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0026d3d:	55                   	push   %ebp
c0026d3e:	89 e5                	mov    %esp,%ebp
c0026d40:	83 ec 08             	sub    $0x8,%esp
c0026d43:	8b 55 08             	mov    0x8(%ebp),%edx
c0026d46:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026d49:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026d4d:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026d50:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0026d54:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0026d58:	ee                   	out    %al,(%dx)
}
c0026d59:	90                   	nop
c0026d5a:	c9                   	leave  
c0026d5b:	c3                   	ret    

c0026d5c <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c0026d5c:	55                   	push   %ebp
c0026d5d:	89 e5                	mov    %esp,%ebp
c0026d5f:	83 ec 08             	sub    $0x8,%esp
c0026d62:	8b 55 08             	mov    0x8(%ebp),%edx
c0026d65:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026d68:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026d6c:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026d70:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c0026d74:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0026d78:	66 ef                	out    %ax,(%dx)
}
c0026d7a:	90                   	nop
c0026d7b:	c9                   	leave  
c0026d7c:	c3                   	ret    

c0026d7d <shutdown>:
/* Shuts down the machine in the way configured by
   shutdown_configure().  If the shutdown type is SHUTDOWN_NONE
   (which is the default), returns without doing anything. */
void
shutdown (void)
{
c0026d7d:	55                   	push   %ebp
c0026d7e:	89 e5                	mov    %esp,%ebp
c0026d80:	83 ec 08             	sub    $0x8,%esp
  switch (how)
c0026d83:	a1 08 9b 03 c0       	mov    0xc0039b08,%eax
c0026d88:	83 f8 01             	cmp    $0x1,%eax
c0026d8b:	74 07                	je     c0026d94 <shutdown+0x17>
c0026d8d:	83 f8 02             	cmp    $0x2,%eax
c0026d90:	74 07                	je     c0026d99 <shutdown+0x1c>
      shutdown_reboot ();
      break;

    default:
      /* Nothing to do. */
      break;
c0026d92:	eb 0a                	jmp    c0026d9e <shutdown+0x21>
shutdown (void)
{
  switch (how)
    {
    case SHUTDOWN_POWER_OFF:
      shutdown_power_off ();
c0026d94:	e8 9d 00 00 00       	call   c0026e36 <shutdown_power_off>
      break;

    case SHUTDOWN_REBOOT:
      shutdown_reboot ();
c0026d99:	e8 11 00 00 00       	call   c0026daf <shutdown_reboot>

    default:
      /* Nothing to do. */
      break;
    }
}
c0026d9e:	90                   	nop
c0026d9f:	c9                   	leave  
c0026da0:	c3                   	ret    

c0026da1 <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c0026da1:	55                   	push   %ebp
c0026da2:	89 e5                	mov    %esp,%ebp
  how = type;
c0026da4:	8b 45 08             	mov    0x8(%ebp),%eax
c0026da7:	a3 08 9b 03 c0       	mov    %eax,0xc0039b08
}
c0026dac:	90                   	nop
c0026dad:	5d                   	pop    %ebp
c0026dae:	c3                   	ret    

c0026daf <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c0026daf:	55                   	push   %ebp
c0026db0:	89 e5                	mov    %esp,%ebp
c0026db2:	83 ec 18             	sub    $0x18,%esp
  printf ("Rebooting...\n");
c0026db5:	83 ec 0c             	sub    $0xc,%esp
c0026db8:	68 f0 06 03 c0       	push   $0xc00306f0
c0026dbd:	e8 69 4b 00 00       	call   c002b92b <puts>
c0026dc2:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c0026dc5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026dcc:	eb 2a                	jmp    c0026df8 <shutdown_reboot+0x49>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026dce:	83 ec 0c             	sub    $0xc,%esp
c0026dd1:	6a 64                	push   $0x64
c0026dd3:	e8 48 ff ff ff       	call   c0026d20 <inb>
c0026dd8:	83 c4 10             	add    $0x10,%esp
c0026ddb:	0f b6 c0             	movzbl %al,%eax
c0026dde:	83 e0 02             	and    $0x2,%eax
c0026de1:	85 c0                	test   %eax,%eax
c0026de3:	74 1e                	je     c0026e03 <shutdown_reboot+0x54>
            break;
          timer_udelay (2);
c0026de5:	83 ec 08             	sub    $0x8,%esp
c0026de8:	6a 00                	push   $0x0
c0026dea:	6a 02                	push   $0x2
c0026dec:	e8 7b d1 ff ff       	call   c0023f6c <timer_udelay>
c0026df1:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c0026df4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0026df8:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
c0026dff:	7e cd                	jle    c0026dce <shutdown_reboot+0x1f>
c0026e01:	eb 01                	jmp    c0026e04 <shutdown_reboot+0x55>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
            break;
c0026e03:	90                   	nop
          timer_udelay (2);
        }

      timer_udelay (50);
c0026e04:	83 ec 08             	sub    $0x8,%esp
c0026e07:	6a 00                	push   $0x0
c0026e09:	6a 32                	push   $0x32
c0026e0b:	e8 5c d1 ff ff       	call   c0023f6c <timer_udelay>
c0026e10:	83 c4 10             	add    $0x10,%esp

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
c0026e13:	83 ec 08             	sub    $0x8,%esp
c0026e16:	68 fe 00 00 00       	push   $0xfe
c0026e1b:	6a 64                	push   $0x64
c0026e1d:	e8 1b ff ff ff       	call   c0026d3d <outb>
c0026e22:	83 c4 10             	add    $0x10,%esp
      timer_udelay (50);
c0026e25:	83 ec 08             	sub    $0x8,%esp
c0026e28:	6a 00                	push   $0x0
c0026e2a:	6a 32                	push   $0x32
c0026e2c:	e8 3b d1 ff ff       	call   c0023f6c <timer_udelay>
c0026e31:	83 c4 10             	add    $0x10,%esp
    }
c0026e34:	eb 8f                	jmp    c0026dc5 <shutdown_reboot+0x16>

c0026e36 <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c0026e36:	55                   	push   %ebp
c0026e37:	89 e5                	mov    %esp,%ebp
c0026e39:	83 ec 18             	sub    $0x18,%esp
  const char s[] = "Shutdown";
c0026e3c:	c7 45 eb 53 68 75 74 	movl   $0x74756853,-0x15(%ebp)
c0026e43:	c7 45 ef 64 6f 77 6e 	movl   $0x6e776f64,-0x11(%ebp)
c0026e4a:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)

#ifdef FILESYS
  filesys_done ();
#endif

  print_stats ();
c0026e4e:	e8 80 00 00 00       	call   c0026ed3 <print_stats>

  printf ("Powering off...\n");
c0026e53:	83 ec 0c             	sub    $0xc,%esp
c0026e56:	68 fd 06 03 c0       	push   $0xc00306fd
c0026e5b:	e8 cb 4a 00 00       	call   c002b92b <puts>
c0026e60:	83 c4 10             	add    $0x10,%esp
  serial_flush ();
c0026e63:	e8 81 dd ff ff       	call   c0024be9 <serial_flush>

  /* ACPI power-off */
  outw (0xB004, 0x2000);
c0026e68:	83 ec 08             	sub    $0x8,%esp
c0026e6b:	68 00 20 00 00       	push   $0x2000
c0026e70:	68 04 b0 00 00       	push   $0xb004
c0026e75:	e8 e2 fe ff ff       	call   c0026d5c <outw>
c0026e7a:	83 c4 10             	add    $0x10,%esp

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c0026e7d:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0026e80:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0026e83:	eb 1e                	jmp    c0026ea3 <shutdown_power_off+0x6d>
    outb (0x8900, *p);
c0026e85:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026e88:	0f b6 00             	movzbl (%eax),%eax
c0026e8b:	0f b6 c0             	movzbl %al,%eax
c0026e8e:	83 ec 08             	sub    $0x8,%esp
c0026e91:	50                   	push   %eax
c0026e92:	68 00 89 00 00       	push   $0x8900
c0026e97:	e8 a1 fe ff ff       	call   c0026d3d <outb>
c0026e9c:	83 c4 10             	add    $0x10,%esp
  /* ACPI power-off */
  outw (0xB004, 0x2000);

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c0026e9f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0026ea3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026ea6:	0f b6 00             	movzbl (%eax),%eax
c0026ea9:	84 c0                	test   %al,%al
c0026eab:	75 d8                	jne    c0026e85 <shutdown_power_off+0x4f>
  /* For newer versions of qemu, you must run with -device
   * isa-debug-exit, which exits on any write to an IO port (by
   * default 0x501).  Qemu's exit code is double the value plus one,
   * so there is no way to exit cleanly.  We use 0x31 which should
   * result in a qemu exit code of 0x63.  */
  outb (0x501, 0x31);
c0026ead:	83 ec 08             	sub    $0x8,%esp
c0026eb0:	6a 31                	push   $0x31
c0026eb2:	68 01 05 00 00       	push   $0x501
c0026eb7:	e8 81 fe ff ff       	call   c0026d3d <outb>
c0026ebc:	83 c4 10             	add    $0x10,%esp

  /* This will power off a VMware VM if "gui.exitOnCLIHLT = TRUE"
     is set in its configuration file.  (The "pintos" script does
     that automatically.)  */
  asm volatile ("cli; hlt" : : : "memory");
c0026ebf:	fa                   	cli    
c0026ec0:	f4                   	hlt    

  /* None of those worked. */
  printf ("still running...\n");
c0026ec1:	83 ec 0c             	sub    $0xc,%esp
c0026ec4:	68 0d 07 03 c0       	push   $0xc003070d
c0026ec9:	e8 5d 4a 00 00       	call   c002b92b <puts>
c0026ece:	83 c4 10             	add    $0x10,%esp
  for (;;);
c0026ed1:	eb fe                	jmp    c0026ed1 <shutdown_power_off+0x9b>

c0026ed3 <print_stats>:
}

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
c0026ed3:	55                   	push   %ebp
c0026ed4:	89 e5                	mov    %esp,%ebp
c0026ed6:	83 ec 08             	sub    $0x8,%esp
  timer_print_stats ();
c0026ed9:	e8 e4 d0 ff ff       	call   c0023fc2 <timer_print_stats>
  thread_print_stats ();
c0026ede:	e8 58 9c ff ff       	call   c0020b3b <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
#endif
  console_print_stats ();
c0026ee3:	e8 0d 49 00 00       	call   c002b7f5 <console_print_stats>
  kbd_print_stats ();
c0026ee8:	e8 04 d4 ff ff       	call   c00242f1 <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
#endif
}
c0026eed:	90                   	nop
c0026eee:	c9                   	leave  
c0026eef:	c3                   	ret    

c0026ef0 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0026ef0:	55                   	push   %ebp
c0026ef1:	89 e5                	mov    %esp,%ebp
c0026ef3:	83 ec 14             	sub    $0x14,%esp
c0026ef6:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ef9:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026efd:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0026f01:	89 c2                	mov    %eax,%edx
c0026f03:	ec                   	in     (%dx),%al
c0026f04:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026f07:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0026f0b:	c9                   	leave  
c0026f0c:	c3                   	ret    

c0026f0d <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0026f0d:	55                   	push   %ebp
c0026f0e:	89 e5                	mov    %esp,%ebp
c0026f10:	83 ec 08             	sub    $0x8,%esp
c0026f13:	8b 55 08             	mov    0x8(%ebp),%edx
c0026f16:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f19:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026f1d:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026f20:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0026f24:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0026f28:	ee                   	out    %al,(%dx)
}
c0026f29:	90                   	nop
c0026f2a:	c9                   	leave  
c0026f2b:	c3                   	ret    

c0026f2c <speaker_on>:

/* Sets the PC speaker to emit a tone at the given FREQUENCY, in
   Hz. */
void
speaker_on (int frequency)
{
c0026f2c:	55                   	push   %ebp
c0026f2d:	89 e5                	mov    %esp,%ebp
c0026f2f:	83 ec 18             	sub    $0x18,%esp
  if (frequency >= 20 && frequency <= 20000)
c0026f32:	83 7d 08 13          	cmpl   $0x13,0x8(%ebp)
c0026f36:	7e 54                	jle    c0026f8c <speaker_on+0x60>
c0026f38:	81 7d 08 20 4e 00 00 	cmpl   $0x4e20,0x8(%ebp)
c0026f3f:	7f 4b                	jg     c0026f8c <speaker_on+0x60>
    {
      /* Set the timer channel that's connected to the speaker to
         output a square wave at the given FREQUENCY, then
         connect the timer channel output to the speaker. */
      enum intr_level old_level = intr_disable ();
c0026f41:	e8 86 a5 ff ff       	call   c00214cc <intr_disable>
c0026f46:	89 45 f4             	mov    %eax,-0xc(%ebp)
      pit_configure_channel (2, 3, frequency);
c0026f49:	83 ec 04             	sub    $0x4,%esp
c0026f4c:	ff 75 08             	pushl  0x8(%ebp)
c0026f4f:	6a 03                	push   $0x3
c0026f51:	6a 02                	push   $0x2
c0026f53:	e8 46 cc ff ff       	call   c0023b9e <pit_configure_channel>
c0026f58:	83 c4 10             	add    $0x10,%esp
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026f5b:	83 ec 0c             	sub    $0xc,%esp
c0026f5e:	6a 61                	push   $0x61
c0026f60:	e8 8b ff ff ff       	call   c0026ef0 <inb>
c0026f65:	83 c4 10             	add    $0x10,%esp
c0026f68:	83 c8 03             	or     $0x3,%eax
c0026f6b:	0f b6 c0             	movzbl %al,%eax
c0026f6e:	83 ec 08             	sub    $0x8,%esp
c0026f71:	50                   	push   %eax
c0026f72:	6a 61                	push   $0x61
c0026f74:	e8 94 ff ff ff       	call   c0026f0d <outb>
c0026f79:	83 c4 10             	add    $0x10,%esp
      intr_set_level (old_level);
c0026f7c:	83 ec 0c             	sub    $0xc,%esp
c0026f7f:	ff 75 f4             	pushl  -0xc(%ebp)
c0026f82:	e8 ed a4 ff ff       	call   c0021474 <intr_set_level>
c0026f87:	83 c4 10             	add    $0x10,%esp
   Hz. */
void
speaker_on (int frequency)
{
  if (frequency >= 20 && frequency <= 20000)
    {
c0026f8a:	eb 05                	jmp    c0026f91 <speaker_on+0x65>
    }
  else
    {
      /* FREQUENCY is outside the range of normal human hearing.
         Just turn off the speaker. */
      speaker_off ();
c0026f8c:	e8 03 00 00 00       	call   c0026f94 <speaker_off>
    }
}
c0026f91:	90                   	nop
c0026f92:	c9                   	leave  
c0026f93:	c3                   	ret    

c0026f94 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0026f94:	55                   	push   %ebp
c0026f95:	89 e5                	mov    %esp,%ebp
c0026f97:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0026f9a:	e8 2d a5 ff ff       	call   c00214cc <intr_disable>
c0026f9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
c0026fa2:	83 ec 0c             	sub    $0xc,%esp
c0026fa5:	6a 61                	push   $0x61
c0026fa7:	e8 44 ff ff ff       	call   c0026ef0 <inb>
c0026fac:	83 c4 10             	add    $0x10,%esp
c0026faf:	0f b6 c0             	movzbl %al,%eax
c0026fb2:	25 fc 00 00 00       	and    $0xfc,%eax
c0026fb7:	83 ec 08             	sub    $0x8,%esp
c0026fba:	50                   	push   %eax
c0026fbb:	6a 61                	push   $0x61
c0026fbd:	e8 4b ff ff ff       	call   c0026f0d <outb>
c0026fc2:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0026fc5:	83 ec 0c             	sub    $0xc,%esp
c0026fc8:	ff 75 f4             	pushl  -0xc(%ebp)
c0026fcb:	e8 a4 a4 ff ff       	call   c0021474 <intr_set_level>
c0026fd0:	83 c4 10             	add    $0x10,%esp
}
c0026fd3:	90                   	nop
c0026fd4:	c9                   	leave  
c0026fd5:	c3                   	ret    

c0026fd6 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0026fd6:	55                   	push   %ebp
c0026fd7:	89 e5                	mov    %esp,%ebp
c0026fd9:	83 ec 08             	sub    $0x8,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0026fdc:	e8 76 a4 ff ff       	call   c0021457 <intr_get_level>
c0026fe1:	83 f8 01             	cmp    $0x1,%eax
c0026fe4:	75 27                	jne    c002700d <speaker_beep+0x37>
    {
      speaker_on (440);
c0026fe6:	83 ec 0c             	sub    $0xc,%esp
c0026fe9:	68 b8 01 00 00       	push   $0x1b8
c0026fee:	e8 39 ff ff ff       	call   c0026f2c <speaker_on>
c0026ff3:	83 c4 10             	add    $0x10,%esp
      timer_msleep (250);
c0026ff6:	83 ec 08             	sub    $0x8,%esp
c0026ff9:	6a 00                	push   $0x0
c0026ffb:	68 fa 00 00 00       	push   $0xfa
c0027000:	e8 bb ce ff ff       	call   c0023ec0 <timer_msleep>
c0027005:	83 c4 10             	add    $0x10,%esp
      speaker_off ();
c0027008:	e8 87 ff ff ff       	call   c0026f94 <speaker_off>
    }
}
c002700d:	90                   	nop
c002700e:	c9                   	leave  
c002700f:	c3                   	ret    

c0027010 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0027010:	55                   	push   %ebp
c0027011:	89 e5                	mov    %esp,%ebp
c0027013:	83 ec 18             	sub    $0x18,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0027016:	8b 45 04             	mov    0x4(%ebp),%eax
c0027019:	83 ec 08             	sub    $0x8,%esp
c002701c:	50                   	push   %eax
c002701d:	68 20 07 03 c0       	push   $0xc0030720
c0027022:	e8 1e 03 00 00       	call   c0027345 <printf>
c0027027:	83 c4 10             	add    $0x10,%esp
  for (frame = __builtin_frame_address (1);
c002702a:	8b 45 00             	mov    0x0(%ebp),%eax
c002702d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0027030:	eb 21                	jmp    c0027053 <debug_backtrace+0x43>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0027032:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027035:	83 c0 04             	add    $0x4,%eax
c0027038:	8b 00                	mov    (%eax),%eax
c002703a:	83 ec 08             	sub    $0x8,%esp
c002703d:	50                   	push   %eax
c002703e:	68 2f 07 03 c0       	push   $0xc003072f
c0027043:	e8 fd 02 00 00       	call   c0027345 <printf>
c0027048:	83 c4 10             	add    $0x10,%esp
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
c002704b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002704e:	8b 00                	mov    (%eax),%eax
c0027050:	89 45 f4             	mov    %eax,-0xc(%ebp)
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0027053:	8b 45 f4             	mov    -0xc(%ebp),%eax
{
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
c0027056:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002705b:	76 09                	jbe    c0027066 <debug_backtrace+0x56>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c002705d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027060:	8b 00                	mov    (%eax),%eax
c0027062:	85 c0                	test   %eax,%eax
c0027064:	75 cc                	jne    c0027032 <debug_backtrace+0x22>
       frame = frame[0]) 
    printf (" %p", frame[1]);
  printf (".\n");
c0027066:	83 ec 0c             	sub    $0xc,%esp
c0027069:	68 33 07 03 c0       	push   $0xc0030733
c002706e:	e8 b8 48 00 00       	call   c002b92b <puts>
c0027073:	83 c4 10             	add    $0x10,%esp

  if (!explained) 
c0027076:	0f b6 05 0c 9b 03 c0 	movzbl 0xc0039b0c,%eax
c002707d:	83 f0 01             	xor    $0x1,%eax
c0027080:	84 c0                	test   %al,%al
c0027082:	74 17                	je     c002709b <debug_backtrace+0x8b>
    {
      explained = true;
c0027084:	c6 05 0c 9b 03 c0 01 	movb   $0x1,0xc0039b0c
      printf ("The `backtrace' program can make call stacks useful.\n"
c002708b:	83 ec 0c             	sub    $0xc,%esp
c002708e:	68 38 07 03 c0       	push   $0xc0030738
c0027093:	e8 93 48 00 00       	call   c002b92b <puts>
c0027098:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c002709b:	90                   	nop
c002709c:	c9                   	leave  
c002709d:	c3                   	ret    

c002709e <swap_byte>:
static bool inited;     

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
c002709e:	55                   	push   %ebp
c002709f:	89 e5                	mov    %esp,%ebp
c00270a1:	83 ec 10             	sub    $0x10,%esp
  uint8_t t = *a;
c00270a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00270a7:	0f b6 00             	movzbl (%eax),%eax
c00270aa:	88 45 ff             	mov    %al,-0x1(%ebp)
  *a = *b;
c00270ad:	8b 45 0c             	mov    0xc(%ebp),%eax
c00270b0:	0f b6 10             	movzbl (%eax),%edx
c00270b3:	8b 45 08             	mov    0x8(%ebp),%eax
c00270b6:	88 10                	mov    %dl,(%eax)
  *b = t;
c00270b8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00270bb:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c00270bf:	88 10                	mov    %dl,(%eax)
}
c00270c1:	90                   	nop
c00270c2:	c9                   	leave  
c00270c3:	c3                   	ret    

c00270c4 <random_init>:

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c00270c4:	55                   	push   %ebp
c00270c5:	89 e5                	mov    %esp,%ebp
c00270c7:	83 ec 10             	sub    $0x10,%esp
  uint8_t *seedp = (uint8_t *) &seed;
c00270ca:	8d 45 08             	lea    0x8(%ebp),%eax
c00270cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c00270d0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00270d7:	eb 13                	jmp    c00270ec <random_init+0x28>
    s[i] = i;
c00270d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00270dc:	89 c2                	mov    %eax,%edx
c00270de:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00270e1:	05 20 9b 03 c0       	add    $0xc0039b20,%eax
c00270e6:	88 10                	mov    %dl,(%eax)
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c00270e8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c00270ec:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c00270f3:	7e e4                	jle    c00270d9 <random_init+0x15>
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
c00270f5:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
c00270f9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0027100:	eb 40                	jmp    c0027142 <random_init+0x7e>
    {
      j += s[i] + seedp[i % sizeof seed];
c0027102:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027105:	05 20 9b 03 c0       	add    $0xc0039b20,%eax
c002710a:	0f b6 10             	movzbl (%eax),%edx
c002710d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027110:	83 e0 03             	and    $0x3,%eax
c0027113:	89 c1                	mov    %eax,%ecx
c0027115:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027118:	01 c8                	add    %ecx,%eax
c002711a:	0f b6 00             	movzbl (%eax),%eax
c002711d:	01 d0                	add    %edx,%eax
c002711f:	00 45 fb             	add    %al,-0x5(%ebp)
      swap_byte (s + i, s + j);
c0027122:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0027126:	8d 90 20 9b 03 c0    	lea    -0x3ffc64e0(%eax),%edx
c002712c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002712f:	05 20 9b 03 c0       	add    $0xc0039b20,%eax
c0027134:	52                   	push   %edx
c0027135:	50                   	push   %eax
c0027136:	e8 63 ff ff ff       	call   c002709e <swap_byte>
c002713b:	83 c4 08             	add    $0x8,%esp
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
c002713e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0027142:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0027149:	7e b7                	jle    c0027102 <random_init+0x3e>
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
    }

  s_i = s_j = 0;
c002714b:	c6 05 21 9c 03 c0 00 	movb   $0x0,0xc0039c21
c0027152:	0f b6 05 21 9c 03 c0 	movzbl 0xc0039c21,%eax
c0027159:	a2 20 9c 03 c0       	mov    %al,0xc0039c20
  inited = true;
c002715e:	c6 05 22 9c 03 c0 01 	movb   $0x1,0xc0039c22
}
c0027165:	90                   	nop
c0027166:	c9                   	leave  
c0027167:	c3                   	ret    

c0027168 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0027168:	55                   	push   %ebp
c0027169:	89 e5                	mov    %esp,%ebp
c002716b:	83 ec 10             	sub    $0x10,%esp
  uint8_t *buf;

  if (!inited)
c002716e:	0f b6 05 22 9c 03 c0 	movzbl 0xc0039c22,%eax
c0027175:	83 f0 01             	xor    $0x1,%eax
c0027178:	84 c0                	test   %al,%al
c002717a:	74 0a                	je     c0027186 <random_bytes+0x1e>
    random_init (0);
c002717c:	6a 00                	push   $0x0
c002717e:	e8 41 ff ff ff       	call   c00270c4 <random_init>
c0027183:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
c0027186:	8b 45 08             	mov    0x8(%ebp),%eax
c0027189:	89 45 fc             	mov    %eax,-0x4(%ebp)
c002718c:	e9 92 00 00 00       	jmp    c0027223 <random_bytes+0xbb>
    {
      uint8_t s_k;
      
      s_i++;
c0027191:	0f b6 05 20 9c 03 c0 	movzbl 0xc0039c20,%eax
c0027198:	83 c0 01             	add    $0x1,%eax
c002719b:	a2 20 9c 03 c0       	mov    %al,0xc0039c20
      s_j += s[s_i];
c00271a0:	0f b6 05 20 9c 03 c0 	movzbl 0xc0039c20,%eax
c00271a7:	0f b6 c0             	movzbl %al,%eax
c00271aa:	0f b6 90 20 9b 03 c0 	movzbl -0x3ffc64e0(%eax),%edx
c00271b1:	0f b6 05 21 9c 03 c0 	movzbl 0xc0039c21,%eax
c00271b8:	01 d0                	add    %edx,%eax
c00271ba:	a2 21 9c 03 c0       	mov    %al,0xc0039c21
      swap_byte (s + s_i, s + s_j);
c00271bf:	0f b6 05 21 9c 03 c0 	movzbl 0xc0039c21,%eax
c00271c6:	0f b6 c0             	movzbl %al,%eax
c00271c9:	8d 90 20 9b 03 c0    	lea    -0x3ffc64e0(%eax),%edx
c00271cf:	0f b6 05 20 9c 03 c0 	movzbl 0xc0039c20,%eax
c00271d6:	0f b6 c0             	movzbl %al,%eax
c00271d9:	05 20 9b 03 c0       	add    $0xc0039b20,%eax
c00271de:	52                   	push   %edx
c00271df:	50                   	push   %eax
c00271e0:	e8 b9 fe ff ff       	call   c002709e <swap_byte>
c00271e5:	83 c4 08             	add    $0x8,%esp

      s_k = s[s_i] + s[s_j];
c00271e8:	0f b6 05 20 9c 03 c0 	movzbl 0xc0039c20,%eax
c00271ef:	0f b6 c0             	movzbl %al,%eax
c00271f2:	0f b6 90 20 9b 03 c0 	movzbl -0x3ffc64e0(%eax),%edx
c00271f9:	0f b6 05 21 9c 03 c0 	movzbl 0xc0039c21,%eax
c0027200:	0f b6 c0             	movzbl %al,%eax
c0027203:	0f b6 80 20 9b 03 c0 	movzbl -0x3ffc64e0(%eax),%eax
c002720a:	01 d0                	add    %edx,%eax
c002720c:	88 45 fb             	mov    %al,-0x5(%ebp)
      *buf = s[s_k];
c002720f:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0027213:	0f b6 90 20 9b 03 c0 	movzbl -0x3ffc64e0(%eax),%edx
c002721a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002721d:	88 10                	mov    %dl,(%eax)
  uint8_t *buf;

  if (!inited)
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c002721f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0027223:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027226:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027229:	89 55 0c             	mov    %edx,0xc(%ebp)
c002722c:	85 c0                	test   %eax,%eax
c002722e:	0f 85 5d ff ff ff    	jne    c0027191 <random_bytes+0x29>
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
    }
}
c0027234:	90                   	nop
c0027235:	c9                   	leave  
c0027236:	c3                   	ret    

c0027237 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c0027237:	55                   	push   %ebp
c0027238:	89 e5                	mov    %esp,%ebp
c002723a:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c002723d:	6a 04                	push   $0x4
c002723f:	8d 45 fc             	lea    -0x4(%ebp),%eax
c0027242:	50                   	push   %eax
c0027243:	e8 20 ff ff ff       	call   c0027168 <random_bytes>
c0027248:	83 c4 08             	add    $0x8,%esp
  return ul;
c002724b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002724e:	c9                   	leave  
c002724f:	c3                   	ret    

c0027250 <isdigit>:
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
static inline int isalpha (int c) { return islower (c) || isupper (c); }
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027250:	55                   	push   %ebp
c0027251:	89 e5                	mov    %esp,%ebp
c0027253:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0027257:	7e 0d                	jle    c0027266 <isdigit+0x16>
c0027259:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c002725d:	7f 07                	jg     c0027266 <isdigit+0x16>
c002725f:	b8 01 00 00 00       	mov    $0x1,%eax
c0027264:	eb 05                	jmp    c002726b <isdigit+0x1b>
c0027266:	b8 00 00 00 00       	mov    $0x0,%eax
c002726b:	5d                   	pop    %ebp
c002726c:	c3                   	ret    

c002726d <isprint>:
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
}
static inline int isblank (int c) { return c == ' ' || c == '\t'; }
static inline int isgraph (int c) { return c > 32 && c < 127; }
static inline int isprint (int c) { return c >= 32 && c < 127; }
c002726d:	55                   	push   %ebp
c002726e:	89 e5                	mov    %esp,%ebp
c0027270:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0027274:	7e 0d                	jle    c0027283 <isprint+0x16>
c0027276:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c002727a:	7f 07                	jg     c0027283 <isprint+0x16>
c002727c:	b8 01 00 00 00       	mov    $0x1,%eax
c0027281:	eb 05                	jmp    c0027288 <isprint+0x1b>
c0027283:	b8 00 00 00 00       	mov    $0x0,%eax
c0027288:	5d                   	pop    %ebp
c0027289:	c3                   	ret    

c002728a <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
c002728a:	55                   	push   %ebp
c002728b:	89 e5                	mov    %esp,%ebp
c002728d:	83 ec 18             	sub    $0x18,%esp
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
c0027290:	8b 45 08             	mov    0x8(%ebp),%eax
c0027293:	89 45 ec             	mov    %eax,-0x14(%ebp)
  aux.length = 0;
c0027296:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c002729d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00272a1:	74 08                	je     c00272ab <vsnprintf+0x21>
c00272a3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272a6:	83 e8 01             	sub    $0x1,%eax
c00272a9:	eb 05                	jmp    c00272b0 <vsnprintf+0x26>
c00272ab:	b8 00 00 00 00       	mov    $0x0,%eax
c00272b0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c00272b3:	8d 45 ec             	lea    -0x14(%ebp),%eax
c00272b6:	50                   	push   %eax
c00272b7:	68 db 72 02 c0       	push   $0xc00272db
c00272bc:	ff 75 14             	pushl  0x14(%ebp)
c00272bf:	ff 75 10             	pushl  0x10(%ebp)
c00272c2:	e8 a4 00 00 00       	call   c002736b <__vprintf>
c00272c7:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
c00272ca:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00272ce:	74 06                	je     c00272d6 <vsnprintf+0x4c>
    *aux.p = '\0';
c00272d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00272d3:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
c00272d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c00272d9:	c9                   	leave  
c00272da:	c3                   	ret    

c00272db <vsnprintf_helper>:

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c00272db:	55                   	push   %ebp
c00272dc:	89 e5                	mov    %esp,%ebp
c00272de:	83 ec 14             	sub    $0x14,%esp
c00272e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00272e4:	88 45 ec             	mov    %al,-0x14(%ebp)
  struct vsnprintf_aux *aux = aux_;
c00272e7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272ea:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (aux->length++ < aux->max_length)
c00272ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00272f0:	8b 40 04             	mov    0x4(%eax),%eax
c00272f3:	8d 48 01             	lea    0x1(%eax),%ecx
c00272f6:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00272f9:	89 4a 04             	mov    %ecx,0x4(%edx)
c00272fc:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00272ff:	8b 52 08             	mov    0x8(%edx),%edx
c0027302:	39 d0                	cmp    %edx,%eax
c0027304:	7d 13                	jge    c0027319 <vsnprintf_helper+0x3e>
    *aux->p++ = ch;
c0027306:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027309:	8b 00                	mov    (%eax),%eax
c002730b:	8d 48 01             	lea    0x1(%eax),%ecx
c002730e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027311:	89 0a                	mov    %ecx,(%edx)
c0027313:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
c0027317:	88 10                	mov    %dl,(%eax)
}
c0027319:	90                   	nop
c002731a:	c9                   	leave  
c002731b:	c3                   	ret    

c002731c <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
c002731c:	55                   	push   %ebp
c002731d:	89 e5                	mov    %esp,%ebp
c002731f:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c0027322:	8d 45 14             	lea    0x14(%ebp),%eax
c0027325:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vsnprintf (buffer, buf_size, format, args);
c0027328:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002732b:	50                   	push   %eax
c002732c:	ff 75 10             	pushl  0x10(%ebp)
c002732f:	ff 75 0c             	pushl  0xc(%ebp)
c0027332:	ff 75 08             	pushl  0x8(%ebp)
c0027335:	e8 50 ff ff ff       	call   c002728a <vsnprintf>
c002733a:	83 c4 10             	add    $0x10,%esp
c002733d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c0027340:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0027343:	c9                   	leave  
c0027344:	c3                   	ret    

c0027345 <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
c0027345:	55                   	push   %ebp
c0027346:	89 e5                	mov    %esp,%ebp
c0027348:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c002734b:	8d 45 0c             	lea    0xc(%ebp),%eax
c002734e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vprintf (format, args);
c0027351:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027354:	83 ec 08             	sub    $0x8,%esp
c0027357:	50                   	push   %eax
c0027358:	ff 75 08             	pushl  0x8(%ebp)
c002735b:	e8 98 45 00 00       	call   c002b8f8 <vprintf>
c0027360:	83 c4 10             	add    $0x10,%esp
c0027363:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c0027366:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0027369:	c9                   	leave  
c002736a:	c3                   	ret    

c002736b <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
c002736b:	55                   	push   %ebp
c002736c:	89 e5                	mov    %esp,%ebp
c002736e:	57                   	push   %edi
c002736f:	56                   	push   %esi
c0027370:	53                   	push   %ebx
c0027371:	83 ec 3c             	sub    $0x3c,%esp
  for (; *format != '\0'; format++)
c0027374:	e9 45 04 00 00       	jmp    c00277be <__vprintf+0x453>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
c0027379:	8b 45 08             	mov    0x8(%ebp),%eax
c002737c:	0f b6 00             	movzbl (%eax),%eax
c002737f:	3c 25                	cmp    $0x25,%al
c0027381:	74 1d                	je     c00273a0 <__vprintf+0x35>
        {
          output (*format, aux);
c0027383:	8b 45 08             	mov    0x8(%ebp),%eax
c0027386:	0f b6 00             	movzbl (%eax),%eax
c0027389:	0f be c0             	movsbl %al,%eax
c002738c:	83 ec 08             	sub    $0x8,%esp
c002738f:	ff 75 14             	pushl  0x14(%ebp)
c0027392:	50                   	push   %eax
c0027393:	8b 45 10             	mov    0x10(%ebp),%eax
c0027396:	ff d0                	call   *%eax
c0027398:	83 c4 10             	add    $0x10,%esp
          continue;
c002739b:	e9 1a 04 00 00       	jmp    c00277ba <__vprintf+0x44f>
        }
      format++;
c00273a0:	83 45 08 01          	addl   $0x1,0x8(%ebp)

      /* %% => %. */
      if (*format == '%') 
c00273a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00273a7:	0f b6 00             	movzbl (%eax),%eax
c00273aa:	3c 25                	cmp    $0x25,%al
c00273ac:	75 15                	jne    c00273c3 <__vprintf+0x58>
        {
          output ('%', aux);
c00273ae:	83 ec 08             	sub    $0x8,%esp
c00273b1:	ff 75 14             	pushl  0x14(%ebp)
c00273b4:	6a 25                	push   $0x25
c00273b6:	8b 45 10             	mov    0x10(%ebp),%eax
c00273b9:	ff d0                	call   *%eax
c00273bb:	83 c4 10             	add    $0x10,%esp
          continue;
c00273be:	e9 f7 03 00 00       	jmp    c00277ba <__vprintf+0x44f>
        }

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);
c00273c3:	83 ec 04             	sub    $0x4,%esp
c00273c6:	8d 45 0c             	lea    0xc(%ebp),%eax
c00273c9:	50                   	push   %eax
c00273ca:	8d 45 bc             	lea    -0x44(%ebp),%eax
c00273cd:	50                   	push   %eax
c00273ce:	ff 75 08             	pushl  0x8(%ebp)
c00273d1:	e8 ff 03 00 00       	call   c00277d5 <parse_conversion>
c00273d6:	83 c4 10             	add    $0x10,%esp
c00273d9:	89 45 08             	mov    %eax,0x8(%ebp)

      /* Do conversion. */
      switch (*format) 
c00273dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00273df:	0f b6 00             	movzbl (%eax),%eax
c00273e2:	0f be c0             	movsbl %al,%eax
c00273e5:	83 e8 45             	sub    $0x45,%eax
c00273e8:	83 f8 33             	cmp    $0x33,%eax
c00273eb:	0f 87 ab 03 00 00    	ja     c002779c <__vprintf+0x431>
c00273f1:	8b 04 85 bc 08 03 c0 	mov    -0x3ffcf744(,%eax,4),%eax
c00273f8:	ff e0                	jmp    *%eax
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
c00273fa:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00273fd:	83 f8 08             	cmp    $0x8,%eax
c0027400:	0f 87 dd 00 00 00    	ja     c00274e3 <__vprintf+0x178>
c0027406:	8b 04 85 8c 09 03 c0 	mov    -0x3ffcf674(,%eax,4),%eax
c002740d:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
c002740f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027412:	8d 50 04             	lea    0x4(%eax),%edx
c0027415:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027418:	8b 00                	mov    (%eax),%eax
c002741a:	0f be c0             	movsbl %al,%eax
c002741d:	99                   	cltd   
c002741e:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027421:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0027424:	e9 d4 00 00 00       	jmp    c00274fd <__vprintf+0x192>
              case SHORT:
                value = (short) va_arg (args, int);
c0027429:	8b 45 0c             	mov    0xc(%ebp),%eax
c002742c:	8d 50 04             	lea    0x4(%eax),%edx
c002742f:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027432:	8b 00                	mov    (%eax),%eax
c0027434:	98                   	cwtl   
c0027435:	99                   	cltd   
c0027436:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027439:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c002743c:	e9 bc 00 00 00       	jmp    c00274fd <__vprintf+0x192>
              case INT:
                value = va_arg (args, int);
c0027441:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027444:	8d 50 04             	lea    0x4(%eax),%edx
c0027447:	89 55 0c             	mov    %edx,0xc(%ebp)
c002744a:	8b 00                	mov    (%eax),%eax
c002744c:	99                   	cltd   
c002744d:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027450:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0027453:	e9 a5 00 00 00       	jmp    c00274fd <__vprintf+0x192>
              case INTMAX:
                value = va_arg (args, intmax_t);
c0027458:	8b 45 0c             	mov    0xc(%ebp),%eax
c002745b:	8d 50 08             	lea    0x8(%eax),%edx
c002745e:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027461:	8b 50 04             	mov    0x4(%eax),%edx
c0027464:	8b 00                	mov    (%eax),%eax
c0027466:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027469:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c002746c:	e9 8c 00 00 00       	jmp    c00274fd <__vprintf+0x192>
              case LONG:
                value = va_arg (args, long);
c0027471:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027474:	8d 50 04             	lea    0x4(%eax),%edx
c0027477:	89 55 0c             	mov    %edx,0xc(%ebp)
c002747a:	8b 00                	mov    (%eax),%eax
c002747c:	99                   	cltd   
c002747d:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027480:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0027483:	eb 78                	jmp    c00274fd <__vprintf+0x192>
              case LONGLONG:
                value = va_arg (args, long long);
c0027485:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027488:	8d 50 08             	lea    0x8(%eax),%edx
c002748b:	89 55 0c             	mov    %edx,0xc(%ebp)
c002748e:	8b 50 04             	mov    0x4(%eax),%edx
c0027491:	8b 00                	mov    (%eax),%eax
c0027493:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027496:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0027499:	eb 62                	jmp    c00274fd <__vprintf+0x192>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c002749b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002749e:	8d 50 04             	lea    0x4(%eax),%edx
c00274a1:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274a4:	8b 00                	mov    (%eax),%eax
c00274a6:	99                   	cltd   
c00274a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00274aa:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c00274ad:	eb 4e                	jmp    c00274fd <__vprintf+0x192>
              case SIZET:
                value = va_arg (args, size_t);
c00274af:	8b 45 0c             	mov    0xc(%ebp),%eax
c00274b2:	8d 50 04             	lea    0x4(%eax),%edx
c00274b5:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274b8:	8b 00                	mov    (%eax),%eax
c00274ba:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00274bd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                if (value > SIZE_MAX / 2)
c00274c4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00274c8:	78 32                	js     c00274fc <__vprintf+0x191>
c00274ca:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00274ce:	7f 09                	jg     c00274d9 <__vprintf+0x16e>
c00274d0:	81 7d e0 ff ff ff 7f 	cmpl   $0x7fffffff,-0x20(%ebp)
c00274d7:	76 23                	jbe    c00274fc <__vprintf+0x191>
                  value = value - SIZE_MAX - 1;
c00274d9:	83 45 e0 00          	addl   $0x0,-0x20(%ebp)
c00274dd:	83 55 e4 ff          	adcl   $0xffffffff,-0x1c(%ebp)
                break;
c00274e1:	eb 19                	jmp    c00274fc <__vprintf+0x191>
              default:
                NOT_REACHED ();
c00274e3:	68 54 08 03 c0       	push   $0xc0030854
c00274e8:	68 88 0a 03 c0       	push   $0xc0030a88
c00274ed:	68 dc 00 00 00       	push   $0xdc
c00274f2:	68 76 08 03 c0       	push   $0xc0030876
c00274f7:	e8 7c 22 00 00       	call   c0029778 <debug_panic>
                break;
              case SIZET:
                value = va_arg (args, size_t);
                if (value > SIZE_MAX / 2)
                  value = value - SIZE_MAX - 1;
                break;
c00274fc:	90                   	nop
              default:
                NOT_REACHED ();
              }

            format_integer (value < 0 ? -value : value,
c00274fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027500:	c1 e8 1f             	shr    $0x1f,%eax
c0027503:	0f b6 c8             	movzbl %al,%ecx
c0027506:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027509:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002750c:	89 d2                	mov    %edx,%edx
c002750e:	c1 fa 1f             	sar    $0x1f,%edx
c0027511:	89 d0                	mov    %edx,%eax
c0027513:	89 c7                	mov    %eax,%edi
c0027515:	33 7d e0             	xor    -0x20(%ebp),%edi
c0027518:	89 fb                	mov    %edi,%ebx
c002751a:	89 d7                	mov    %edx,%edi
c002751c:	33 7d e4             	xor    -0x1c(%ebp),%edi
c002751f:	89 fe                	mov    %edi,%esi
c0027521:	29 c3                	sub    %eax,%ebx
c0027523:	19 d6                	sbb    %edx,%esi
c0027525:	89 d8                	mov    %ebx,%eax
c0027527:	89 f2                	mov    %esi,%edx
c0027529:	ff 75 14             	pushl  0x14(%ebp)
c002752c:	ff 75 10             	pushl  0x10(%ebp)
c002752f:	8d 7d bc             	lea    -0x44(%ebp),%edi
c0027532:	57                   	push   %edi
c0027533:	68 e0 07 03 c0       	push   $0xc00307e0
c0027538:	51                   	push   %ecx
c0027539:	6a 01                	push   $0x1
c002753b:	52                   	push   %edx
c002753c:	50                   	push   %eax
c002753d:	e8 5b 05 00 00       	call   c0027a9d <format_integer>
c0027542:	83 c4 20             	add    $0x20,%esp
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
c0027545:	e9 70 02 00 00       	jmp    c00277ba <__vprintf+0x44f>
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
c002754a:	8b 45 c8             	mov    -0x38(%ebp),%eax
c002754d:	83 f8 08             	cmp    $0x8,%eax
c0027550:	0f 87 d3 00 00 00    	ja     c0027629 <__vprintf+0x2be>
c0027556:	8b 04 85 b0 09 03 c0 	mov    -0x3ffcf650(,%eax,4),%eax
c002755d:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c002755f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027562:	8d 50 04             	lea    0x4(%eax),%edx
c0027565:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027568:	8b 00                	mov    (%eax),%eax
c002756a:	0f b6 c0             	movzbl %al,%eax
c002756d:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027570:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027577:	e9 c6 00 00 00       	jmp    c0027642 <__vprintf+0x2d7>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c002757c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002757f:	8d 50 04             	lea    0x4(%eax),%edx
c0027582:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027585:	8b 00                	mov    (%eax),%eax
c0027587:	0f b7 c0             	movzwl %ax,%eax
c002758a:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002758d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027594:	e9 a9 00 00 00       	jmp    c0027642 <__vprintf+0x2d7>
              case INT:
                value = va_arg (args, unsigned);
c0027599:	8b 45 0c             	mov    0xc(%ebp),%eax
c002759c:	8d 50 04             	lea    0x4(%eax),%edx
c002759f:	89 55 0c             	mov    %edx,0xc(%ebp)
c00275a2:	8b 00                	mov    (%eax),%eax
c00275a4:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00275a7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c00275ae:	e9 8f 00 00 00       	jmp    c0027642 <__vprintf+0x2d7>
              case INTMAX:
                value = va_arg (args, uintmax_t);
c00275b3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275b6:	8d 50 08             	lea    0x8(%eax),%edx
c00275b9:	89 55 0c             	mov    %edx,0xc(%ebp)
c00275bc:	8b 50 04             	mov    0x4(%eax),%edx
c00275bf:	8b 00                	mov    (%eax),%eax
c00275c1:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00275c4:	89 55 dc             	mov    %edx,-0x24(%ebp)
                break;
c00275c7:	eb 79                	jmp    c0027642 <__vprintf+0x2d7>
              case LONG:
                value = va_arg (args, unsigned long);
c00275c9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275cc:	8d 50 04             	lea    0x4(%eax),%edx
c00275cf:	89 55 0c             	mov    %edx,0xc(%ebp)
c00275d2:	8b 00                	mov    (%eax),%eax
c00275d4:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00275d7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c00275de:	eb 62                	jmp    c0027642 <__vprintf+0x2d7>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c00275e0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275e3:	8d 50 08             	lea    0x8(%eax),%edx
c00275e6:	89 55 0c             	mov    %edx,0xc(%ebp)
c00275e9:	8b 50 04             	mov    0x4(%eax),%edx
c00275ec:	8b 00                	mov    (%eax),%eax
c00275ee:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00275f1:	89 55 dc             	mov    %edx,-0x24(%ebp)
                break;
c00275f4:	eb 4c                	jmp    c0027642 <__vprintf+0x2d7>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c00275f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275f9:	8d 50 04             	lea    0x4(%eax),%edx
c00275fc:	89 55 0c             	mov    %edx,0xc(%ebp)
c00275ff:	8b 00                	mov    (%eax),%eax
c0027601:	99                   	cltd   
c0027602:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027605:	89 55 dc             	mov    %edx,-0x24(%ebp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c0027608:	83 65 d8 ff          	andl   $0xffffffff,-0x28(%ebp)
c002760c:	83 65 dc 00          	andl   $0x0,-0x24(%ebp)
#endif
                break;
c0027610:	eb 30                	jmp    c0027642 <__vprintf+0x2d7>
              case SIZET:
                value = va_arg (args, size_t);
c0027612:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027615:	8d 50 04             	lea    0x4(%eax),%edx
c0027618:	89 55 0c             	mov    %edx,0xc(%ebp)
c002761b:	8b 00                	mov    (%eax),%eax
c002761d:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027620:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027627:	eb 19                	jmp    c0027642 <__vprintf+0x2d7>
              default:
                NOT_REACHED ();
c0027629:	68 54 08 03 c0       	push   $0xc0030854
c002762e:	68 88 0a 03 c0       	push   $0xc0030a88
c0027633:	68 0b 01 00 00       	push   $0x10b
c0027638:	68 76 08 03 c0       	push   $0xc0030876
c002763d:	e8 36 21 00 00       	call   c0029778 <debug_panic>
              }

            switch (*format) 
c0027642:	8b 45 08             	mov    0x8(%ebp),%eax
c0027645:	0f b6 00             	movzbl (%eax),%eax
c0027648:	0f be c0             	movsbl %al,%eax
c002764b:	83 f8 6f             	cmp    $0x6f,%eax
c002764e:	74 18                	je     c0027668 <__vprintf+0x2fd>
c0027650:	83 f8 6f             	cmp    $0x6f,%eax
c0027653:	7f 07                	jg     c002765c <__vprintf+0x2f1>
c0027655:	83 f8 58             	cmp    $0x58,%eax
c0027658:	74 29                	je     c0027683 <__vprintf+0x318>
c002765a:	eb 30                	jmp    c002768c <__vprintf+0x321>
c002765c:	83 f8 75             	cmp    $0x75,%eax
c002765f:	74 10                	je     c0027671 <__vprintf+0x306>
c0027661:	83 f8 78             	cmp    $0x78,%eax
c0027664:	74 14                	je     c002767a <__vprintf+0x30f>
c0027666:	eb 24                	jmp    c002768c <__vprintf+0x321>
              {
              case 'o': b = &base_o; break;
c0027668:	c7 45 d4 fc 07 03 c0 	movl   $0xc00307fc,-0x2c(%ebp)
c002766f:	eb 34                	jmp    c00276a5 <__vprintf+0x33a>
              case 'u': b = &base_d; break;
c0027671:	c7 45 d4 e0 07 03 c0 	movl   $0xc00307e0,-0x2c(%ebp)
c0027678:	eb 2b                	jmp    c00276a5 <__vprintf+0x33a>
              case 'x': b = &base_x; break;
c002767a:	c7 45 d4 20 08 03 c0 	movl   $0xc0030820,-0x2c(%ebp)
c0027681:	eb 22                	jmp    c00276a5 <__vprintf+0x33a>
              case 'X': b = &base_X; break;
c0027683:	c7 45 d4 44 08 03 c0 	movl   $0xc0030844,-0x2c(%ebp)
c002768a:	eb 19                	jmp    c00276a5 <__vprintf+0x33a>
              default: NOT_REACHED ();
c002768c:	68 54 08 03 c0       	push   $0xc0030854
c0027691:	68 88 0a 03 c0       	push   $0xc0030a88
c0027696:	68 14 01 00 00       	push   $0x114
c002769b:	68 76 08 03 c0       	push   $0xc0030876
c00276a0:	e8 d3 20 00 00       	call   c0029778 <debug_panic>
              }

            format_integer (value, false, false, b, &c, output, aux);
c00276a5:	ff 75 14             	pushl  0x14(%ebp)
c00276a8:	ff 75 10             	pushl  0x10(%ebp)
c00276ab:	8d 45 bc             	lea    -0x44(%ebp),%eax
c00276ae:	50                   	push   %eax
c00276af:	ff 75 d4             	pushl  -0x2c(%ebp)
c00276b2:	6a 00                	push   $0x0
c00276b4:	6a 00                	push   $0x0
c00276b6:	ff 75 dc             	pushl  -0x24(%ebp)
c00276b9:	ff 75 d8             	pushl  -0x28(%ebp)
c00276bc:	e8 dc 03 00 00       	call   c0027a9d <format_integer>
c00276c1:	83 c4 20             	add    $0x20,%esp
          }
          break;
c00276c4:	e9 f1 00 00 00       	jmp    c00277ba <__vprintf+0x44f>

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c00276c9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276cc:	8d 50 04             	lea    0x4(%eax),%edx
c00276cf:	89 55 0c             	mov    %edx,0xc(%ebp)
c00276d2:	8b 00                	mov    (%eax),%eax
c00276d4:	88 45 bb             	mov    %al,-0x45(%ebp)
            format_string (&ch, 1, &c, output, aux);
c00276d7:	83 ec 0c             	sub    $0xc,%esp
c00276da:	ff 75 14             	pushl  0x14(%ebp)
c00276dd:	ff 75 10             	pushl  0x10(%ebp)
c00276e0:	8d 45 bc             	lea    -0x44(%ebp),%eax
c00276e3:	50                   	push   %eax
c00276e4:	6a 01                	push   $0x1
c00276e6:	8d 45 bb             	lea    -0x45(%ebp),%eax
c00276e9:	50                   	push   %eax
c00276ea:	e8 d0 06 00 00       	call   c0027dbf <format_string>
c00276ef:	83 c4 20             	add    $0x20,%esp
          }
          break;
c00276f2:	e9 c3 00 00 00       	jmp    c00277ba <__vprintf+0x44f>

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c00276f7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276fa:	8d 50 04             	lea    0x4(%eax),%edx
c00276fd:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027700:	8b 00                	mov    (%eax),%eax
c0027702:	89 45 d0             	mov    %eax,-0x30(%ebp)
            if (s == NULL)
c0027705:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
c0027709:	75 07                	jne    c0027712 <__vprintf+0x3a7>
              s = "(null)";
c002770b:	c7 45 d0 88 08 03 c0 	movl   $0xc0030888,-0x30(%ebp)

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0027712:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0027715:	83 ec 08             	sub    $0x8,%esp
c0027718:	50                   	push   %eax
c0027719:	ff 75 d0             	pushl  -0x30(%ebp)
c002771c:	e8 f3 14 00 00       	call   c0028c14 <strnlen>
c0027721:	83 c4 10             	add    $0x10,%esp
c0027724:	89 c2                	mov    %eax,%edx
c0027726:	83 ec 0c             	sub    $0xc,%esp
c0027729:	ff 75 14             	pushl  0x14(%ebp)
c002772c:	ff 75 10             	pushl  0x10(%ebp)
c002772f:	8d 45 bc             	lea    -0x44(%ebp),%eax
c0027732:	50                   	push   %eax
c0027733:	52                   	push   %edx
c0027734:	ff 75 d0             	pushl  -0x30(%ebp)
c0027737:	e8 83 06 00 00       	call   c0027dbf <format_string>
c002773c:	83 c4 20             	add    $0x20,%esp
          }
          break;
c002773f:	eb 79                	jmp    c00277ba <__vprintf+0x44f>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c0027741:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027744:	8d 50 04             	lea    0x4(%eax),%edx
c0027747:	89 55 0c             	mov    %edx,0xc(%ebp)
c002774a:	8b 00                	mov    (%eax),%eax
c002774c:	89 45 cc             	mov    %eax,-0x34(%ebp)

            c.flags = POUND;
c002774f:	c7 45 bc 08 00 00 00 	movl   $0x8,-0x44(%ebp)
            format_integer ((uintptr_t) p, false, false,
c0027756:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0027759:	ba 00 00 00 00       	mov    $0x0,%edx
c002775e:	ff 75 14             	pushl  0x14(%ebp)
c0027761:	ff 75 10             	pushl  0x10(%ebp)
c0027764:	8d 4d bc             	lea    -0x44(%ebp),%ecx
c0027767:	51                   	push   %ecx
c0027768:	68 20 08 03 c0       	push   $0xc0030820
c002776d:	6a 00                	push   $0x0
c002776f:	6a 00                	push   $0x0
c0027771:	52                   	push   %edx
c0027772:	50                   	push   %eax
c0027773:	e8 25 03 00 00       	call   c0027a9d <format_integer>
c0027778:	83 c4 20             	add    $0x20,%esp
                            &base_x, &c, output, aux);
          }
          break;
c002777b:	eb 3d                	jmp    c00277ba <__vprintf+0x44f>
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c002777d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027780:	0f b6 00             	movzbl (%eax),%eax
c0027783:	0f be c0             	movsbl %al,%eax
c0027786:	50                   	push   %eax
c0027787:	ff 75 14             	pushl  0x14(%ebp)
c002778a:	ff 75 10             	pushl  0x10(%ebp)
c002778d:	68 8f 08 03 c0       	push   $0xc003088f
c0027792:	e8 c5 06 00 00       	call   c0027e5c <__printf>
c0027797:	83 c4 10             	add    $0x10,%esp
          break;
c002779a:	eb 1e                	jmp    c00277ba <__vprintf+0x44f>

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c002779c:	8b 45 08             	mov    0x8(%ebp),%eax
c002779f:	0f b6 00             	movzbl (%eax),%eax
c00277a2:	0f be c0             	movsbl %al,%eax
c00277a5:	50                   	push   %eax
c00277a6:	ff 75 14             	pushl  0x14(%ebp)
c00277a9:	ff 75 10             	pushl  0x10(%ebp)
c00277ac:	68 a5 08 03 c0       	push   $0xc00308a5
c00277b1:	e8 a6 06 00 00       	call   c0027e5c <__printf>
c00277b6:	83 c4 10             	add    $0x10,%esp
          break;
c00277b9:	90                   	nop

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
  for (; *format != '\0'; format++)
c00277ba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c00277be:	8b 45 08             	mov    0x8(%ebp),%eax
c00277c1:	0f b6 00             	movzbl (%eax),%eax
c00277c4:	84 c0                	test   %al,%al
c00277c6:	0f 85 ad fb ff ff    	jne    c0027379 <__vprintf+0xe>
        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
          break;
        }
    }
}
c00277cc:	90                   	nop
c00277cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00277d0:	5b                   	pop    %ebx
c00277d1:	5e                   	pop    %esi
c00277d2:	5f                   	pop    %edi
c00277d3:	5d                   	pop    %ebp
c00277d4:	c3                   	ret    

c00277d5 <parse_conversion>:
   that indicates the conversion (e.g. the `d' in `%d').  Uses
   *ARGS for `*' field widths and precisions. */
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
c00277d5:	55                   	push   %ebp
c00277d6:	89 e5                	mov    %esp,%ebp
  /* Parse flag characters. */
  c->flags = 0;
c00277d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (;;) 
    {
      switch (*format++) 
c00277e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00277e4:	8d 50 01             	lea    0x1(%eax),%edx
c00277e7:	89 55 08             	mov    %edx,0x8(%ebp)
c00277ea:	0f b6 00             	movzbl (%eax),%eax
c00277ed:	0f be c0             	movsbl %al,%eax
c00277f0:	83 e8 20             	sub    $0x20,%eax
c00277f3:	83 f8 10             	cmp    $0x10,%eax
c00277f6:	77 6f                	ja     c0027867 <parse_conversion+0x92>
c00277f8:	8b 04 85 d4 09 03 c0 	mov    -0x3ffcf62c(,%eax,4),%eax
c00277ff:	ff e0                	jmp    *%eax
        {
        case '-':
          c->flags |= MINUS;
c0027801:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027804:	8b 00                	mov    (%eax),%eax
c0027806:	83 c8 01             	or     $0x1,%eax
c0027809:	89 c2                	mov    %eax,%edx
c002780b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002780e:	89 10                	mov    %edx,(%eax)
          break;
c0027810:	eb 68                	jmp    c002787a <parse_conversion+0xa5>
        case '+':
          c->flags |= PLUS;
c0027812:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027815:	8b 00                	mov    (%eax),%eax
c0027817:	83 c8 02             	or     $0x2,%eax
c002781a:	89 c2                	mov    %eax,%edx
c002781c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002781f:	89 10                	mov    %edx,(%eax)
          break;
c0027821:	eb 57                	jmp    c002787a <parse_conversion+0xa5>
        case ' ':
          c->flags |= SPACE;
c0027823:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027826:	8b 00                	mov    (%eax),%eax
c0027828:	83 c8 04             	or     $0x4,%eax
c002782b:	89 c2                	mov    %eax,%edx
c002782d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027830:	89 10                	mov    %edx,(%eax)
          break;
c0027832:	eb 46                	jmp    c002787a <parse_conversion+0xa5>
        case '#':
          c->flags |= POUND;
c0027834:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027837:	8b 00                	mov    (%eax),%eax
c0027839:	83 c8 08             	or     $0x8,%eax
c002783c:	89 c2                	mov    %eax,%edx
c002783e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027841:	89 10                	mov    %edx,(%eax)
          break;
c0027843:	eb 35                	jmp    c002787a <parse_conversion+0xa5>
        case '0':
          c->flags |= ZERO;
c0027845:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027848:	8b 00                	mov    (%eax),%eax
c002784a:	83 c8 10             	or     $0x10,%eax
c002784d:	89 c2                	mov    %eax,%edx
c002784f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027852:	89 10                	mov    %edx,(%eax)
          break;
c0027854:	eb 24                	jmp    c002787a <parse_conversion+0xa5>
        case '\'':
          c->flags |= GROUP;
c0027856:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027859:	8b 00                	mov    (%eax),%eax
c002785b:	83 c8 20             	or     $0x20,%eax
c002785e:	89 c2                	mov    %eax,%edx
c0027860:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027863:	89 10                	mov    %edx,(%eax)
          break;
c0027865:	eb 13                	jmp    c002787a <parse_conversion+0xa5>
        default:
          format--;
c0027867:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
          goto not_a_flag;
c002786b:	90                   	nop
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
c002786c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002786f:	8b 00                	mov    (%eax),%eax
c0027871:	83 e0 01             	and    $0x1,%eax
c0027874:	85 c0                	test   %eax,%eax
c0027876:	74 16                	je     c002788e <parse_conversion+0xb9>
c0027878:	eb 05                	jmp    c002787f <parse_conversion+0xaa>
          break;
        default:
          format--;
          goto not_a_flag;
        }
    }
c002787a:	e9 62 ff ff ff       	jmp    c00277e1 <parse_conversion+0xc>
 not_a_flag:
  if (c->flags & MINUS)
    c->flags &= ~ZERO;
c002787f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027882:	8b 00                	mov    (%eax),%eax
c0027884:	83 e0 ef             	and    $0xffffffef,%eax
c0027887:	89 c2                	mov    %eax,%edx
c0027889:	8b 45 0c             	mov    0xc(%ebp),%eax
c002788c:	89 10                	mov    %edx,(%eax)
  if (c->flags & PLUS)
c002788e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027891:	8b 00                	mov    (%eax),%eax
c0027893:	83 e0 02             	and    $0x2,%eax
c0027896:	85 c0                	test   %eax,%eax
c0027898:	74 0f                	je     c00278a9 <parse_conversion+0xd4>
    c->flags &= ~SPACE;
c002789a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002789d:	8b 00                	mov    (%eax),%eax
c002789f:	83 e0 fb             	and    $0xfffffffb,%eax
c00278a2:	89 c2                	mov    %eax,%edx
c00278a4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278a7:	89 10                	mov    %edx,(%eax)

  /* Parse field width. */
  c->width = 0;
c00278a9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278ac:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (*format == '*')
c00278b3:	8b 45 08             	mov    0x8(%ebp),%eax
c00278b6:	0f b6 00             	movzbl (%eax),%eax
c00278b9:	3c 2a                	cmp    $0x2a,%al
c00278bb:	75 44                	jne    c0027901 <parse_conversion+0x12c>
    {
      format++;
c00278bd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      c->width = va_arg (*args, int);
c00278c1:	8b 45 10             	mov    0x10(%ebp),%eax
c00278c4:	8b 00                	mov    (%eax),%eax
c00278c6:	8d 48 04             	lea    0x4(%eax),%ecx
c00278c9:	8b 55 10             	mov    0x10(%ebp),%edx
c00278cc:	89 0a                	mov    %ecx,(%edx)
c00278ce:	8b 10                	mov    (%eax),%edx
c00278d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278d3:	89 50 04             	mov    %edx,0x4(%eax)
c00278d6:	eb 3f                	jmp    c0027917 <parse_conversion+0x142>
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
c00278d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278db:	8b 50 04             	mov    0x4(%eax),%edx
c00278de:	89 d0                	mov    %edx,%eax
c00278e0:	c1 e0 02             	shl    $0x2,%eax
c00278e3:	01 d0                	add    %edx,%eax
c00278e5:	01 c0                	add    %eax,%eax
c00278e7:	89 c2                	mov    %eax,%edx
c00278e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00278ec:	0f b6 00             	movzbl (%eax),%eax
c00278ef:	0f be c0             	movsbl %al,%eax
c00278f2:	01 d0                	add    %edx,%eax
c00278f4:	8d 50 d0             	lea    -0x30(%eax),%edx
c00278f7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278fa:	89 50 04             	mov    %edx,0x4(%eax)
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
c00278fd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0027901:	8b 45 08             	mov    0x8(%ebp),%eax
c0027904:	0f b6 00             	movzbl (%eax),%eax
c0027907:	0f be c0             	movsbl %al,%eax
c002790a:	50                   	push   %eax
c002790b:	e8 40 f9 ff ff       	call   c0027250 <isdigit>
c0027910:	83 c4 04             	add    $0x4,%esp
c0027913:	85 c0                	test   %eax,%eax
c0027915:	75 c1                	jne    c00278d8 <parse_conversion+0x103>
        c->width = c->width * 10 + *format - '0';
    }
  if (c->width < 0) 
c0027917:	8b 45 0c             	mov    0xc(%ebp),%eax
c002791a:	8b 40 04             	mov    0x4(%eax),%eax
c002791d:	85 c0                	test   %eax,%eax
c002791f:	79 1f                	jns    c0027940 <parse_conversion+0x16b>
    {
      c->width = -c->width;
c0027921:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027924:	8b 40 04             	mov    0x4(%eax),%eax
c0027927:	f7 d8                	neg    %eax
c0027929:	89 c2                	mov    %eax,%edx
c002792b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002792e:	89 50 04             	mov    %edx,0x4(%eax)
      c->flags |= MINUS;
c0027931:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027934:	8b 00                	mov    (%eax),%eax
c0027936:	83 c8 01             	or     $0x1,%eax
c0027939:	89 c2                	mov    %eax,%edx
c002793b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002793e:	89 10                	mov    %edx,(%eax)
    }
      
  /* Parse precision. */
  c->precision = -1;
c0027940:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027943:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  if (*format == '.') 
c002794a:	8b 45 08             	mov    0x8(%ebp),%eax
c002794d:	0f b6 00             	movzbl (%eax),%eax
c0027950:	3c 2e                	cmp    $0x2e,%al
c0027952:	0f 85 88 00 00 00    	jne    c00279e0 <parse_conversion+0x20b>
    {
      format++;
c0027958:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      if (*format == '*') 
c002795c:	8b 45 08             	mov    0x8(%ebp),%eax
c002795f:	0f b6 00             	movzbl (%eax),%eax
c0027962:	3c 2a                	cmp    $0x2a,%al
c0027964:	75 1b                	jne    c0027981 <parse_conversion+0x1ac>
        {
          format++;
c0027966:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->precision = va_arg (*args, int);
c002796a:	8b 45 10             	mov    0x10(%ebp),%eax
c002796d:	8b 00                	mov    (%eax),%eax
c002796f:	8d 48 04             	lea    0x4(%eax),%ecx
c0027972:	8b 55 10             	mov    0x10(%ebp),%edx
c0027975:	89 0a                	mov    %ecx,(%edx)
c0027977:	8b 10                	mov    (%eax),%edx
c0027979:	8b 45 0c             	mov    0xc(%ebp),%eax
c002797c:	89 50 08             	mov    %edx,0x8(%eax)
c002797f:	eb 4b                	jmp    c00279cc <parse_conversion+0x1f7>
        }
      else 
        {
          c->precision = 0;
c0027981:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027984:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          for (; isdigit (*format); format++)
c002798b:	eb 29                	jmp    c00279b6 <parse_conversion+0x1e1>
            c->precision = c->precision * 10 + *format - '0';
c002798d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027990:	8b 50 08             	mov    0x8(%eax),%edx
c0027993:	89 d0                	mov    %edx,%eax
c0027995:	c1 e0 02             	shl    $0x2,%eax
c0027998:	01 d0                	add    %edx,%eax
c002799a:	01 c0                	add    %eax,%eax
c002799c:	89 c2                	mov    %eax,%edx
c002799e:	8b 45 08             	mov    0x8(%ebp),%eax
c00279a1:	0f b6 00             	movzbl (%eax),%eax
c00279a4:	0f be c0             	movsbl %al,%eax
c00279a7:	01 d0                	add    %edx,%eax
c00279a9:	8d 50 d0             	lea    -0x30(%eax),%edx
c00279ac:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279af:	89 50 08             	mov    %edx,0x8(%eax)
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
          for (; isdigit (*format); format++)
c00279b2:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c00279b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00279b9:	0f b6 00             	movzbl (%eax),%eax
c00279bc:	0f be c0             	movsbl %al,%eax
c00279bf:	50                   	push   %eax
c00279c0:	e8 8b f8 ff ff       	call   c0027250 <isdigit>
c00279c5:	83 c4 04             	add    $0x4,%esp
c00279c8:	85 c0                	test   %eax,%eax
c00279ca:	75 c1                	jne    c002798d <parse_conversion+0x1b8>
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
c00279cc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279cf:	8b 40 08             	mov    0x8(%eax),%eax
c00279d2:	85 c0                	test   %eax,%eax
c00279d4:	79 0a                	jns    c00279e0 <parse_conversion+0x20b>
        c->precision = -1;
c00279d6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279d9:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    }
  if (c->precision >= 0)
c00279e0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279e3:	8b 40 08             	mov    0x8(%eax),%eax
c00279e6:	85 c0                	test   %eax,%eax
c00279e8:	78 0f                	js     c00279f9 <parse_conversion+0x224>
    c->flags &= ~ZERO;
c00279ea:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279ed:	8b 00                	mov    (%eax),%eax
c00279ef:	83 e0 ef             	and    $0xffffffef,%eax
c00279f2:	89 c2                	mov    %eax,%edx
c00279f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279f7:	89 10                	mov    %edx,(%eax)

  /* Parse type. */
  c->type = INT;
c00279f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279fc:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  switch (*format++) 
c0027a03:	8b 45 08             	mov    0x8(%ebp),%eax
c0027a06:	8d 50 01             	lea    0x1(%eax),%edx
c0027a09:	89 55 08             	mov    %edx,0x8(%ebp)
c0027a0c:	0f b6 00             	movzbl (%eax),%eax
c0027a0f:	0f be c0             	movsbl %al,%eax
c0027a12:	83 e8 68             	sub    $0x68,%eax
c0027a15:	83 f8 12             	cmp    $0x12,%eax
c0027a18:	77 79                	ja     c0027a93 <parse_conversion+0x2be>
c0027a1a:	8b 04 85 18 0a 03 c0 	mov    -0x3ffcf5e8(,%eax,4),%eax
c0027a21:	ff e0                	jmp    *%eax
    {
    case 'h':
      if (*format == 'h') 
c0027a23:	8b 45 08             	mov    0x8(%ebp),%eax
c0027a26:	0f b6 00             	movzbl (%eax),%eax
c0027a29:	3c 68                	cmp    $0x68,%al
c0027a2b:	75 10                	jne    c0027a3d <parse_conversion+0x268>
        {
          format++;
c0027a2d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->type = CHAR;
c0027a31:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a34:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
        }
      else
        c->type = SHORT;
      break;
c0027a3b:	eb 5b                	jmp    c0027a98 <parse_conversion+0x2c3>
        {
          format++;
          c->type = CHAR;
        }
      else
        c->type = SHORT;
c0027a3d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a40:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
      break;
c0027a47:	eb 4f                	jmp    c0027a98 <parse_conversion+0x2c3>
      
    case 'j':
      c->type = INTMAX;
c0027a49:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a4c:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      break;
c0027a53:	eb 43                	jmp    c0027a98 <parse_conversion+0x2c3>

    case 'l':
      if (*format == 'l')
c0027a55:	8b 45 08             	mov    0x8(%ebp),%eax
c0027a58:	0f b6 00             	movzbl (%eax),%eax
c0027a5b:	3c 6c                	cmp    $0x6c,%al
c0027a5d:	75 10                	jne    c0027a6f <parse_conversion+0x29a>
        {
          format++;
c0027a5f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->type = LONGLONG;
c0027a63:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a66:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
        }
      else
        c->type = LONG;
      break;
c0027a6d:	eb 29                	jmp    c0027a98 <parse_conversion+0x2c3>
        {
          format++;
          c->type = LONGLONG;
        }
      else
        c->type = LONG;
c0027a6f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a72:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
      break;
c0027a79:	eb 1d                	jmp    c0027a98 <parse_conversion+0x2c3>

    case 't':
      c->type = PTRDIFFT;
c0027a7b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a7e:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
      break;
c0027a85:	eb 11                	jmp    c0027a98 <parse_conversion+0x2c3>

    case 'z':
      c->type = SIZET;
c0027a87:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a8a:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)
      break;
c0027a91:	eb 05                	jmp    c0027a98 <parse_conversion+0x2c3>

    default:
      format--;
c0027a93:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
      break;
c0027a97:	90                   	nop
    }

  return format;
c0027a98:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0027a9b:	c9                   	leave  
c0027a9c:	c3                   	ret    

c0027a9d <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
c0027a9d:	55                   	push   %ebp
c0027a9e:	89 e5                	mov    %esp,%ebp
c0027aa0:	57                   	push   %edi
c0027aa1:	56                   	push   %esi
c0027aa2:	53                   	push   %ebx
c0027aa3:	83 ec 7c             	sub    $0x7c,%esp
c0027aa6:	8b 55 10             	mov    0x10(%ebp),%edx
c0027aa9:	8b 45 14             	mov    0x14(%ebp),%eax
c0027aac:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0027aaf:	89 4d 80             	mov    %ecx,-0x80(%ebp)
c0027ab2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0027ab5:	89 4d 84             	mov    %ecx,-0x7c(%ebp)
c0027ab8:	88 95 7c ff ff ff    	mov    %dl,-0x84(%ebp)
c0027abe:	88 85 78 ff ff ff    	mov    %al,-0x88(%ebp)
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
c0027ac4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  if (is_signed) 
c0027acb:	80 bd 7c ff ff ff 00 	cmpb   $0x0,-0x84(%ebp)
c0027ad2:	74 5c                	je     c0027b30 <format_integer+0x93>
    {
      if (c->flags & PLUS)
c0027ad4:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027ad7:	8b 00                	mov    (%eax),%eax
c0027ad9:	83 e0 02             	and    $0x2,%eax
c0027adc:	85 c0                	test   %eax,%eax
c0027ade:	74 1a                	je     c0027afa <format_integer+0x5d>
        sign = negative ? '-' : '+';
c0027ae0:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027ae7:	74 07                	je     c0027af0 <format_integer+0x53>
c0027ae9:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027aee:	eb 05                	jmp    c0027af5 <format_integer+0x58>
c0027af0:	b8 2b 00 00 00       	mov    $0x2b,%eax
c0027af5:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027af8:	eb 36                	jmp    c0027b30 <format_integer+0x93>
      else if (c->flags & SPACE)
c0027afa:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027afd:	8b 00                	mov    (%eax),%eax
c0027aff:	83 e0 04             	and    $0x4,%eax
c0027b02:	85 c0                	test   %eax,%eax
c0027b04:	74 1a                	je     c0027b20 <format_integer+0x83>
        sign = negative ? '-' : ' ';
c0027b06:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027b0d:	74 07                	je     c0027b16 <format_integer+0x79>
c0027b0f:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027b14:	eb 05                	jmp    c0027b1b <format_integer+0x7e>
c0027b16:	b8 20 00 00 00       	mov    $0x20,%eax
c0027b1b:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027b1e:	eb 10                	jmp    c0027b30 <format_integer+0x93>
      else if (negative)
c0027b20:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027b27:	74 07                	je     c0027b30 <format_integer+0x93>
        sign = '-';
c0027b29:	c7 45 e0 2d 00 00 00 	movl   $0x2d,-0x20(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c0027b30:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b33:	8b 00                	mov    (%eax),%eax
c0027b35:	83 e0 08             	and    $0x8,%eax
c0027b38:	85 c0                	test   %eax,%eax
c0027b3a:	74 12                	je     c0027b4e <format_integer+0xb1>
c0027b3c:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027b3f:	0b 45 80             	or     -0x80(%ebp),%eax
c0027b42:	85 c0                	test   %eax,%eax
c0027b44:	74 08                	je     c0027b4e <format_integer+0xb1>
c0027b46:	8b 45 18             	mov    0x18(%ebp),%eax
c0027b49:	8b 40 08             	mov    0x8(%eax),%eax
c0027b4c:	eb 05                	jmp    c0027b53 <format_integer+0xb6>
c0027b4e:	b8 00 00 00 00       	mov    $0x0,%eax
c0027b53:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
c0027b56:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027b59:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  digit_cnt = 0;
c0027b5c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  while (value > 0) 
c0027b63:	e9 84 00 00 00       	jmp    c0027bec <format_integer+0x14f>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0027b68:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b6b:	8b 00                	mov    (%eax),%eax
c0027b6d:	83 e0 20             	and    $0x20,%eax
c0027b70:	85 c0                	test   %eax,%eax
c0027b72:	74 24                	je     c0027b98 <format_integer+0xfb>
c0027b74:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0027b78:	7e 1e                	jle    c0027b98 <format_integer+0xfb>
c0027b7a:	8b 45 18             	mov    0x18(%ebp),%eax
c0027b7d:	8b 48 0c             	mov    0xc(%eax),%ecx
c0027b80:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0027b83:	99                   	cltd   
c0027b84:	f7 f9                	idiv   %ecx
c0027b86:	89 d0                	mov    %edx,%eax
c0027b88:	85 c0                	test   %eax,%eax
c0027b8a:	75 0c                	jne    c0027b98 <format_integer+0xfb>
        *cp++ = ',';
c0027b8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027b8f:	8d 50 01             	lea    0x1(%eax),%edx
c0027b92:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027b95:	c6 00 2c             	movb   $0x2c,(%eax)
      *cp++ = b->digits[value % b->base];
c0027b98:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0027b9b:	8d 46 01             	lea    0x1(%esi),%eax
c0027b9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0027ba1:	8b 45 18             	mov    0x18(%ebp),%eax
c0027ba4:	8b 78 04             	mov    0x4(%eax),%edi
c0027ba7:	8b 45 18             	mov    0x18(%ebp),%eax
c0027baa:	8b 00                	mov    (%eax),%eax
c0027bac:	89 c1                	mov    %eax,%ecx
c0027bae:	89 c3                	mov    %eax,%ebx
c0027bb0:	c1 fb 1f             	sar    $0x1f,%ebx
c0027bb3:	8b 45 80             	mov    -0x80(%ebp),%eax
c0027bb6:	8b 55 84             	mov    -0x7c(%ebp),%edx
c0027bb9:	53                   	push   %ebx
c0027bba:	51                   	push   %ecx
c0027bbb:	52                   	push   %edx
c0027bbc:	50                   	push   %eax
c0027bbd:	e8 2d 16 00 00       	call   c00291ef <__umoddi3>
c0027bc2:	83 c4 10             	add    $0x10,%esp
c0027bc5:	01 f8                	add    %edi,%eax
c0027bc7:	0f b6 00             	movzbl (%eax),%eax
c0027bca:	88 06                	mov    %al,(%esi)
      value /= b->base;
c0027bcc:	8b 45 18             	mov    0x18(%ebp),%eax
c0027bcf:	8b 00                	mov    (%eax),%eax
c0027bd1:	99                   	cltd   
c0027bd2:	52                   	push   %edx
c0027bd3:	50                   	push   %eax
c0027bd4:	ff 75 84             	pushl  -0x7c(%ebp)
c0027bd7:	ff 75 80             	pushl  -0x80(%ebp)
c0027bda:	e8 dc 15 00 00       	call   c00291bb <__udivdi3>
c0027bdf:	83 c4 10             	add    $0x10,%esp
c0027be2:	89 45 80             	mov    %eax,-0x80(%ebp)
c0027be5:	89 55 84             	mov    %edx,-0x7c(%ebp)
      digit_cnt++;
c0027be8:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
c0027bec:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027bef:	0b 45 80             	or     -0x80(%ebp),%eax
c0027bf2:	85 c0                	test   %eax,%eax
c0027bf4:	0f 85 6e ff ff ff    	jne    c0027b68 <format_integer+0xcb>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
c0027bfa:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027bfd:	8b 40 08             	mov    0x8(%eax),%eax
c0027c00:	85 c0                	test   %eax,%eax
c0027c02:	78 08                	js     c0027c0c <format_integer+0x16f>
c0027c04:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027c07:	8b 40 08             	mov    0x8(%eax),%eax
c0027c0a:	eb 05                	jmp    c0027c11 <format_integer+0x174>
c0027c0c:	b8 01 00 00 00       	mov    $0x1,%eax
c0027c11:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027c14:	eb 0c                	jmp    c0027c22 <format_integer+0x185>
    *cp++ = '0';
c0027c16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027c19:	8d 50 01             	lea    0x1(%eax),%edx
c0027c1c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027c1f:	c6 00 30             	movb   $0x30,(%eax)
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027c22:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027c25:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027c28:	29 c2                	sub    %eax,%edx
c0027c2a:	89 d0                	mov    %edx,%eax
c0027c2c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0027c2f:	7d 0b                	jge    c0027c3c <format_integer+0x19f>
c0027c31:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027c34:	83 c0 3f             	add    $0x3f,%eax
c0027c37:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027c3a:	77 da                	ja     c0027c16 <format_integer+0x179>
    *cp++ = '0';
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0027c3c:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027c3f:	8b 00                	mov    (%eax),%eax
c0027c41:	83 e0 08             	and    $0x8,%eax
c0027c44:	85 c0                	test   %eax,%eax
c0027c46:	74 2b                	je     c0027c73 <format_integer+0x1d6>
c0027c48:	8b 45 18             	mov    0x18(%ebp),%eax
c0027c4b:	8b 00                	mov    (%eax),%eax
c0027c4d:	83 f8 08             	cmp    $0x8,%eax
c0027c50:	75 21                	jne    c0027c73 <format_integer+0x1d6>
c0027c52:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027c55:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027c58:	74 0d                	je     c0027c67 <format_integer+0x1ca>
c0027c5a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027c5d:	83 e8 01             	sub    $0x1,%eax
c0027c60:	0f b6 00             	movzbl (%eax),%eax
c0027c63:	3c 30                	cmp    $0x30,%al
c0027c65:	74 0c                	je     c0027c73 <format_integer+0x1d6>
    *cp++ = '0';
c0027c67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027c6a:	8d 50 01             	lea    0x1(%eax),%edx
c0027c6d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027c70:	c6 00 30             	movb   $0x30,(%eax)

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0027c73:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027c76:	8b 40 04             	mov    0x4(%eax),%eax
c0027c79:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0027c7c:	8d 55 90             	lea    -0x70(%ebp),%edx
c0027c7f:	29 d1                	sub    %edx,%ecx
c0027c81:	89 ca                	mov    %ecx,%edx
c0027c83:	29 d0                	sub    %edx,%eax
c0027c85:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0027c89:	74 07                	je     c0027c92 <format_integer+0x1f5>
c0027c8b:	ba 02 00 00 00       	mov    $0x2,%edx
c0027c90:	eb 05                	jmp    c0027c97 <format_integer+0x1fa>
c0027c92:	ba 00 00 00 00       	mov    $0x0,%edx
c0027c97:	29 d0                	sub    %edx,%eax
c0027c99:	89 c2                	mov    %eax,%edx
c0027c9b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027c9f:	0f 95 c0             	setne  %al
c0027ca2:	0f b6 c0             	movzbl %al,%eax
c0027ca5:	29 c2                	sub    %eax,%edx
c0027ca7:	89 d0                	mov    %edx,%eax
c0027ca9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (pad_cnt < 0)
c0027cac:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0027cb0:	79 07                	jns    c0027cb9 <format_integer+0x21c>
    pad_cnt = 0;
c0027cb2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
c0027cb9:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027cbc:	8b 00                	mov    (%eax),%eax
c0027cbe:	83 e0 11             	and    $0x11,%eax
c0027cc1:	85 c0                	test   %eax,%eax
c0027cc3:	75 14                	jne    c0027cd9 <format_integer+0x23c>
    output_dup (' ', pad_cnt, output, aux);
c0027cc5:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027cc8:	ff 75 24             	pushl  0x24(%ebp)
c0027ccb:	ff 75 20             	pushl  0x20(%ebp)
c0027cce:	50                   	push   %eax
c0027ccf:	6a 20                	push   $0x20
c0027cd1:	e8 b8 00 00 00       	call   c0027d8e <output_dup>
c0027cd6:	83 c4 10             	add    $0x10,%esp
  if (sign)
c0027cd9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027cdd:	74 15                	je     c0027cf4 <format_integer+0x257>
    output (sign, aux);
c0027cdf:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027ce2:	0f be c0             	movsbl %al,%eax
c0027ce5:	83 ec 08             	sub    $0x8,%esp
c0027ce8:	ff 75 24             	pushl  0x24(%ebp)
c0027ceb:	50                   	push   %eax
c0027cec:	8b 45 20             	mov    0x20(%ebp),%eax
c0027cef:	ff d0                	call   *%eax
c0027cf1:	83 c4 10             	add    $0x10,%esp
  if (x) 
c0027cf4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0027cf8:	74 25                	je     c0027d1f <format_integer+0x282>
    {
      output ('0', aux);
c0027cfa:	83 ec 08             	sub    $0x8,%esp
c0027cfd:	ff 75 24             	pushl  0x24(%ebp)
c0027d00:	6a 30                	push   $0x30
c0027d02:	8b 45 20             	mov    0x20(%ebp),%eax
c0027d05:	ff d0                	call   *%eax
c0027d07:	83 c4 10             	add    $0x10,%esp
      output (x, aux); 
c0027d0a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0027d0d:	0f be c0             	movsbl %al,%eax
c0027d10:	83 ec 08             	sub    $0x8,%esp
c0027d13:	ff 75 24             	pushl  0x24(%ebp)
c0027d16:	50                   	push   %eax
c0027d17:	8b 45 20             	mov    0x20(%ebp),%eax
c0027d1a:	ff d0                	call   *%eax
c0027d1c:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
c0027d1f:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027d22:	8b 00                	mov    (%eax),%eax
c0027d24:	83 e0 10             	and    $0x10,%eax
c0027d27:	85 c0                	test   %eax,%eax
c0027d29:	74 32                	je     c0027d5d <format_integer+0x2c0>
    output_dup ('0', pad_cnt, output, aux);
c0027d2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027d2e:	ff 75 24             	pushl  0x24(%ebp)
c0027d31:	ff 75 20             	pushl  0x20(%ebp)
c0027d34:	50                   	push   %eax
c0027d35:	6a 30                	push   $0x30
c0027d37:	e8 52 00 00 00       	call   c0027d8e <output_dup>
c0027d3c:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c0027d3f:	eb 1c                	jmp    c0027d5d <format_integer+0x2c0>
    output (*--cp, aux);
c0027d41:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
c0027d45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027d48:	0f b6 00             	movzbl (%eax),%eax
c0027d4b:	0f be c0             	movsbl %al,%eax
c0027d4e:	83 ec 08             	sub    $0x8,%esp
c0027d51:	ff 75 24             	pushl  0x24(%ebp)
c0027d54:	50                   	push   %eax
c0027d55:	8b 45 20             	mov    0x20(%ebp),%eax
c0027d58:	ff d0                	call   *%eax
c0027d5a:	83 c4 10             	add    $0x10,%esp
      output ('0', aux);
      output (x, aux); 
    }
  if (c->flags & ZERO)
    output_dup ('0', pad_cnt, output, aux);
  while (cp > buf)
c0027d5d:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027d60:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027d63:	77 dc                	ja     c0027d41 <format_integer+0x2a4>
    output (*--cp, aux);
  if (c->flags & MINUS)
c0027d65:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027d68:	8b 00                	mov    (%eax),%eax
c0027d6a:	83 e0 01             	and    $0x1,%eax
c0027d6d:	85 c0                	test   %eax,%eax
c0027d6f:	74 14                	je     c0027d85 <format_integer+0x2e8>
    output_dup (' ', pad_cnt, output, aux);
c0027d71:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027d74:	ff 75 24             	pushl  0x24(%ebp)
c0027d77:	ff 75 20             	pushl  0x20(%ebp)
c0027d7a:	50                   	push   %eax
c0027d7b:	6a 20                	push   $0x20
c0027d7d:	e8 0c 00 00 00       	call   c0027d8e <output_dup>
c0027d82:	83 c4 10             	add    $0x10,%esp
}
c0027d85:	90                   	nop
c0027d86:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0027d89:	5b                   	pop    %ebx
c0027d8a:	5e                   	pop    %esi
c0027d8b:	5f                   	pop    %edi
c0027d8c:	5d                   	pop    %ebp
c0027d8d:	c3                   	ret    

c0027d8e <output_dup>:

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0027d8e:	55                   	push   %ebp
c0027d8f:	89 e5                	mov    %esp,%ebp
c0027d91:	83 ec 18             	sub    $0x18,%esp
c0027d94:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d97:	88 45 f4             	mov    %al,-0xc(%ebp)
  while (cnt-- > 0)
c0027d9a:	eb 13                	jmp    c0027daf <output_dup+0x21>
    output (ch, aux);
c0027d9c:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0027da0:	83 ec 08             	sub    $0x8,%esp
c0027da3:	ff 75 14             	pushl  0x14(%ebp)
c0027da6:	50                   	push   %eax
c0027da7:	8b 45 10             	mov    0x10(%ebp),%eax
c0027daa:	ff d0                	call   *%eax
c0027dac:	83 c4 10             	add    $0x10,%esp

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
  while (cnt-- > 0)
c0027daf:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027db2:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027db5:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027db8:	85 c0                	test   %eax,%eax
c0027dba:	75 e0                	jne    c0027d9c <output_dup+0xe>
    output (ch, aux);
}
c0027dbc:	90                   	nop
c0027dbd:	c9                   	leave  
c0027dbe:	c3                   	ret    

c0027dbf <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0027dbf:	55                   	push   %ebp
c0027dc0:	89 e5                	mov    %esp,%ebp
c0027dc2:	83 ec 18             	sub    $0x18,%esp
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0027dc5:	8b 45 10             	mov    0x10(%ebp),%eax
c0027dc8:	8b 40 04             	mov    0x4(%eax),%eax
c0027dcb:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027dce:	7e 26                	jle    c0027df6 <format_string+0x37>
c0027dd0:	8b 45 10             	mov    0x10(%ebp),%eax
c0027dd3:	8b 00                	mov    (%eax),%eax
c0027dd5:	83 e0 01             	and    $0x1,%eax
c0027dd8:	85 c0                	test   %eax,%eax
c0027dda:	75 1a                	jne    c0027df6 <format_string+0x37>
    output_dup (' ', c->width - length, output, aux);
c0027ddc:	8b 45 10             	mov    0x10(%ebp),%eax
c0027ddf:	8b 40 04             	mov    0x4(%eax),%eax
c0027de2:	2b 45 0c             	sub    0xc(%ebp),%eax
c0027de5:	ff 75 18             	pushl  0x18(%ebp)
c0027de8:	ff 75 14             	pushl  0x14(%ebp)
c0027deb:	50                   	push   %eax
c0027dec:	6a 20                	push   $0x20
c0027dee:	e8 9b ff ff ff       	call   c0027d8e <output_dup>
c0027df3:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0027df6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0027dfd:	eb 21                	jmp    c0027e20 <format_string+0x61>
    output (string[i], aux);
c0027dff:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027e02:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e05:	01 d0                	add    %edx,%eax
c0027e07:	0f b6 00             	movzbl (%eax),%eax
c0027e0a:	0f be c0             	movsbl %al,%eax
c0027e0d:	83 ec 08             	sub    $0x8,%esp
c0027e10:	ff 75 18             	pushl  0x18(%ebp)
c0027e13:	50                   	push   %eax
c0027e14:	8b 45 14             	mov    0x14(%ebp),%eax
c0027e17:	ff d0                	call   *%eax
c0027e19:	83 c4 10             	add    $0x10,%esp
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c0027e1c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0027e20:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e23:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027e26:	7c d7                	jl     c0027dff <format_string+0x40>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
c0027e28:	8b 45 10             	mov    0x10(%ebp),%eax
c0027e2b:	8b 40 04             	mov    0x4(%eax),%eax
c0027e2e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027e31:	7e 26                	jle    c0027e59 <format_string+0x9a>
c0027e33:	8b 45 10             	mov    0x10(%ebp),%eax
c0027e36:	8b 00                	mov    (%eax),%eax
c0027e38:	83 e0 01             	and    $0x1,%eax
c0027e3b:	85 c0                	test   %eax,%eax
c0027e3d:	74 1a                	je     c0027e59 <format_string+0x9a>
    output_dup (' ', c->width - length, output, aux);
c0027e3f:	8b 45 10             	mov    0x10(%ebp),%eax
c0027e42:	8b 40 04             	mov    0x4(%eax),%eax
c0027e45:	2b 45 0c             	sub    0xc(%ebp),%eax
c0027e48:	ff 75 18             	pushl  0x18(%ebp)
c0027e4b:	ff 75 14             	pushl  0x14(%ebp)
c0027e4e:	50                   	push   %eax
c0027e4f:	6a 20                	push   $0x20
c0027e51:	e8 38 ff ff ff       	call   c0027d8e <output_dup>
c0027e56:	83 c4 10             	add    $0x10,%esp
}
c0027e59:	90                   	nop
c0027e5a:	c9                   	leave  
c0027e5b:	c3                   	ret    

c0027e5c <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0027e5c:	55                   	push   %ebp
c0027e5d:	89 e5                	mov    %esp,%ebp
c0027e5f:	83 ec 18             	sub    $0x18,%esp
  va_list args;

  va_start (args, aux);
c0027e62:	8d 45 14             	lea    0x14(%ebp),%eax
c0027e65:	89 45 f4             	mov    %eax,-0xc(%ebp)
  __vprintf (format, args, output, aux);
c0027e68:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e6b:	ff 75 10             	pushl  0x10(%ebp)
c0027e6e:	ff 75 0c             	pushl  0xc(%ebp)
c0027e71:	50                   	push   %eax
c0027e72:	ff 75 08             	pushl  0x8(%ebp)
c0027e75:	e8 f1 f4 ff ff       	call   c002736b <__vprintf>
c0027e7a:	83 c4 10             	add    $0x10,%esp
  va_end (args);
}
c0027e7d:	90                   	nop
c0027e7e:	c9                   	leave  
c0027e7f:	c3                   	ret    

c0027e80 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027e80:	55                   	push   %ebp
c0027e81:	89 e5                	mov    %esp,%ebp
c0027e83:	83 ec 38             	sub    $0x38,%esp
c0027e86:	8b 45 14             	mov    0x14(%ebp),%eax
c0027e89:	88 45 d4             	mov    %al,-0x2c(%ebp)
  const uint8_t *buf = buf_;
c0027e8c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const size_t per_line = 16; /* Maximum bytes per line. */
c0027e92:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)

  while (size > 0)
c0027e99:	e9 bf 01 00 00       	jmp    c002805d <hex_dump+0x1dd>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
c0027e9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ea1:	ba 00 00 00 00       	mov    $0x0,%edx
c0027ea6:	f7 75 e8             	divl   -0x18(%ebp)
c0027ea9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      end = per_line;
c0027eac:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027eaf:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (end - start > size)
c0027eb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027eb5:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027eb8:	3b 45 10             	cmp    0x10(%ebp),%eax
c0027ebb:	76 0b                	jbe    c0027ec8 <hex_dump+0x48>
        end = start + size;
c0027ebd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027ec0:	8b 45 10             	mov    0x10(%ebp),%eax
c0027ec3:	01 d0                	add    %edx,%eax
c0027ec5:	89 45 f0             	mov    %eax,-0x10(%ebp)
      n = end - start;
c0027ec8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027ecb:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027ece:	89 45 e0             	mov    %eax,-0x20(%ebp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027ed1:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ed4:	ba 00 00 00 00       	mov    $0x0,%edx
c0027ed9:	f7 75 e8             	divl   -0x18(%ebp)
c0027edc:	0f af 45 e8          	imul   -0x18(%ebp),%eax
c0027ee0:	ba 00 00 00 00       	mov    $0x0,%edx
c0027ee5:	83 ec 04             	sub    $0x4,%esp
c0027ee8:	52                   	push   %edx
c0027ee9:	50                   	push   %eax
c0027eea:	68 64 0a 03 c0       	push   $0xc0030a64
c0027eef:	e8 51 f4 ff ff       	call   c0027345 <printf>
c0027ef4:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0027ef7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0027efe:	eb 14                	jmp    c0027f14 <hex_dump+0x94>
        printf ("   ");
c0027f00:	83 ec 0c             	sub    $0xc,%esp
c0027f03:	68 6c 0a 03 c0       	push   $0xc0030a6c
c0027f08:	e8 38 f4 ff ff       	call   c0027345 <printf>
c0027f0d:	83 c4 10             	add    $0x10,%esp
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
c0027f10:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027f14:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027f17:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027f1a:	72 e4                	jb     c0027f00 <hex_dump+0x80>
        printf ("   ");
      for (; i < end; i++) 
c0027f1c:	eb 42                	jmp    c0027f60 <hex_dump+0xe0>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027f1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027f21:	d1 e8                	shr    %eax
c0027f23:	83 e8 01             	sub    $0x1,%eax
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
c0027f26:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0027f29:	75 07                	jne    c0027f32 <hex_dump+0xb2>
c0027f2b:	b9 2d 00 00 00       	mov    $0x2d,%ecx
c0027f30:	eb 05                	jmp    c0027f37 <hex_dump+0xb7>
c0027f32:	b9 20 00 00 00       	mov    $0x20,%ecx
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027f37:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027f3a:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027f3d:	89 c2                	mov    %eax,%edx
c0027f3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027f42:	01 d0                	add    %edx,%eax
c0027f44:	0f b6 00             	movzbl (%eax),%eax
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
c0027f47:	0f b6 c0             	movzbl %al,%eax
c0027f4a:	83 ec 04             	sub    $0x4,%esp
c0027f4d:	51                   	push   %ecx
c0027f4e:	50                   	push   %eax
c0027f4f:	68 70 0a 03 c0       	push   $0xc0030a70
c0027f54:	e8 ec f3 ff ff       	call   c0027345 <printf>
c0027f59:	83 c4 10             	add    $0x10,%esp

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
c0027f5c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027f60:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027f63:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0027f66:	72 b6                	jb     c0027f1e <hex_dump+0x9e>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
c0027f68:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
c0027f6c:	0f 84 cc 00 00 00    	je     c002803e <hex_dump+0x1be>
        {
          for (; i < per_line; i++)
c0027f72:	eb 14                	jmp    c0027f88 <hex_dump+0x108>
            printf ("   ");
c0027f74:	83 ec 0c             	sub    $0xc,%esp
c0027f77:	68 6c 0a 03 c0       	push   $0xc0030a6c
c0027f7c:	e8 c4 f3 ff ff       	call   c0027345 <printf>
c0027f81:	83 c4 10             	add    $0x10,%esp
      for (; i < end; i++) 
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
        {
          for (; i < per_line; i++)
c0027f84:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027f88:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027f8b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0027f8e:	72 e4                	jb     c0027f74 <hex_dump+0xf4>
            printf ("   ");
          printf ("|");
c0027f90:	83 ec 0c             	sub    $0xc,%esp
c0027f93:	6a 7c                	push   $0x7c
c0027f95:	e8 19 3a 00 00       	call   c002b9b3 <putchar>
c0027f9a:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0027f9d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0027fa4:	eb 11                	jmp    c0027fb7 <hex_dump+0x137>
            printf (" ");
c0027fa6:	83 ec 0c             	sub    $0xc,%esp
c0027fa9:	6a 20                	push   $0x20
c0027fab:	e8 03 3a 00 00       	call   c002b9b3 <putchar>
c0027fb0:	83 c4 10             	add    $0x10,%esp
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c0027fb3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027fb7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027fba:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027fbd:	72 e7                	jb     c0027fa6 <hex_dump+0x126>
            printf (" ");
          for (; i < end; i++)
c0027fbf:	eb 4d                	jmp    c002800e <hex_dump+0x18e>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027fc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027fc4:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027fc7:	89 c2                	mov    %eax,%edx
c0027fc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027fcc:	01 d0                	add    %edx,%eax
c0027fce:	0f b6 00             	movzbl (%eax),%eax
c0027fd1:	0f b6 c0             	movzbl %al,%eax
c0027fd4:	83 ec 0c             	sub    $0xc,%esp
c0027fd7:	50                   	push   %eax
c0027fd8:	e8 90 f2 ff ff       	call   c002726d <isprint>
c0027fdd:	83 c4 10             	add    $0x10,%esp
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c0027fe0:	85 c0                	test   %eax,%eax
c0027fe2:	74 15                	je     c0027ff9 <hex_dump+0x179>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027fe4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027fe7:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027fea:	89 c2                	mov    %eax,%edx
c0027fec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027fef:	01 d0                	add    %edx,%eax
c0027ff1:	0f b6 00             	movzbl (%eax),%eax
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c0027ff4:	0f b6 c0             	movzbl %al,%eax
c0027ff7:	eb 05                	jmp    c0027ffe <hex_dump+0x17e>
c0027ff9:	b8 2e 00 00 00       	mov    $0x2e,%eax
c0027ffe:	83 ec 0c             	sub    $0xc,%esp
c0028001:	50                   	push   %eax
c0028002:	e8 ac 39 00 00       	call   c002b9b3 <putchar>
c0028007:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
c002800a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002800e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028011:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028014:	72 ab                	jb     c0027fc1 <hex_dump+0x141>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
c0028016:	eb 11                	jmp    c0028029 <hex_dump+0x1a9>
            printf (" ");
c0028018:	83 ec 0c             	sub    $0xc,%esp
c002801b:	6a 20                	push   $0x20
c002801d:	e8 91 39 00 00       	call   c002b9b3 <putchar>
c0028022:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
c0028025:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0028029:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002802c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002802f:	72 e7                	jb     c0028018 <hex_dump+0x198>
            printf (" ");
          printf ("|");
c0028031:	83 ec 0c             	sub    $0xc,%esp
c0028034:	6a 7c                	push   $0x7c
c0028036:	e8 78 39 00 00       	call   c002b9b3 <putchar>
c002803b:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c002803e:	83 ec 0c             	sub    $0xc,%esp
c0028041:	6a 0a                	push   $0xa
c0028043:	e8 6b 39 00 00       	call   c002b9b3 <putchar>
c0028048:	83 c4 10             	add    $0x10,%esp

      ofs += n;
c002804b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002804e:	01 45 08             	add    %eax,0x8(%ebp)
      buf += n;
c0028051:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0028054:	01 45 f4             	add    %eax,-0xc(%ebp)
      size -= n;
c0028057:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002805a:	29 45 10             	sub    %eax,0x10(%ebp)
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c002805d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028061:	0f 85 37 fe ff ff    	jne    c0027e9e <hex_dump+0x1e>

      ofs += n;
      buf += n;
      size -= n;
    }
}
c0028067:	90                   	nop
c0028068:	c9                   	leave  
c0028069:	c3                   	ret    

c002806a <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c002806a:	55                   	push   %ebp
c002806b:	89 e5                	mov    %esp,%ebp
c002806d:	83 ec 28             	sub    $0x28,%esp
c0028070:	8b 45 08             	mov    0x8(%ebp),%eax
c0028073:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0028076:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028079:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (size == 1)
c002807c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002807f:	83 f0 01             	xor    $0x1,%eax
c0028082:	0b 45 e4             	or     -0x1c(%ebp),%eax
c0028085:	85 c0                	test   %eax,%eax
c0028087:	75 12                	jne    c002809b <print_human_readable_size+0x31>
    printf ("1 byte");
c0028089:	83 ec 0c             	sub    $0xc,%esp
c002808c:	68 79 0a 03 c0       	push   $0xc0030a79
c0028091:	e8 af f2 ff ff       	call   c0027345 <printf>
c0028096:	83 c4 10             	add    $0x10,%esp

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
    }
}
c0028099:	eb 5a                	jmp    c00280f5 <print_human_readable_size+0x8b>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002809b:	c7 45 f4 e8 80 03 c0 	movl   $0xc00380e8,-0xc(%ebp)
c00280a2:	eb 17                	jmp    c00280bb <print_human_readable_size+0x51>
        size /= 1024;
c00280a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00280a7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00280aa:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c00280ae:	c1 ea 0a             	shr    $0xa,%edx
c00280b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00280b4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c00280b7:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c00280bb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00280bf:	72 1b                	jb     c00280dc <print_human_readable_size+0x72>
c00280c1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00280c5:	77 09                	ja     c00280d0 <print_human_readable_size+0x66>
c00280c7:	81 7d e0 ff 03 00 00 	cmpl   $0x3ff,-0x20(%ebp)
c00280ce:	76 0c                	jbe    c00280dc <print_human_readable_size+0x72>
c00280d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00280d3:	83 c0 04             	add    $0x4,%eax
c00280d6:	8b 00                	mov    (%eax),%eax
c00280d8:	85 c0                	test   %eax,%eax
c00280da:	75 c8                	jne    c00280a4 <print_human_readable_size+0x3a>
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
c00280dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00280df:	8b 00                	mov    (%eax),%eax
c00280e1:	50                   	push   %eax
c00280e2:	ff 75 e4             	pushl  -0x1c(%ebp)
c00280e5:	ff 75 e0             	pushl  -0x20(%ebp)
c00280e8:	68 80 0a 03 c0       	push   $0xc0030a80
c00280ed:	e8 53 f2 ff ff       	call   c0027345 <printf>
c00280f2:	83 c4 10             	add    $0x10,%esp
    }
}
c00280f5:	90                   	nop
c00280f6:	c9                   	leave  
c00280f7:	c3                   	ret    

c00280f8 <isdigit>:
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
static inline int isalpha (int c) { return islower (c) || isupper (c); }
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c00280f8:	55                   	push   %ebp
c00280f9:	89 e5                	mov    %esp,%ebp
c00280fb:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c00280ff:	7e 0d                	jle    c002810e <isdigit+0x16>
c0028101:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0028105:	7f 07                	jg     c002810e <isdigit+0x16>
c0028107:	b8 01 00 00 00       	mov    $0x1,%eax
c002810c:	eb 05                	jmp    c0028113 <isdigit+0x1b>
c002810e:	b8 00 00 00 00       	mov    $0x0,%eax
c0028113:	5d                   	pop    %ebp
c0028114:	c3                   	ret    

c0028115 <isspace>:
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
c0028115:	55                   	push   %ebp
c0028116:	89 e5                	mov    %esp,%ebp
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
c0028118:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c002811c:	74 1e                	je     c002813c <isspace+0x27>
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
  return (c == ' ' || c == '\f' || c == '\n'
c002811e:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0028122:	74 18                	je     c002813c <isspace+0x27>
c0028124:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0028128:	74 12                	je     c002813c <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c002812a:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c002812e:	74 0c                	je     c002813c <isspace+0x27>
c0028130:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0028134:	74 06                	je     c002813c <isspace+0x27>
c0028136:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c002813a:	75 07                	jne    c0028143 <isspace+0x2e>
c002813c:	b8 01 00 00 00       	mov    $0x1,%eax
c0028141:	eb 05                	jmp    c0028148 <isspace+0x33>
c0028143:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028148:	5d                   	pop    %ebp
c0028149:	c3                   	ret    

c002814a <atoi>:

/* Converts a string representation of a signed decimal integer
   in S into an `int', which is returned. */
int
atoi (const char *s) 
{
c002814a:	55                   	push   %ebp
c002814b:	89 e5                	mov    %esp,%ebp
c002814d:	83 ec 18             	sub    $0x18,%esp
  bool negative;
  int value;

  ASSERT (s != NULL);
c0028150:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028154:	75 22                	jne    c0028178 <atoi+0x2e>
c0028156:	83 ec 0c             	sub    $0xc,%esp
c0028159:	68 a4 0a 03 c0       	push   $0xc0030aa4
c002815e:	68 ae 0a 03 c0       	push   $0xc0030aae
c0028163:	68 0c 0b 03 c0       	push   $0xc0030b0c
c0028168:	6a 0f                	push   $0xf
c002816a:	68 c5 0a 03 c0       	push   $0xc0030ac5
c002816f:	e8 04 16 00 00       	call   c0029778 <debug_panic>

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
    s++;
c0028174:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  int value;

  ASSERT (s != NULL);

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
c0028178:	8b 45 08             	mov    0x8(%ebp),%eax
c002817b:	0f b6 00             	movzbl (%eax),%eax
c002817e:	0f b6 c0             	movzbl %al,%eax
c0028181:	83 ec 0c             	sub    $0xc,%esp
c0028184:	50                   	push   %eax
c0028185:	e8 8b ff ff ff       	call   c0028115 <isspace>
c002818a:	83 c4 10             	add    $0x10,%esp
c002818d:	85 c0                	test   %eax,%eax
c002818f:	75 e3                	jne    c0028174 <atoi+0x2a>
    s++;

  /* Parse sign. */
  negative = false;
c0028191:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (*s == '+')
c0028195:	8b 45 08             	mov    0x8(%ebp),%eax
c0028198:	0f b6 00             	movzbl (%eax),%eax
c002819b:	3c 2b                	cmp    $0x2b,%al
c002819d:	75 06                	jne    c00281a5 <atoi+0x5b>
    s++;
c002819f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c00281a3:	eb 12                	jmp    c00281b7 <atoi+0x6d>
  else if (*s == '-')
c00281a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00281a8:	0f b6 00             	movzbl (%eax),%eax
c00281ab:	3c 2d                	cmp    $0x2d,%al
c00281ad:	75 08                	jne    c00281b7 <atoi+0x6d>
    {
      negative = true;
c00281af:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
      s++;
c00281b3:	83 45 08 01          	addl   $0x1,0x8(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c00281b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00281be:	eb 25                	jmp    c00281e5 <atoi+0x9b>
    value = value * 10 - (*s - '0');
c00281c0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00281c3:	89 d0                	mov    %edx,%eax
c00281c5:	c1 e0 02             	shl    $0x2,%eax
c00281c8:	01 d0                	add    %edx,%eax
c00281ca:	01 c0                	add    %eax,%eax
c00281cc:	89 c2                	mov    %eax,%edx
c00281ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00281d1:	0f b6 00             	movzbl (%eax),%eax
c00281d4:	0f be c0             	movsbl %al,%eax
c00281d7:	83 e8 30             	sub    $0x30,%eax
c00281da:	29 c2                	sub    %eax,%edx
c00281dc:	89 d0                	mov    %edx,%eax
c00281de:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c00281e1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c00281e5:	8b 45 08             	mov    0x8(%ebp),%eax
c00281e8:	0f b6 00             	movzbl (%eax),%eax
c00281eb:	0f be c0             	movsbl %al,%eax
c00281ee:	83 ec 0c             	sub    $0xc,%esp
c00281f1:	50                   	push   %eax
c00281f2:	e8 01 ff ff ff       	call   c00280f8 <isdigit>
c00281f7:	83 c4 10             	add    $0x10,%esp
c00281fa:	85 c0                	test   %eax,%eax
c00281fc:	75 c2                	jne    c00281c0 <atoi+0x76>
    value = value * 10 - (*s - '0');
  if (!negative)
c00281fe:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0028202:	83 f0 01             	xor    $0x1,%eax
c0028205:	84 c0                	test   %al,%al
c0028207:	74 03                	je     c002820c <atoi+0xc2>
    value = -value;
c0028209:	f7 5d f0             	negl   -0x10(%ebp)

  return value;
c002820c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002820f:	c9                   	leave  
c0028210:	c3                   	ret    

c0028211 <compare_thunk>:

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c0028211:	55                   	push   %ebp
c0028212:	89 e5                	mov    %esp,%ebp
c0028214:	83 ec 18             	sub    $0x18,%esp
  int (**compare) (const void *, const void *) = aux;
c0028217:	8b 45 10             	mov    0x10(%ebp),%eax
c002821a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return (*compare) (a, b);
c002821d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028220:	8b 00                	mov    (%eax),%eax
c0028222:	83 ec 08             	sub    $0x8,%esp
c0028225:	ff 75 0c             	pushl  0xc(%ebp)
c0028228:	ff 75 08             	pushl  0x8(%ebp)
c002822b:	ff d0                	call   *%eax
c002822d:	83 c4 10             	add    $0x10,%esp
}
c0028230:	c9                   	leave  
c0028231:	c3                   	ret    

c0028232 <qsort>:
   zero if A > B.  Runs in O(n lg n) time and O(1) space in
   CNT. */
void
qsort (void *array, size_t cnt, size_t size,
       int (*compare) (const void *, const void *)) 
{
c0028232:	55                   	push   %ebp
c0028233:	89 e5                	mov    %esp,%ebp
c0028235:	83 ec 08             	sub    $0x8,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c0028238:	83 ec 0c             	sub    $0xc,%esp
c002823b:	8d 45 14             	lea    0x14(%ebp),%eax
c002823e:	50                   	push   %eax
c002823f:	68 11 82 02 c0       	push   $0xc0028211
c0028244:	ff 75 10             	pushl  0x10(%ebp)
c0028247:	ff 75 0c             	pushl  0xc(%ebp)
c002824a:	ff 75 08             	pushl  0x8(%ebp)
c002824d:	e8 5f 01 00 00       	call   c00283b1 <sort>
c0028252:	83 c4 20             	add    $0x20,%esp
}
c0028255:	90                   	nop
c0028256:	c9                   	leave  
c0028257:	c3                   	ret    

c0028258 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0028258:	55                   	push   %ebp
c0028259:	89 e5                	mov    %esp,%ebp
c002825b:	83 ec 10             	sub    $0x10,%esp
  unsigned char *a = array + (a_idx - 1) * size;
c002825e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028261:	83 e8 01             	sub    $0x1,%eax
c0028264:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028268:	89 c2                	mov    %eax,%edx
c002826a:	8b 45 08             	mov    0x8(%ebp),%eax
c002826d:	01 d0                	add    %edx,%eax
c002826f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned char *b = array + (b_idx - 1) * size;
c0028272:	8b 45 10             	mov    0x10(%ebp),%eax
c0028275:	83 e8 01             	sub    $0x1,%eax
c0028278:	0f af 45 14          	imul   0x14(%ebp),%eax
c002827c:	89 c2                	mov    %eax,%edx
c002827e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028281:	01 d0                	add    %edx,%eax
c0028283:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t i;

  for (i = 0; i < size; i++)
c0028286:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002828d:	eb 35                	jmp    c00282c4 <do_swap+0x6c>
    {
      unsigned char t = a[i];
c002828f:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0028292:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028295:	01 d0                	add    %edx,%eax
c0028297:	0f b6 00             	movzbl (%eax),%eax
c002829a:	88 45 f3             	mov    %al,-0xd(%ebp)
      a[i] = b[i];
c002829d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00282a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00282a3:	01 c2                	add    %eax,%edx
c00282a5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00282a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00282ab:	01 c8                	add    %ecx,%eax
c00282ad:	0f b6 00             	movzbl (%eax),%eax
c00282b0:	88 02                	mov    %al,(%edx)
      b[i] = t;
c00282b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00282b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00282b8:	01 c2                	add    %eax,%edx
c00282ba:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c00282be:	88 02                	mov    %al,(%edx)
{
  unsigned char *a = array + (a_idx - 1) * size;
  unsigned char *b = array + (b_idx - 1) * size;
  size_t i;

  for (i = 0; i < size; i++)
c00282c0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c00282c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00282c7:	3b 45 14             	cmp    0x14(%ebp),%eax
c00282ca:	72 c3                	jb     c002828f <do_swap+0x37>
    {
      unsigned char t = a[i];
      a[i] = b[i];
      b[i] = t;
    }
}
c00282cc:	90                   	nop
c00282cd:	c9                   	leave  
c00282ce:	c3                   	ret    

c00282cf <do_compare>:
   strcmp()-type result. */
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
c00282cf:	55                   	push   %ebp
c00282d0:	89 e5                	mov    %esp,%ebp
c00282d2:	83 ec 08             	sub    $0x8,%esp
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c00282d5:	8b 45 10             	mov    0x10(%ebp),%eax
c00282d8:	83 e8 01             	sub    $0x1,%eax
c00282db:	0f af 45 14          	imul   0x14(%ebp),%eax
c00282df:	89 c2                	mov    %eax,%edx
c00282e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00282e4:	01 c2                	add    %eax,%edx
c00282e6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00282e9:	83 e8 01             	sub    $0x1,%eax
c00282ec:	0f af 45 14          	imul   0x14(%ebp),%eax
c00282f0:	89 c1                	mov    %eax,%ecx
c00282f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00282f5:	01 c8                	add    %ecx,%eax
c00282f7:	83 ec 04             	sub    $0x4,%esp
c00282fa:	ff 75 1c             	pushl  0x1c(%ebp)
c00282fd:	52                   	push   %edx
c00282fe:	50                   	push   %eax
c00282ff:	8b 45 18             	mov    0x18(%ebp),%eax
c0028302:	ff d0                	call   *%eax
c0028304:	83 c4 10             	add    $0x10,%esp
}
c0028307:	c9                   	leave  
c0028308:	c3                   	ret    

c0028309 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0028309:	55                   	push   %ebp
c002830a:	89 e5                	mov    %esp,%ebp
c002830c:	83 ec 18             	sub    $0x18,%esp
  for (;;) 
    {
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
c002830f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028312:	01 c0                	add    %eax,%eax
c0028314:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t right = 2 * i + 1;
c0028317:	8b 45 0c             	mov    0xc(%ebp),%eax
c002831a:	01 c0                	add    %eax,%eax
c002831c:	83 c0 01             	add    $0x1,%eax
c002831f:	89 45 ec             	mov    %eax,-0x14(%ebp)
      size_t max = i;
c0028322:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028325:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0028328:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002832b:	3b 45 10             	cmp    0x10(%ebp),%eax
c002832e:	77 27                	ja     c0028357 <heapify+0x4e>
c0028330:	83 ec 08             	sub    $0x8,%esp
c0028333:	ff 75 1c             	pushl  0x1c(%ebp)
c0028336:	ff 75 18             	pushl  0x18(%ebp)
c0028339:	ff 75 14             	pushl  0x14(%ebp)
c002833c:	ff 75 f4             	pushl  -0xc(%ebp)
c002833f:	ff 75 f0             	pushl  -0x10(%ebp)
c0028342:	ff 75 08             	pushl  0x8(%ebp)
c0028345:	e8 85 ff ff ff       	call   c00282cf <do_compare>
c002834a:	83 c4 20             	add    $0x20,%esp
c002834d:	85 c0                	test   %eax,%eax
c002834f:	7e 06                	jle    c0028357 <heapify+0x4e>
        max = left;
c0028351:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028354:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (right <= cnt
c0028357:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002835a:	3b 45 10             	cmp    0x10(%ebp),%eax
c002835d:	77 27                	ja     c0028386 <heapify+0x7d>
          && do_compare (array, right, max, size, compare, aux) > 0) 
c002835f:	83 ec 08             	sub    $0x8,%esp
c0028362:	ff 75 1c             	pushl  0x1c(%ebp)
c0028365:	ff 75 18             	pushl  0x18(%ebp)
c0028368:	ff 75 14             	pushl  0x14(%ebp)
c002836b:	ff 75 f4             	pushl  -0xc(%ebp)
c002836e:	ff 75 ec             	pushl  -0x14(%ebp)
c0028371:	ff 75 08             	pushl  0x8(%ebp)
c0028374:	e8 56 ff ff ff       	call   c00282cf <do_compare>
c0028379:	83 c4 20             	add    $0x20,%esp
c002837c:	85 c0                	test   %eax,%eax
c002837e:	7e 06                	jle    c0028386 <heapify+0x7d>
        max = right;
c0028380:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028383:	89 45 f4             	mov    %eax,-0xc(%ebp)

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0028386:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028389:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002838c:	74 1f                	je     c00283ad <heapify+0xa4>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c002838e:	ff 75 14             	pushl  0x14(%ebp)
c0028391:	ff 75 f4             	pushl  -0xc(%ebp)
c0028394:	ff 75 0c             	pushl  0xc(%ebp)
c0028397:	ff 75 08             	pushl  0x8(%ebp)
c002839a:	e8 b9 fe ff ff       	call   c0028258 <do_swap>
c002839f:	83 c4 10             	add    $0x10,%esp
      i = max;
c00283a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00283a5:	89 45 0c             	mov    %eax,0xc(%ebp)
    }
c00283a8:	e9 62 ff ff ff       	jmp    c002830f <heapify+0x6>
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
        break;
c00283ad:	90                   	nop

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
      i = max;
    }
}
c00283ae:	90                   	nop
c00283af:	c9                   	leave  
c00283b0:	c3                   	ret    

c00283b1 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c00283b1:	55                   	push   %ebp
c00283b2:	89 e5                	mov    %esp,%ebp
c00283b4:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c00283b7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00283bb:	75 27                	jne    c00283e4 <sort+0x33>
c00283bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00283c1:	74 21                	je     c00283e4 <sort+0x33>
c00283c3:	83 ec 0c             	sub    $0xc,%esp
c00283c6:	68 d8 0a 03 c0       	push   $0xc0030ad8
c00283cb:	68 ae 0a 03 c0       	push   $0xc0030aae
c00283d0:	68 14 0b 03 c0       	push   $0xc0030b14
c00283d5:	68 8a 00 00 00       	push   $0x8a
c00283da:	68 c5 0a 03 c0       	push   $0xc0030ac5
c00283df:	e8 94 13 00 00       	call   c0029778 <debug_panic>
  ASSERT (compare != NULL);
c00283e4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c00283e8:	75 21                	jne    c002840b <sort+0x5a>
c00283ea:	83 ec 0c             	sub    $0xc,%esp
c00283ed:	68 f2 0a 03 c0       	push   $0xc0030af2
c00283f2:	68 ae 0a 03 c0       	push   $0xc0030aae
c00283f7:	68 14 0b 03 c0       	push   $0xc0030b14
c00283fc:	68 8b 00 00 00       	push   $0x8b
c0028401:	68 c5 0a 03 c0       	push   $0xc0030ac5
c0028406:	e8 6d 13 00 00       	call   c0029778 <debug_panic>
  ASSERT (size > 0);
c002840b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002840f:	75 21                	jne    c0028432 <sort+0x81>
c0028411:	83 ec 0c             	sub    $0xc,%esp
c0028414:	68 02 0b 03 c0       	push   $0xc0030b02
c0028419:	68 ae 0a 03 c0       	push   $0xc0030aae
c002841e:	68 14 0b 03 c0       	push   $0xc0030b14
c0028423:	68 8c 00 00 00       	push   $0x8c
c0028428:	68 c5 0a 03 c0       	push   $0xc0030ac5
c002842d:	e8 46 13 00 00       	call   c0029778 <debug_panic>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0028432:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028435:	d1 e8                	shr    %eax
c0028437:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002843a:	eb 21                	jmp    c002845d <sort+0xac>
    heapify (array, i, cnt, size, compare, aux);
c002843c:	83 ec 08             	sub    $0x8,%esp
c002843f:	ff 75 18             	pushl  0x18(%ebp)
c0028442:	ff 75 14             	pushl  0x14(%ebp)
c0028445:	ff 75 10             	pushl  0x10(%ebp)
c0028448:	ff 75 0c             	pushl  0xc(%ebp)
c002844b:	ff 75 f4             	pushl  -0xc(%ebp)
c002844e:	ff 75 08             	pushl  0x8(%ebp)
c0028451:	e8 b3 fe ff ff       	call   c0028309 <heapify>
c0028456:	83 c4 20             	add    $0x20,%esp
  ASSERT (array != NULL || cnt == 0);
  ASSERT (compare != NULL);
  ASSERT (size > 0);

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0028459:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c002845d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028461:	75 d9                	jne    c002843c <sort+0x8b>
    heapify (array, i, cnt, size, compare, aux);

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0028463:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028466:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028469:	eb 37                	jmp    c00284a2 <sort+0xf1>
    {
      do_swap (array, 1, i, size);
c002846b:	ff 75 10             	pushl  0x10(%ebp)
c002846e:	ff 75 f4             	pushl  -0xc(%ebp)
c0028471:	6a 01                	push   $0x1
c0028473:	ff 75 08             	pushl  0x8(%ebp)
c0028476:	e8 dd fd ff ff       	call   c0028258 <do_swap>
c002847b:	83 c4 10             	add    $0x10,%esp
      heapify (array, 1, i - 1, size, compare, aux); 
c002847e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028481:	83 e8 01             	sub    $0x1,%eax
c0028484:	83 ec 08             	sub    $0x8,%esp
c0028487:	ff 75 18             	pushl  0x18(%ebp)
c002848a:	ff 75 14             	pushl  0x14(%ebp)
c002848d:	ff 75 10             	pushl  0x10(%ebp)
c0028490:	50                   	push   %eax
c0028491:	6a 01                	push   $0x1
c0028493:	ff 75 08             	pushl  0x8(%ebp)
c0028496:	e8 6e fe ff ff       	call   c0028309 <heapify>
c002849b:	83 c4 20             	add    $0x20,%esp
  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
    heapify (array, i, cnt, size, compare, aux);

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c002849e:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c00284a2:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c00284a6:	77 c3                	ja     c002846b <sort+0xba>
    {
      do_swap (array, 1, i, size);
      heapify (array, 1, i - 1, size, compare, aux); 
    }
}
c00284a8:	90                   	nop
c00284a9:	c9                   	leave  
c00284aa:	c3                   	ret    

c00284ab <bsearch>:
   strcmp()-type result, i.e. less than zero if A < B, zero if A
   == B, greater than zero if A > B. */
void *
bsearch (const void *key, const void *array, size_t cnt,
         size_t size, int (*compare) (const void *, const void *)) 
{
c00284ab:	55                   	push   %ebp
c00284ac:	89 e5                	mov    %esp,%ebp
c00284ae:	83 ec 08             	sub    $0x8,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c00284b1:	83 ec 08             	sub    $0x8,%esp
c00284b4:	8d 45 18             	lea    0x18(%ebp),%eax
c00284b7:	50                   	push   %eax
c00284b8:	68 11 82 02 c0       	push   $0xc0028211
c00284bd:	ff 75 14             	pushl  0x14(%ebp)
c00284c0:	ff 75 10             	pushl  0x10(%ebp)
c00284c3:	ff 75 0c             	pushl  0xc(%ebp)
c00284c6:	ff 75 08             	pushl  0x8(%ebp)
c00284c9:	e8 05 00 00 00       	call   c00284d3 <binary_search>
c00284ce:	83 c4 20             	add    $0x20,%esp
}
c00284d1:	c9                   	leave  
c00284d2:	c3                   	ret    

c00284d3 <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c00284d3:	55                   	push   %ebp
c00284d4:	89 e5                	mov    %esp,%ebp
c00284d6:	83 ec 28             	sub    $0x28,%esp
  const unsigned char *first = array;
c00284d9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00284dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *last = array + size * cnt;
c00284df:	8b 45 14             	mov    0x14(%ebp),%eax
c00284e2:	0f af 45 10          	imul   0x10(%ebp),%eax
c00284e6:	89 c2                	mov    %eax,%edx
c00284e8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00284eb:	01 d0                	add    %edx,%eax
c00284ed:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while (first < last) 
c00284f0:	eb 65                	jmp    c0028557 <binary_search+0x84>
    {
      size_t range = (last - first) / size;
c00284f2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00284f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00284f8:	29 c2                	sub    %eax,%edx
c00284fa:	89 d0                	mov    %edx,%eax
c00284fc:	ba 00 00 00 00       	mov    $0x0,%edx
c0028501:	f7 75 14             	divl   0x14(%ebp)
c0028504:	89 45 ec             	mov    %eax,-0x14(%ebp)
      const unsigned char *middle = first + (range / 2) * size;
c0028507:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002850a:	d1 e8                	shr    %eax
c002850c:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028510:	89 c2                	mov    %eax,%edx
c0028512:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028515:	01 d0                	add    %edx,%eax
c0028517:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int cmp = compare (key, middle, aux);
c002851a:	83 ec 04             	sub    $0x4,%esp
c002851d:	ff 75 1c             	pushl  0x1c(%ebp)
c0028520:	ff 75 e8             	pushl  -0x18(%ebp)
c0028523:	ff 75 08             	pushl  0x8(%ebp)
c0028526:	8b 45 18             	mov    0x18(%ebp),%eax
c0028529:	ff d0                	call   *%eax
c002852b:	83 c4 10             	add    $0x10,%esp
c002852e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if (cmp < 0) 
c0028531:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028535:	79 08                	jns    c002853f <binary_search+0x6c>
        last = middle;
c0028537:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002853a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002853d:	eb 18                	jmp    c0028557 <binary_search+0x84>
      else if (cmp > 0) 
c002853f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028543:	7e 0d                	jle    c0028552 <binary_search+0x7f>
        first = middle + size;
c0028545:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0028548:	8b 45 14             	mov    0x14(%ebp),%eax
c002854b:	01 d0                	add    %edx,%eax
c002854d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028550:	eb 05                	jmp    c0028557 <binary_search+0x84>
      else
        return (void *) middle;
c0028552:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028555:	eb 0d                	jmp    c0028564 <binary_search+0x91>
               void *aux) 
{
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;

  while (first < last) 
c0028557:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002855a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002855d:	72 93                	jb     c00284f2 <binary_search+0x1f>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c002855f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028564:	c9                   	leave  
c0028565:	c3                   	ret    

c0028566 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c0028566:	55                   	push   %ebp
c0028567:	89 e5                	mov    %esp,%ebp
c0028569:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c002856c:	8b 45 08             	mov    0x8(%ebp),%eax
c002856f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c0028572:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028575:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028578:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002857c:	75 24                	jne    c00285a2 <memcpy+0x3c>
c002857e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028582:	74 1e                	je     c00285a2 <memcpy+0x3c>
c0028584:	83 ec 0c             	sub    $0xc,%esp
c0028587:	68 1c 0b 03 c0       	push   $0xc0030b1c
c002858c:	68 35 0b 03 c0       	push   $0xc0030b35
c0028591:	68 2c 0c 03 c0       	push   $0xc0030c2c
c0028596:	6a 0c                	push   $0xc
c0028598:	68 4c 0b 03 c0       	push   $0xc0030b4c
c002859d:	e8 d6 11 00 00       	call   c0029778 <debug_panic>
  ASSERT (src != NULL || size == 0);
c00285a2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00285a6:	75 3b                	jne    c00285e3 <memcpy+0x7d>
c00285a8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00285ac:	74 35                	je     c00285e3 <memcpy+0x7d>
c00285ae:	83 ec 0c             	sub    $0xc,%esp
c00285b1:	68 5f 0b 03 c0       	push   $0xc0030b5f
c00285b6:	68 35 0b 03 c0       	push   $0xc0030b35
c00285bb:	68 2c 0c 03 c0       	push   $0xc0030c2c
c00285c0:	6a 0d                	push   $0xd
c00285c2:	68 4c 0b 03 c0       	push   $0xc0030b4c
c00285c7:	e8 ac 11 00 00       	call   c0029778 <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
c00285cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285cf:	8d 50 01             	lea    0x1(%eax),%edx
c00285d2:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00285d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00285d8:	8d 4a 01             	lea    0x1(%edx),%ecx
c00285db:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c00285de:	0f b6 12             	movzbl (%edx),%edx
c00285e1:	88 10                	mov    %dl,(%eax)
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c00285e3:	8b 45 10             	mov    0x10(%ebp),%eax
c00285e6:	8d 50 ff             	lea    -0x1(%eax),%edx
c00285e9:	89 55 10             	mov    %edx,0x10(%ebp)
c00285ec:	85 c0                	test   %eax,%eax
c00285ee:	75 dc                	jne    c00285cc <memcpy+0x66>
    *dst++ = *src++;

  return dst_;
c00285f0:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00285f3:	c9                   	leave  
c00285f4:	c3                   	ret    

c00285f5 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c00285f5:	55                   	push   %ebp
c00285f6:	89 e5                	mov    %esp,%ebp
c00285f8:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c00285fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00285fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c0028601:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028604:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028607:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002860b:	75 24                	jne    c0028631 <memmove+0x3c>
c002860d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028611:	74 1e                	je     c0028631 <memmove+0x3c>
c0028613:	83 ec 0c             	sub    $0xc,%esp
c0028616:	68 1c 0b 03 c0       	push   $0xc0030b1c
c002861b:	68 35 0b 03 c0       	push   $0xc0030b35
c0028620:	68 34 0c 03 c0       	push   $0xc0030c34
c0028625:	6a 1d                	push   $0x1d
c0028627:	68 4c 0b 03 c0       	push   $0xc0030b4c
c002862c:	e8 47 11 00 00       	call   c0029778 <debug_panic>
  ASSERT (src != NULL || size == 0);
c0028631:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028635:	75 24                	jne    c002865b <memmove+0x66>
c0028637:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002863b:	74 1e                	je     c002865b <memmove+0x66>
c002863d:	83 ec 0c             	sub    $0xc,%esp
c0028640:	68 5f 0b 03 c0       	push   $0xc0030b5f
c0028645:	68 35 0b 03 c0       	push   $0xc0030b35
c002864a:	68 34 0c 03 c0       	push   $0xc0030c34
c002864f:	6a 1e                	push   $0x1e
c0028651:	68 4c 0b 03 c0       	push   $0xc0030b4c
c0028656:	e8 1d 11 00 00       	call   c0029778 <debug_panic>

  if (dst < src) 
c002865b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002865e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028661:	73 28                	jae    c002868b <memmove+0x96>
    {
      while (size-- > 0)
c0028663:	eb 17                	jmp    c002867c <memmove+0x87>
        *dst++ = *src++;
c0028665:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028668:	8d 50 01             	lea    0x1(%eax),%edx
c002866b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002866e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028671:	8d 4a 01             	lea    0x1(%edx),%ecx
c0028674:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028677:	0f b6 12             	movzbl (%edx),%edx
c002867a:	88 10                	mov    %dl,(%eax)
  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
    {
      while (size-- > 0)
c002867c:	8b 45 10             	mov    0x10(%ebp),%eax
c002867f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028682:	89 55 10             	mov    %edx,0x10(%ebp)
c0028685:	85 c0                	test   %eax,%eax
c0028687:	75 dc                	jne    c0028665 <memmove+0x70>
c0028689:	eb 2e                	jmp    c00286b9 <memmove+0xc4>
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
c002868b:	8b 45 10             	mov    0x10(%ebp),%eax
c002868e:	01 45 f4             	add    %eax,-0xc(%ebp)
      src += size;
c0028691:	8b 45 10             	mov    0x10(%ebp),%eax
c0028694:	01 45 f0             	add    %eax,-0x10(%ebp)
      while (size-- > 0)
c0028697:	eb 13                	jmp    c00286ac <memmove+0xb7>
        *--dst = *--src;
c0028699:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c002869d:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c00286a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00286a4:	0f b6 10             	movzbl (%eax),%edx
c00286a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286aa:	88 10                	mov    %dl,(%eax)
    }
  else 
    {
      dst += size;
      src += size;
      while (size-- > 0)
c00286ac:	8b 45 10             	mov    0x10(%ebp),%eax
c00286af:	8d 50 ff             	lea    -0x1(%eax),%edx
c00286b2:	89 55 10             	mov    %edx,0x10(%ebp)
c00286b5:	85 c0                	test   %eax,%eax
c00286b7:	75 e0                	jne    c0028699 <memmove+0xa4>
        *--dst = *--src;
    }

  return dst;
c00286b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00286bc:	c9                   	leave  
c00286bd:	c3                   	ret    

c00286be <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c00286be:	55                   	push   %ebp
c00286bf:	89 e5                	mov    %esp,%ebp
c00286c1:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = a_;
c00286c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00286c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = b_;
c00286ca:	8b 45 0c             	mov    0xc(%ebp),%eax
c00286cd:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL || size == 0);
c00286d0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00286d4:	75 24                	jne    c00286fa <memcmp+0x3c>
c00286d6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00286da:	74 1e                	je     c00286fa <memcmp+0x3c>
c00286dc:	83 ec 0c             	sub    $0xc,%esp
c00286df:	68 78 0b 03 c0       	push   $0xc0030b78
c00286e4:	68 35 0b 03 c0       	push   $0xc0030b35
c00286e9:	68 3c 0c 03 c0       	push   $0xc0030c3c
c00286ee:	6a 3a                	push   $0x3a
c00286f0:	68 4c 0b 03 c0       	push   $0xc0030b4c
c00286f5:	e8 7e 10 00 00       	call   c0029778 <debug_panic>
  ASSERT (b != NULL || size == 0);
c00286fa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00286fe:	75 5a                	jne    c002875a <memcmp+0x9c>
c0028700:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028704:	74 54                	je     c002875a <memcmp+0x9c>
c0028706:	83 ec 0c             	sub    $0xc,%esp
c0028709:	68 8f 0b 03 c0       	push   $0xc0030b8f
c002870e:	68 35 0b 03 c0       	push   $0xc0030b35
c0028713:	68 3c 0c 03 c0       	push   $0xc0030c3c
c0028718:	6a 3b                	push   $0x3b
c002871a:	68 4c 0b 03 c0       	push   $0xc0030b4c
c002871f:	e8 54 10 00 00       	call   c0029778 <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
c0028724:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028727:	0f b6 10             	movzbl (%eax),%edx
c002872a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002872d:	0f b6 00             	movzbl (%eax),%eax
c0028730:	38 c2                	cmp    %al,%dl
c0028732:	74 1e                	je     c0028752 <memcmp+0x94>
      return *a > *b ? +1 : -1;
c0028734:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028737:	0f b6 10             	movzbl (%eax),%edx
c002873a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002873d:	0f b6 00             	movzbl (%eax),%eax
c0028740:	38 c2                	cmp    %al,%dl
c0028742:	76 07                	jbe    c002874b <memcmp+0x8d>
c0028744:	b8 01 00 00 00       	mov    $0x1,%eax
c0028749:	eb 21                	jmp    c002876c <memcmp+0xae>
c002874b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0028750:	eb 1a                	jmp    c002876c <memcmp+0xae>
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c0028752:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028756:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002875a:	8b 45 10             	mov    0x10(%ebp),%eax
c002875d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028760:	89 55 10             	mov    %edx,0x10(%ebp)
c0028763:	85 c0                	test   %eax,%eax
c0028765:	75 bd                	jne    c0028724 <memcmp+0x66>
    if (*a != *b)
      return *a > *b ? +1 : -1;
  return 0;
c0028767:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002876c:	c9                   	leave  
c002876d:	c3                   	ret    

c002876e <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c002876e:	55                   	push   %ebp
c002876f:	89 e5                	mov    %esp,%ebp
c0028771:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = (const unsigned char *) a_;
c0028774:	8b 45 08             	mov    0x8(%ebp),%eax
c0028777:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = (const unsigned char *) b_;
c002877a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002877d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL);
c0028780:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028784:	75 1e                	jne    c00287a4 <strcmp+0x36>
c0028786:	83 ec 0c             	sub    $0xc,%esp
c0028789:	68 a6 0b 03 c0       	push   $0xc0030ba6
c002878e:	68 35 0b 03 c0       	push   $0xc0030b35
c0028793:	68 44 0c 03 c0       	push   $0xc0030c44
c0028798:	6a 4e                	push   $0x4e
c002879a:	68 4c 0b 03 c0       	push   $0xc0030b4c
c002879f:	e8 d4 0f 00 00       	call   c0029778 <debug_panic>
  ASSERT (b != NULL);
c00287a4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00287a8:	75 26                	jne    c00287d0 <strcmp+0x62>
c00287aa:	83 ec 0c             	sub    $0xc,%esp
c00287ad:	68 b0 0b 03 c0       	push   $0xc0030bb0
c00287b2:	68 35 0b 03 c0       	push   $0xc0030b35
c00287b7:	68 44 0c 03 c0       	push   $0xc0030c44
c00287bc:	6a 4f                	push   $0x4f
c00287be:	68 4c 0b 03 c0       	push   $0xc0030b4c
c00287c3:	e8 b0 0f 00 00       	call   c0029778 <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
c00287c8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      b++;
c00287cc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c00287d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287d3:	0f b6 00             	movzbl (%eax),%eax
c00287d6:	84 c0                	test   %al,%al
c00287d8:	74 10                	je     c00287ea <strcmp+0x7c>
c00287da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287dd:	0f b6 10             	movzbl (%eax),%edx
c00287e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00287e3:	0f b6 00             	movzbl (%eax),%eax
c00287e6:	38 c2                	cmp    %al,%dl
c00287e8:	74 de                	je     c00287c8 <strcmp+0x5a>
    {
      a++;
      b++;
    }

  return *a < *b ? -1 : *a > *b;
c00287ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287ed:	0f b6 10             	movzbl (%eax),%edx
c00287f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00287f3:	0f b6 00             	movzbl (%eax),%eax
c00287f6:	38 c2                	cmp    %al,%dl
c00287f8:	72 16                	jb     c0028810 <strcmp+0xa2>
c00287fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287fd:	0f b6 10             	movzbl (%eax),%edx
c0028800:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028803:	0f b6 00             	movzbl (%eax),%eax
c0028806:	38 c2                	cmp    %al,%dl
c0028808:	0f 97 c0             	seta   %al
c002880b:	0f b6 c0             	movzbl %al,%eax
c002880e:	eb 05                	jmp    c0028815 <strcmp+0xa7>
c0028810:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0028815:	c9                   	leave  
c0028816:	c3                   	ret    

c0028817 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c0028817:	55                   	push   %ebp
c0028818:	89 e5                	mov    %esp,%ebp
c002881a:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *block = block_;
c002881d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028820:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned char ch = ch_;
c0028823:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028826:	88 45 f3             	mov    %al,-0xd(%ebp)

  ASSERT (block != NULL || size == 0);
c0028829:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002882d:	75 38                	jne    c0028867 <memchr+0x50>
c002882f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028833:	74 32                	je     c0028867 <memchr+0x50>
c0028835:	83 ec 0c             	sub    $0xc,%esp
c0028838:	68 ba 0b 03 c0       	push   $0xc0030bba
c002883d:	68 35 0b 03 c0       	push   $0xc0030b35
c0028842:	68 4c 0c 03 c0       	push   $0xc0030c4c
c0028847:	6a 63                	push   $0x63
c0028849:	68 4c 0b 03 c0       	push   $0xc0030b4c
c002884e:	e8 25 0f 00 00       	call   c0029778 <debug_panic>

  for (; size-- > 0; block++)
    if (*block == ch)
c0028853:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028856:	0f b6 00             	movzbl (%eax),%eax
c0028859:	3a 45 f3             	cmp    -0xd(%ebp),%al
c002885c:	75 05                	jne    c0028863 <memchr+0x4c>
      return (void *) block;
c002885e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028861:	eb 16                	jmp    c0028879 <memchr+0x62>
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c0028863:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028867:	8b 45 10             	mov    0x10(%ebp),%eax
c002886a:	8d 50 ff             	lea    -0x1(%eax),%edx
c002886d:	89 55 10             	mov    %edx,0x10(%ebp)
c0028870:	85 c0                	test   %eax,%eax
c0028872:	75 df                	jne    c0028853 <memchr+0x3c>
    if (*block == ch)
      return (void *) block;

  return NULL;
c0028874:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028879:	c9                   	leave  
c002887a:	c3                   	ret    

c002887b <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c002887b:	55                   	push   %ebp
c002887c:	89 e5                	mov    %esp,%ebp
c002887e:	83 ec 18             	sub    $0x18,%esp
  char c = c_;
c0028881:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028884:	88 45 f7             	mov    %al,-0x9(%ebp)

  ASSERT (string != NULL);
c0028887:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002888b:	75 1e                	jne    c00288ab <strchr+0x30>
c002888d:	83 ec 0c             	sub    $0xc,%esp
c0028890:	68 d5 0b 03 c0       	push   $0xc0030bd5
c0028895:	68 35 0b 03 c0       	push   $0xc0030b35
c002889a:	68 54 0c 03 c0       	push   $0xc0030c54
c002889f:	6a 75                	push   $0x75
c00288a1:	68 4c 0b 03 c0       	push   $0xc0030b4c
c00288a6:	e8 cd 0e 00 00       	call   c0029778 <debug_panic>

  for (;;) 
    if (*string == c)
c00288ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00288ae:	0f b6 00             	movzbl (%eax),%eax
c00288b1:	3a 45 f7             	cmp    -0x9(%ebp),%al
c00288b4:	75 05                	jne    c00288bb <strchr+0x40>
      return (char *) string;
c00288b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00288b9:	eb 17                	jmp    c00288d2 <strchr+0x57>
    else if (*string == '\0')
c00288bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00288be:	0f b6 00             	movzbl (%eax),%eax
c00288c1:	84 c0                	test   %al,%al
c00288c3:	75 07                	jne    c00288cc <strchr+0x51>
      return NULL;
c00288c5:	b8 00 00 00 00       	mov    $0x0,%eax
c00288ca:	eb 06                	jmp    c00288d2 <strchr+0x57>
    else
      string++;
c00288cc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c00288d0:	eb d9                	jmp    c00288ab <strchr+0x30>
}
c00288d2:	c9                   	leave  
c00288d3:	c3                   	ret    

c00288d4 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c00288d4:	55                   	push   %ebp
c00288d5:	89 e5                	mov    %esp,%ebp
c00288d7:	83 ec 18             	sub    $0x18,%esp
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c00288da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00288e1:	eb 25                	jmp    c0028908 <strcspn+0x34>
    if (strchr (stop, string[length]) != NULL)
c00288e3:	8b 55 08             	mov    0x8(%ebp),%edx
c00288e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00288e9:	01 d0                	add    %edx,%eax
c00288eb:	0f b6 00             	movzbl (%eax),%eax
c00288ee:	0f be c0             	movsbl %al,%eax
c00288f1:	83 ec 08             	sub    $0x8,%esp
c00288f4:	50                   	push   %eax
c00288f5:	ff 75 0c             	pushl  0xc(%ebp)
c00288f8:	e8 7e ff ff ff       	call   c002887b <strchr>
c00288fd:	83 c4 10             	add    $0x10,%esp
c0028900:	85 c0                	test   %eax,%eax
c0028902:	75 15                	jne    c0028919 <strcspn+0x45>
size_t
strcspn (const char *string, const char *stop) 
{
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0028904:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028908:	8b 55 08             	mov    0x8(%ebp),%edx
c002890b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002890e:	01 d0                	add    %edx,%eax
c0028910:	0f b6 00             	movzbl (%eax),%eax
c0028913:	84 c0                	test   %al,%al
c0028915:	75 cc                	jne    c00288e3 <strcspn+0xf>
c0028917:	eb 01                	jmp    c002891a <strcspn+0x46>
    if (strchr (stop, string[length]) != NULL)
      break;
c0028919:	90                   	nop
  return length;
c002891a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002891d:	c9                   	leave  
c002891e:	c3                   	ret    

c002891f <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c002891f:	55                   	push   %ebp
c0028920:	89 e5                	mov    %esp,%ebp
c0028922:	83 ec 08             	sub    $0x8,%esp
  for (; *string != '\0'; string++)
c0028925:	eb 25                	jmp    c002894c <strpbrk+0x2d>
    if (strchr (stop, *string) != NULL)
c0028927:	8b 45 08             	mov    0x8(%ebp),%eax
c002892a:	0f b6 00             	movzbl (%eax),%eax
c002892d:	0f be c0             	movsbl %al,%eax
c0028930:	83 ec 08             	sub    $0x8,%esp
c0028933:	50                   	push   %eax
c0028934:	ff 75 0c             	pushl  0xc(%ebp)
c0028937:	e8 3f ff ff ff       	call   c002887b <strchr>
c002893c:	83 c4 10             	add    $0x10,%esp
c002893f:	85 c0                	test   %eax,%eax
c0028941:	74 05                	je     c0028948 <strpbrk+0x29>
      return (char *) string;
c0028943:	8b 45 08             	mov    0x8(%ebp),%eax
c0028946:	eb 13                	jmp    c002895b <strpbrk+0x3c>
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
  for (; *string != '\0'; string++)
c0028948:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c002894c:	8b 45 08             	mov    0x8(%ebp),%eax
c002894f:	0f b6 00             	movzbl (%eax),%eax
c0028952:	84 c0                	test   %al,%al
c0028954:	75 d1                	jne    c0028927 <strpbrk+0x8>
    if (strchr (stop, *string) != NULL)
      return (char *) string;
  return NULL;
c0028956:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002895b:	c9                   	leave  
c002895c:	c3                   	ret    

c002895d <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c002895d:	55                   	push   %ebp
c002895e:	89 e5                	mov    %esp,%ebp
c0028960:	83 ec 10             	sub    $0x10,%esp
  char c = c_;
c0028963:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028966:	88 45 fb             	mov    %al,-0x5(%ebp)
  const char *p = NULL;
c0028969:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (; *string != '\0'; string++)
c0028970:	eb 15                	jmp    c0028987 <strrchr+0x2a>
    if (*string == c)
c0028972:	8b 45 08             	mov    0x8(%ebp),%eax
c0028975:	0f b6 00             	movzbl (%eax),%eax
c0028978:	3a 45 fb             	cmp    -0x5(%ebp),%al
c002897b:	75 06                	jne    c0028983 <strrchr+0x26>
      p = string;
c002897d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028980:	89 45 fc             	mov    %eax,-0x4(%ebp)
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;

  for (; *string != '\0'; string++)
c0028983:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0028987:	8b 45 08             	mov    0x8(%ebp),%eax
c002898a:	0f b6 00             	movzbl (%eax),%eax
c002898d:	84 c0                	test   %al,%al
c002898f:	75 e1                	jne    c0028972 <strrchr+0x15>
    if (*string == c)
      p = string;
  return (char *) p;
c0028991:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028994:	c9                   	leave  
c0028995:	c3                   	ret    

c0028996 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c0028996:	55                   	push   %ebp
c0028997:	89 e5                	mov    %esp,%ebp
c0028999:	83 ec 18             	sub    $0x18,%esp
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c002899c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00289a3:	eb 25                	jmp    c00289ca <strspn+0x34>
    if (strchr (skip, string[length]) == NULL)
c00289a5:	8b 55 08             	mov    0x8(%ebp),%edx
c00289a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00289ab:	01 d0                	add    %edx,%eax
c00289ad:	0f b6 00             	movzbl (%eax),%eax
c00289b0:	0f be c0             	movsbl %al,%eax
c00289b3:	83 ec 08             	sub    $0x8,%esp
c00289b6:	50                   	push   %eax
c00289b7:	ff 75 0c             	pushl  0xc(%ebp)
c00289ba:	e8 bc fe ff ff       	call   c002887b <strchr>
c00289bf:	83 c4 10             	add    $0x10,%esp
c00289c2:	85 c0                	test   %eax,%eax
c00289c4:	74 15                	je     c00289db <strspn+0x45>
size_t
strspn (const char *string, const char *skip) 
{
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c00289c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00289ca:	8b 55 08             	mov    0x8(%ebp),%edx
c00289cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00289d0:	01 d0                	add    %edx,%eax
c00289d2:	0f b6 00             	movzbl (%eax),%eax
c00289d5:	84 c0                	test   %al,%al
c00289d7:	75 cc                	jne    c00289a5 <strspn+0xf>
c00289d9:	eb 01                	jmp    c00289dc <strspn+0x46>
    if (strchr (skip, string[length]) == NULL)
      break;
c00289db:	90                   	nop
  return length;
c00289dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00289df:	c9                   	leave  
c00289e0:	c3                   	ret    

c00289e1 <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
c00289e1:	55                   	push   %ebp
c00289e2:	89 e5                	mov    %esp,%ebp
c00289e4:	83 ec 18             	sub    $0x18,%esp
  size_t haystack_len = strlen (haystack);
c00289e7:	83 ec 0c             	sub    $0xc,%esp
c00289ea:	ff 75 08             	pushl  0x8(%ebp)
c00289ed:	e8 d3 01 00 00       	call   c0028bc5 <strlen>
c00289f2:	83 c4 10             	add    $0x10,%esp
c00289f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t needle_len = strlen (needle);
c00289f8:	83 ec 0c             	sub    $0xc,%esp
c00289fb:	ff 75 0c             	pushl  0xc(%ebp)
c00289fe:	e8 c2 01 00 00       	call   c0028bc5 <strlen>
c0028a03:	83 c4 10             	add    $0x10,%esp
c0028a06:	89 45 ec             	mov    %eax,-0x14(%ebp)

  if (haystack_len >= needle_len) 
c0028a09:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028a0c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0028a0f:	72 40                	jb     c0028a51 <strstr+0x70>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c0028a11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028a18:	eb 2c                	jmp    c0028a46 <strstr+0x65>
        if (!memcmp (haystack + i, needle, needle_len))
c0028a1a:	8b 55 08             	mov    0x8(%ebp),%edx
c0028a1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028a20:	01 d0                	add    %edx,%eax
c0028a22:	83 ec 04             	sub    $0x4,%esp
c0028a25:	ff 75 ec             	pushl  -0x14(%ebp)
c0028a28:	ff 75 0c             	pushl  0xc(%ebp)
c0028a2b:	50                   	push   %eax
c0028a2c:	e8 8d fc ff ff       	call   c00286be <memcmp>
c0028a31:	83 c4 10             	add    $0x10,%esp
c0028a34:	85 c0                	test   %eax,%eax
c0028a36:	75 0a                	jne    c0028a42 <strstr+0x61>
          return (char *) haystack + i;
c0028a38:	8b 55 08             	mov    0x8(%ebp),%edx
c0028a3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028a3e:	01 d0                	add    %edx,%eax
c0028a40:	eb 14                	jmp    c0028a56 <strstr+0x75>

  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c0028a42:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028a46:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028a49:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028a4c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028a4f:	73 c9                	jae    c0028a1a <strstr+0x39>
        if (!memcmp (haystack + i, needle, needle_len))
          return (char *) haystack + i;
    }

  return NULL;
c0028a51:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028a56:	c9                   	leave  
c0028a57:	c3                   	ret    

c0028a58 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c0028a58:	55                   	push   %ebp
c0028a59:	89 e5                	mov    %esp,%ebp
c0028a5b:	83 ec 18             	sub    $0x18,%esp
  char *token;
  
  ASSERT (delimiters != NULL);
c0028a5e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028a62:	75 21                	jne    c0028a85 <strtok_r+0x2d>
c0028a64:	83 ec 0c             	sub    $0xc,%esp
c0028a67:	68 e4 0b 03 c0       	push   $0xc0030be4
c0028a6c:	68 35 0b 03 c0       	push   $0xc0030b35
c0028a71:	68 5c 0c 03 c0       	push   $0xc0030c5c
c0028a76:	68 ef 00 00 00       	push   $0xef
c0028a7b:	68 4c 0b 03 c0       	push   $0xc0030b4c
c0028a80:	e8 f3 0c 00 00       	call   c0029778 <debug_panic>
  ASSERT (save_ptr != NULL);
c0028a85:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028a89:	75 21                	jne    c0028aac <strtok_r+0x54>
c0028a8b:	83 ec 0c             	sub    $0xc,%esp
c0028a8e:	68 f7 0b 03 c0       	push   $0xc0030bf7
c0028a93:	68 35 0b 03 c0       	push   $0xc0030b35
c0028a98:	68 5c 0c 03 c0       	push   $0xc0030c5c
c0028a9d:	68 f0 00 00 00       	push   $0xf0
c0028aa2:	68 4c 0b 03 c0       	push   $0xc0030b4c
c0028aa7:	e8 cc 0c 00 00       	call   c0029778 <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0028aac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028ab0:	75 08                	jne    c0028aba <strtok_r+0x62>
    s = *save_ptr;
c0028ab2:	8b 45 10             	mov    0x10(%ebp),%eax
c0028ab5:	8b 00                	mov    (%eax),%eax
c0028ab7:	89 45 08             	mov    %eax,0x8(%ebp)
  ASSERT (s != NULL);
c0028aba:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028abe:	75 3e                	jne    c0028afe <strtok_r+0xa6>
c0028ac0:	83 ec 0c             	sub    $0xc,%esp
c0028ac3:	68 08 0c 03 c0       	push   $0xc0030c08
c0028ac8:	68 35 0b 03 c0       	push   $0xc0030b35
c0028acd:	68 5c 0c 03 c0       	push   $0xc0030c5c
c0028ad2:	68 f6 00 00 00       	push   $0xf6
c0028ad7:	68 4c 0b 03 c0       	push   $0xc0030b4c
c0028adc:	e8 97 0c 00 00       	call   c0029778 <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0028ae1:	8b 45 08             	mov    0x8(%ebp),%eax
c0028ae4:	0f b6 00             	movzbl (%eax),%eax
c0028ae7:	84 c0                	test   %al,%al
c0028ae9:	75 0f                	jne    c0028afa <strtok_r+0xa2>
        {
          *save_ptr = s;
c0028aeb:	8b 45 10             	mov    0x10(%ebp),%eax
c0028aee:	8b 55 08             	mov    0x8(%ebp),%edx
c0028af1:	89 10                	mov    %edx,(%eax)
          return NULL;
c0028af3:	b8 00 00 00 00       	mov    $0x0,%eax
c0028af8:	eb 70                	jmp    c0028b6a <strtok_r+0x112>
        }

      s++;
c0028afa:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  if (s == NULL)
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c0028afe:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b01:	0f b6 00             	movzbl (%eax),%eax
c0028b04:	0f be c0             	movsbl %al,%eax
c0028b07:	83 ec 08             	sub    $0x8,%esp
c0028b0a:	50                   	push   %eax
c0028b0b:	ff 75 0c             	pushl  0xc(%ebp)
c0028b0e:	e8 68 fd ff ff       	call   c002887b <strchr>
c0028b13:	83 c4 10             	add    $0x10,%esp
c0028b16:	85 c0                	test   %eax,%eax
c0028b18:	75 c7                	jne    c0028ae1 <strtok_r+0x89>

      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
c0028b1a:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (strchr (delimiters, *s) == NULL)
c0028b20:	eb 04                	jmp    c0028b26 <strtok_r+0xce>
    s++;
c0028b22:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
c0028b26:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b29:	0f b6 00             	movzbl (%eax),%eax
c0028b2c:	0f be c0             	movsbl %al,%eax
c0028b2f:	83 ec 08             	sub    $0x8,%esp
c0028b32:	50                   	push   %eax
c0028b33:	ff 75 0c             	pushl  0xc(%ebp)
c0028b36:	e8 40 fd ff ff       	call   c002887b <strchr>
c0028b3b:	83 c4 10             	add    $0x10,%esp
c0028b3e:	85 c0                	test   %eax,%eax
c0028b40:	74 e0                	je     c0028b22 <strtok_r+0xca>
    s++;
  if (*s != '\0') 
c0028b42:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b45:	0f b6 00             	movzbl (%eax),%eax
c0028b48:	84 c0                	test   %al,%al
c0028b4a:	74 13                	je     c0028b5f <strtok_r+0x107>
    {
      *s = '\0';
c0028b4c:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b4f:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c0028b52:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b55:	8d 50 01             	lea    0x1(%eax),%edx
c0028b58:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b5b:	89 10                	mov    %edx,(%eax)
c0028b5d:	eb 08                	jmp    c0028b67 <strtok_r+0x10f>
    }
  else 
    *save_ptr = s;
c0028b5f:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b62:	8b 55 08             	mov    0x8(%ebp),%edx
c0028b65:	89 10                	mov    %edx,(%eax)
  return token;
c0028b67:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028b6a:	c9                   	leave  
c0028b6b:	c3                   	ret    

c0028b6c <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0028b6c:	55                   	push   %ebp
c0028b6d:	89 e5                	mov    %esp,%ebp
c0028b6f:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028b72:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b75:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028b78:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028b7c:	75 35                	jne    c0028bb3 <memset+0x47>
c0028b7e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028b82:	74 2f                	je     c0028bb3 <memset+0x47>
c0028b84:	83 ec 0c             	sub    $0xc,%esp
c0028b87:	68 1c 0b 03 c0       	push   $0xc0030b1c
c0028b8c:	68 35 0b 03 c0       	push   $0xc0030b35
c0028b91:	68 68 0c 03 c0       	push   $0xc0030c68
c0028b96:	68 1b 01 00 00       	push   $0x11b
c0028b9b:	68 4c 0b 03 c0       	push   $0xc0030b4c
c0028ba0:	e8 d3 0b 00 00       	call   c0029778 <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
c0028ba5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028ba8:	8d 50 01             	lea    0x1(%eax),%edx
c0028bab:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028bae:	8b 55 0c             	mov    0xc(%ebp),%edx
c0028bb1:	88 10                	mov    %dl,(%eax)
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c0028bb3:	8b 45 10             	mov    0x10(%ebp),%eax
c0028bb6:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028bb9:	89 55 10             	mov    %edx,0x10(%ebp)
c0028bbc:	85 c0                	test   %eax,%eax
c0028bbe:	75 e5                	jne    c0028ba5 <memset+0x39>
    *dst++ = value;

  return dst_;
c0028bc0:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0028bc3:	c9                   	leave  
c0028bc4:	c3                   	ret    

c0028bc5 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0028bc5:	55                   	push   %ebp
c0028bc6:	89 e5                	mov    %esp,%ebp
c0028bc8:	83 ec 18             	sub    $0x18,%esp
  const char *p;

  ASSERT (string != NULL);
c0028bcb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028bcf:	75 21                	jne    c0028bf2 <strlen+0x2d>
c0028bd1:	83 ec 0c             	sub    $0xc,%esp
c0028bd4:	68 d5 0b 03 c0       	push   $0xc0030bd5
c0028bd9:	68 35 0b 03 c0       	push   $0xc0030b35
c0028bde:	68 70 0c 03 c0       	push   $0xc0030c70
c0028be3:	68 29 01 00 00       	push   $0x129
c0028be8:	68 4c 0b 03 c0       	push   $0xc0030b4c
c0028bed:	e8 86 0b 00 00       	call   c0029778 <debug_panic>

  for (p = string; *p != '\0'; p++)
c0028bf2:	8b 45 08             	mov    0x8(%ebp),%eax
c0028bf5:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028bf8:	eb 04                	jmp    c0028bfe <strlen+0x39>
c0028bfa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028bfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c01:	0f b6 00             	movzbl (%eax),%eax
c0028c04:	84 c0                	test   %al,%al
c0028c06:	75 f2                	jne    c0028bfa <strlen+0x35>
    continue;
  return p - string;
c0028c08:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0028c0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c0e:	29 c2                	sub    %eax,%edx
c0028c10:	89 d0                	mov    %edx,%eax
}
c0028c12:	c9                   	leave  
c0028c13:	c3                   	ret    

c0028c14 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c0028c14:	55                   	push   %ebp
c0028c15:	89 e5                	mov    %esp,%ebp
c0028c17:	83 ec 10             	sub    $0x10,%esp
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0028c1a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0028c21:	eb 04                	jmp    c0028c27 <strnlen+0x13>
c0028c23:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0028c27:	8b 55 08             	mov    0x8(%ebp),%edx
c0028c2a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028c2d:	01 d0                	add    %edx,%eax
c0028c2f:	0f b6 00             	movzbl (%eax),%eax
c0028c32:	84 c0                	test   %al,%al
c0028c34:	74 08                	je     c0028c3e <strnlen+0x2a>
c0028c36:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028c39:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028c3c:	72 e5                	jb     c0028c23 <strnlen+0xf>
    continue;
  return length;
c0028c3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028c41:	c9                   	leave  
c0028c42:	c3                   	ret    

c0028c43 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c0028c43:	55                   	push   %ebp
c0028c44:	89 e5                	mov    %esp,%ebp
c0028c46:	83 ec 18             	sub    $0x18,%esp
  size_t src_len;

  ASSERT (dst != NULL);
c0028c49:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028c4d:	75 21                	jne    c0028c70 <strlcpy+0x2d>
c0028c4f:	83 ec 0c             	sub    $0xc,%esp
c0028c52:	68 12 0c 03 c0       	push   $0xc0030c12
c0028c57:	68 35 0b 03 c0       	push   $0xc0030b35
c0028c5c:	68 78 0c 03 c0       	push   $0xc0030c78
c0028c61:	68 4a 01 00 00       	push   $0x14a
c0028c66:	68 4c 0b 03 c0       	push   $0xc0030b4c
c0028c6b:	e8 08 0b 00 00       	call   c0029778 <debug_panic>
  ASSERT (src != NULL);
c0028c70:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028c74:	75 21                	jne    c0028c97 <strlcpy+0x54>
c0028c76:	83 ec 0c             	sub    $0xc,%esp
c0028c79:	68 1e 0c 03 c0       	push   $0xc0030c1e
c0028c7e:	68 35 0b 03 c0       	push   $0xc0030b35
c0028c83:	68 78 0c 03 c0       	push   $0xc0030c78
c0028c88:	68 4b 01 00 00       	push   $0x14b
c0028c8d:	68 4c 0b 03 c0       	push   $0xc0030b4c
c0028c92:	e8 e1 0a 00 00       	call   c0029778 <debug_panic>

  src_len = strlen (src);
c0028c97:	83 ec 0c             	sub    $0xc,%esp
c0028c9a:	ff 75 0c             	pushl  0xc(%ebp)
c0028c9d:	e8 23 ff ff ff       	call   c0028bc5 <strlen>
c0028ca2:	83 c4 10             	add    $0x10,%esp
c0028ca5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (size > 0) 
c0028ca8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028cac:	74 36                	je     c0028ce4 <strlcpy+0xa1>
    {
      size_t dst_len = size - 1;
c0028cae:	8b 45 10             	mov    0x10(%ebp),%eax
c0028cb1:	83 e8 01             	sub    $0x1,%eax
c0028cb4:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < dst_len)
c0028cb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028cba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028cbd:	73 06                	jae    c0028cc5 <strlcpy+0x82>
        dst_len = src_len;
c0028cbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028cc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst, src, dst_len);
c0028cc5:	83 ec 04             	sub    $0x4,%esp
c0028cc8:	ff 75 f4             	pushl  -0xc(%ebp)
c0028ccb:	ff 75 0c             	pushl  0xc(%ebp)
c0028cce:	ff 75 08             	pushl  0x8(%ebp)
c0028cd1:	e8 90 f8 ff ff       	call   c0028566 <memcpy>
c0028cd6:	83 c4 10             	add    $0x10,%esp
      dst[dst_len] = '\0';
c0028cd9:	8b 55 08             	mov    0x8(%ebp),%edx
c0028cdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028cdf:	01 d0                	add    %edx,%eax
c0028ce1:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len;
c0028ce4:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028ce7:	c9                   	leave  
c0028ce8:	c3                   	ret    

c0028ce9 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c0028ce9:	55                   	push   %ebp
c0028cea:	89 e5                	mov    %esp,%ebp
c0028cec:	83 ec 18             	sub    $0x18,%esp
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0028cef:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028cf3:	75 21                	jne    c0028d16 <strlcat+0x2d>
c0028cf5:	83 ec 0c             	sub    $0xc,%esp
c0028cf8:	68 12 0c 03 c0       	push   $0xc0030c12
c0028cfd:	68 35 0b 03 c0       	push   $0xc0030b35
c0028d02:	68 80 0c 03 c0       	push   $0xc0030c80
c0028d07:	68 68 01 00 00       	push   $0x168
c0028d0c:	68 4c 0b 03 c0       	push   $0xc0030b4c
c0028d11:	e8 62 0a 00 00       	call   c0029778 <debug_panic>
  ASSERT (src != NULL);
c0028d16:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028d1a:	75 21                	jne    c0028d3d <strlcat+0x54>
c0028d1c:	83 ec 0c             	sub    $0xc,%esp
c0028d1f:	68 1e 0c 03 c0       	push   $0xc0030c1e
c0028d24:	68 35 0b 03 c0       	push   $0xc0030b35
c0028d29:	68 80 0c 03 c0       	push   $0xc0030c80
c0028d2e:	68 69 01 00 00       	push   $0x169
c0028d33:	68 4c 0b 03 c0       	push   $0xc0030b4c
c0028d38:	e8 3b 0a 00 00       	call   c0029778 <debug_panic>

  src_len = strlen (src);
c0028d3d:	83 ec 0c             	sub    $0xc,%esp
c0028d40:	ff 75 0c             	pushl  0xc(%ebp)
c0028d43:	e8 7d fe ff ff       	call   c0028bc5 <strlen>
c0028d48:	83 c4 10             	add    $0x10,%esp
c0028d4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  dst_len = strlen (dst);
c0028d4e:	83 ec 0c             	sub    $0xc,%esp
c0028d51:	ff 75 08             	pushl  0x8(%ebp)
c0028d54:	e8 6c fe ff ff       	call   c0028bc5 <strlen>
c0028d59:	83 c4 10             	add    $0x10,%esp
c0028d5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (size > 0 && dst_len < size) 
c0028d5f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028d63:	74 4c                	je     c0028db1 <strlcat+0xc8>
c0028d65:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028d68:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028d6b:	73 44                	jae    c0028db1 <strlcat+0xc8>
    {
      size_t copy_cnt = size - dst_len - 1;
c0028d6d:	8b 45 10             	mov    0x10(%ebp),%eax
c0028d70:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028d73:	83 e8 01             	sub    $0x1,%eax
c0028d76:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < copy_cnt)
c0028d79:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028d7c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028d7f:	73 06                	jae    c0028d87 <strlcat+0x9e>
        copy_cnt = src_len;
c0028d81:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028d84:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst + dst_len, src, copy_cnt);
c0028d87:	8b 55 08             	mov    0x8(%ebp),%edx
c0028d8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028d8d:	01 d0                	add    %edx,%eax
c0028d8f:	83 ec 04             	sub    $0x4,%esp
c0028d92:	ff 75 f4             	pushl  -0xc(%ebp)
c0028d95:	ff 75 0c             	pushl  0xc(%ebp)
c0028d98:	50                   	push   %eax
c0028d99:	e8 c8 f7 ff ff       	call   c0028566 <memcpy>
c0028d9e:	83 c4 10             	add    $0x10,%esp
      dst[dst_len + copy_cnt] = '\0';
c0028da1:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028da4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028da7:	01 c2                	add    %eax,%edx
c0028da9:	8b 45 08             	mov    0x8(%ebp),%eax
c0028dac:	01 d0                	add    %edx,%eax
c0028dae:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len + dst_len;
c0028db1:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028db4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028db7:	01 d0                	add    %edx,%eax
}
c0028db9:	c9                   	leave  
c0028dba:	c3                   	ret    

c0028dbb <divl>:
   yield a 32-bit quotient.  Returns the quotient.
   Traps with a divide error (#DE) if the quotient does not fit
   in 32 bits. */
static inline uint32_t
divl (uint64_t n, uint32_t d)
{
c0028dbb:	55                   	push   %ebp
c0028dbc:	89 e5                	mov    %esp,%ebp
c0028dbe:	83 ec 18             	sub    $0x18,%esp
c0028dc1:	8b 45 08             	mov    0x8(%ebp),%eax
c0028dc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028dc7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028dca:	89 45 ec             	mov    %eax,-0x14(%ebp)
  uint32_t n1 = n >> 32;
c0028dcd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028dd0:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028dd3:	89 d0                	mov    %edx,%eax
c0028dd5:	31 d2                	xor    %edx,%edx
c0028dd7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  uint32_t n0 = n;
c0028dda:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028ddd:	89 45 f8             	mov    %eax,-0x8(%ebp)
  uint32_t q, r;

  asm ("divl %4"
c0028de0:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0028de3:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0028de6:	f7 75 10             	divl   0x10(%ebp)
c0028de9:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028dec:	89 45 f0             	mov    %eax,-0x10(%ebp)
       : "=d" (r), "=a" (q)
       : "0" (n1), "1" (n0), "rm" (d));

  return q;
c0028def:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028df2:	c9                   	leave  
c0028df3:	c3                   	ret    

c0028df4 <nlz>:

/* Returns the number of leading zero bits in X,
   which must be nonzero. */
static int
nlz (uint32_t x) 
{
c0028df4:	55                   	push   %ebp
c0028df5:	89 e5                	mov    %esp,%ebp
c0028df7:	83 ec 10             	sub    $0x10,%esp
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
c0028dfa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if (x <= 0x0000FFFF)
c0028e01:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
c0028e08:	77 08                	ja     c0028e12 <nlz+0x1e>
    {
      n += 16;
c0028e0a:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
      x <<= 16; 
c0028e0e:	c1 65 08 10          	shll   $0x10,0x8(%ebp)
    }
  if (x <= 0x00FFFFFF)
c0028e12:	81 7d 08 ff ff ff 00 	cmpl   $0xffffff,0x8(%ebp)
c0028e19:	77 08                	ja     c0028e23 <nlz+0x2f>
    {
      n += 8;
c0028e1b:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
      x <<= 8; 
c0028e1f:	c1 65 08 08          	shll   $0x8,0x8(%ebp)
    }
  if (x <= 0x0FFFFFFF)
c0028e23:	81 7d 08 ff ff ff 0f 	cmpl   $0xfffffff,0x8(%ebp)
c0028e2a:	77 08                	ja     c0028e34 <nlz+0x40>
    {
      n += 4;
c0028e2c:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
      x <<= 4;
c0028e30:	c1 65 08 04          	shll   $0x4,0x8(%ebp)
    }
  if (x <= 0x3FFFFFFF)
c0028e34:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
c0028e3b:	77 08                	ja     c0028e45 <nlz+0x51>
    {
      n += 2;
c0028e3d:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
      x <<= 2; 
c0028e41:	c1 65 08 02          	shll   $0x2,0x8(%ebp)
    }
  if (x <= 0x7FFFFFFF)
c0028e45:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e48:	85 c0                	test   %eax,%eax
c0028e4a:	78 04                	js     c0028e50 <nlz+0x5c>
    n++;
c0028e4c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return n;
c0028e50:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028e53:	c9                   	leave  
c0028e54:	c3                   	ret    

c0028e55 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0028e55:	55                   	push   %ebp
c0028e56:	89 e5                	mov    %esp,%ebp
c0028e58:	57                   	push   %edi
c0028e59:	56                   	push   %esi
c0028e5a:	53                   	push   %ebx
c0028e5b:	83 ec 44             	sub    $0x44,%esp
c0028e5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e61:	89 45 b8             	mov    %eax,-0x48(%ebp)
c0028e64:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028e67:	89 45 bc             	mov    %eax,-0x44(%ebp)
c0028e6a:	8b 45 10             	mov    0x10(%ebp),%eax
c0028e6d:	89 45 b0             	mov    %eax,-0x50(%ebp)
c0028e70:	8b 45 14             	mov    0x14(%ebp),%eax
c0028e73:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if ((d >> 32) == 0) 
c0028e76:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028e79:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028e7c:	89 d0                	mov    %edx,%eax
c0028e7e:	31 d2                	xor    %edx,%edx
c0028e80:	09 d0                	or     %edx,%eax
c0028e82:	85 c0                	test   %eax,%eax
c0028e84:	0f 85 a3 00 00 00    	jne    c0028f2d <udiv64+0xd8>
             <=> [(bd - 1)/d] < b
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
c0028e8a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0028e91:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      uint32_t n1 = n >> 32;
c0028e98:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028e9b:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028e9e:	89 d0                	mov    %edx,%eax
c0028ea0:	31 d2                	xor    %edx,%edx
c0028ea2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      uint32_t n0 = n; 
c0028ea5:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028ea8:	89 45 e0             	mov    %eax,-0x20(%ebp)
      uint32_t d0 = d;
c0028eab:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028eae:	89 45 dc             	mov    %eax,-0x24(%ebp)

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0028eb1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028eb4:	ba 00 00 00 00       	mov    $0x0,%edx
c0028eb9:	f7 75 dc             	divl   -0x24(%ebp)
c0028ebc:	89 d0                	mov    %edx,%eax
c0028ebe:	ba 00 00 00 00       	mov    $0x0,%edx
c0028ec3:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0028ec6:	89 cb                	mov    %ecx,%ebx
c0028ec8:	0f af da             	imul   %edx,%ebx
c0028ecb:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0028ece:	0f af c8             	imul   %eax,%ecx
c0028ed1:	01 d9                	add    %ebx,%ecx
c0028ed3:	f7 65 e8             	mull   -0x18(%ebp)
c0028ed6:	01 d1                	add    %edx,%ecx
c0028ed8:	89 ca                	mov    %ecx,%edx
c0028eda:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c0028edd:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028ee2:	01 c8                	add    %ecx,%eax
c0028ee4:	11 da                	adc    %ebx,%edx
c0028ee6:	83 ec 04             	sub    $0x4,%esp
c0028ee9:	ff 75 dc             	pushl  -0x24(%ebp)
c0028eec:	52                   	push   %edx
c0028eed:	50                   	push   %eax
c0028eee:	e8 c8 fe ff ff       	call   c0028dbb <divl>
c0028ef3:	83 c4 10             	add    $0x10,%esp
c0028ef6:	89 c6                	mov    %eax,%esi
c0028ef8:	bf 00 00 00 00       	mov    $0x0,%edi
c0028efd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028f00:	ba 00 00 00 00       	mov    $0x0,%edx
c0028f05:	f7 75 dc             	divl   -0x24(%ebp)
c0028f08:	ba 00 00 00 00       	mov    $0x0,%edx
c0028f0d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0028f10:	89 cb                	mov    %ecx,%ebx
c0028f12:	0f af da             	imul   %edx,%ebx
c0028f15:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0028f18:	0f af c8             	imul   %eax,%ecx
c0028f1b:	01 d9                	add    %ebx,%ecx
c0028f1d:	f7 65 e8             	mull   -0x18(%ebp)
c0028f20:	01 d1                	add    %edx,%ecx
c0028f22:	89 ca                	mov    %ecx,%edx
c0028f24:	01 f0                	add    %esi,%eax
c0028f26:	11 fa                	adc    %edi,%edx
c0028f28:	e9 e8 00 00 00       	jmp    c0029015 <udiv64+0x1c0>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0028f2d:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028f30:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028f33:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028f36:	77 19                	ja     c0028f51 <udiv64+0xfc>
c0028f38:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028f3b:	72 05                	jb     c0028f42 <udiv64+0xed>
c0028f3d:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0028f40:	73 0f                	jae    c0028f51 <udiv64+0xfc>
        return 0;
c0028f42:	b8 00 00 00 00       	mov    $0x0,%eax
c0028f47:	ba 00 00 00 00       	mov    $0x0,%edx
c0028f4c:	e9 c4 00 00 00       	jmp    c0029015 <udiv64+0x1c0>
      else 
        {
          uint32_t d1 = d >> 32;
c0028f51:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028f54:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028f57:	89 d0                	mov    %edx,%eax
c0028f59:	31 d2                	xor    %edx,%edx
c0028f5b:	89 45 d8             	mov    %eax,-0x28(%ebp)
          int s = nlz (d1);
c0028f5e:	83 ec 04             	sub    $0x4,%esp
c0028f61:	ff 75 d8             	pushl  -0x28(%ebp)
c0028f64:	e8 8b fe ff ff       	call   c0028df4 <nlz>
c0028f69:	83 c4 08             	add    $0x8,%esp
c0028f6c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028f6f:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c0028f72:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028f75:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028f78:	0f a5 c2             	shld   %cl,%eax,%edx
c0028f7b:	d3 e0                	shl    %cl,%eax
c0028f7d:	f6 c1 20             	test   $0x20,%cl
c0028f80:	74 04                	je     c0028f86 <udiv64+0x131>
c0028f82:	89 c2                	mov    %eax,%edx
c0028f84:	31 c0                	xor    %eax,%eax
c0028f86:	89 d0                	mov    %edx,%eax
c0028f88:	31 d2                	xor    %edx,%edx
c0028f8a:	89 c1                	mov    %eax,%ecx
c0028f8c:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028f8f:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028f92:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c0028f96:	d1 ea                	shr    %edx
c0028f98:	83 ec 04             	sub    $0x4,%esp
c0028f9b:	51                   	push   %ecx
c0028f9c:	52                   	push   %edx
c0028f9d:	50                   	push   %eax
c0028f9e:	e8 18 fe ff ff       	call   c0028dbb <divl>
c0028fa3:	83 c4 10             	add    $0x10,%esp
c0028fa6:	89 c2                	mov    %eax,%edx
c0028fa8:	b8 1f 00 00 00       	mov    $0x1f,%eax
c0028fad:	2b 45 d4             	sub    -0x2c(%ebp),%eax
c0028fb0:	89 c1                	mov    %eax,%ecx
c0028fb2:	d3 ea                	shr    %cl,%edx
c0028fb4:	89 d0                	mov    %edx,%eax
c0028fb6:	89 45 c8             	mov    %eax,-0x38(%ebp)
c0028fb9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0028fc0:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0028fc3:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0028fc6:	83 c0 ff             	add    $0xffffffff,%eax
c0028fc9:	83 d2 ff             	adc    $0xffffffff,%edx
c0028fcc:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c0028fcf:	89 cb                	mov    %ecx,%ebx
c0028fd1:	0f af da             	imul   %edx,%ebx
c0028fd4:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
c0028fd7:	0f af c8             	imul   %eax,%ecx
c0028fda:	01 d9                	add    %ebx,%ecx
c0028fdc:	f7 65 b0             	mull   -0x50(%ebp)
c0028fdf:	01 d1                	add    %edx,%ecx
c0028fe1:	89 ca                	mov    %ecx,%edx
c0028fe3:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c0028fe6:	8b 5d bc             	mov    -0x44(%ebp),%ebx
c0028fe9:	29 c1                	sub    %eax,%ecx
c0028feb:	19 d3                	sbb    %edx,%ebx
c0028fed:	89 c8                	mov    %ecx,%eax
c0028fef:	89 da                	mov    %ebx,%edx
c0028ff1:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028ff4:	77 18                	ja     c002900e <udiv64+0x1b9>
c0028ff6:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028ff9:	72 05                	jb     c0029000 <udiv64+0x1ab>
c0028ffb:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0028ffe:	73 0e                	jae    c002900e <udiv64+0x1b9>
c0029000:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0029003:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0029006:	83 c0 ff             	add    $0xffffffff,%eax
c0029009:	83 d2 ff             	adc    $0xffffffff,%edx
c002900c:	eb 06                	jmp    c0029014 <udiv64+0x1bf>
c002900e:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0029011:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0029014:	90                   	nop
        }
    }
}
c0029015:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0029018:	5b                   	pop    %ebx
c0029019:	5e                   	pop    %esi
c002901a:	5f                   	pop    %edi
c002901b:	5d                   	pop    %ebp
c002901c:	c3                   	ret    

c002901d <umod64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
c002901d:	55                   	push   %ebp
c002901e:	89 e5                	mov    %esp,%ebp
c0029020:	53                   	push   %ebx
c0029021:	83 ec 14             	sub    $0x14,%esp
c0029024:	8b 45 08             	mov    0x8(%ebp),%eax
c0029027:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002902a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002902d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029030:	8b 45 10             	mov    0x10(%ebp),%eax
c0029033:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0029036:	8b 45 14             	mov    0x14(%ebp),%eax
c0029039:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * udiv64 (n, d);
c002903c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c002903f:	ff 75 ec             	pushl  -0x14(%ebp)
c0029042:	ff 75 e8             	pushl  -0x18(%ebp)
c0029045:	ff 75 f4             	pushl  -0xc(%ebp)
c0029048:	ff 75 f0             	pushl  -0x10(%ebp)
c002904b:	e8 05 fe ff ff       	call   c0028e55 <udiv64>
c0029050:	83 c4 10             	add    $0x10,%esp
c0029053:	89 c2                	mov    %eax,%edx
c0029055:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029058:	0f af c2             	imul   %edx,%eax
c002905b:	29 c3                	sub    %eax,%ebx
c002905d:	89 d8                	mov    %ebx,%eax
}
c002905f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029062:	c9                   	leave  
c0029063:	c3                   	ret    

c0029064 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0029064:	55                   	push   %ebp
c0029065:	89 e5                	mov    %esp,%ebp
c0029067:	83 ec 30             	sub    $0x30,%esp
c002906a:	8b 45 08             	mov    0x8(%ebp),%eax
c002906d:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0029070:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029073:	89 45 dc             	mov    %eax,-0x24(%ebp)
c0029076:	8b 45 10             	mov    0x10(%ebp),%eax
c0029079:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002907c:	8b 45 14             	mov    0x14(%ebp),%eax
c002907f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0029082:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0029086:	79 0f                	jns    c0029097 <sdiv64+0x33>
c0029088:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002908b:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002908e:	f7 d8                	neg    %eax
c0029090:	83 d2 00             	adc    $0x0,%edx
c0029093:	f7 da                	neg    %edx
c0029095:	eb 06                	jmp    c002909d <sdiv64+0x39>
c0029097:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002909a:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002909d:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00290a0:	89 55 fc             	mov    %edx,-0x4(%ebp)
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c00290a3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c00290a7:	79 0f                	jns    c00290b8 <sdiv64+0x54>
c00290a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00290ac:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c00290af:	f7 d8                	neg    %eax
c00290b1:	83 d2 00             	adc    $0x0,%edx
c00290b4:	f7 da                	neg    %edx
c00290b6:	eb 06                	jmp    c00290be <sdiv64+0x5a>
c00290b8:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00290bb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c00290be:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00290c1:	89 55 f4             	mov    %edx,-0xc(%ebp)
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c00290c4:	ff 75 f4             	pushl  -0xc(%ebp)
c00290c7:	ff 75 f0             	pushl  -0x10(%ebp)
c00290ca:	ff 75 fc             	pushl  -0x4(%ebp)
c00290cd:	ff 75 f8             	pushl  -0x8(%ebp)
c00290d0:	e8 80 fd ff ff       	call   c0028e55 <udiv64>
c00290d5:	83 c4 10             	add    $0x10,%esp
c00290d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00290db:	89 55 ec             	mov    %edx,-0x14(%ebp)
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c00290de:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00290e1:	f7 d0                	not    %eax
c00290e3:	c1 e8 1f             	shr    $0x1f,%eax
c00290e6:	89 c2                	mov    %eax,%edx
c00290e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00290eb:	c1 e8 1f             	shr    $0x1f,%eax
c00290ee:	31 d0                	xor    %edx,%eax
c00290f0:	84 c0                	test   %al,%al
c00290f2:	74 08                	je     c00290fc <sdiv64+0x98>
c00290f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00290f7:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00290fa:	eb 0d                	jmp    c0029109 <sdiv64+0xa5>
c00290fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00290ff:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0029102:	f7 d8                	neg    %eax
c0029104:	83 d2 00             	adc    $0x0,%edx
c0029107:	f7 da                	neg    %edx
}
c0029109:	c9                   	leave  
c002910a:	c3                   	ret    

c002910b <smod64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
c002910b:	55                   	push   %ebp
c002910c:	89 e5                	mov    %esp,%ebp
c002910e:	53                   	push   %ebx
c002910f:	83 ec 14             	sub    $0x14,%esp
c0029112:	8b 45 08             	mov    0x8(%ebp),%eax
c0029115:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029118:	8b 45 0c             	mov    0xc(%ebp),%eax
c002911b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002911e:	8b 45 10             	mov    0x10(%ebp),%eax
c0029121:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0029124:	8b 45 14             	mov    0x14(%ebp),%eax
c0029127:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * sdiv64 (n, d);
c002912a:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c002912d:	ff 75 ec             	pushl  -0x14(%ebp)
c0029130:	ff 75 e8             	pushl  -0x18(%ebp)
c0029133:	ff 75 f4             	pushl  -0xc(%ebp)
c0029136:	ff 75 f0             	pushl  -0x10(%ebp)
c0029139:	e8 26 ff ff ff       	call   c0029064 <sdiv64>
c002913e:	83 c4 10             	add    $0x10,%esp
c0029141:	89 c2                	mov    %eax,%edx
c0029143:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029146:	0f af c2             	imul   %edx,%eax
c0029149:	29 c3                	sub    %eax,%ebx
c002914b:	89 d8                	mov    %ebx,%eax
}
c002914d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029150:	c9                   	leave  
c0029151:	c3                   	ret    

c0029152 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0029152:	55                   	push   %ebp
c0029153:	89 e5                	mov    %esp,%ebp
c0029155:	83 ec 10             	sub    $0x10,%esp
c0029158:	8b 45 08             	mov    0x8(%ebp),%eax
c002915b:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002915e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029161:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029164:	8b 45 10             	mov    0x10(%ebp),%eax
c0029167:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002916a:	8b 45 14             	mov    0x14(%ebp),%eax
c002916d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return sdiv64 (n, d);
c0029170:	ff 75 f4             	pushl  -0xc(%ebp)
c0029173:	ff 75 f0             	pushl  -0x10(%ebp)
c0029176:	ff 75 fc             	pushl  -0x4(%ebp)
c0029179:	ff 75 f8             	pushl  -0x8(%ebp)
c002917c:	e8 e3 fe ff ff       	call   c0029064 <sdiv64>
c0029181:	83 c4 10             	add    $0x10,%esp
}
c0029184:	c9                   	leave  
c0029185:	c3                   	ret    

c0029186 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c0029186:	55                   	push   %ebp
c0029187:	89 e5                	mov    %esp,%ebp
c0029189:	83 ec 10             	sub    $0x10,%esp
c002918c:	8b 45 08             	mov    0x8(%ebp),%eax
c002918f:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029192:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029195:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029198:	8b 45 10             	mov    0x10(%ebp),%eax
c002919b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002919e:	8b 45 14             	mov    0x14(%ebp),%eax
c00291a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return smod64 (n, d);
c00291a4:	ff 75 f4             	pushl  -0xc(%ebp)
c00291a7:	ff 75 f0             	pushl  -0x10(%ebp)
c00291aa:	ff 75 fc             	pushl  -0x4(%ebp)
c00291ad:	ff 75 f8             	pushl  -0x8(%ebp)
c00291b0:	e8 56 ff ff ff       	call   c002910b <smod64>
c00291b5:	83 c4 10             	add    $0x10,%esp
c00291b8:	99                   	cltd   
}
c00291b9:	c9                   	leave  
c00291ba:	c3                   	ret    

c00291bb <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c00291bb:	55                   	push   %ebp
c00291bc:	89 e5                	mov    %esp,%ebp
c00291be:	83 ec 10             	sub    $0x10,%esp
c00291c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00291c4:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00291c7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00291ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00291cd:	8b 45 10             	mov    0x10(%ebp),%eax
c00291d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00291d3:	8b 45 14             	mov    0x14(%ebp),%eax
c00291d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return udiv64 (n, d);
c00291d9:	ff 75 f4             	pushl  -0xc(%ebp)
c00291dc:	ff 75 f0             	pushl  -0x10(%ebp)
c00291df:	ff 75 fc             	pushl  -0x4(%ebp)
c00291e2:	ff 75 f8             	pushl  -0x8(%ebp)
c00291e5:	e8 6b fc ff ff       	call   c0028e55 <udiv64>
c00291ea:	83 c4 10             	add    $0x10,%esp
}
c00291ed:	c9                   	leave  
c00291ee:	c3                   	ret    

c00291ef <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c00291ef:	55                   	push   %ebp
c00291f0:	89 e5                	mov    %esp,%ebp
c00291f2:	83 ec 10             	sub    $0x10,%esp
c00291f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00291f8:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00291fb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00291fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029201:	8b 45 10             	mov    0x10(%ebp),%eax
c0029204:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029207:	8b 45 14             	mov    0x14(%ebp),%eax
c002920a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return umod64 (n, d);
c002920d:	ff 75 f4             	pushl  -0xc(%ebp)
c0029210:	ff 75 f0             	pushl  -0x10(%ebp)
c0029213:	ff 75 fc             	pushl  -0x4(%ebp)
c0029216:	ff 75 f8             	pushl  -0x8(%ebp)
c0029219:	e8 ff fd ff ff       	call   c002901d <umod64>
c002921e:	83 c4 10             	add    $0x10,%esp
c0029221:	ba 00 00 00 00       	mov    $0x0,%edx
}
c0029226:	c9                   	leave  
c0029227:	c3                   	ret    

c0029228 <calculate_chksum>:
PACKED;

/* Returns the checksum for the given ustar format HEADER. */
static unsigned int
calculate_chksum (const struct ustar_header *h)
{
c0029228:	55                   	push   %ebp
c0029229:	89 e5                	mov    %esp,%ebp
c002922b:	83 ec 20             	sub    $0x20,%esp
  const uint8_t *header = (const uint8_t *) h;
c002922e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029231:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int chksum;
  size_t i;

  chksum = 0;
c0029234:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c002923b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0029242:	eb 5a                	jmp    c002929e <calculate_chksum+0x76>
    {
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
c0029244:	c7 45 f0 94 00 00 00 	movl   $0x94,-0x10(%ebp)
      const size_t chksum_end = chksum_start + sizeof h->chksum;
c002924b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002924e:	83 c0 08             	add    $0x8,%eax
c0029251:	89 45 ec             	mov    %eax,-0x14(%ebp)
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
c0029254:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029257:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002925a:	72 0f                	jb     c002926b <calculate_chksum+0x43>
c002925c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002925f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0029262:	73 07                	jae    c002926b <calculate_chksum+0x43>
c0029264:	b8 01 00 00 00       	mov    $0x1,%eax
c0029269:	eb 05                	jmp    c0029270 <calculate_chksum+0x48>
c002926b:	b8 00 00 00 00       	mov    $0x0,%eax
c0029270:	88 45 eb             	mov    %al,-0x15(%ebp)
c0029273:	80 65 eb 01          	andb   $0x1,-0x15(%ebp)
      chksum += in_chksum_field ? ' ' : header[i];
c0029277:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002927b:	83 f0 01             	xor    $0x1,%eax
c002927e:	84 c0                	test   %al,%al
c0029280:	74 10                	je     c0029292 <calculate_chksum+0x6a>
c0029282:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029285:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029288:	01 d0                	add    %edx,%eax
c002928a:	0f b6 00             	movzbl (%eax),%eax
c002928d:	0f b6 c0             	movzbl %al,%eax
c0029290:	eb 05                	jmp    c0029297 <calculate_chksum+0x6f>
c0029292:	b8 20 00 00 00       	mov    $0x20,%eax
c0029297:	01 45 fc             	add    %eax,-0x4(%ebp)
  const uint8_t *header = (const uint8_t *) h;
  unsigned int chksum;
  size_t i;

  chksum = 0;
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c002929a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c002929e:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
c00292a5:	76 9d                	jbe    c0029244 <calculate_chksum+0x1c>
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
      const size_t chksum_end = chksum_start + sizeof h->chksum;
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
      chksum += in_chksum_field ? ' ' : header[i];
    }
  return chksum;
c00292a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00292aa:	c9                   	leave  
c00292ab:	c3                   	ret    

c00292ac <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
c00292ac:	55                   	push   %ebp
c00292ad:	89 e5                	mov    %esp,%ebp
c00292af:	83 ec 08             	sub    $0x8,%esp
  while (*file_name == '/'
c00292b2:	eb 16                	jmp    c00292ca <strip_antisocial_prefixes+0x1e>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
c00292b4:	83 ec 08             	sub    $0x8,%esp
c00292b7:	6a 2f                	push   $0x2f
c00292b9:	ff 75 08             	pushl  0x8(%ebp)
c00292bc:	e8 ba f5 ff ff       	call   c002887b <strchr>
c00292c1:	83 c4 10             	add    $0x10,%esp
c00292c4:	83 c0 01             	add    $0x1,%eax
c00292c7:	89 45 08             	mov    %eax,0x8(%ebp)
   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
  while (*file_name == '/'
c00292ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00292cd:	0f b6 00             	movzbl (%eax),%eax
c00292d0:	3c 2f                	cmp    $0x2f,%al
c00292d2:	74 e0                	je     c00292b4 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "./", 2)
c00292d4:	83 ec 04             	sub    $0x4,%esp
c00292d7:	6a 02                	push   $0x2
c00292d9:	68 88 0c 03 c0       	push   $0xc0030c88
c00292de:	ff 75 08             	pushl  0x8(%ebp)
c00292e1:	e8 d8 f3 ff ff       	call   c00286be <memcmp>
c00292e6:	83 c4 10             	add    $0x10,%esp
c00292e9:	85 c0                	test   %eax,%eax
c00292eb:	74 c7                	je     c00292b4 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "../", 3))
c00292ed:	83 ec 04             	sub    $0x4,%esp
c00292f0:	6a 03                	push   $0x3
c00292f2:	68 8b 0c 03 c0       	push   $0xc0030c8b
c00292f7:	ff 75 08             	pushl  0x8(%ebp)
c00292fa:	e8 bf f3 ff ff       	call   c00286be <memcmp>
c00292ff:	83 c4 10             	add    $0x10,%esp
c0029302:	85 c0                	test   %eax,%eax
c0029304:	74 ae                	je     c00292b4 <strip_antisocial_prefixes+0x8>
    file_name = strchr (file_name, '/') + 1;
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0029306:	8b 45 08             	mov    0x8(%ebp),%eax
c0029309:	0f b6 00             	movzbl (%eax),%eax
c002930c:	84 c0                	test   %al,%al
c002930e:	74 1c                	je     c002932c <strip_antisocial_prefixes+0x80>
c0029310:	83 ec 08             	sub    $0x8,%esp
c0029313:	68 8f 0c 03 c0       	push   $0xc0030c8f
c0029318:	ff 75 08             	pushl  0x8(%ebp)
c002931b:	e8 4e f4 ff ff       	call   c002876e <strcmp>
c0029320:	83 c4 10             	add    $0x10,%esp
c0029323:	85 c0                	test   %eax,%eax
c0029325:	74 05                	je     c002932c <strip_antisocial_prefixes+0x80>
c0029327:	8b 45 08             	mov    0x8(%ebp),%eax
c002932a:	eb 05                	jmp    c0029331 <strip_antisocial_prefixes+0x85>
c002932c:	b8 92 0c 03 c0       	mov    $0xc0030c92,%eax
}
c0029331:	c9                   	leave  
c0029332:	c3                   	ret    

c0029333 <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
c0029333:	55                   	push   %ebp
c0029334:	89 e5                	mov    %esp,%ebp
c0029336:	83 ec 18             	sub    $0x18,%esp
  struct ustar_header *h = (struct ustar_header *) header;
c0029339:	8b 45 14             	mov    0x14(%ebp),%eax
c002933c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c002933f:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c0029343:	74 24                	je     c0029369 <ustar_make_header+0x36>
c0029345:	83 7d 0c 35          	cmpl   $0x35,0xc(%ebp)
c0029349:	74 1e                	je     c0029369 <ustar_make_header+0x36>
c002934b:	83 ec 0c             	sub    $0xc,%esp
c002934e:	68 94 0c 03 c0       	push   $0xc0030c94
c0029353:	68 c5 0c 03 c0       	push   $0xc0030cc5
c0029358:	68 c8 0d 03 c0       	push   $0xc0030dc8
c002935d:	6a 59                	push   $0x59
c002935f:	68 dc 0c 03 c0       	push   $0xc0030cdc
c0029364:	e8 0f 04 00 00       	call   c0029778 <debug_panic>

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
c0029369:	83 ec 0c             	sub    $0xc,%esp
c002936c:	ff 75 08             	pushl  0x8(%ebp)
c002936f:	e8 38 ff ff ff       	call   c00292ac <strip_antisocial_prefixes>
c0029374:	83 c4 10             	add    $0x10,%esp
c0029377:	89 45 08             	mov    %eax,0x8(%ebp)
  if (strlen (file_name) > 99)
c002937a:	83 ec 0c             	sub    $0xc,%esp
c002937d:	ff 75 08             	pushl  0x8(%ebp)
c0029380:	e8 40 f8 ff ff       	call   c0028bc5 <strlen>
c0029385:	83 c4 10             	add    $0x10,%esp
c0029388:	83 f8 63             	cmp    $0x63,%eax
c002938b:	76 1d                	jbe    c00293aa <ustar_make_header+0x77>
    {
      printf ("%s: file name too long\n", file_name);
c002938d:	83 ec 08             	sub    $0x8,%esp
c0029390:	ff 75 08             	pushl  0x8(%ebp)
c0029393:	68 ee 0c 03 c0       	push   $0xc0030cee
c0029398:	e8 a8 df ff ff       	call   c0027345 <printf>
c002939d:	83 c4 10             	add    $0x10,%esp
      return false;
c00293a0:	b8 00 00 00 00       	mov    $0x0,%eax
c00293a5:	e9 64 01 00 00       	jmp    c002950e <ustar_make_header+0x1db>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
c00293aa:	83 ec 04             	sub    $0x4,%esp
c00293ad:	68 00 02 00 00       	push   $0x200
c00293b2:	6a 00                	push   $0x0
c00293b4:	ff 75 f4             	pushl  -0xc(%ebp)
c00293b7:	e8 b0 f7 ff ff       	call   c0028b6c <memset>
c00293bc:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->name, file_name, sizeof h->name);
c00293bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293c2:	83 ec 04             	sub    $0x4,%esp
c00293c5:	6a 64                	push   $0x64
c00293c7:	ff 75 08             	pushl  0x8(%ebp)
c00293ca:	50                   	push   %eax
c00293cb:	e8 73 f8 ff ff       	call   c0028c43 <strlcpy>
c00293d0:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c00293d3:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c00293d7:	75 07                	jne    c00293e0 <ustar_make_header+0xad>
c00293d9:	ba a4 01 00 00       	mov    $0x1a4,%edx
c00293de:	eb 05                	jmp    c00293e5 <ustar_make_header+0xb2>
c00293e0:	ba ed 01 00 00       	mov    $0x1ed,%edx
c00293e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293e8:	83 c0 64             	add    $0x64,%eax
c00293eb:	52                   	push   %edx
c00293ec:	68 06 0d 03 c0       	push   $0xc0030d06
c00293f1:	6a 08                	push   $0x8
c00293f3:	50                   	push   %eax
c00293f4:	e8 23 df ff ff       	call   c002731c <snprintf>
c00293f9:	83 c4 10             	add    $0x10,%esp
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
c00293fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293ff:	83 c0 6c             	add    $0x6c,%eax
c0029402:	83 ec 04             	sub    $0x4,%esp
c0029405:	6a 08                	push   $0x8
c0029407:	68 0b 0d 03 c0       	push   $0xc0030d0b
c002940c:	50                   	push   %eax
c002940d:	e8 31 f8 ff ff       	call   c0028c43 <strlcpy>
c0029412:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->gid, "0000000", sizeof h->gid);
c0029415:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029418:	83 c0 74             	add    $0x74,%eax
c002941b:	83 ec 04             	sub    $0x4,%esp
c002941e:	6a 08                	push   $0x8
c0029420:	68 0b 0d 03 c0       	push   $0xc0030d0b
c0029425:	50                   	push   %eax
c0029426:	e8 18 f8 ff ff       	call   c0028c43 <strlcpy>
c002942b:	83 c4 10             	add    $0x10,%esp
  snprintf (h->size, sizeof h->size, "%011o", size);
c002942e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029431:	83 c0 7c             	add    $0x7c,%eax
c0029434:	ff 75 10             	pushl  0x10(%ebp)
c0029437:	68 13 0d 03 c0       	push   $0xc0030d13
c002943c:	6a 0c                	push   $0xc
c002943e:	50                   	push   %eax
c002943f:	e8 d8 de ff ff       	call   c002731c <snprintf>
c0029444:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0029447:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002944a:	05 88 00 00 00       	add    $0x88,%eax
c002944f:	68 00 8c b7 43       	push   $0x43b78c00
c0029454:	68 13 0d 03 c0       	push   $0xc0030d13
c0029459:	6a 0c                	push   $0xc
c002945b:	50                   	push   %eax
c002945c:	e8 bb de ff ff       	call   c002731c <snprintf>
c0029461:	83 c4 10             	add    $0x10,%esp
  h->typeflag = type;
c0029464:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029467:	89 c2                	mov    %eax,%edx
c0029469:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002946c:	88 90 9c 00 00 00    	mov    %dl,0x9c(%eax)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0029472:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029475:	05 01 01 00 00       	add    $0x101,%eax
c002947a:	83 ec 04             	sub    $0x4,%esp
c002947d:	6a 06                	push   $0x6
c002947f:	68 19 0d 03 c0       	push   $0xc0030d19
c0029484:	50                   	push   %eax
c0029485:	e8 b9 f7 ff ff       	call   c0028c43 <strlcpy>
c002948a:	83 c4 10             	add    $0x10,%esp
  h->version[0] = h->version[1] = '0';
c002948d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029490:	c6 80 08 01 00 00 30 	movb   $0x30,0x108(%eax)
c0029497:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002949a:	0f b6 90 08 01 00 00 	movzbl 0x108(%eax),%edx
c00294a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294a4:	88 90 07 01 00 00    	mov    %dl,0x107(%eax)
  strlcpy (h->gname, "root", sizeof h->gname);
c00294aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294ad:	05 29 01 00 00       	add    $0x129,%eax
c00294b2:	83 ec 04             	sub    $0x4,%esp
c00294b5:	6a 20                	push   $0x20
c00294b7:	68 1f 0d 03 c0       	push   $0xc0030d1f
c00294bc:	50                   	push   %eax
c00294bd:	e8 81 f7 ff ff       	call   c0028c43 <strlcpy>
c00294c2:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->uname, "root", sizeof h->uname);
c00294c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294c8:	05 09 01 00 00       	add    $0x109,%eax
c00294cd:	83 ec 04             	sub    $0x4,%esp
c00294d0:	6a 20                	push   $0x20
c00294d2:	68 1f 0d 03 c0       	push   $0xc0030d1f
c00294d7:	50                   	push   %eax
c00294d8:	e8 66 f7 ff ff       	call   c0028c43 <strlcpy>
c00294dd:	83 c4 10             	add    $0x10,%esp

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c00294e0:	83 ec 0c             	sub    $0xc,%esp
c00294e3:	ff 75 f4             	pushl  -0xc(%ebp)
c00294e6:	e8 3d fd ff ff       	call   c0029228 <calculate_chksum>
c00294eb:	83 c4 10             	add    $0x10,%esp
c00294ee:	89 c2                	mov    %eax,%edx
c00294f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294f3:	05 94 00 00 00       	add    $0x94,%eax
c00294f8:	52                   	push   %edx
c00294f9:	68 06 0d 03 c0       	push   $0xc0030d06
c00294fe:	6a 08                	push   $0x8
c0029500:	50                   	push   %eax
c0029501:	e8 16 de ff ff       	call   c002731c <snprintf>
c0029506:	83 c4 10             	add    $0x10,%esp

  return true;
c0029509:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002950e:	c9                   	leave  
c002950f:	c3                   	ret    

c0029510 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c0029510:	55                   	push   %ebp
c0029511:	89 e5                	mov    %esp,%ebp
c0029513:	83 ec 10             	sub    $0x10,%esp
  size_t ofs;

  *value = 0;
c0029516:	8b 45 10             	mov    0x10(%ebp),%eax
c0029519:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c002951f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0029526:	eb 65                	jmp    c002958d <parse_octal_field+0x7d>
    {
      char c = s[ofs];
c0029528:	8b 55 08             	mov    0x8(%ebp),%edx
c002952b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002952e:	01 d0                	add    %edx,%eax
c0029530:	0f b6 00             	movzbl (%eax),%eax
c0029533:	88 45 fb             	mov    %al,-0x5(%ebp)
      if (c >= '0' && c <= '7')
c0029536:	80 7d fb 2f          	cmpb   $0x2f,-0x5(%ebp)
c002953a:	7e 35                	jle    c0029571 <parse_octal_field+0x61>
c002953c:	80 7d fb 37          	cmpb   $0x37,-0x5(%ebp)
c0029540:	7f 2f                	jg     c0029571 <parse_octal_field+0x61>
        {
          if (*value > ULONG_MAX / 8)
c0029542:	8b 45 10             	mov    0x10(%ebp),%eax
c0029545:	8b 00                	mov    (%eax),%eax
c0029547:	3d ff ff ff 1f       	cmp    $0x1fffffff,%eax
c002954c:	76 07                	jbe    c0029555 <parse_octal_field+0x45>
            {
              /* Overflow. */
              return false;
c002954e:	b8 00 00 00 00       	mov    $0x0,%eax
c0029553:	eb 45                	jmp    c002959a <parse_octal_field+0x8a>
            }
          *value = c - '0' + *value * 8;
c0029555:	0f be 55 fb          	movsbl -0x5(%ebp),%edx
c0029559:	8b 45 10             	mov    0x10(%ebp),%eax
c002955c:	8b 00                	mov    (%eax),%eax
c002955e:	c1 e0 03             	shl    $0x3,%eax
c0029561:	01 d0                	add    %edx,%eax
c0029563:	8d 50 d0             	lea    -0x30(%eax),%edx
c0029566:	8b 45 10             	mov    0x10(%ebp),%eax
c0029569:	89 10                	mov    %edx,(%eax)
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
c002956b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c002956f:	eb 1c                	jmp    c002958d <parse_octal_field+0x7d>
              /* Overflow. */
              return false;
            }
          *value = c - '0' + *value * 8;
        }
      else if (c == ' ' || c == '\0')
c0029571:	80 7d fb 20          	cmpb   $0x20,-0x5(%ebp)
c0029575:	74 06                	je     c002957d <parse_octal_field+0x6d>
c0029577:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c002957b:	75 09                	jne    c0029586 <parse_octal_field+0x76>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
c002957d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0029581:	0f 95 c0             	setne  %al
c0029584:	eb 14                	jmp    c002959a <parse_octal_field+0x8a>
        }
      else
        {
          /* Bad character. */
          return false;
c0029586:	b8 00 00 00 00       	mov    $0x0,%eax
c002958b:	eb 0d                	jmp    c002959a <parse_octal_field+0x8a>
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
c002958d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029590:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029593:	72 93                	jb     c0029528 <parse_octal_field+0x18>
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0029595:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002959a:	c9                   	leave  
c002959b:	c3                   	ret    

c002959c <is_all_zeros>:

/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
c002959c:	55                   	push   %ebp
c002959d:	89 e5                	mov    %esp,%ebp
  while (cnt-- > 0)
c002959f:	eb 17                	jmp    c00295b8 <is_all_zeros+0x1c>
    if (*block++ != 0)
c00295a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00295a4:	8d 50 01             	lea    0x1(%eax),%edx
c00295a7:	89 55 08             	mov    %edx,0x8(%ebp)
c00295aa:	0f b6 00             	movzbl (%eax),%eax
c00295ad:	84 c0                	test   %al,%al
c00295af:	74 07                	je     c00295b8 <is_all_zeros+0x1c>
      return false;
c00295b1:	b8 00 00 00 00       	mov    $0x0,%eax
c00295b6:	eb 12                	jmp    c00295ca <is_all_zeros+0x2e>
/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
  while (cnt-- > 0)
c00295b8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295bb:	8d 50 ff             	lea    -0x1(%eax),%edx
c00295be:	89 55 0c             	mov    %edx,0xc(%ebp)
c00295c1:	85 c0                	test   %eax,%eax
c00295c3:	75 dc                	jne    c00295a1 <is_all_zeros+0x5>
    if (*block++ != 0)
      return false;
  return true;
c00295c5:	b8 01 00 00 00       	mov    $0x1,%eax
}
c00295ca:	5d                   	pop    %ebp
c00295cb:	c3                   	ret    

c00295cc <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c00295cc:	55                   	push   %ebp
c00295cd:	89 e5                	mov    %esp,%ebp
c00295cf:	83 ec 18             	sub    $0x18,%esp
  const struct ustar_header *h = (const struct ustar_header *) header;
c00295d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00295d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned long int chksum, size_ul;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
c00295d8:	68 00 02 00 00       	push   $0x200
c00295dd:	ff 75 08             	pushl  0x8(%ebp)
c00295e0:	e8 b7 ff ff ff       	call   c002959c <is_all_zeros>
c00295e5:	83 c4 08             	add    $0x8,%esp
c00295e8:	84 c0                	test   %al,%al
c00295ea:	74 25                	je     c0029611 <ustar_parse_header+0x45>
    {
      *file_name = NULL;
c00295ec:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295ef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c00295f5:	8b 45 10             	mov    0x10(%ebp),%eax
c00295f8:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c00295fe:	8b 45 14             	mov    0x14(%ebp),%eax
c0029601:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0029607:	b8 00 00 00 00       	mov    $0x0,%eax
c002960c:	e9 65 01 00 00       	jmp    c0029776 <ustar_parse_header+0x1aa>
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c0029611:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029614:	05 01 01 00 00       	add    $0x101,%eax
c0029619:	83 ec 04             	sub    $0x4,%esp
c002961c:	6a 06                	push   $0x6
c002961e:	68 19 0d 03 c0       	push   $0xc0030d19
c0029623:	50                   	push   %eax
c0029624:	e8 95 f0 ff ff       	call   c00286be <memcmp>
c0029629:	83 c4 10             	add    $0x10,%esp
c002962c:	85 c0                	test   %eax,%eax
c002962e:	74 0a                	je     c002963a <ustar_parse_header+0x6e>
    return "not a ustar archive";
c0029630:	b8 24 0d 03 c0       	mov    $0xc0030d24,%eax
c0029635:	e9 3c 01 00 00       	jmp    c0029776 <ustar_parse_header+0x1aa>
  else if (h->version[0] != '0' || h->version[1] != '0')
c002963a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002963d:	0f b6 80 07 01 00 00 	movzbl 0x107(%eax),%eax
c0029644:	3c 30                	cmp    $0x30,%al
c0029646:	75 0e                	jne    c0029656 <ustar_parse_header+0x8a>
c0029648:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002964b:	0f b6 80 08 01 00 00 	movzbl 0x108(%eax),%eax
c0029652:	3c 30                	cmp    $0x30,%al
c0029654:	74 0a                	je     c0029660 <ustar_parse_header+0x94>
    return "invalid ustar version";
c0029656:	b8 38 0d 03 c0       	mov    $0xc0030d38,%eax
c002965b:	e9 16 01 00 00       	jmp    c0029776 <ustar_parse_header+0x1aa>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0029660:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029663:	8d 90 94 00 00 00    	lea    0x94(%eax),%edx
c0029669:	83 ec 04             	sub    $0x4,%esp
c002966c:	8d 45 f0             	lea    -0x10(%ebp),%eax
c002966f:	50                   	push   %eax
c0029670:	6a 08                	push   $0x8
c0029672:	52                   	push   %edx
c0029673:	e8 98 fe ff ff       	call   c0029510 <parse_octal_field>
c0029678:	83 c4 10             	add    $0x10,%esp
c002967b:	83 f0 01             	xor    $0x1,%eax
c002967e:	84 c0                	test   %al,%al
c0029680:	74 0a                	je     c002968c <ustar_parse_header+0xc0>
    return "corrupt chksum field";
c0029682:	b8 4e 0d 03 c0       	mov    $0xc0030d4e,%eax
c0029687:	e9 ea 00 00 00       	jmp    c0029776 <ustar_parse_header+0x1aa>
  else if (chksum != calculate_chksum (h))
c002968c:	83 ec 0c             	sub    $0xc,%esp
c002968f:	ff 75 f4             	pushl  -0xc(%ebp)
c0029692:	e8 91 fb ff ff       	call   c0029228 <calculate_chksum>
c0029697:	83 c4 10             	add    $0x10,%esp
c002969a:	89 c2                	mov    %eax,%edx
c002969c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002969f:	39 c2                	cmp    %eax,%edx
c00296a1:	74 0a                	je     c00296ad <ustar_parse_header+0xe1>
    return "checksum mismatch";
c00296a3:	b8 63 0d 03 c0       	mov    $0xc0030d63,%eax
c00296a8:	e9 c9 00 00 00       	jmp    c0029776 <ustar_parse_header+0x1aa>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c00296ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296b0:	0f b6 40 63          	movzbl 0x63(%eax),%eax
c00296b4:	84 c0                	test   %al,%al
c00296b6:	75 0e                	jne    c00296c6 <ustar_parse_header+0xfa>
c00296b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296bb:	0f b6 80 59 01 00 00 	movzbl 0x159(%eax),%eax
c00296c2:	84 c0                	test   %al,%al
c00296c4:	74 0a                	je     c00296d0 <ustar_parse_header+0x104>
    return "file name too long";
c00296c6:	b8 75 0d 03 c0       	mov    $0xc0030d75,%eax
c00296cb:	e9 a6 00 00 00       	jmp    c0029776 <ustar_parse_header+0x1aa>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c00296d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296d3:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c00296da:	3c 30                	cmp    $0x30,%al
c00296dc:	74 18                	je     c00296f6 <ustar_parse_header+0x12a>
c00296de:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296e1:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c00296e8:	3c 35                	cmp    $0x35,%al
c00296ea:	74 0a                	je     c00296f6 <ustar_parse_header+0x12a>
    return "unimplemented file type";
c00296ec:	b8 88 0d 03 c0       	mov    $0xc0030d88,%eax
c00296f1:	e9 80 00 00 00       	jmp    c0029776 <ustar_parse_header+0x1aa>
  if (h->typeflag == USTAR_REGULAR)
c00296f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296f9:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c0029700:	3c 30                	cmp    $0x30,%al
c0029702:	75 34                	jne    c0029738 <ustar_parse_header+0x16c>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0029704:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029707:	8d 50 7c             	lea    0x7c(%eax),%edx
c002970a:	83 ec 04             	sub    $0x4,%esp
c002970d:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0029710:	50                   	push   %eax
c0029711:	6a 0c                	push   $0xc
c0029713:	52                   	push   %edx
c0029714:	e8 f7 fd ff ff       	call   c0029510 <parse_octal_field>
c0029719:	83 c4 10             	add    $0x10,%esp
c002971c:	83 f0 01             	xor    $0x1,%eax
c002971f:	84 c0                	test   %al,%al
c0029721:	74 07                	je     c002972a <ustar_parse_header+0x15e>
        return "corrupt file size field";
c0029723:	b8 a0 0d 03 c0       	mov    $0xc0030da0,%eax
c0029728:	eb 4c                	jmp    c0029776 <ustar_parse_header+0x1aa>
      else if (size_ul > INT_MAX)
c002972a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002972d:	85 c0                	test   %eax,%eax
c002972f:	79 0e                	jns    c002973f <ustar_parse_header+0x173>
        return "file too large";
c0029731:	b8 b8 0d 03 c0       	mov    $0xc0030db8,%eax
c0029736:	eb 3e                	jmp    c0029776 <ustar_parse_header+0x1aa>
    }
  else
    size_ul = 0;
c0029738:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c002973f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029742:	83 ec 0c             	sub    $0xc,%esp
c0029745:	50                   	push   %eax
c0029746:	e8 61 fb ff ff       	call   c00292ac <strip_antisocial_prefixes>
c002974b:	83 c4 10             	add    $0x10,%esp
c002974e:	89 c2                	mov    %eax,%edx
c0029750:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029753:	89 10                	mov    %edx,(%eax)
  *type = h->typeflag;
c0029755:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029758:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c002975f:	0f be d0             	movsbl %al,%edx
c0029762:	8b 45 10             	mov    0x10(%ebp),%eax
c0029765:	89 10                	mov    %edx,(%eax)
  *size = size_ul;
c0029767:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002976a:	89 c2                	mov    %eax,%edx
c002976c:	8b 45 14             	mov    0x14(%ebp),%eax
c002976f:	89 10                	mov    %edx,(%eax)
  return NULL;
c0029771:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029776:	c9                   	leave  
c0029777:	c3                   	ret    

c0029778 <debug_panic>:
/* Halts the OS, printing the source file name, line number, and
   function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
c0029778:	55                   	push   %ebp
c0029779:	89 e5                	mov    %esp,%ebp
c002977b:	83 ec 18             	sub    $0x18,%esp
  static int level;
  va_list args;

  intr_disable ();
c002977e:	e8 49 7d ff ff       	call   c00214cc <intr_disable>
  console_panic ();
c0029783:	e8 60 20 00 00       	call   c002b7e8 <console_panic>

  level++;
c0029788:	a1 24 9c 03 c0       	mov    0xc0039c24,%eax
c002978d:	83 c0 01             	add    $0x1,%eax
c0029790:	a3 24 9c 03 c0       	mov    %eax,0xc0039c24
  if (level == 1) 
c0029795:	a1 24 9c 03 c0       	mov    0xc0039c24,%eax
c002979a:	83 f8 01             	cmp    $0x1,%eax
c002979d:	75 42                	jne    c00297e1 <debug_panic+0x69>
    {
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c002979f:	ff 75 10             	pushl  0x10(%ebp)
c00297a2:	ff 75 0c             	pushl  0xc(%ebp)
c00297a5:	ff 75 08             	pushl  0x8(%ebp)
c00297a8:	68 dc 0d 03 c0       	push   $0xc0030ddc
c00297ad:	e8 93 db ff ff       	call   c0027345 <printf>
c00297b2:	83 c4 10             	add    $0x10,%esp

      va_start (args, message);
c00297b5:	8d 45 18             	lea    0x18(%ebp),%eax
c00297b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
      vprintf (message, args);
c00297bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00297be:	83 ec 08             	sub    $0x8,%esp
c00297c1:	50                   	push   %eax
c00297c2:	ff 75 14             	pushl  0x14(%ebp)
c00297c5:	e8 2e 21 00 00       	call   c002b8f8 <vprintf>
c00297ca:	83 c4 10             	add    $0x10,%esp
      printf ("\n");
c00297cd:	83 ec 0c             	sub    $0xc,%esp
c00297d0:	6a 0a                	push   $0xa
c00297d2:	e8 dc 21 00 00       	call   c002b9b3 <putchar>
c00297d7:	83 c4 10             	add    $0x10,%esp
      va_end (args);

      debug_backtrace ();
c00297da:	e8 31 d8 ff ff       	call   c0027010 <debug_backtrace>
c00297df:	eb 20                	jmp    c0029801 <debug_panic+0x89>
    }
  else if (level == 2)
c00297e1:	a1 24 9c 03 c0       	mov    0xc0039c24,%eax
c00297e6:	83 f8 02             	cmp    $0x2,%eax
c00297e9:	75 16                	jne    c0029801 <debug_panic+0x89>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c00297eb:	ff 75 10             	pushl  0x10(%ebp)
c00297ee:	ff 75 0c             	pushl  0xc(%ebp)
c00297f1:	ff 75 08             	pushl  0x8(%ebp)
c00297f4:	68 fc 0d 03 c0       	push   $0xc0030dfc
c00297f9:	e8 47 db ff ff       	call   c0027345 <printf>
c00297fe:	83 c4 10             	add    $0x10,%esp
  else 
    {
      /* Don't print anything: that's probably why we recursed. */
    }

  serial_flush ();
c0029801:	e8 e3 b3 ff ff       	call   c0024be9 <serial_flush>
  shutdown ();
c0029806:	e8 72 d5 ff ff       	call   c0026d7d <shutdown>
  for (;;);
c002980b:	eb fe                	jmp    c002980b <debug_panic+0x93>

c002980d <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c002980d:	55                   	push   %ebp
c002980e:	89 e5                	mov    %esp,%ebp
c0029810:	83 ec 18             	sub    $0x18,%esp
  void *retaddr = NULL, **frame = NULL;
c0029813:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002981a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  const char *status = "UNKNOWN";
c0029821:	c7 45 ec 26 0e 03 c0 	movl   $0xc0030e26,-0x14(%ebp)

  switch (t->status) {
c0029828:	8b 45 08             	mov    0x8(%ebp),%eax
c002982b:	8b 40 04             	mov    0x4(%eax),%eax
c002982e:	83 f8 01             	cmp    $0x1,%eax
c0029831:	74 15                	je     c0029848 <print_stacktrace+0x3b>
c0029833:	83 f8 01             	cmp    $0x1,%eax
c0029836:	72 07                	jb     c002983f <print_stacktrace+0x32>
c0029838:	83 f8 02             	cmp    $0x2,%eax
c002983b:	74 14                	je     c0029851 <print_stacktrace+0x44>
    case THREAD_BLOCKED:  
      status = "BLOCKED";
      break;

    default:
      break;
c002983d:	eb 1a                	jmp    c0029859 <print_stacktrace+0x4c>
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
    case THREAD_RUNNING:  
      status = "RUNNING";
c002983f:	c7 45 ec 2e 0e 03 c0 	movl   $0xc0030e2e,-0x14(%ebp)
      break;
c0029846:	eb 11                	jmp    c0029859 <print_stacktrace+0x4c>

    case THREAD_READY:  
      status = "READY";
c0029848:	c7 45 ec 36 0e 03 c0 	movl   $0xc0030e36,-0x14(%ebp)
      break;
c002984f:	eb 08                	jmp    c0029859 <print_stacktrace+0x4c>

    case THREAD_BLOCKED:  
      status = "BLOCKED";
c0029851:	c7 45 ec 3c 0e 03 c0 	movl   $0xc0030e3c,-0x14(%ebp)
      break;
c0029858:	90                   	nop

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0029859:	8b 45 08             	mov    0x8(%ebp),%eax
c002985c:	83 c0 08             	add    $0x8,%eax
c002985f:	83 ec 04             	sub    $0x4,%esp
c0029862:	ff 75 ec             	pushl  -0x14(%ebp)
c0029865:	50                   	push   %eax
c0029866:	68 44 0e 03 c0       	push   $0xc0030e44
c002986b:	e8 d5 da ff ff       	call   c0027345 <printf>
c0029870:	83 c4 10             	add    $0x10,%esp

  if (t == thread_current()) 
c0029873:	e8 27 75 ff ff       	call   c0020d9f <thread_current>
c0029878:	3b 45 08             	cmp    0x8(%ebp),%eax
c002987b:	75 0e                	jne    c002988b <print_stacktrace+0x7e>
    {
      frame = __builtin_frame_address (1);
c002987d:	8b 45 00             	mov    0x0(%ebp),%eax
c0029880:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = __builtin_return_address (0);
c0029883:	8b 45 04             	mov    0x4(%ebp),%eax
c0029886:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029889:	eb 4d                	jmp    c00298d8 <print_stacktrace+0xcb>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c002988b:	8b 45 08             	mov    0x8(%ebp),%eax
c002988e:	8b 40 18             	mov    0x18(%eax),%eax
c0029891:	89 45 e8             	mov    %eax,-0x18(%ebp)
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0029894:	8b 45 08             	mov    0x8(%ebp),%eax
c0029897:	8b 40 18             	mov    0x18(%eax),%eax
c002989a:	8b 55 08             	mov    0x8(%ebp),%edx
c002989d:	81 c2 00 10 00 00    	add    $0x1000,%edx
c00298a3:	39 d0                	cmp    %edx,%eax
c00298a5:	74 0d                	je     c00298b4 <print_stacktrace+0xa7>
c00298a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00298aa:	8b 40 10             	mov    0x10(%eax),%eax
c00298ad:	3d 2b 14 02 c0       	cmp    $0xc002142b,%eax
c00298b2:	75 12                	jne    c00298c6 <print_stacktrace+0xb9>
        {
          printf (" thread was never scheduled.\n");
c00298b4:	83 ec 0c             	sub    $0xc,%esp
c00298b7:	68 6b 0e 03 c0       	push   $0xc0030e6b
c00298bc:	e8 6a 20 00 00       	call   c002b92b <puts>
c00298c1:	83 c4 10             	add    $0x10,%esp
          return;
c00298c4:	eb 6b                	jmp    c0029931 <print_stacktrace+0x124>
        }

      frame = (void **) saved_frame->ebp;
c00298c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00298c9:	8b 40 08             	mov    0x8(%eax),%eax
c00298cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = (void *) saved_frame->eip;
c00298cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00298d2:	8b 40 10             	mov    0x10(%eax),%eax
c00298d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

  printf (" %p", retaddr);
c00298d8:	83 ec 08             	sub    $0x8,%esp
c00298db:	ff 75 f4             	pushl  -0xc(%ebp)
c00298de:	68 88 0e 03 c0       	push   $0xc0030e88
c00298e3:	e8 5d da ff ff       	call   c0027345 <printf>
c00298e8:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00298eb:	eb 21                	jmp    c002990e <print_stacktrace+0x101>
    printf (" %p", frame[1]);
c00298ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00298f0:	83 c0 04             	add    $0x4,%eax
c00298f3:	8b 00                	mov    (%eax),%eax
c00298f5:	83 ec 08             	sub    $0x8,%esp
c00298f8:	50                   	push   %eax
c00298f9:	68 88 0e 03 c0       	push   $0xc0030e88
c00298fe:	e8 42 da ff ff       	call   c0027345 <printf>
c0029903:	83 c4 10             	add    $0x10,%esp
      frame = (void **) saved_frame->ebp;
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0029906:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029909:	8b 00                	mov    (%eax),%eax
c002990b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002990e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029911:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c0029916:	76 09                	jbe    c0029921 <print_stacktrace+0x114>
c0029918:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002991b:	8b 00                	mov    (%eax),%eax
c002991d:	85 c0                	test   %eax,%eax
c002991f:	75 cc                	jne    c00298ed <print_stacktrace+0xe0>
    printf (" %p", frame[1]);
  printf (".\n");
c0029921:	83 ec 0c             	sub    $0xc,%esp
c0029924:	68 8c 0e 03 c0       	push   $0xc0030e8c
c0029929:	e8 fd 1f 00 00       	call   c002b92b <puts>
c002992e:	83 c4 10             	add    $0x10,%esp
}
c0029931:	c9                   	leave  
c0029932:	c3                   	ret    

c0029933 <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c0029933:	55                   	push   %ebp
c0029934:	89 e5                	mov    %esp,%ebp
c0029936:	83 ec 18             	sub    $0x18,%esp
  enum intr_level oldlevel = intr_disable ();
c0029939:	e8 8e 7b ff ff       	call   c00214cc <intr_disable>
c002993e:	89 45 f4             	mov    %eax,-0xc(%ebp)

  thread_foreach (print_stacktrace, 0);
c0029941:	83 ec 08             	sub    $0x8,%esp
c0029944:	6a 00                	push   $0x0
c0029946:	68 0d 98 02 c0       	push   $0xc002980d
c002994b:	e8 c9 75 ff ff       	call   c0020f19 <thread_foreach>
c0029950:	83 c4 10             	add    $0x10,%esp
  intr_set_level (oldlevel);
c0029953:	83 ec 0c             	sub    $0xc,%esp
c0029956:	ff 75 f4             	pushl  -0xc(%ebp)
c0029959:	e8 16 7b ff ff       	call   c0021474 <intr_set_level>
c002995e:	83 c4 10             	add    $0x10,%esp
}
c0029961:	90                   	nop
c0029962:	c9                   	leave  
c0029963:	c3                   	ret    

c0029964 <is_head>:
                       list_less_func *less, void *aux) UNUSED;

/* Returns true if ELEM is a head, false otherwise. */
static inline bool
is_head (struct list_elem *elem)
{
c0029964:	55                   	push   %ebp
c0029965:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029967:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002996b:	74 1a                	je     c0029987 <is_head+0x23>
c002996d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029970:	8b 00                	mov    (%eax),%eax
c0029972:	85 c0                	test   %eax,%eax
c0029974:	75 11                	jne    c0029987 <is_head+0x23>
c0029976:	8b 45 08             	mov    0x8(%ebp),%eax
c0029979:	8b 40 04             	mov    0x4(%eax),%eax
c002997c:	85 c0                	test   %eax,%eax
c002997e:	74 07                	je     c0029987 <is_head+0x23>
c0029980:	b8 01 00 00 00       	mov    $0x1,%eax
c0029985:	eb 05                	jmp    c002998c <is_head+0x28>
c0029987:	b8 00 00 00 00       	mov    $0x0,%eax
c002998c:	83 e0 01             	and    $0x1,%eax
}
c002998f:	5d                   	pop    %ebp
c0029990:	c3                   	ret    

c0029991 <is_interior>:

/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
c0029991:	55                   	push   %ebp
c0029992:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029994:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029998:	74 1a                	je     c00299b4 <is_interior+0x23>
c002999a:	8b 45 08             	mov    0x8(%ebp),%eax
c002999d:	8b 00                	mov    (%eax),%eax
c002999f:	85 c0                	test   %eax,%eax
c00299a1:	74 11                	je     c00299b4 <is_interior+0x23>
c00299a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00299a6:	8b 40 04             	mov    0x4(%eax),%eax
c00299a9:	85 c0                	test   %eax,%eax
c00299ab:	74 07                	je     c00299b4 <is_interior+0x23>
c00299ad:	b8 01 00 00 00       	mov    $0x1,%eax
c00299b2:	eb 05                	jmp    c00299b9 <is_interior+0x28>
c00299b4:	b8 00 00 00 00       	mov    $0x0,%eax
c00299b9:	83 e0 01             	and    $0x1,%eax
}
c00299bc:	5d                   	pop    %ebp
c00299bd:	c3                   	ret    

c00299be <is_tail>:

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
c00299be:	55                   	push   %ebp
c00299bf:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00299c1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00299c5:	74 1a                	je     c00299e1 <is_tail+0x23>
c00299c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00299ca:	8b 00                	mov    (%eax),%eax
c00299cc:	85 c0                	test   %eax,%eax
c00299ce:	74 11                	je     c00299e1 <is_tail+0x23>
c00299d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00299d3:	8b 40 04             	mov    0x4(%eax),%eax
c00299d6:	85 c0                	test   %eax,%eax
c00299d8:	75 07                	jne    c00299e1 <is_tail+0x23>
c00299da:	b8 01 00 00 00       	mov    $0x1,%eax
c00299df:	eb 05                	jmp    c00299e6 <is_tail+0x28>
c00299e1:	b8 00 00 00 00       	mov    $0x0,%eax
c00299e6:	83 e0 01             	and    $0x1,%eax
}
c00299e9:	5d                   	pop    %ebp
c00299ea:	c3                   	ret    

c00299eb <list_init>:

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c00299eb:	55                   	push   %ebp
c00299ec:	89 e5                	mov    %esp,%ebp
c00299ee:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c00299f1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00299f5:	75 1e                	jne    c0029a15 <list_init+0x2a>
c00299f7:	83 ec 0c             	sub    $0xc,%esp
c00299fa:	68 90 0e 03 c0       	push   $0xc0030e90
c00299ff:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029a04:	68 68 10 03 c0       	push   $0xc0031068
c0029a09:	6a 3f                	push   $0x3f
c0029a0b:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029a10:	e8 63 fd ff ff       	call   c0029778 <debug_panic>
  list->head.prev = NULL;
c0029a15:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a18:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c0029a1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a21:	8d 50 08             	lea    0x8(%eax),%edx
c0029a24:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a27:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c0029a2a:	8b 55 08             	mov    0x8(%ebp),%edx
c0029a2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a30:	89 50 08             	mov    %edx,0x8(%eax)
  list->tail.next = NULL;
c0029a33:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a36:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c0029a3d:	90                   	nop
c0029a3e:	c9                   	leave  
c0029a3f:	c3                   	ret    

c0029a40 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c0029a40:	55                   	push   %ebp
c0029a41:	89 e5                	mov    %esp,%ebp
c0029a43:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029a46:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029a4a:	75 1e                	jne    c0029a6a <list_begin+0x2a>
c0029a4c:	83 ec 0c             	sub    $0xc,%esp
c0029a4f:	68 90 0e 03 c0       	push   $0xc0030e90
c0029a54:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029a59:	68 74 10 03 c0       	push   $0xc0031074
c0029a5e:	6a 4a                	push   $0x4a
c0029a60:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029a65:	e8 0e fd ff ff       	call   c0029778 <debug_panic>
  return list->head.next;
c0029a6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a6d:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029a70:	c9                   	leave  
c0029a71:	c3                   	ret    

c0029a72 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c0029a72:	55                   	push   %ebp
c0029a73:	89 e5                	mov    %esp,%ebp
c0029a75:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_head (elem) || is_interior (elem));
c0029a78:	ff 75 08             	pushl  0x8(%ebp)
c0029a7b:	e8 e4 fe ff ff       	call   c0029964 <is_head>
c0029a80:	83 c4 04             	add    $0x4,%esp
c0029a83:	84 c0                	test   %al,%al
c0029a85:	75 2d                	jne    c0029ab4 <list_next+0x42>
c0029a87:	ff 75 08             	pushl  0x8(%ebp)
c0029a8a:	e8 02 ff ff ff       	call   c0029991 <is_interior>
c0029a8f:	83 c4 04             	add    $0x4,%esp
c0029a92:	84 c0                	test   %al,%al
c0029a94:	75 1e                	jne    c0029ab4 <list_next+0x42>
c0029a96:	83 ec 0c             	sub    $0xc,%esp
c0029a99:	68 cc 0e 03 c0       	push   $0xc0030ecc
c0029a9e:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029aa3:	68 80 10 03 c0       	push   $0xc0031080
c0029aa8:	6a 54                	push   $0x54
c0029aaa:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029aaf:	e8 c4 fc ff ff       	call   c0029778 <debug_panic>
  return elem->next;
c0029ab4:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ab7:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029aba:	c9                   	leave  
c0029abb:	c3                   	ret    

c0029abc <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c0029abc:	55                   	push   %ebp
c0029abd:	89 e5                	mov    %esp,%ebp
c0029abf:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029ac2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029ac6:	75 1e                	jne    c0029ae6 <list_end+0x2a>
c0029ac8:	83 ec 0c             	sub    $0xc,%esp
c0029acb:	68 90 0e 03 c0       	push   $0xc0030e90
c0029ad0:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029ad5:	68 8c 10 03 c0       	push   $0xc003108c
c0029ada:	6a 60                	push   $0x60
c0029adc:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029ae1:	e8 92 fc ff ff       	call   c0029778 <debug_panic>
  return &list->tail;
c0029ae6:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ae9:	83 c0 08             	add    $0x8,%eax
}
c0029aec:	c9                   	leave  
c0029aed:	c3                   	ret    

c0029aee <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c0029aee:	55                   	push   %ebp
c0029aef:	89 e5                	mov    %esp,%ebp
c0029af1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029af4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029af8:	75 1e                	jne    c0029b18 <list_rbegin+0x2a>
c0029afa:	83 ec 0c             	sub    $0xc,%esp
c0029afd:	68 90 0e 03 c0       	push   $0xc0030e90
c0029b02:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029b07:	68 98 10 03 c0       	push   $0xc0031098
c0029b0c:	6a 69                	push   $0x69
c0029b0e:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029b13:	e8 60 fc ff ff       	call   c0029778 <debug_panic>
  return list->tail.prev;
c0029b18:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b1b:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029b1e:	c9                   	leave  
c0029b1f:	c3                   	ret    

c0029b20 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c0029b20:	55                   	push   %ebp
c0029b21:	89 e5                	mov    %esp,%ebp
c0029b23:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem) || is_tail (elem));
c0029b26:	ff 75 08             	pushl  0x8(%ebp)
c0029b29:	e8 63 fe ff ff       	call   c0029991 <is_interior>
c0029b2e:	83 c4 04             	add    $0x4,%esp
c0029b31:	84 c0                	test   %al,%al
c0029b33:	75 2d                	jne    c0029b62 <list_prev+0x42>
c0029b35:	ff 75 08             	pushl  0x8(%ebp)
c0029b38:	e8 81 fe ff ff       	call   c00299be <is_tail>
c0029b3d:	83 c4 04             	add    $0x4,%esp
c0029b40:	84 c0                	test   %al,%al
c0029b42:	75 1e                	jne    c0029b62 <list_prev+0x42>
c0029b44:	83 ec 0c             	sub    $0xc,%esp
c0029b47:	68 f4 0e 03 c0       	push   $0xc0030ef4
c0029b4c:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029b51:	68 a4 10 03 c0       	push   $0xc00310a4
c0029b56:	6a 73                	push   $0x73
c0029b58:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029b5d:	e8 16 fc ff ff       	call   c0029778 <debug_panic>
  return elem->prev;
c0029b62:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b65:	8b 00                	mov    (%eax),%eax
}
c0029b67:	c9                   	leave  
c0029b68:	c3                   	ret    

c0029b69 <list_rend>:
          ...do something with f...
        }
*/
struct list_elem *
list_rend (struct list *list) 
{
c0029b69:	55                   	push   %ebp
c0029b6a:	89 e5                	mov    %esp,%ebp
c0029b6c:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029b6f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029b73:	75 21                	jne    c0029b96 <list_rend+0x2d>
c0029b75:	83 ec 0c             	sub    $0xc,%esp
c0029b78:	68 90 0e 03 c0       	push   $0xc0030e90
c0029b7d:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029b82:	68 b0 10 03 c0       	push   $0xc00310b0
c0029b87:	68 87 00 00 00       	push   $0x87
c0029b8c:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029b91:	e8 e2 fb ff ff       	call   c0029778 <debug_panic>
  return &list->head;
c0029b96:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029b99:	c9                   	leave  
c0029b9a:	c3                   	ret    

c0029b9b <list_head>:
          ...
        }
*/
struct list_elem *
list_head (struct list *list) 
{
c0029b9b:	55                   	push   %ebp
c0029b9c:	89 e5                	mov    %esp,%ebp
c0029b9e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029ba1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029ba5:	75 21                	jne    c0029bc8 <list_head+0x2d>
c0029ba7:	83 ec 0c             	sub    $0xc,%esp
c0029baa:	68 90 0e 03 c0       	push   $0xc0030e90
c0029baf:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029bb4:	68 bc 10 03 c0       	push   $0xc00310bc
c0029bb9:	68 99 00 00 00       	push   $0x99
c0029bbe:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029bc3:	e8 b0 fb ff ff       	call   c0029778 <debug_panic>
  return &list->head;
c0029bc8:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029bcb:	c9                   	leave  
c0029bcc:	c3                   	ret    

c0029bcd <list_tail>:

/* Return's LIST's tail. */
struct list_elem *
list_tail (struct list *list) 
{
c0029bcd:	55                   	push   %ebp
c0029bce:	89 e5                	mov    %esp,%ebp
c0029bd0:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029bd3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029bd7:	75 21                	jne    c0029bfa <list_tail+0x2d>
c0029bd9:	83 ec 0c             	sub    $0xc,%esp
c0029bdc:	68 90 0e 03 c0       	push   $0xc0030e90
c0029be1:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029be6:	68 c8 10 03 c0       	push   $0xc00310c8
c0029beb:	68 a1 00 00 00       	push   $0xa1
c0029bf0:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029bf5:	e8 7e fb ff ff       	call   c0029778 <debug_panic>
  return &list->tail;
c0029bfa:	8b 45 08             	mov    0x8(%ebp),%eax
c0029bfd:	83 c0 08             	add    $0x8,%eax
}
c0029c00:	c9                   	leave  
c0029c01:	c3                   	ret    

c0029c02 <list_insert>:
/* Inserts ELEM just before BEFORE, which may be either an
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
c0029c02:	55                   	push   %ebp
c0029c03:	89 e5                	mov    %esp,%ebp
c0029c05:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c0029c08:	ff 75 08             	pushl  0x8(%ebp)
c0029c0b:	e8 81 fd ff ff       	call   c0029991 <is_interior>
c0029c10:	83 c4 04             	add    $0x4,%esp
c0029c13:	84 c0                	test   %al,%al
c0029c15:	75 30                	jne    c0029c47 <list_insert+0x45>
c0029c17:	ff 75 08             	pushl  0x8(%ebp)
c0029c1a:	e8 9f fd ff ff       	call   c00299be <is_tail>
c0029c1f:	83 c4 04             	add    $0x4,%esp
c0029c22:	84 c0                	test   %al,%al
c0029c24:	75 21                	jne    c0029c47 <list_insert+0x45>
c0029c26:	83 ec 0c             	sub    $0xc,%esp
c0029c29:	68 1c 0f 03 c0       	push   $0xc0030f1c
c0029c2e:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029c33:	68 d4 10 03 c0       	push   $0xc00310d4
c0029c38:	68 ab 00 00 00       	push   $0xab
c0029c3d:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029c42:	e8 31 fb ff ff       	call   c0029778 <debug_panic>
  ASSERT (elem != NULL);
c0029c47:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0029c4b:	75 21                	jne    c0029c6e <list_insert+0x6c>
c0029c4d:	83 ec 0c             	sub    $0xc,%esp
c0029c50:	68 45 0f 03 c0       	push   $0xc0030f45
c0029c55:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029c5a:	68 d4 10 03 c0       	push   $0xc00310d4
c0029c5f:	68 ac 00 00 00       	push   $0xac
c0029c64:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029c69:	e8 0a fb ff ff       	call   c0029778 <debug_panic>

  elem->prev = before->prev;
c0029c6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c71:	8b 10                	mov    (%eax),%edx
c0029c73:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029c76:	89 10                	mov    %edx,(%eax)
  elem->next = before;
c0029c78:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029c7b:	8b 55 08             	mov    0x8(%ebp),%edx
c0029c7e:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = elem;
c0029c81:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c84:	8b 00                	mov    (%eax),%eax
c0029c86:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029c89:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = elem;
c0029c8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c8f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029c92:	89 10                	mov    %edx,(%eax)
}
c0029c94:	90                   	nop
c0029c95:	c9                   	leave  
c0029c96:	c3                   	ret    

c0029c97 <list_splice>:
   current list, then inserts them just before BEFORE, which may
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
c0029c97:	55                   	push   %ebp
c0029c98:	89 e5                	mov    %esp,%ebp
c0029c9a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c0029c9d:	ff 75 08             	pushl  0x8(%ebp)
c0029ca0:	e8 ec fc ff ff       	call   c0029991 <is_interior>
c0029ca5:	83 c4 04             	add    $0x4,%esp
c0029ca8:	84 c0                	test   %al,%al
c0029caa:	75 30                	jne    c0029cdc <list_splice+0x45>
c0029cac:	ff 75 08             	pushl  0x8(%ebp)
c0029caf:	e8 0a fd ff ff       	call   c00299be <is_tail>
c0029cb4:	83 c4 04             	add    $0x4,%esp
c0029cb7:	84 c0                	test   %al,%al
c0029cb9:	75 21                	jne    c0029cdc <list_splice+0x45>
c0029cbb:	83 ec 0c             	sub    $0xc,%esp
c0029cbe:	68 1c 0f 03 c0       	push   $0xc0030f1c
c0029cc3:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029cc8:	68 e0 10 03 c0       	push   $0xc00310e0
c0029ccd:	68 bb 00 00 00       	push   $0xbb
c0029cd2:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029cd7:	e8 9c fa ff ff       	call   c0029778 <debug_panic>
  if (first == last)
c0029cdc:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029cdf:	3b 45 10             	cmp    0x10(%ebp),%eax
c0029ce2:	0f 84 ba 00 00 00    	je     c0029da2 <list_splice+0x10b>
    return;
  last = list_prev (last);
c0029ce8:	83 ec 0c             	sub    $0xc,%esp
c0029ceb:	ff 75 10             	pushl  0x10(%ebp)
c0029cee:	e8 2d fe ff ff       	call   c0029b20 <list_prev>
c0029cf3:	83 c4 10             	add    $0x10,%esp
c0029cf6:	89 45 10             	mov    %eax,0x10(%ebp)

  ASSERT (is_interior (first));
c0029cf9:	83 ec 0c             	sub    $0xc,%esp
c0029cfc:	ff 75 0c             	pushl  0xc(%ebp)
c0029cff:	e8 8d fc ff ff       	call   c0029991 <is_interior>
c0029d04:	83 c4 10             	add    $0x10,%esp
c0029d07:	84 c0                	test   %al,%al
c0029d09:	75 21                	jne    c0029d2c <list_splice+0x95>
c0029d0b:	83 ec 0c             	sub    $0xc,%esp
c0029d0e:	68 52 0f 03 c0       	push   $0xc0030f52
c0029d13:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029d18:	68 e0 10 03 c0       	push   $0xc00310e0
c0029d1d:	68 c0 00 00 00       	push   $0xc0
c0029d22:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029d27:	e8 4c fa ff ff       	call   c0029778 <debug_panic>
  ASSERT (is_interior (last));
c0029d2c:	83 ec 0c             	sub    $0xc,%esp
c0029d2f:	ff 75 10             	pushl  0x10(%ebp)
c0029d32:	e8 5a fc ff ff       	call   c0029991 <is_interior>
c0029d37:	83 c4 10             	add    $0x10,%esp
c0029d3a:	84 c0                	test   %al,%al
c0029d3c:	75 21                	jne    c0029d5f <list_splice+0xc8>
c0029d3e:	83 ec 0c             	sub    $0xc,%esp
c0029d41:	68 66 0f 03 c0       	push   $0xc0030f66
c0029d46:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029d4b:	68 e0 10 03 c0       	push   $0xc00310e0
c0029d50:	68 c1 00 00 00       	push   $0xc1
c0029d55:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029d5a:	e8 19 fa ff ff       	call   c0029778 <debug_panic>

  /* Cleanly remove FIRST...LAST from its current list. */
  first->prev->next = last->next;
c0029d5f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029d62:	8b 00                	mov    (%eax),%eax
c0029d64:	8b 55 10             	mov    0x10(%ebp),%edx
c0029d67:	8b 52 04             	mov    0x4(%edx),%edx
c0029d6a:	89 50 04             	mov    %edx,0x4(%eax)
  last->next->prev = first->prev;
c0029d6d:	8b 45 10             	mov    0x10(%ebp),%eax
c0029d70:	8b 40 04             	mov    0x4(%eax),%eax
c0029d73:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029d76:	8b 12                	mov    (%edx),%edx
c0029d78:	89 10                	mov    %edx,(%eax)

  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
c0029d7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d7d:	8b 10                	mov    (%eax),%edx
c0029d7f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029d82:	89 10                	mov    %edx,(%eax)
  last->next = before;
c0029d84:	8b 45 10             	mov    0x10(%ebp),%eax
c0029d87:	8b 55 08             	mov    0x8(%ebp),%edx
c0029d8a:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = first;
c0029d8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d90:	8b 00                	mov    (%eax),%eax
c0029d92:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029d95:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = last;
c0029d98:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d9b:	8b 55 10             	mov    0x10(%ebp),%edx
c0029d9e:	89 10                	mov    %edx,(%eax)
c0029da0:	eb 01                	jmp    c0029da3 <list_splice+0x10c>
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
  ASSERT (is_interior (before) || is_tail (before));
  if (first == last)
    return;
c0029da2:	90                   	nop
  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
  last->next = before;
  before->prev->next = first;
  before->prev = last;
}
c0029da3:	c9                   	leave  
c0029da4:	c3                   	ret    

c0029da5 <list_push_front>:

/* Inserts ELEM at the beginning of LIST, so that it becomes the
   front in LIST. */
void
list_push_front (struct list *list, struct list_elem *elem)
{
c0029da5:	55                   	push   %ebp
c0029da6:	89 e5                	mov    %esp,%ebp
c0029da8:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_begin (list), elem);
c0029dab:	83 ec 0c             	sub    $0xc,%esp
c0029dae:	ff 75 08             	pushl  0x8(%ebp)
c0029db1:	e8 8a fc ff ff       	call   c0029a40 <list_begin>
c0029db6:	83 c4 10             	add    $0x10,%esp
c0029db9:	83 ec 08             	sub    $0x8,%esp
c0029dbc:	ff 75 0c             	pushl  0xc(%ebp)
c0029dbf:	50                   	push   %eax
c0029dc0:	e8 3d fe ff ff       	call   c0029c02 <list_insert>
c0029dc5:	83 c4 10             	add    $0x10,%esp
}
c0029dc8:	90                   	nop
c0029dc9:	c9                   	leave  
c0029dca:	c3                   	ret    

c0029dcb <list_push_back>:

/* Inserts ELEM at the end of LIST, so that it becomes the
   back in LIST. */
void
list_push_back (struct list *list, struct list_elem *elem)
{
c0029dcb:	55                   	push   %ebp
c0029dcc:	89 e5                	mov    %esp,%ebp
c0029dce:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_end (list), elem);
c0029dd1:	83 ec 0c             	sub    $0xc,%esp
c0029dd4:	ff 75 08             	pushl  0x8(%ebp)
c0029dd7:	e8 e0 fc ff ff       	call   c0029abc <list_end>
c0029ddc:	83 c4 10             	add    $0x10,%esp
c0029ddf:	83 ec 08             	sub    $0x8,%esp
c0029de2:	ff 75 0c             	pushl  0xc(%ebp)
c0029de5:	50                   	push   %eax
c0029de6:	e8 17 fe ff ff       	call   c0029c02 <list_insert>
c0029deb:	83 c4 10             	add    $0x10,%esp
}
c0029dee:	90                   	nop
c0029def:	c9                   	leave  
c0029df0:	c3                   	ret    

c0029df1 <list_remove>:
       ...do something with e...
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
c0029df1:	55                   	push   %ebp
c0029df2:	89 e5                	mov    %esp,%ebp
c0029df4:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem));
c0029df7:	ff 75 08             	pushl  0x8(%ebp)
c0029dfa:	e8 92 fb ff ff       	call   c0029991 <is_interior>
c0029dff:	83 c4 04             	add    $0x4,%esp
c0029e02:	84 c0                	test   %al,%al
c0029e04:	75 21                	jne    c0029e27 <list_remove+0x36>
c0029e06:	83 ec 0c             	sub    $0xc,%esp
c0029e09:	68 79 0f 03 c0       	push   $0xc0030f79
c0029e0e:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029e13:	68 ec 10 03 c0       	push   $0xc00310ec
c0029e18:	68 fb 00 00 00       	push   $0xfb
c0029e1d:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029e22:	e8 51 f9 ff ff       	call   c0029778 <debug_panic>
  elem->prev->next = elem->next;
c0029e27:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e2a:	8b 00                	mov    (%eax),%eax
c0029e2c:	8b 55 08             	mov    0x8(%ebp),%edx
c0029e2f:	8b 52 04             	mov    0x4(%edx),%edx
c0029e32:	89 50 04             	mov    %edx,0x4(%eax)
  elem->next->prev = elem->prev;
c0029e35:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e38:	8b 40 04             	mov    0x4(%eax),%eax
c0029e3b:	8b 55 08             	mov    0x8(%ebp),%edx
c0029e3e:	8b 12                	mov    (%edx),%edx
c0029e40:	89 10                	mov    %edx,(%eax)
  return elem->next;
c0029e42:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e45:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029e48:	c9                   	leave  
c0029e49:	c3                   	ret    

c0029e4a <list_pop_front>:

/* Removes the front element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_front (struct list *list)
{
c0029e4a:	55                   	push   %ebp
c0029e4b:	89 e5                	mov    %esp,%ebp
c0029e4d:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *front = list_front (list);
c0029e50:	83 ec 0c             	sub    $0xc,%esp
c0029e53:	ff 75 08             	pushl  0x8(%ebp)
c0029e56:	e8 43 00 00 00       	call   c0029e9e <list_front>
c0029e5b:	83 c4 10             	add    $0x10,%esp
c0029e5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (front);
c0029e61:	83 ec 0c             	sub    $0xc,%esp
c0029e64:	ff 75 f4             	pushl  -0xc(%ebp)
c0029e67:	e8 85 ff ff ff       	call   c0029df1 <list_remove>
c0029e6c:	83 c4 10             	add    $0x10,%esp
  return front;
c0029e6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029e72:	c9                   	leave  
c0029e73:	c3                   	ret    

c0029e74 <list_pop_back>:

/* Removes the back element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_back (struct list *list)
{
c0029e74:	55                   	push   %ebp
c0029e75:	89 e5                	mov    %esp,%ebp
c0029e77:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *back = list_back (list);
c0029e7a:	83 ec 0c             	sub    $0xc,%esp
c0029e7d:	ff 75 08             	pushl  0x8(%ebp)
c0029e80:	e8 5d 00 00 00       	call   c0029ee2 <list_back>
c0029e85:	83 c4 10             	add    $0x10,%esp
c0029e88:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (back);
c0029e8b:	83 ec 0c             	sub    $0xc,%esp
c0029e8e:	ff 75 f4             	pushl  -0xc(%ebp)
c0029e91:	e8 5b ff ff ff       	call   c0029df1 <list_remove>
c0029e96:	83 c4 10             	add    $0x10,%esp
  return back;
c0029e99:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029e9c:	c9                   	leave  
c0029e9d:	c3                   	ret    

c0029e9e <list_front>:

/* Returns the front element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_front (struct list *list)
{
c0029e9e:	55                   	push   %ebp
c0029e9f:	89 e5                	mov    %esp,%ebp
c0029ea1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c0029ea4:	83 ec 0c             	sub    $0xc,%esp
c0029ea7:	ff 75 08             	pushl  0x8(%ebp)
c0029eaa:	e8 c4 00 00 00       	call   c0029f73 <list_empty>
c0029eaf:	83 c4 10             	add    $0x10,%esp
c0029eb2:	83 f0 01             	xor    $0x1,%eax
c0029eb5:	84 c0                	test   %al,%al
c0029eb7:	75 21                	jne    c0029eda <list_front+0x3c>
c0029eb9:	83 ec 0c             	sub    $0xc,%esp
c0029ebc:	68 8c 0f 03 c0       	push   $0xc0030f8c
c0029ec1:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029ec6:	68 f8 10 03 c0       	push   $0xc00310f8
c0029ecb:	68 1a 01 00 00       	push   $0x11a
c0029ed0:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029ed5:	e8 9e f8 ff ff       	call   c0029778 <debug_panic>
  return list->head.next;
c0029eda:	8b 45 08             	mov    0x8(%ebp),%eax
c0029edd:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029ee0:	c9                   	leave  
c0029ee1:	c3                   	ret    

c0029ee2 <list_back>:

/* Returns the back element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_back (struct list *list)
{
c0029ee2:	55                   	push   %ebp
c0029ee3:	89 e5                	mov    %esp,%ebp
c0029ee5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c0029ee8:	83 ec 0c             	sub    $0xc,%esp
c0029eeb:	ff 75 08             	pushl  0x8(%ebp)
c0029eee:	e8 80 00 00 00       	call   c0029f73 <list_empty>
c0029ef3:	83 c4 10             	add    $0x10,%esp
c0029ef6:	83 f0 01             	xor    $0x1,%eax
c0029ef9:	84 c0                	test   %al,%al
c0029efb:	75 21                	jne    c0029f1e <list_back+0x3c>
c0029efd:	83 ec 0c             	sub    $0xc,%esp
c0029f00:	68 8c 0f 03 c0       	push   $0xc0030f8c
c0029f05:	68 9d 0e 03 c0       	push   $0xc0030e9d
c0029f0a:	68 04 11 03 c0       	push   $0xc0031104
c0029f0f:	68 23 01 00 00       	push   $0x123
c0029f14:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029f19:	e8 5a f8 ff ff       	call   c0029778 <debug_panic>
  return list->tail.prev;
c0029f1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f21:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029f24:	c9                   	leave  
c0029f25:	c3                   	ret    

c0029f26 <list_size>:

/* Returns the number of elements in LIST.
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
c0029f26:	55                   	push   %ebp
c0029f27:	89 e5                	mov    %esp,%ebp
c0029f29:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;
  size_t cnt = 0;
c0029f2c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029f33:	83 ec 0c             	sub    $0xc,%esp
c0029f36:	ff 75 08             	pushl  0x8(%ebp)
c0029f39:	e8 02 fb ff ff       	call   c0029a40 <list_begin>
c0029f3e:	83 c4 10             	add    $0x10,%esp
c0029f41:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029f44:	eb 15                	jmp    c0029f5b <list_size+0x35>
    cnt++;
c0029f46:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
list_size (struct list *list)
{
  struct list_elem *e;
  size_t cnt = 0;

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029f4a:	83 ec 0c             	sub    $0xc,%esp
c0029f4d:	ff 75 f4             	pushl  -0xc(%ebp)
c0029f50:	e8 1d fb ff ff       	call   c0029a72 <list_next>
c0029f55:	83 c4 10             	add    $0x10,%esp
c0029f58:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029f5b:	83 ec 0c             	sub    $0xc,%esp
c0029f5e:	ff 75 08             	pushl  0x8(%ebp)
c0029f61:	e8 56 fb ff ff       	call   c0029abc <list_end>
c0029f66:	83 c4 10             	add    $0x10,%esp
c0029f69:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029f6c:	75 d8                	jne    c0029f46 <list_size+0x20>
    cnt++;
  return cnt;
c0029f6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0029f71:	c9                   	leave  
c0029f72:	c3                   	ret    

c0029f73 <list_empty>:

/* Returns true if LIST is empty, false otherwise. */
bool
list_empty (struct list *list)
{
c0029f73:	55                   	push   %ebp
c0029f74:	89 e5                	mov    %esp,%ebp
c0029f76:	53                   	push   %ebx
c0029f77:	83 ec 04             	sub    $0x4,%esp
  return list_begin (list) == list_end (list);
c0029f7a:	83 ec 0c             	sub    $0xc,%esp
c0029f7d:	ff 75 08             	pushl  0x8(%ebp)
c0029f80:	e8 bb fa ff ff       	call   c0029a40 <list_begin>
c0029f85:	83 c4 10             	add    $0x10,%esp
c0029f88:	89 c3                	mov    %eax,%ebx
c0029f8a:	83 ec 0c             	sub    $0xc,%esp
c0029f8d:	ff 75 08             	pushl  0x8(%ebp)
c0029f90:	e8 27 fb ff ff       	call   c0029abc <list_end>
c0029f95:	83 c4 10             	add    $0x10,%esp
c0029f98:	39 c3                	cmp    %eax,%ebx
c0029f9a:	0f 94 c0             	sete   %al
}
c0029f9d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029fa0:	c9                   	leave  
c0029fa1:	c3                   	ret    

c0029fa2 <swap>:

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
c0029fa2:	55                   	push   %ebp
c0029fa3:	89 e5                	mov    %esp,%ebp
c0029fa5:	83 ec 10             	sub    $0x10,%esp
  struct list_elem *t = *a;
c0029fa8:	8b 45 08             	mov    0x8(%ebp),%eax
c0029fab:	8b 00                	mov    (%eax),%eax
c0029fad:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *a = *b;
c0029fb0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029fb3:	8b 10                	mov    (%eax),%edx
c0029fb5:	8b 45 08             	mov    0x8(%ebp),%eax
c0029fb8:	89 10                	mov    %edx,(%eax)
  *b = t;
c0029fba:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029fbd:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0029fc0:	89 10                	mov    %edx,(%eax)
}
c0029fc2:	90                   	nop
c0029fc3:	c9                   	leave  
c0029fc4:	c3                   	ret    

c0029fc5 <list_reverse>:

/* Reverses the order of LIST. */
void
list_reverse (struct list *list)
{
c0029fc5:	55                   	push   %ebp
c0029fc6:	89 e5                	mov    %esp,%ebp
c0029fc8:	83 ec 18             	sub    $0x18,%esp
  if (!list_empty (list)) 
c0029fcb:	83 ec 0c             	sub    $0xc,%esp
c0029fce:	ff 75 08             	pushl  0x8(%ebp)
c0029fd1:	e8 9d ff ff ff       	call   c0029f73 <list_empty>
c0029fd6:	83 c4 10             	add    $0x10,%esp
c0029fd9:	83 f0 01             	xor    $0x1,%eax
c0029fdc:	84 c0                	test   %al,%al
c0029fde:	74 79                	je     c002a059 <list_reverse+0x94>
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029fe0:	83 ec 0c             	sub    $0xc,%esp
c0029fe3:	ff 75 08             	pushl  0x8(%ebp)
c0029fe6:	e8 55 fa ff ff       	call   c0029a40 <list_begin>
c0029feb:	83 c4 10             	add    $0x10,%esp
c0029fee:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029ff1:	eb 1e                	jmp    c002a011 <list_reverse+0x4c>
        swap (&e->prev, &e->next);
c0029ff3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ff6:	8d 50 04             	lea    0x4(%eax),%edx
c0029ff9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ffc:	83 ec 08             	sub    $0x8,%esp
c0029fff:	52                   	push   %edx
c002a000:	50                   	push   %eax
c002a001:	e8 9c ff ff ff       	call   c0029fa2 <swap>
c002a006:	83 c4 10             	add    $0x10,%esp
{
  if (!list_empty (list)) 
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c002a009:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a00c:	8b 00                	mov    (%eax),%eax
c002a00e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a011:	83 ec 0c             	sub    $0xc,%esp
c002a014:	ff 75 08             	pushl  0x8(%ebp)
c002a017:	e8 a0 fa ff ff       	call   c0029abc <list_end>
c002a01c:	83 c4 10             	add    $0x10,%esp
c002a01f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a022:	75 cf                	jne    c0029ff3 <list_reverse+0x2e>
        swap (&e->prev, &e->next);
      swap (&list->head.next, &list->tail.prev);
c002a024:	8b 45 08             	mov    0x8(%ebp),%eax
c002a027:	8d 50 08             	lea    0x8(%eax),%edx
c002a02a:	8b 45 08             	mov    0x8(%ebp),%eax
c002a02d:	83 c0 04             	add    $0x4,%eax
c002a030:	83 ec 08             	sub    $0x8,%esp
c002a033:	52                   	push   %edx
c002a034:	50                   	push   %eax
c002a035:	e8 68 ff ff ff       	call   c0029fa2 <swap>
c002a03a:	83 c4 10             	add    $0x10,%esp
      swap (&list->head.next->prev, &list->tail.prev->next);
c002a03d:	8b 45 08             	mov    0x8(%ebp),%eax
c002a040:	8b 40 08             	mov    0x8(%eax),%eax
c002a043:	8d 50 04             	lea    0x4(%eax),%edx
c002a046:	8b 45 08             	mov    0x8(%ebp),%eax
c002a049:	8b 40 04             	mov    0x4(%eax),%eax
c002a04c:	83 ec 08             	sub    $0x8,%esp
c002a04f:	52                   	push   %edx
c002a050:	50                   	push   %eax
c002a051:	e8 4c ff ff ff       	call   c0029fa2 <swap>
c002a056:	83 c4 10             	add    $0x10,%esp
    }
}
c002a059:	90                   	nop
c002a05a:	c9                   	leave  
c002a05b:	c3                   	ret    

c002a05c <is_sorted>:
/* Returns true only if the list elements A through B (exclusive)
   are in order according to LESS given auxiliary data AUX. */
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
c002a05c:	55                   	push   %ebp
c002a05d:	89 e5                	mov    %esp,%ebp
c002a05f:	83 ec 08             	sub    $0x8,%esp
  if (a != b)
c002a062:	8b 45 08             	mov    0x8(%ebp),%eax
c002a065:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a068:	74 46                	je     c002a0b0 <is_sorted+0x54>
    while ((a = list_next (a)) != b) 
c002a06a:	eb 2b                	jmp    c002a097 <is_sorted+0x3b>
      if (less (a, list_prev (a), aux))
c002a06c:	83 ec 0c             	sub    $0xc,%esp
c002a06f:	ff 75 08             	pushl  0x8(%ebp)
c002a072:	e8 a9 fa ff ff       	call   c0029b20 <list_prev>
c002a077:	83 c4 10             	add    $0x10,%esp
c002a07a:	83 ec 04             	sub    $0x4,%esp
c002a07d:	ff 75 14             	pushl  0x14(%ebp)
c002a080:	50                   	push   %eax
c002a081:	ff 75 08             	pushl  0x8(%ebp)
c002a084:	8b 45 10             	mov    0x10(%ebp),%eax
c002a087:	ff d0                	call   *%eax
c002a089:	83 c4 10             	add    $0x10,%esp
c002a08c:	84 c0                	test   %al,%al
c002a08e:	74 07                	je     c002a097 <is_sorted+0x3b>
        return false;
c002a090:	b8 00 00 00 00       	mov    $0x0,%eax
c002a095:	eb 1e                	jmp    c002a0b5 <is_sorted+0x59>
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
  if (a != b)
    while ((a = list_next (a)) != b) 
c002a097:	83 ec 0c             	sub    $0xc,%esp
c002a09a:	ff 75 08             	pushl  0x8(%ebp)
c002a09d:	e8 d0 f9 ff ff       	call   c0029a72 <list_next>
c002a0a2:	83 c4 10             	add    $0x10,%esp
c002a0a5:	89 45 08             	mov    %eax,0x8(%ebp)
c002a0a8:	8b 45 08             	mov    0x8(%ebp),%eax
c002a0ab:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a0ae:	75 bc                	jne    c002a06c <is_sorted+0x10>
      if (less (a, list_prev (a), aux))
        return false;
  return true;
c002a0b0:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002a0b5:	c9                   	leave  
c002a0b6:	c3                   	ret    

c002a0b7 <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c002a0b7:	55                   	push   %ebp
c002a0b8:	89 e5                	mov    %esp,%ebp
c002a0ba:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c002a0bd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a0c1:	75 21                	jne    c002a0e4 <find_end_of_run+0x2d>
c002a0c3:	83 ec 0c             	sub    $0xc,%esp
c002a0c6:	68 9f 0f 03 c0       	push   $0xc0030f9f
c002a0cb:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a0d0:	68 10 11 03 c0       	push   $0xc0031110
c002a0d5:	68 69 01 00 00       	push   $0x169
c002a0da:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a0df:	e8 94 f6 ff ff       	call   c0029778 <debug_panic>
  ASSERT (b != NULL);
c002a0e4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a0e8:	75 21                	jne    c002a10b <find_end_of_run+0x54>
c002a0ea:	83 ec 0c             	sub    $0xc,%esp
c002a0ed:	68 a9 0f 03 c0       	push   $0xc0030fa9
c002a0f2:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a0f7:	68 10 11 03 c0       	push   $0xc0031110
c002a0fc:	68 6a 01 00 00       	push   $0x16a
c002a101:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a106:	e8 6d f6 ff ff       	call   c0029778 <debug_panic>
  ASSERT (less != NULL);
c002a10b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a10f:	75 21                	jne    c002a132 <find_end_of_run+0x7b>
c002a111:	83 ec 0c             	sub    $0xc,%esp
c002a114:	68 b3 0f 03 c0       	push   $0xc0030fb3
c002a119:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a11e:	68 10 11 03 c0       	push   $0xc0031110
c002a123:	68 6b 01 00 00       	push   $0x16b
c002a128:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a12d:	e8 46 f6 ff ff       	call   c0029778 <debug_panic>
  ASSERT (a != b);
c002a132:	8b 45 08             	mov    0x8(%ebp),%eax
c002a135:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a138:	75 21                	jne    c002a15b <find_end_of_run+0xa4>
c002a13a:	83 ec 0c             	sub    $0xc,%esp
c002a13d:	68 c0 0f 03 c0       	push   $0xc0030fc0
c002a142:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a147:	68 10 11 03 c0       	push   $0xc0031110
c002a14c:	68 6c 01 00 00       	push   $0x16c
c002a151:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a156:	e8 1d f6 ff ff       	call   c0029778 <debug_panic>
  
  do 
    {
      a = list_next (a);
c002a15b:	83 ec 0c             	sub    $0xc,%esp
c002a15e:	ff 75 08             	pushl  0x8(%ebp)
c002a161:	e8 0c f9 ff ff       	call   c0029a72 <list_next>
c002a166:	83 c4 10             	add    $0x10,%esp
c002a169:	89 45 08             	mov    %eax,0x8(%ebp)
    }
  while (a != b && !less (a, list_prev (a), aux));
c002a16c:	8b 45 08             	mov    0x8(%ebp),%eax
c002a16f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a172:	74 27                	je     c002a19b <find_end_of_run+0xe4>
c002a174:	83 ec 0c             	sub    $0xc,%esp
c002a177:	ff 75 08             	pushl  0x8(%ebp)
c002a17a:	e8 a1 f9 ff ff       	call   c0029b20 <list_prev>
c002a17f:	83 c4 10             	add    $0x10,%esp
c002a182:	83 ec 04             	sub    $0x4,%esp
c002a185:	ff 75 14             	pushl  0x14(%ebp)
c002a188:	50                   	push   %eax
c002a189:	ff 75 08             	pushl  0x8(%ebp)
c002a18c:	8b 45 10             	mov    0x10(%ebp),%eax
c002a18f:	ff d0                	call   *%eax
c002a191:	83 c4 10             	add    $0x10,%esp
c002a194:	83 f0 01             	xor    $0x1,%eax
c002a197:	84 c0                	test   %al,%al
c002a199:	75 c0                	jne    c002a15b <find_end_of_run+0xa4>
  return a;
c002a19b:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002a19e:	c9                   	leave  
c002a19f:	c3                   	ret    

c002a1a0 <inplace_merge>:
   AUX.  The output range will be sorted the same way. */
static void
inplace_merge (struct list_elem *a0, struct list_elem *a1b0,
               struct list_elem *b1,
               list_less_func *less, void *aux)
{
c002a1a0:	55                   	push   %ebp
c002a1a1:	89 e5                	mov    %esp,%ebp
c002a1a3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a0 != NULL);
c002a1a6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a1aa:	75 21                	jne    c002a1cd <inplace_merge+0x2d>
c002a1ac:	83 ec 0c             	sub    $0xc,%esp
c002a1af:	68 c7 0f 03 c0       	push   $0xc0030fc7
c002a1b4:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a1b9:	68 20 11 03 c0       	push   $0xc0031120
c002a1be:	68 80 01 00 00       	push   $0x180
c002a1c3:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a1c8:	e8 ab f5 ff ff       	call   c0029778 <debug_panic>
  ASSERT (a1b0 != NULL);
c002a1cd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a1d1:	75 21                	jne    c002a1f4 <inplace_merge+0x54>
c002a1d3:	83 ec 0c             	sub    $0xc,%esp
c002a1d6:	68 d2 0f 03 c0       	push   $0xc0030fd2
c002a1db:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a1e0:	68 20 11 03 c0       	push   $0xc0031120
c002a1e5:	68 81 01 00 00       	push   $0x181
c002a1ea:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a1ef:	e8 84 f5 ff ff       	call   c0029778 <debug_panic>
  ASSERT (b1 != NULL);
c002a1f4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a1f8:	75 21                	jne    c002a21b <inplace_merge+0x7b>
c002a1fa:	83 ec 0c             	sub    $0xc,%esp
c002a1fd:	68 df 0f 03 c0       	push   $0xc0030fdf
c002a202:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a207:	68 20 11 03 c0       	push   $0xc0031120
c002a20c:	68 82 01 00 00       	push   $0x182
c002a211:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a216:	e8 5d f5 ff ff       	call   c0029778 <debug_panic>
  ASSERT (less != NULL);
c002a21b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002a21f:	75 21                	jne    c002a242 <inplace_merge+0xa2>
c002a221:	83 ec 0c             	sub    $0xc,%esp
c002a224:	68 b3 0f 03 c0       	push   $0xc0030fb3
c002a229:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a22e:	68 20 11 03 c0       	push   $0xc0031120
c002a233:	68 83 01 00 00       	push   $0x183
c002a238:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a23d:	e8 36 f5 ff ff       	call   c0029778 <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c002a242:	ff 75 18             	pushl  0x18(%ebp)
c002a245:	ff 75 14             	pushl  0x14(%ebp)
c002a248:	ff 75 0c             	pushl  0xc(%ebp)
c002a24b:	ff 75 08             	pushl  0x8(%ebp)
c002a24e:	e8 09 fe ff ff       	call   c002a05c <is_sorted>
c002a253:	83 c4 10             	add    $0x10,%esp
c002a256:	84 c0                	test   %al,%al
c002a258:	75 21                	jne    c002a27b <inplace_merge+0xdb>
c002a25a:	83 ec 0c             	sub    $0xc,%esp
c002a25d:	68 ec 0f 03 c0       	push   $0xc0030fec
c002a262:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a267:	68 20 11 03 c0       	push   $0xc0031120
c002a26c:	68 84 01 00 00       	push   $0x184
c002a271:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a276:	e8 fd f4 ff ff       	call   c0029778 <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c002a27b:	ff 75 18             	pushl  0x18(%ebp)
c002a27e:	ff 75 14             	pushl  0x14(%ebp)
c002a281:	ff 75 10             	pushl  0x10(%ebp)
c002a284:	ff 75 0c             	pushl  0xc(%ebp)
c002a287:	e8 d0 fd ff ff       	call   c002a05c <is_sorted>
c002a28c:	83 c4 10             	add    $0x10,%esp
c002a28f:	84 c0                	test   %al,%al
c002a291:	0f 85 80 00 00 00    	jne    c002a317 <inplace_merge+0x177>
c002a297:	83 ec 0c             	sub    $0xc,%esp
c002a29a:	68 0c 10 03 c0       	push   $0xc003100c
c002a29f:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a2a4:	68 20 11 03 c0       	push   $0xc0031120
c002a2a9:	68 85 01 00 00       	push   $0x185
c002a2ae:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a2b3:	e8 c0 f4 ff ff       	call   c0029778 <debug_panic>

  while (a0 != a1b0 && a1b0 != b1)
    if (!less (a1b0, a0, aux)) 
c002a2b8:	83 ec 04             	sub    $0x4,%esp
c002a2bb:	ff 75 18             	pushl  0x18(%ebp)
c002a2be:	ff 75 08             	pushl  0x8(%ebp)
c002a2c1:	ff 75 0c             	pushl  0xc(%ebp)
c002a2c4:	8b 45 14             	mov    0x14(%ebp),%eax
c002a2c7:	ff d0                	call   *%eax
c002a2c9:	83 c4 10             	add    $0x10,%esp
c002a2cc:	83 f0 01             	xor    $0x1,%eax
c002a2cf:	84 c0                	test   %al,%al
c002a2d1:	74 13                	je     c002a2e6 <inplace_merge+0x146>
      a0 = list_next (a0);
c002a2d3:	83 ec 0c             	sub    $0xc,%esp
c002a2d6:	ff 75 08             	pushl  0x8(%ebp)
c002a2d9:	e8 94 f7 ff ff       	call   c0029a72 <list_next>
c002a2de:	83 c4 10             	add    $0x10,%esp
c002a2e1:	89 45 08             	mov    %eax,0x8(%ebp)
c002a2e4:	eb 31                	jmp    c002a317 <inplace_merge+0x177>
    else 
      {
        a1b0 = list_next (a1b0);
c002a2e6:	83 ec 0c             	sub    $0xc,%esp
c002a2e9:	ff 75 0c             	pushl  0xc(%ebp)
c002a2ec:	e8 81 f7 ff ff       	call   c0029a72 <list_next>
c002a2f1:	83 c4 10             	add    $0x10,%esp
c002a2f4:	89 45 0c             	mov    %eax,0xc(%ebp)
        list_splice (a0, list_prev (a1b0), a1b0);
c002a2f7:	83 ec 0c             	sub    $0xc,%esp
c002a2fa:	ff 75 0c             	pushl  0xc(%ebp)
c002a2fd:	e8 1e f8 ff ff       	call   c0029b20 <list_prev>
c002a302:	83 c4 10             	add    $0x10,%esp
c002a305:	83 ec 04             	sub    $0x4,%esp
c002a308:	ff 75 0c             	pushl  0xc(%ebp)
c002a30b:	50                   	push   %eax
c002a30c:	ff 75 08             	pushl  0x8(%ebp)
c002a30f:	e8 83 f9 ff ff       	call   c0029c97 <list_splice>
c002a314:	83 c4 10             	add    $0x10,%esp
  ASSERT (b1 != NULL);
  ASSERT (less != NULL);
  ASSERT (is_sorted (a0, a1b0, less, aux));
  ASSERT (is_sorted (a1b0, b1, less, aux));

  while (a0 != a1b0 && a1b0 != b1)
c002a317:	8b 45 08             	mov    0x8(%ebp),%eax
c002a31a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a31d:	74 08                	je     c002a327 <inplace_merge+0x187>
c002a31f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a322:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a325:	75 91                	jne    c002a2b8 <inplace_merge+0x118>
    else 
      {
        a1b0 = list_next (a1b0);
        list_splice (a0, list_prev (a1b0), a1b0);
      }
}
c002a327:	90                   	nop
c002a328:	c9                   	leave  
c002a329:	c3                   	ret    

c002a32a <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c002a32a:	55                   	push   %ebp
c002a32b:	89 e5                	mov    %esp,%ebp
c002a32d:	53                   	push   %ebx
c002a32e:	83 ec 14             	sub    $0x14,%esp
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c002a331:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a335:	75 21                	jne    c002a358 <list_sort+0x2e>
c002a337:	83 ec 0c             	sub    $0xc,%esp
c002a33a:	68 90 0e 03 c0       	push   $0xc0030e90
c002a33f:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a344:	68 30 11 03 c0       	push   $0xc0031130
c002a349:	68 99 01 00 00       	push   $0x199
c002a34e:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a353:	e8 20 f4 ff ff       	call   c0029778 <debug_panic>
  ASSERT (less != NULL);
c002a358:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a35c:	75 21                	jne    c002a37f <list_sort+0x55>
c002a35e:	83 ec 0c             	sub    $0xc,%esp
c002a361:	68 b3 0f 03 c0       	push   $0xc0030fb3
c002a366:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a36b:	68 30 11 03 c0       	push   $0xc0031130
c002a370:	68 9a 01 00 00       	push   $0x19a
c002a375:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a37a:	e8 f9 f3 ff ff       	call   c0029778 <debug_panic>
    {
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
c002a37f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a386:	83 ec 0c             	sub    $0xc,%esp
c002a389:	ff 75 08             	pushl  0x8(%ebp)
c002a38c:	e8 af f6 ff ff       	call   c0029a40 <list_begin>
c002a391:	83 c4 10             	add    $0x10,%esp
c002a394:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a397:	eb 7d                	jmp    c002a416 <list_sort+0xec>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c002a399:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c002a39d:	83 ec 0c             	sub    $0xc,%esp
c002a3a0:	ff 75 08             	pushl  0x8(%ebp)
c002a3a3:	e8 14 f7 ff ff       	call   c0029abc <list_end>
c002a3a8:	83 c4 10             	add    $0x10,%esp
c002a3ab:	ff 75 10             	pushl  0x10(%ebp)
c002a3ae:	ff 75 0c             	pushl  0xc(%ebp)
c002a3b1:	50                   	push   %eax
c002a3b2:	ff 75 f0             	pushl  -0x10(%ebp)
c002a3b5:	e8 fd fc ff ff       	call   c002a0b7 <find_end_of_run>
c002a3ba:	83 c4 10             	add    $0x10,%esp
c002a3bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
          if (a1b0 == list_end (list))
c002a3c0:	83 ec 0c             	sub    $0xc,%esp
c002a3c3:	ff 75 08             	pushl  0x8(%ebp)
c002a3c6:	e8 f1 f6 ff ff       	call   c0029abc <list_end>
c002a3cb:	83 c4 10             	add    $0x10,%esp
c002a3ce:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002a3d1:	74 5c                	je     c002a42f <list_sort+0x105>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c002a3d3:	83 ec 0c             	sub    $0xc,%esp
c002a3d6:	ff 75 08             	pushl  0x8(%ebp)
c002a3d9:	e8 de f6 ff ff       	call   c0029abc <list_end>
c002a3de:	83 c4 10             	add    $0x10,%esp
c002a3e1:	ff 75 10             	pushl  0x10(%ebp)
c002a3e4:	ff 75 0c             	pushl  0xc(%ebp)
c002a3e7:	50                   	push   %eax
c002a3e8:	ff 75 ec             	pushl  -0x14(%ebp)
c002a3eb:	e8 c7 fc ff ff       	call   c002a0b7 <find_end_of_run>
c002a3f0:	83 c4 10             	add    $0x10,%esp
c002a3f3:	89 45 e8             	mov    %eax,-0x18(%ebp)

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
c002a3f6:	83 ec 0c             	sub    $0xc,%esp
c002a3f9:	ff 75 10             	pushl  0x10(%ebp)
c002a3fc:	ff 75 0c             	pushl  0xc(%ebp)
c002a3ff:	ff 75 e8             	pushl  -0x18(%ebp)
c002a402:	ff 75 ec             	pushl  -0x14(%ebp)
c002a405:	ff 75 f0             	pushl  -0x10(%ebp)
c002a408:	e8 93 fd ff ff       	call   c002a1a0 <inplace_merge>
c002a40d:	83 c4 20             	add    $0x20,%esp
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a410:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a413:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a416:	83 ec 0c             	sub    $0xc,%esp
c002a419:	ff 75 08             	pushl  0x8(%ebp)
c002a41c:	e8 9b f6 ff ff       	call   c0029abc <list_end>
c002a421:	83 c4 10             	add    $0x10,%esp
c002a424:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a427:	0f 85 6c ff ff ff    	jne    c002a399 <list_sort+0x6f>
c002a42d:	eb 01                	jmp    c002a430 <list_sort+0x106>

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
          if (a1b0 == list_end (list))
            break;
c002a42f:	90                   	nop

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
        }
    }
  while (output_run_cnt > 1);
c002a430:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002a434:	0f 87 45 ff ff ff    	ja     c002a37f <list_sort+0x55>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c002a43a:	83 ec 0c             	sub    $0xc,%esp
c002a43d:	ff 75 08             	pushl  0x8(%ebp)
c002a440:	e8 77 f6 ff ff       	call   c0029abc <list_end>
c002a445:	83 c4 10             	add    $0x10,%esp
c002a448:	89 c3                	mov    %eax,%ebx
c002a44a:	83 ec 0c             	sub    $0xc,%esp
c002a44d:	ff 75 08             	pushl  0x8(%ebp)
c002a450:	e8 eb f5 ff ff       	call   c0029a40 <list_begin>
c002a455:	83 c4 10             	add    $0x10,%esp
c002a458:	ff 75 10             	pushl  0x10(%ebp)
c002a45b:	ff 75 0c             	pushl  0xc(%ebp)
c002a45e:	53                   	push   %ebx
c002a45f:	50                   	push   %eax
c002a460:	e8 f7 fb ff ff       	call   c002a05c <is_sorted>
c002a465:	83 c4 10             	add    $0x10,%esp
c002a468:	84 c0                	test   %al,%al
c002a46a:	75 21                	jne    c002a48d <list_sort+0x163>
c002a46c:	83 ec 0c             	sub    $0xc,%esp
c002a46f:	68 2c 10 03 c0       	push   $0xc003102c
c002a474:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a479:	68 30 11 03 c0       	push   $0xc0031130
c002a47e:	68 b7 01 00 00       	push   $0x1b7
c002a483:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a488:	e8 eb f2 ff ff       	call   c0029778 <debug_panic>
}
c002a48d:	90                   	nop
c002a48e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a491:	c9                   	leave  
c002a492:	c3                   	ret    

c002a493 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c002a493:	55                   	push   %ebp
c002a494:	89 e5                	mov    %esp,%ebp
c002a496:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (list != NULL);
c002a499:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a49d:	75 21                	jne    c002a4c0 <list_insert_ordered+0x2d>
c002a49f:	83 ec 0c             	sub    $0xc,%esp
c002a4a2:	68 90 0e 03 c0       	push   $0xc0030e90
c002a4a7:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a4ac:	68 3c 11 03 c0       	push   $0xc003113c
c002a4b1:	68 c3 01 00 00       	push   $0x1c3
c002a4b6:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a4bb:	e8 b8 f2 ff ff       	call   c0029778 <debug_panic>
  ASSERT (elem != NULL);
c002a4c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a4c4:	75 21                	jne    c002a4e7 <list_insert_ordered+0x54>
c002a4c6:	83 ec 0c             	sub    $0xc,%esp
c002a4c9:	68 45 0f 03 c0       	push   $0xc0030f45
c002a4ce:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a4d3:	68 3c 11 03 c0       	push   $0xc003113c
c002a4d8:	68 c4 01 00 00       	push   $0x1c4
c002a4dd:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a4e2:	e8 91 f2 ff ff       	call   c0029778 <debug_panic>
  ASSERT (less != NULL);
c002a4e7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a4eb:	75 21                	jne    c002a50e <list_insert_ordered+0x7b>
c002a4ed:	83 ec 0c             	sub    $0xc,%esp
c002a4f0:	68 b3 0f 03 c0       	push   $0xc0030fb3
c002a4f5:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a4fa:	68 3c 11 03 c0       	push   $0xc003113c
c002a4ff:	68 c5 01 00 00       	push   $0x1c5
c002a504:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a509:	e8 6a f2 ff ff       	call   c0029778 <debug_panic>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a50e:	83 ec 0c             	sub    $0xc,%esp
c002a511:	ff 75 08             	pushl  0x8(%ebp)
c002a514:	e8 27 f5 ff ff       	call   c0029a40 <list_begin>
c002a519:	83 c4 10             	add    $0x10,%esp
c002a51c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a51f:	eb 29                	jmp    c002a54a <list_insert_ordered+0xb7>
    if (less (elem, e, aux))
c002a521:	83 ec 04             	sub    $0x4,%esp
c002a524:	ff 75 14             	pushl  0x14(%ebp)
c002a527:	ff 75 f4             	pushl  -0xc(%ebp)
c002a52a:	ff 75 0c             	pushl  0xc(%ebp)
c002a52d:	8b 45 10             	mov    0x10(%ebp),%eax
c002a530:	ff d0                	call   *%eax
c002a532:	83 c4 10             	add    $0x10,%esp
c002a535:	84 c0                	test   %al,%al
c002a537:	75 26                	jne    c002a55f <list_insert_ordered+0xcc>

  ASSERT (list != NULL);
  ASSERT (elem != NULL);
  ASSERT (less != NULL);

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a539:	83 ec 0c             	sub    $0xc,%esp
c002a53c:	ff 75 f4             	pushl  -0xc(%ebp)
c002a53f:	e8 2e f5 ff ff       	call   c0029a72 <list_next>
c002a544:	83 c4 10             	add    $0x10,%esp
c002a547:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a54a:	83 ec 0c             	sub    $0xc,%esp
c002a54d:	ff 75 08             	pushl  0x8(%ebp)
c002a550:	e8 67 f5 ff ff       	call   c0029abc <list_end>
c002a555:	83 c4 10             	add    $0x10,%esp
c002a558:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a55b:	75 c4                	jne    c002a521 <list_insert_ordered+0x8e>
c002a55d:	eb 01                	jmp    c002a560 <list_insert_ordered+0xcd>
    if (less (elem, e, aux))
      break;
c002a55f:	90                   	nop
  return list_insert (e, elem);
c002a560:	83 ec 08             	sub    $0x8,%esp
c002a563:	ff 75 0c             	pushl  0xc(%ebp)
c002a566:	ff 75 f4             	pushl  -0xc(%ebp)
c002a569:	e8 94 f6 ff ff       	call   c0029c02 <list_insert>
c002a56e:	83 c4 10             	add    $0x10,%esp
}
c002a571:	c9                   	leave  
c002a572:	c3                   	ret    

c002a573 <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c002a573:	55                   	push   %ebp
c002a574:	89 e5                	mov    %esp,%ebp
c002a576:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c002a579:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a57d:	75 21                	jne    c002a5a0 <list_unique+0x2d>
c002a57f:	83 ec 0c             	sub    $0xc,%esp
c002a582:	68 90 0e 03 c0       	push   $0xc0030e90
c002a587:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a58c:	68 50 11 03 c0       	push   $0xc0031150
c002a591:	68 d7 01 00 00       	push   $0x1d7
c002a596:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a59b:	e8 d8 f1 ff ff       	call   c0029778 <debug_panic>
  ASSERT (less != NULL);
c002a5a0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a5a4:	75 21                	jne    c002a5c7 <list_unique+0x54>
c002a5a6:	83 ec 0c             	sub    $0xc,%esp
c002a5a9:	68 b3 0f 03 c0       	push   $0xc0030fb3
c002a5ae:	68 9d 0e 03 c0       	push   $0xc0030e9d
c002a5b3:	68 50 11 03 c0       	push   $0xc0031150
c002a5b8:	68 d8 01 00 00       	push   $0x1d8
c002a5bd:	68 b4 0e 03 c0       	push   $0xc0030eb4
c002a5c2:	e8 b1 f1 ff ff       	call   c0029778 <debug_panic>
  if (list_empty (list))
c002a5c7:	83 ec 0c             	sub    $0xc,%esp
c002a5ca:	ff 75 08             	pushl  0x8(%ebp)
c002a5cd:	e8 a1 f9 ff ff       	call   c0029f73 <list_empty>
c002a5d2:	83 c4 10             	add    $0x10,%esp
c002a5d5:	84 c0                	test   %al,%al
c002a5d7:	0f 85 a0 00 00 00    	jne    c002a67d <list_unique+0x10a>
    return;

  elem = list_begin (list);
c002a5dd:	83 ec 0c             	sub    $0xc,%esp
c002a5e0:	ff 75 08             	pushl  0x8(%ebp)
c002a5e3:	e8 58 f4 ff ff       	call   c0029a40 <list_begin>
c002a5e8:	83 c4 10             	add    $0x10,%esp
c002a5eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002a5ee:	eb 63                	jmp    c002a653 <list_unique+0xe0>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002a5f0:	83 ec 04             	sub    $0x4,%esp
c002a5f3:	ff 75 14             	pushl  0x14(%ebp)
c002a5f6:	ff 75 f0             	pushl  -0x10(%ebp)
c002a5f9:	ff 75 f4             	pushl  -0xc(%ebp)
c002a5fc:	8b 45 10             	mov    0x10(%ebp),%eax
c002a5ff:	ff d0                	call   *%eax
c002a601:	83 c4 10             	add    $0x10,%esp
c002a604:	83 f0 01             	xor    $0x1,%eax
c002a607:	84 c0                	test   %al,%al
c002a609:	74 42                	je     c002a64d <list_unique+0xda>
c002a60b:	83 ec 04             	sub    $0x4,%esp
c002a60e:	ff 75 14             	pushl  0x14(%ebp)
c002a611:	ff 75 f4             	pushl  -0xc(%ebp)
c002a614:	ff 75 f0             	pushl  -0x10(%ebp)
c002a617:	8b 45 10             	mov    0x10(%ebp),%eax
c002a61a:	ff d0                	call   *%eax
c002a61c:	83 c4 10             	add    $0x10,%esp
c002a61f:	83 f0 01             	xor    $0x1,%eax
c002a622:	84 c0                	test   %al,%al
c002a624:	74 27                	je     c002a64d <list_unique+0xda>
      {
        list_remove (next);
c002a626:	83 ec 0c             	sub    $0xc,%esp
c002a629:	ff 75 f0             	pushl  -0x10(%ebp)
c002a62c:	e8 c0 f7 ff ff       	call   c0029df1 <list_remove>
c002a631:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002a634:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a638:	74 19                	je     c002a653 <list_unique+0xe0>
          list_push_back (duplicates, next);
c002a63a:	83 ec 08             	sub    $0x8,%esp
c002a63d:	ff 75 f0             	pushl  -0x10(%ebp)
c002a640:	ff 75 0c             	pushl  0xc(%ebp)
c002a643:	e8 83 f7 ff ff       	call   c0029dcb <list_push_back>
c002a648:	83 c4 10             	add    $0x10,%esp
  elem = list_begin (list);
  while ((next = list_next (elem)) != list_end (list))
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
      {
        list_remove (next);
        if (duplicates != NULL)
c002a64b:	eb 06                	jmp    c002a653 <list_unique+0xe0>
          list_push_back (duplicates, next);
      }
    else
      elem = next;
c002a64d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a650:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (less != NULL);
  if (list_empty (list))
    return;

  elem = list_begin (list);
  while ((next = list_next (elem)) != list_end (list))
c002a653:	83 ec 0c             	sub    $0xc,%esp
c002a656:	ff 75 f4             	pushl  -0xc(%ebp)
c002a659:	e8 14 f4 ff ff       	call   c0029a72 <list_next>
c002a65e:	83 c4 10             	add    $0x10,%esp
c002a661:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a664:	83 ec 0c             	sub    $0xc,%esp
c002a667:	ff 75 08             	pushl  0x8(%ebp)
c002a66a:	e8 4d f4 ff ff       	call   c0029abc <list_end>
c002a66f:	83 c4 10             	add    $0x10,%esp
c002a672:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002a675:	0f 85 75 ff ff ff    	jne    c002a5f0 <list_unique+0x7d>
c002a67b:	eb 01                	jmp    c002a67e <list_unique+0x10b>
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
  ASSERT (less != NULL);
  if (list_empty (list))
    return;
c002a67d:	90                   	nop
        if (duplicates != NULL)
          list_push_back (duplicates, next);
      }
    else
      elem = next;
}
c002a67e:	c9                   	leave  
c002a67f:	c3                   	ret    

c002a680 <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c002a680:	55                   	push   %ebp
c002a681:	89 e5                	mov    %esp,%ebp
c002a683:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *max = list_begin (list);
c002a686:	83 ec 0c             	sub    $0xc,%esp
c002a689:	ff 75 08             	pushl  0x8(%ebp)
c002a68c:	e8 af f3 ff ff       	call   c0029a40 <list_begin>
c002a691:	83 c4 10             	add    $0x10,%esp
c002a694:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (max != list_end (list)) 
c002a697:	83 ec 0c             	sub    $0xc,%esp
c002a69a:	ff 75 08             	pushl  0x8(%ebp)
c002a69d:	e8 1a f4 ff ff       	call   c0029abc <list_end>
c002a6a2:	83 c4 10             	add    $0x10,%esp
c002a6a5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a6a8:	74 55                	je     c002a6ff <list_max+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a6aa:	83 ec 0c             	sub    $0xc,%esp
c002a6ad:	ff 75 f4             	pushl  -0xc(%ebp)
c002a6b0:	e8 bd f3 ff ff       	call   c0029a72 <list_next>
c002a6b5:	83 c4 10             	add    $0x10,%esp
c002a6b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a6bb:	eb 2f                	jmp    c002a6ec <list_max+0x6c>
        if (less (max, e, aux))
c002a6bd:	83 ec 04             	sub    $0x4,%esp
c002a6c0:	ff 75 10             	pushl  0x10(%ebp)
c002a6c3:	ff 75 f0             	pushl  -0x10(%ebp)
c002a6c6:	ff 75 f4             	pushl  -0xc(%ebp)
c002a6c9:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a6cc:	ff d0                	call   *%eax
c002a6ce:	83 c4 10             	add    $0x10,%esp
c002a6d1:	84 c0                	test   %al,%al
c002a6d3:	74 06                	je     c002a6db <list_max+0x5b>
          max = e; 
c002a6d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a6d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct list_elem *max = list_begin (list);
  if (max != list_end (list)) 
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a6db:	83 ec 0c             	sub    $0xc,%esp
c002a6de:	ff 75 f0             	pushl  -0x10(%ebp)
c002a6e1:	e8 8c f3 ff ff       	call   c0029a72 <list_next>
c002a6e6:	83 c4 10             	add    $0x10,%esp
c002a6e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a6ec:	83 ec 0c             	sub    $0xc,%esp
c002a6ef:	ff 75 08             	pushl  0x8(%ebp)
c002a6f2:	e8 c5 f3 ff ff       	call   c0029abc <list_end>
c002a6f7:	83 c4 10             	add    $0x10,%esp
c002a6fa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a6fd:	75 be                	jne    c002a6bd <list_max+0x3d>
        if (less (max, e, aux))
          max = e; 
    }
  return max;
c002a6ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a702:	c9                   	leave  
c002a703:	c3                   	ret    

c002a704 <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002a704:	55                   	push   %ebp
c002a705:	89 e5                	mov    %esp,%ebp
c002a707:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *min = list_begin (list);
c002a70a:	83 ec 0c             	sub    $0xc,%esp
c002a70d:	ff 75 08             	pushl  0x8(%ebp)
c002a710:	e8 2b f3 ff ff       	call   c0029a40 <list_begin>
c002a715:	83 c4 10             	add    $0x10,%esp
c002a718:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (min != list_end (list)) 
c002a71b:	83 ec 0c             	sub    $0xc,%esp
c002a71e:	ff 75 08             	pushl  0x8(%ebp)
c002a721:	e8 96 f3 ff ff       	call   c0029abc <list_end>
c002a726:	83 c4 10             	add    $0x10,%esp
c002a729:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a72c:	74 55                	je     c002a783 <list_min+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a72e:	83 ec 0c             	sub    $0xc,%esp
c002a731:	ff 75 f4             	pushl  -0xc(%ebp)
c002a734:	e8 39 f3 ff ff       	call   c0029a72 <list_next>
c002a739:	83 c4 10             	add    $0x10,%esp
c002a73c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a73f:	eb 2f                	jmp    c002a770 <list_min+0x6c>
        if (less (e, min, aux))
c002a741:	83 ec 04             	sub    $0x4,%esp
c002a744:	ff 75 10             	pushl  0x10(%ebp)
c002a747:	ff 75 f4             	pushl  -0xc(%ebp)
c002a74a:	ff 75 f0             	pushl  -0x10(%ebp)
c002a74d:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a750:	ff d0                	call   *%eax
c002a752:	83 c4 10             	add    $0x10,%esp
c002a755:	84 c0                	test   %al,%al
c002a757:	74 06                	je     c002a75f <list_min+0x5b>
          min = e; 
c002a759:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a75c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct list_elem *min = list_begin (list);
  if (min != list_end (list)) 
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a75f:	83 ec 0c             	sub    $0xc,%esp
c002a762:	ff 75 f0             	pushl  -0x10(%ebp)
c002a765:	e8 08 f3 ff ff       	call   c0029a72 <list_next>
c002a76a:	83 c4 10             	add    $0x10,%esp
c002a76d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a770:	83 ec 0c             	sub    $0xc,%esp
c002a773:	ff 75 08             	pushl  0x8(%ebp)
c002a776:	e8 41 f3 ff ff       	call   c0029abc <list_end>
c002a77b:	83 c4 10             	add    $0x10,%esp
c002a77e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a781:	75 be                	jne    c002a741 <list_min+0x3d>
        if (less (e, min, aux))
          min = e; 
    }
  return min;
c002a783:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a786:	c9                   	leave  
c002a787:	c3                   	ret    

c002a788 <elem_idx>:

/* Returns the index of the element that contains the bit
   numbered BIT_IDX. */
static inline size_t
elem_idx (size_t bit_idx) 
{
c002a788:	55                   	push   %ebp
c002a789:	89 e5                	mov    %esp,%ebp
  return bit_idx / ELEM_BITS;
c002a78b:	8b 45 08             	mov    0x8(%ebp),%eax
c002a78e:	c1 e8 05             	shr    $0x5,%eax
}
c002a791:	5d                   	pop    %ebp
c002a792:	c3                   	ret    

c002a793 <bit_mask>:

/* Returns an elem_type where only the bit corresponding to
   BIT_IDX is turned on. */
static inline elem_type
bit_mask (size_t bit_idx) 
{
c002a793:	55                   	push   %ebp
c002a794:	89 e5                	mov    %esp,%ebp
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a796:	8b 45 08             	mov    0x8(%ebp),%eax
c002a799:	83 e0 1f             	and    $0x1f,%eax
c002a79c:	ba 01 00 00 00       	mov    $0x1,%edx
c002a7a1:	89 c1                	mov    %eax,%ecx
c002a7a3:	d3 e2                	shl    %cl,%edx
c002a7a5:	89 d0                	mov    %edx,%eax
}
c002a7a7:	5d                   	pop    %ebp
c002a7a8:	c3                   	ret    

c002a7a9 <elem_cnt>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
c002a7a9:	55                   	push   %ebp
c002a7aa:	89 e5                	mov    %esp,%ebp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a7ac:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7af:	83 c0 1f             	add    $0x1f,%eax
c002a7b2:	c1 e8 05             	shr    $0x5,%eax
}
c002a7b5:	5d                   	pop    %ebp
c002a7b6:	c3                   	ret    

c002a7b7 <byte_cnt>:

/* Returns the number of bytes required for BIT_CNT bits. */
static inline size_t
byte_cnt (size_t bit_cnt)
{
c002a7b7:	55                   	push   %ebp
c002a7b8:	89 e5                	mov    %esp,%ebp
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a7ba:	ff 75 08             	pushl  0x8(%ebp)
c002a7bd:	e8 e7 ff ff ff       	call   c002a7a9 <elem_cnt>
c002a7c2:	83 c4 04             	add    $0x4,%esp
c002a7c5:	c1 e0 02             	shl    $0x2,%eax
}
c002a7c8:	c9                   	leave  
c002a7c9:	c3                   	ret    

c002a7ca <bitmap_create>:
   BIT_CNT (or more) bits.  Returns a null pointer if memory allocation fails.
   The caller is responsible for freeing the bitmap, with bitmap_destroy(),
   when it is no longer needed. */
struct bitmap *
bitmap_create (size_t bit_cnt) 
{
c002a7ca:	55                   	push   %ebp
c002a7cb:	89 e5                	mov    %esp,%ebp
c002a7cd:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = malloc (sizeof *b);
c002a7d0:	83 ec 0c             	sub    $0xc,%esp
c002a7d3:	6a 08                	push   $0x8
c002a7d5:	e8 cf 8d ff ff       	call   c00235a9 <malloc>
c002a7da:	83 c4 10             	add    $0x10,%esp
c002a7dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (b != NULL)
c002a7e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a7e4:	74 5d                	je     c002a843 <bitmap_create+0x79>
    {
      b->bit_cnt = bit_cnt;
c002a7e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a7e9:	8b 55 08             	mov    0x8(%ebp),%edx
c002a7ec:	89 10                	mov    %edx,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002a7ee:	83 ec 0c             	sub    $0xc,%esp
c002a7f1:	ff 75 08             	pushl  0x8(%ebp)
c002a7f4:	e8 be ff ff ff       	call   c002a7b7 <byte_cnt>
c002a7f9:	83 c4 10             	add    $0x10,%esp
c002a7fc:	83 ec 0c             	sub    $0xc,%esp
c002a7ff:	50                   	push   %eax
c002a800:	e8 a4 8d ff ff       	call   c00235a9 <malloc>
c002a805:	83 c4 10             	add    $0x10,%esp
c002a808:	89 c2                	mov    %eax,%edx
c002a80a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a80d:	89 50 04             	mov    %edx,0x4(%eax)
      if (b->bits != NULL || bit_cnt == 0)
c002a810:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a813:	8b 40 04             	mov    0x4(%eax),%eax
c002a816:	85 c0                	test   %eax,%eax
c002a818:	75 06                	jne    c002a820 <bitmap_create+0x56>
c002a81a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a81e:	75 15                	jne    c002a835 <bitmap_create+0x6b>
        {
          bitmap_set_all (b, false);
c002a820:	83 ec 08             	sub    $0x8,%esp
c002a823:	6a 00                	push   $0x0
c002a825:	ff 75 f4             	pushl  -0xc(%ebp)
c002a828:	e8 92 02 00 00       	call   c002aabf <bitmap_set_all>
c002a82d:	83 c4 10             	add    $0x10,%esp
          return b;
c002a830:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a833:	eb 13                	jmp    c002a848 <bitmap_create+0x7e>
        }
      free (b);
c002a835:	83 ec 0c             	sub    $0xc,%esp
c002a838:	ff 75 f4             	pushl  -0xc(%ebp)
c002a83b:	e8 62 90 ff ff       	call   c00238a2 <free>
c002a840:	83 c4 10             	add    $0x10,%esp
    }
  return NULL;
c002a843:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002a848:	c9                   	leave  
c002a849:	c3                   	ret    

c002a84a <bitmap_create_in_buf>:
/* Creates and returns a bitmap with BIT_CNT bits in the
   BLOCK_SIZE bytes of storage preallocated at BLOCK.
   BLOCK_SIZE must be at least bitmap_needed_bytes(BIT_CNT). */
struct bitmap *
bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size UNUSED)
{
c002a84a:	55                   	push   %ebp
c002a84b:	89 e5                	mov    %esp,%ebp
c002a84d:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = block;
c002a850:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a853:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a856:	83 ec 0c             	sub    $0xc,%esp
c002a859:	ff 75 08             	pushl  0x8(%ebp)
c002a85c:	e8 4f 00 00 00       	call   c002a8b0 <bitmap_buf_size>
c002a861:	83 c4 10             	add    $0x10,%esp
c002a864:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a867:	76 1e                	jbe    c002a887 <bitmap_create_in_buf+0x3d>
c002a869:	83 ec 0c             	sub    $0xc,%esp
c002a86c:	68 5c 11 03 c0       	push   $0xc003115c
c002a871:	68 84 11 03 c0       	push   $0xc0031184
c002a876:	68 00 12 03 c0       	push   $0xc0031200
c002a87b:	6a 68                	push   $0x68
c002a87d:	68 9b 11 03 c0       	push   $0xc003119b
c002a882:	e8 f1 ee ff ff       	call   c0029778 <debug_panic>

  b->bit_cnt = bit_cnt;
c002a887:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a88a:	8b 55 08             	mov    0x8(%ebp),%edx
c002a88d:	89 10                	mov    %edx,(%eax)
  b->bits = (elem_type *) (b + 1);
c002a88f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a892:	8d 50 08             	lea    0x8(%eax),%edx
c002a895:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a898:	89 50 04             	mov    %edx,0x4(%eax)
  bitmap_set_all (b, false);
c002a89b:	83 ec 08             	sub    $0x8,%esp
c002a89e:	6a 00                	push   $0x0
c002a8a0:	ff 75 f4             	pushl  -0xc(%ebp)
c002a8a3:	e8 17 02 00 00       	call   c002aabf <bitmap_set_all>
c002a8a8:	83 c4 10             	add    $0x10,%esp
  return b;
c002a8ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a8ae:	c9                   	leave  
c002a8af:	c3                   	ret    

c002a8b0 <bitmap_buf_size>:

/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
c002a8b0:	55                   	push   %ebp
c002a8b1:	89 e5                	mov    %esp,%ebp
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002a8b3:	ff 75 08             	pushl  0x8(%ebp)
c002a8b6:	e8 fc fe ff ff       	call   c002a7b7 <byte_cnt>
c002a8bb:	83 c4 04             	add    $0x4,%esp
c002a8be:	83 c0 08             	add    $0x8,%eax
}
c002a8c1:	c9                   	leave  
c002a8c2:	c3                   	ret    

c002a8c3 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c002a8c3:	55                   	push   %ebp
c002a8c4:	89 e5                	mov    %esp,%ebp
c002a8c6:	83 ec 08             	sub    $0x8,%esp
  if (b != NULL) 
c002a8c9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a8cd:	74 20                	je     c002a8ef <bitmap_destroy+0x2c>
    {
      free (b->bits);
c002a8cf:	8b 45 08             	mov    0x8(%ebp),%eax
c002a8d2:	8b 40 04             	mov    0x4(%eax),%eax
c002a8d5:	83 ec 0c             	sub    $0xc,%esp
c002a8d8:	50                   	push   %eax
c002a8d9:	e8 c4 8f ff ff       	call   c00238a2 <free>
c002a8de:	83 c4 10             	add    $0x10,%esp
      free (b);
c002a8e1:	83 ec 0c             	sub    $0xc,%esp
c002a8e4:	ff 75 08             	pushl  0x8(%ebp)
c002a8e7:	e8 b6 8f ff ff       	call   c00238a2 <free>
c002a8ec:	83 c4 10             	add    $0x10,%esp
    }
}
c002a8ef:	90                   	nop
c002a8f0:	c9                   	leave  
c002a8f1:	c3                   	ret    

c002a8f2 <bitmap_size>:
/* Bitmap size. */

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
c002a8f2:	55                   	push   %ebp
c002a8f3:	89 e5                	mov    %esp,%ebp
  return b->bit_cnt;
c002a8f5:	8b 45 08             	mov    0x8(%ebp),%eax
c002a8f8:	8b 00                	mov    (%eax),%eax
}
c002a8fa:	5d                   	pop    %ebp
c002a8fb:	c3                   	ret    

c002a8fc <bitmap_set>:
/* Setting and testing single bits. */

/* Atomically sets the bit numbered IDX in B to VALUE. */
void
bitmap_set (struct bitmap *b, size_t idx, bool value) 
{
c002a8fc:	55                   	push   %ebp
c002a8fd:	89 e5                	mov    %esp,%ebp
c002a8ff:	83 ec 18             	sub    $0x18,%esp
c002a902:	8b 45 10             	mov    0x10(%ebp),%eax
c002a905:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002a908:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a90c:	75 21                	jne    c002a92f <bitmap_set+0x33>
c002a90e:	83 ec 0c             	sub    $0xc,%esp
c002a911:	68 b5 11 03 c0       	push   $0xc00311b5
c002a916:	68 84 11 03 c0       	push   $0xc0031184
c002a91b:	68 18 12 03 c0       	push   $0xc0031218
c002a920:	68 93 00 00 00       	push   $0x93
c002a925:	68 9b 11 03 c0       	push   $0xc003119b
c002a92a:	e8 49 ee ff ff       	call   c0029778 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a92f:	8b 45 08             	mov    0x8(%ebp),%eax
c002a932:	8b 00                	mov    (%eax),%eax
c002a934:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a937:	77 21                	ja     c002a95a <bitmap_set+0x5e>
c002a939:	83 ec 0c             	sub    $0xc,%esp
c002a93c:	68 bf 11 03 c0       	push   $0xc00311bf
c002a941:	68 84 11 03 c0       	push   $0xc0031184
c002a946:	68 18 12 03 c0       	push   $0xc0031218
c002a94b:	68 94 00 00 00       	push   $0x94
c002a950:	68 9b 11 03 c0       	push   $0xc003119b
c002a955:	e8 1e ee ff ff       	call   c0029778 <debug_panic>
  if (value)
c002a95a:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002a95e:	74 13                	je     c002a973 <bitmap_set+0x77>
    bitmap_mark (b, idx);
c002a960:	83 ec 08             	sub    $0x8,%esp
c002a963:	ff 75 0c             	pushl  0xc(%ebp)
c002a966:	ff 75 08             	pushl  0x8(%ebp)
c002a969:	e8 19 00 00 00       	call   c002a987 <bitmap_mark>
c002a96e:	83 c4 10             	add    $0x10,%esp
  else
    bitmap_reset (b, idx);
}
c002a971:	eb 11                	jmp    c002a984 <bitmap_set+0x88>
  ASSERT (b != NULL);
  ASSERT (idx < b->bit_cnt);
  if (value)
    bitmap_mark (b, idx);
  else
    bitmap_reset (b, idx);
c002a973:	83 ec 08             	sub    $0x8,%esp
c002a976:	ff 75 0c             	pushl  0xc(%ebp)
c002a979:	ff 75 08             	pushl  0x8(%ebp)
c002a97c:	e8 3e 00 00 00       	call   c002a9bf <bitmap_reset>
c002a981:	83 c4 10             	add    $0x10,%esp
}
c002a984:	90                   	nop
c002a985:	c9                   	leave  
c002a986:	c3                   	ret    

c002a987 <bitmap_mark>:

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002a987:	55                   	push   %ebp
c002a988:	89 e5                	mov    %esp,%ebp
c002a98a:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a98d:	ff 75 0c             	pushl  0xc(%ebp)
c002a990:	e8 f3 fd ff ff       	call   c002a788 <elem_idx>
c002a995:	83 c4 04             	add    $0x4,%esp
c002a998:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a99b:	ff 75 0c             	pushl  0xc(%ebp)
c002a99e:	e8 f0 fd ff ff       	call   c002a793 <bit_mask>
c002a9a3:	83 c4 04             	add    $0x4,%esp
c002a9a6:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a9a9:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9ac:	8b 40 04             	mov    0x4(%eax),%eax
c002a9af:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a9b2:	c1 e2 02             	shl    $0x2,%edx
c002a9b5:	01 c2                	add    %eax,%edx
c002a9b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002a9ba:	09 02                	or     %eax,(%edx)
}
c002a9bc:	90                   	nop
c002a9bd:	c9                   	leave  
c002a9be:	c3                   	ret    

c002a9bf <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002a9bf:	55                   	push   %ebp
c002a9c0:	89 e5                	mov    %esp,%ebp
c002a9c2:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a9c5:	ff 75 0c             	pushl  0xc(%ebp)
c002a9c8:	e8 bb fd ff ff       	call   c002a788 <elem_idx>
c002a9cd:	83 c4 04             	add    $0x4,%esp
c002a9d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a9d3:	ff 75 0c             	pushl  0xc(%ebp)
c002a9d6:	e8 b8 fd ff ff       	call   c002a793 <bit_mask>
c002a9db:	83 c4 04             	add    $0x4,%esp
c002a9de:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002a9e1:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9e4:	8b 40 04             	mov    0x4(%eax),%eax
c002a9e7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a9ea:	c1 e2 02             	shl    $0x2,%edx
c002a9ed:	01 d0                	add    %edx,%eax
c002a9ef:	8b 55 f8             	mov    -0x8(%ebp),%edx
c002a9f2:	f7 d2                	not    %edx
c002a9f4:	21 10                	and    %edx,(%eax)
}
c002a9f6:	90                   	nop
c002a9f7:	c9                   	leave  
c002a9f8:	c3                   	ret    

c002a9f9 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002a9f9:	55                   	push   %ebp
c002a9fa:	89 e5                	mov    %esp,%ebp
c002a9fc:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a9ff:	ff 75 0c             	pushl  0xc(%ebp)
c002aa02:	e8 81 fd ff ff       	call   c002a788 <elem_idx>
c002aa07:	83 c4 04             	add    $0x4,%esp
c002aa0a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002aa0d:	ff 75 0c             	pushl  0xc(%ebp)
c002aa10:	e8 7e fd ff ff       	call   c002a793 <bit_mask>
c002aa15:	83 c4 04             	add    $0x4,%esp
c002aa18:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002aa1b:	8b 45 08             	mov    0x8(%ebp),%eax
c002aa1e:	8b 40 04             	mov    0x4(%eax),%eax
c002aa21:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002aa24:	c1 e2 02             	shl    $0x2,%edx
c002aa27:	01 c2                	add    %eax,%edx
c002aa29:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002aa2c:	31 02                	xor    %eax,(%edx)
}
c002aa2e:	90                   	nop
c002aa2f:	c9                   	leave  
c002aa30:	c3                   	ret    

c002aa31 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002aa31:	55                   	push   %ebp
c002aa32:	89 e5                	mov    %esp,%ebp
c002aa34:	53                   	push   %ebx
c002aa35:	83 ec 04             	sub    $0x4,%esp
  ASSERT (b != NULL);
c002aa38:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aa3c:	75 21                	jne    c002aa5f <bitmap_test+0x2e>
c002aa3e:	83 ec 0c             	sub    $0xc,%esp
c002aa41:	68 b5 11 03 c0       	push   $0xc00311b5
c002aa46:	68 84 11 03 c0       	push   $0xc0031184
c002aa4b:	68 24 12 03 c0       	push   $0xc0031224
c002aa50:	68 c8 00 00 00       	push   $0xc8
c002aa55:	68 9b 11 03 c0       	push   $0xc003119b
c002aa5a:	e8 19 ed ff ff       	call   c0029778 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002aa5f:	8b 45 08             	mov    0x8(%ebp),%eax
c002aa62:	8b 00                	mov    (%eax),%eax
c002aa64:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002aa67:	77 21                	ja     c002aa8a <bitmap_test+0x59>
c002aa69:	83 ec 0c             	sub    $0xc,%esp
c002aa6c:	68 bf 11 03 c0       	push   $0xc00311bf
c002aa71:	68 84 11 03 c0       	push   $0xc0031184
c002aa76:	68 24 12 03 c0       	push   $0xc0031224
c002aa7b:	68 c9 00 00 00       	push   $0xc9
c002aa80:	68 9b 11 03 c0       	push   $0xc003119b
c002aa85:	e8 ee ec ff ff       	call   c0029778 <debug_panic>
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002aa8a:	8b 45 08             	mov    0x8(%ebp),%eax
c002aa8d:	8b 58 04             	mov    0x4(%eax),%ebx
c002aa90:	83 ec 0c             	sub    $0xc,%esp
c002aa93:	ff 75 0c             	pushl  0xc(%ebp)
c002aa96:	e8 ed fc ff ff       	call   c002a788 <elem_idx>
c002aa9b:	83 c4 10             	add    $0x10,%esp
c002aa9e:	c1 e0 02             	shl    $0x2,%eax
c002aaa1:	01 d8                	add    %ebx,%eax
c002aaa3:	8b 18                	mov    (%eax),%ebx
c002aaa5:	83 ec 0c             	sub    $0xc,%esp
c002aaa8:	ff 75 0c             	pushl  0xc(%ebp)
c002aaab:	e8 e3 fc ff ff       	call   c002a793 <bit_mask>
c002aab0:	83 c4 10             	add    $0x10,%esp
c002aab3:	21 d8                	and    %ebx,%eax
c002aab5:	85 c0                	test   %eax,%eax
c002aab7:	0f 95 c0             	setne  %al
}
c002aaba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002aabd:	c9                   	leave  
c002aabe:	c3                   	ret    

c002aabf <bitmap_set_all>:
/* Setting and testing multiple bits. */

/* Sets all bits in B to VALUE. */
void
bitmap_set_all (struct bitmap *b, bool value) 
{
c002aabf:	55                   	push   %ebp
c002aac0:	89 e5                	mov    %esp,%ebp
c002aac2:	53                   	push   %ebx
c002aac3:	83 ec 14             	sub    $0x14,%esp
c002aac6:	8b 45 0c             	mov    0xc(%ebp),%eax
c002aac9:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002aacc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aad0:	75 21                	jne    c002aaf3 <bitmap_set_all+0x34>
c002aad2:	83 ec 0c             	sub    $0xc,%esp
c002aad5:	68 b5 11 03 c0       	push   $0xc00311b5
c002aada:	68 84 11 03 c0       	push   $0xc0031184
c002aadf:	68 30 12 03 c0       	push   $0xc0031230
c002aae4:	68 d3 00 00 00       	push   $0xd3
c002aae9:	68 9b 11 03 c0       	push   $0xc003119b
c002aaee:	e8 85 ec ff ff       	call   c0029778 <debug_panic>

  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002aaf3:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002aaf7:	83 ec 0c             	sub    $0xc,%esp
c002aafa:	ff 75 08             	pushl  0x8(%ebp)
c002aafd:	e8 f0 fd ff ff       	call   c002a8f2 <bitmap_size>
c002ab02:	83 c4 10             	add    $0x10,%esp
c002ab05:	53                   	push   %ebx
c002ab06:	50                   	push   %eax
c002ab07:	6a 00                	push   $0x0
c002ab09:	ff 75 08             	pushl  0x8(%ebp)
c002ab0c:	e8 09 00 00 00       	call   c002ab1a <bitmap_set_multiple>
c002ab11:	83 c4 10             	add    $0x10,%esp
}
c002ab14:	90                   	nop
c002ab15:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ab18:	c9                   	leave  
c002ab19:	c3                   	ret    

c002ab1a <bitmap_set_multiple>:

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002ab1a:	55                   	push   %ebp
c002ab1b:	89 e5                	mov    %esp,%ebp
c002ab1d:	83 ec 28             	sub    $0x28,%esp
c002ab20:	8b 45 14             	mov    0x14(%ebp),%eax
c002ab23:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002ab26:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ab2a:	75 21                	jne    c002ab4d <bitmap_set_multiple+0x33>
c002ab2c:	83 ec 0c             	sub    $0xc,%esp
c002ab2f:	68 b5 11 03 c0       	push   $0xc00311b5
c002ab34:	68 84 11 03 c0       	push   $0xc0031184
c002ab39:	68 40 12 03 c0       	push   $0xc0031240
c002ab3e:	68 de 00 00 00       	push   $0xde
c002ab43:	68 9b 11 03 c0       	push   $0xc003119b
c002ab48:	e8 2b ec ff ff       	call   c0029778 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002ab4d:	8b 45 08             	mov    0x8(%ebp),%eax
c002ab50:	8b 00                	mov    (%eax),%eax
c002ab52:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002ab55:	73 21                	jae    c002ab78 <bitmap_set_multiple+0x5e>
c002ab57:	83 ec 0c             	sub    $0xc,%esp
c002ab5a:	68 d0 11 03 c0       	push   $0xc00311d0
c002ab5f:	68 84 11 03 c0       	push   $0xc0031184
c002ab64:	68 40 12 03 c0       	push   $0xc0031240
c002ab69:	68 df 00 00 00       	push   $0xdf
c002ab6e:	68 9b 11 03 c0       	push   $0xc003119b
c002ab73:	e8 00 ec ff ff       	call   c0029778 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002ab78:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ab7b:	8b 45 10             	mov    0x10(%ebp),%eax
c002ab7e:	01 c2                	add    %eax,%edx
c002ab80:	8b 45 08             	mov    0x8(%ebp),%eax
c002ab83:	8b 00                	mov    (%eax),%eax
c002ab85:	39 c2                	cmp    %eax,%edx
c002ab87:	76 21                	jbe    c002abaa <bitmap_set_multiple+0x90>
c002ab89:	83 ec 0c             	sub    $0xc,%esp
c002ab8c:	68 e4 11 03 c0       	push   $0xc00311e4
c002ab91:	68 84 11 03 c0       	push   $0xc0031184
c002ab96:	68 40 12 03 c0       	push   $0xc0031240
c002ab9b:	68 e0 00 00 00       	push   $0xe0
c002aba0:	68 9b 11 03 c0       	push   $0xc003119b
c002aba5:	e8 ce eb ff ff       	call   c0029778 <debug_panic>

  for (i = 0; i < cnt; i++)
c002abaa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002abb1:	eb 20                	jmp    c002abd3 <bitmap_set_multiple+0xb9>
    bitmap_set (b, start + i, value);
c002abb3:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002abb7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002abba:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002abbd:	01 ca                	add    %ecx,%edx
c002abbf:	83 ec 04             	sub    $0x4,%esp
c002abc2:	50                   	push   %eax
c002abc3:	52                   	push   %edx
c002abc4:	ff 75 08             	pushl  0x8(%ebp)
c002abc7:	e8 30 fd ff ff       	call   c002a8fc <bitmap_set>
c002abcc:	83 c4 10             	add    $0x10,%esp
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  for (i = 0; i < cnt; i++)
c002abcf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002abd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002abd6:	3b 45 10             	cmp    0x10(%ebp),%eax
c002abd9:	72 d8                	jb     c002abb3 <bitmap_set_multiple+0x99>
    bitmap_set (b, start + i, value);
}
c002abdb:	90                   	nop
c002abdc:	c9                   	leave  
c002abdd:	c3                   	ret    

c002abde <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002abde:	55                   	push   %ebp
c002abdf:	89 e5                	mov    %esp,%ebp
c002abe1:	83 ec 28             	sub    $0x28,%esp
c002abe4:	8b 45 14             	mov    0x14(%ebp),%eax
c002abe7:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002abea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002abee:	75 21                	jne    c002ac11 <bitmap_count+0x33>
c002abf0:	83 ec 0c             	sub    $0xc,%esp
c002abf3:	68 b5 11 03 c0       	push   $0xc00311b5
c002abf8:	68 84 11 03 c0       	push   $0xc0031184
c002abfd:	68 54 12 03 c0       	push   $0xc0031254
c002ac02:	68 ed 00 00 00       	push   $0xed
c002ac07:	68 9b 11 03 c0       	push   $0xc003119b
c002ac0c:	e8 67 eb ff ff       	call   c0029778 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002ac11:	8b 45 08             	mov    0x8(%ebp),%eax
c002ac14:	8b 00                	mov    (%eax),%eax
c002ac16:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002ac19:	73 21                	jae    c002ac3c <bitmap_count+0x5e>
c002ac1b:	83 ec 0c             	sub    $0xc,%esp
c002ac1e:	68 d0 11 03 c0       	push   $0xc00311d0
c002ac23:	68 84 11 03 c0       	push   $0xc0031184
c002ac28:	68 54 12 03 c0       	push   $0xc0031254
c002ac2d:	68 ee 00 00 00       	push   $0xee
c002ac32:	68 9b 11 03 c0       	push   $0xc003119b
c002ac37:	e8 3c eb ff ff       	call   c0029778 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002ac3c:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ac3f:	8b 45 10             	mov    0x10(%ebp),%eax
c002ac42:	01 c2                	add    %eax,%edx
c002ac44:	8b 45 08             	mov    0x8(%ebp),%eax
c002ac47:	8b 00                	mov    (%eax),%eax
c002ac49:	39 c2                	cmp    %eax,%edx
c002ac4b:	76 21                	jbe    c002ac6e <bitmap_count+0x90>
c002ac4d:	83 ec 0c             	sub    $0xc,%esp
c002ac50:	68 e4 11 03 c0       	push   $0xc00311e4
c002ac55:	68 84 11 03 c0       	push   $0xc0031184
c002ac5a:	68 54 12 03 c0       	push   $0xc0031254
c002ac5f:	68 ef 00 00 00       	push   $0xef
c002ac64:	68 9b 11 03 c0       	push   $0xc003119b
c002ac69:	e8 0a eb ff ff       	call   c0029778 <debug_panic>

  value_cnt = 0;
c002ac6e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002ac75:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ac7c:	eb 24                	jmp    c002aca2 <bitmap_count+0xc4>
    if (bitmap_test (b, start + i) == value)
c002ac7e:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ac81:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac84:	01 d0                	add    %edx,%eax
c002ac86:	83 ec 08             	sub    $0x8,%esp
c002ac89:	50                   	push   %eax
c002ac8a:	ff 75 08             	pushl  0x8(%ebp)
c002ac8d:	e8 9f fd ff ff       	call   c002aa31 <bitmap_test>
c002ac92:	83 c4 10             	add    $0x10,%esp
c002ac95:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002ac98:	75 04                	jne    c002ac9e <bitmap_count+0xc0>
      value_cnt++;
c002ac9a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  value_cnt = 0;
  for (i = 0; i < cnt; i++)
c002ac9e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002aca2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aca5:	3b 45 10             	cmp    0x10(%ebp),%eax
c002aca8:	72 d4                	jb     c002ac7e <bitmap_count+0xa0>
    if (bitmap_test (b, start + i) == value)
      value_cnt++;
  return value_cnt;
c002acaa:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002acad:	c9                   	leave  
c002acae:	c3                   	ret    

c002acaf <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002acaf:	55                   	push   %ebp
c002acb0:	89 e5                	mov    %esp,%ebp
c002acb2:	83 ec 28             	sub    $0x28,%esp
c002acb5:	8b 45 14             	mov    0x14(%ebp),%eax
c002acb8:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002acbb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002acbf:	75 21                	jne    c002ace2 <bitmap_contains+0x33>
c002acc1:	83 ec 0c             	sub    $0xc,%esp
c002acc4:	68 b5 11 03 c0       	push   $0xc00311b5
c002acc9:	68 84 11 03 c0       	push   $0xc0031184
c002acce:	68 64 12 03 c0       	push   $0xc0031264
c002acd3:	68 ff 00 00 00       	push   $0xff
c002acd8:	68 9b 11 03 c0       	push   $0xc003119b
c002acdd:	e8 96 ea ff ff       	call   c0029778 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002ace2:	8b 45 08             	mov    0x8(%ebp),%eax
c002ace5:	8b 00                	mov    (%eax),%eax
c002ace7:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002acea:	73 21                	jae    c002ad0d <bitmap_contains+0x5e>
c002acec:	83 ec 0c             	sub    $0xc,%esp
c002acef:	68 d0 11 03 c0       	push   $0xc00311d0
c002acf4:	68 84 11 03 c0       	push   $0xc0031184
c002acf9:	68 64 12 03 c0       	push   $0xc0031264
c002acfe:	68 00 01 00 00       	push   $0x100
c002ad03:	68 9b 11 03 c0       	push   $0xc003119b
c002ad08:	e8 6b ea ff ff       	call   c0029778 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002ad0d:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ad10:	8b 45 10             	mov    0x10(%ebp),%eax
c002ad13:	01 c2                	add    %eax,%edx
c002ad15:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad18:	8b 00                	mov    (%eax),%eax
c002ad1a:	39 c2                	cmp    %eax,%edx
c002ad1c:	76 21                	jbe    c002ad3f <bitmap_contains+0x90>
c002ad1e:	83 ec 0c             	sub    $0xc,%esp
c002ad21:	68 e4 11 03 c0       	push   $0xc00311e4
c002ad26:	68 84 11 03 c0       	push   $0xc0031184
c002ad2b:	68 64 12 03 c0       	push   $0xc0031264
c002ad30:	68 01 01 00 00       	push   $0x101
c002ad35:	68 9b 11 03 c0       	push   $0xc003119b
c002ad3a:	e8 39 ea ff ff       	call   c0029778 <debug_panic>

  for (i = 0; i < cnt; i++)
c002ad3f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ad46:	eb 27                	jmp    c002ad6f <bitmap_contains+0xc0>
    if (bitmap_test (b, start + i) == value)
c002ad48:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ad4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ad4e:	01 d0                	add    %edx,%eax
c002ad50:	83 ec 08             	sub    $0x8,%esp
c002ad53:	50                   	push   %eax
c002ad54:	ff 75 08             	pushl  0x8(%ebp)
c002ad57:	e8 d5 fc ff ff       	call   c002aa31 <bitmap_test>
c002ad5c:	83 c4 10             	add    $0x10,%esp
c002ad5f:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002ad62:	75 07                	jne    c002ad6b <bitmap_contains+0xbc>
      return true;
c002ad64:	b8 01 00 00 00       	mov    $0x1,%eax
c002ad69:	eb 11                	jmp    c002ad7c <bitmap_contains+0xcd>
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  for (i = 0; i < cnt; i++)
c002ad6b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002ad6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ad72:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ad75:	72 d1                	jb     c002ad48 <bitmap_contains+0x99>
    if (bitmap_test (b, start + i) == value)
      return true;
  return false;
c002ad77:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002ad7c:	c9                   	leave  
c002ad7d:	c3                   	ret    

c002ad7e <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ad7e:	55                   	push   %ebp
c002ad7f:	89 e5                	mov    %esp,%ebp
c002ad81:	83 ec 08             	sub    $0x8,%esp
  return bitmap_contains (b, start, cnt, true);
c002ad84:	6a 01                	push   $0x1
c002ad86:	ff 75 10             	pushl  0x10(%ebp)
c002ad89:	ff 75 0c             	pushl  0xc(%ebp)
c002ad8c:	ff 75 08             	pushl  0x8(%ebp)
c002ad8f:	e8 1b ff ff ff       	call   c002acaf <bitmap_contains>
c002ad94:	83 c4 10             	add    $0x10,%esp
}
c002ad97:	c9                   	leave  
c002ad98:	c3                   	ret    

c002ad99 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ad99:	55                   	push   %ebp
c002ad9a:	89 e5                	mov    %esp,%ebp
c002ad9c:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, true);
c002ad9f:	6a 01                	push   $0x1
c002ada1:	ff 75 10             	pushl  0x10(%ebp)
c002ada4:	ff 75 0c             	pushl  0xc(%ebp)
c002ada7:	ff 75 08             	pushl  0x8(%ebp)
c002adaa:	e8 00 ff ff ff       	call   c002acaf <bitmap_contains>
c002adaf:	83 c4 10             	add    $0x10,%esp
c002adb2:	0f b6 c0             	movzbl %al,%eax
c002adb5:	85 c0                	test   %eax,%eax
c002adb7:	0f 95 c0             	setne  %al
c002adba:	83 f0 01             	xor    $0x1,%eax
c002adbd:	0f b6 c0             	movzbl %al,%eax
c002adc0:	83 e0 01             	and    $0x1,%eax
}
c002adc3:	c9                   	leave  
c002adc4:	c3                   	ret    

c002adc5 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002adc5:	55                   	push   %ebp
c002adc6:	89 e5                	mov    %esp,%ebp
c002adc8:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, false);
c002adcb:	6a 00                	push   $0x0
c002adcd:	ff 75 10             	pushl  0x10(%ebp)
c002add0:	ff 75 0c             	pushl  0xc(%ebp)
c002add3:	ff 75 08             	pushl  0x8(%ebp)
c002add6:	e8 d4 fe ff ff       	call   c002acaf <bitmap_contains>
c002addb:	83 c4 10             	add    $0x10,%esp
c002adde:	0f b6 c0             	movzbl %al,%eax
c002ade1:	85 c0                	test   %eax,%eax
c002ade3:	0f 95 c0             	setne  %al
c002ade6:	83 f0 01             	xor    $0x1,%eax
c002ade9:	0f b6 c0             	movzbl %al,%eax
c002adec:	83 e0 01             	and    $0x1,%eax
}
c002adef:	c9                   	leave  
c002adf0:	c3                   	ret    

c002adf1 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002adf1:	55                   	push   %ebp
c002adf2:	89 e5                	mov    %esp,%ebp
c002adf4:	83 ec 28             	sub    $0x28,%esp
c002adf7:	8b 45 14             	mov    0x14(%ebp),%eax
c002adfa:	88 45 e4             	mov    %al,-0x1c(%ebp)
  ASSERT (b != NULL);
c002adfd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ae01:	75 21                	jne    c002ae24 <bitmap_scan+0x33>
c002ae03:	83 ec 0c             	sub    $0xc,%esp
c002ae06:	68 b5 11 03 c0       	push   $0xc00311b5
c002ae0b:	68 84 11 03 c0       	push   $0xc0031184
c002ae10:	68 74 12 03 c0       	push   $0xc0031274
c002ae15:	68 2a 01 00 00       	push   $0x12a
c002ae1a:	68 9b 11 03 c0       	push   $0xc003119b
c002ae1f:	e8 54 e9 ff ff       	call   c0029778 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002ae24:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae27:	8b 00                	mov    (%eax),%eax
c002ae29:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002ae2c:	73 21                	jae    c002ae4f <bitmap_scan+0x5e>
c002ae2e:	83 ec 0c             	sub    $0xc,%esp
c002ae31:	68 d0 11 03 c0       	push   $0xc00311d0
c002ae36:	68 84 11 03 c0       	push   $0xc0031184
c002ae3b:	68 74 12 03 c0       	push   $0xc0031274
c002ae40:	68 2b 01 00 00       	push   $0x12b
c002ae45:	68 9b 11 03 c0       	push   $0xc003119b
c002ae4a:	e8 29 e9 ff ff       	call   c0029778 <debug_panic>

  if (cnt <= b->bit_cnt) 
c002ae4f:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae52:	8b 00                	mov    (%eax),%eax
c002ae54:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ae57:	72 47                	jb     c002aea0 <bitmap_scan+0xaf>
    {
      size_t last = b->bit_cnt - cnt;
c002ae59:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae5c:	8b 00                	mov    (%eax),%eax
c002ae5e:	2b 45 10             	sub    0x10(%ebp),%eax
c002ae61:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t i;
      for (i = start; i <= last; i++)
c002ae64:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ae67:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002ae6a:	eb 2c                	jmp    c002ae98 <bitmap_scan+0xa7>
        if (!bitmap_contains (b, i, cnt, !value))
c002ae6c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ae70:	83 f0 01             	xor    $0x1,%eax
c002ae73:	0f b6 c0             	movzbl %al,%eax
c002ae76:	50                   	push   %eax
c002ae77:	ff 75 10             	pushl  0x10(%ebp)
c002ae7a:	ff 75 f4             	pushl  -0xc(%ebp)
c002ae7d:	ff 75 08             	pushl  0x8(%ebp)
c002ae80:	e8 2a fe ff ff       	call   c002acaf <bitmap_contains>
c002ae85:	83 c4 10             	add    $0x10,%esp
c002ae88:	83 f0 01             	xor    $0x1,%eax
c002ae8b:	84 c0                	test   %al,%al
c002ae8d:	74 05                	je     c002ae94 <bitmap_scan+0xa3>
          return i; 
c002ae8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ae92:	eb 11                	jmp    c002aea5 <bitmap_scan+0xb4>

  if (cnt <= b->bit_cnt) 
    {
      size_t last = b->bit_cnt - cnt;
      size_t i;
      for (i = start; i <= last; i++)
c002ae94:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002ae98:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ae9b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002ae9e:	76 cc                	jbe    c002ae6c <bitmap_scan+0x7b>
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c002aea0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002aea5:	c9                   	leave  
c002aea6:	c3                   	ret    

c002aea7 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002aea7:	55                   	push   %ebp
c002aea8:	89 e5                	mov    %esp,%ebp
c002aeaa:	83 ec 28             	sub    $0x28,%esp
c002aead:	8b 45 14             	mov    0x14(%ebp),%eax
c002aeb0:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t idx = bitmap_scan (b, start, cnt, value);
c002aeb3:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002aeb7:	50                   	push   %eax
c002aeb8:	ff 75 10             	pushl  0x10(%ebp)
c002aebb:	ff 75 0c             	pushl  0xc(%ebp)
c002aebe:	ff 75 08             	pushl  0x8(%ebp)
c002aec1:	e8 2b ff ff ff       	call   c002adf1 <bitmap_scan>
c002aec6:	83 c4 10             	add    $0x10,%esp
c002aec9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (idx != BITMAP_ERROR) 
c002aecc:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002aed0:	74 1c                	je     c002aeee <bitmap_scan_and_flip+0x47>
    bitmap_set_multiple (b, idx, cnt, !value);
c002aed2:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002aed6:	83 f0 01             	xor    $0x1,%eax
c002aed9:	0f b6 c0             	movzbl %al,%eax
c002aedc:	50                   	push   %eax
c002aedd:	ff 75 10             	pushl  0x10(%ebp)
c002aee0:	ff 75 f4             	pushl  -0xc(%ebp)
c002aee3:	ff 75 08             	pushl  0x8(%ebp)
c002aee6:	e8 2f fc ff ff       	call   c002ab1a <bitmap_set_multiple>
c002aeeb:	83 c4 10             	add    $0x10,%esp
  return idx;
c002aeee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002aef1:	c9                   	leave  
c002aef2:	c3                   	ret    

c002aef3 <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002aef3:	55                   	push   %ebp
c002aef4:	89 e5                	mov    %esp,%ebp
c002aef6:	83 ec 08             	sub    $0x8,%esp
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002aef9:	8b 45 08             	mov    0x8(%ebp),%eax
c002aefc:	8b 00                	mov    (%eax),%eax
c002aefe:	50                   	push   %eax
c002aeff:	e8 b3 f8 ff ff       	call   c002a7b7 <byte_cnt>
c002af04:	83 c4 04             	add    $0x4,%esp
c002af07:	89 c2                	mov    %eax,%edx
c002af09:	8b 45 08             	mov    0x8(%ebp),%eax
c002af0c:	8b 40 04             	mov    0x4(%eax),%eax
c002af0f:	6a 00                	push   $0x0
c002af11:	52                   	push   %edx
c002af12:	50                   	push   %eax
c002af13:	6a 00                	push   $0x0
c002af15:	e8 66 cf ff ff       	call   c0027e80 <hex_dump>
c002af1a:	83 c4 10             	add    $0x10,%esp
}
c002af1d:	90                   	nop
c002af1e:	c9                   	leave  
c002af1f:	c3                   	ret    

c002af20 <hash_init>:
/* Initializes hash table H to compute hash values using HASH and
   compare hash elements using LESS, given auxiliary data AUX. */
bool
hash_init (struct hash *h,
           hash_hash_func *hash, hash_less_func *less, void *aux) 
{
c002af20:	55                   	push   %ebp
c002af21:	89 e5                	mov    %esp,%ebp
c002af23:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt = 0;
c002af26:	8b 45 08             	mov    0x8(%ebp),%eax
c002af29:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  h->bucket_cnt = 4;
c002af2f:	8b 45 08             	mov    0x8(%ebp),%eax
c002af32:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002af39:	8b 45 08             	mov    0x8(%ebp),%eax
c002af3c:	8b 40 04             	mov    0x4(%eax),%eax
c002af3f:	c1 e0 04             	shl    $0x4,%eax
c002af42:	83 ec 0c             	sub    $0xc,%esp
c002af45:	50                   	push   %eax
c002af46:	e8 5e 86 ff ff       	call   c00235a9 <malloc>
c002af4b:	83 c4 10             	add    $0x10,%esp
c002af4e:	89 c2                	mov    %eax,%edx
c002af50:	8b 45 08             	mov    0x8(%ebp),%eax
c002af53:	89 50 08             	mov    %edx,0x8(%eax)
  h->hash = hash;
c002af56:	8b 45 08             	mov    0x8(%ebp),%eax
c002af59:	8b 55 0c             	mov    0xc(%ebp),%edx
c002af5c:	89 50 0c             	mov    %edx,0xc(%eax)
  h->less = less;
c002af5f:	8b 45 08             	mov    0x8(%ebp),%eax
c002af62:	8b 55 10             	mov    0x10(%ebp),%edx
c002af65:	89 50 10             	mov    %edx,0x10(%eax)
  h->aux = aux;
c002af68:	8b 45 08             	mov    0x8(%ebp),%eax
c002af6b:	8b 55 14             	mov    0x14(%ebp),%edx
c002af6e:	89 50 14             	mov    %edx,0x14(%eax)

  if (h->buckets != NULL) 
c002af71:	8b 45 08             	mov    0x8(%ebp),%eax
c002af74:	8b 40 08             	mov    0x8(%eax),%eax
c002af77:	85 c0                	test   %eax,%eax
c002af79:	74 17                	je     c002af92 <hash_init+0x72>
    {
      hash_clear (h, NULL);
c002af7b:	83 ec 08             	sub    $0x8,%esp
c002af7e:	6a 00                	push   $0x0
c002af80:	ff 75 08             	pushl  0x8(%ebp)
c002af83:	e8 11 00 00 00       	call   c002af99 <hash_clear>
c002af88:	83 c4 10             	add    $0x10,%esp
      return true;
c002af8b:	b8 01 00 00 00       	mov    $0x1,%eax
c002af90:	eb 05                	jmp    c002af97 <hash_init+0x77>
    }
  else
    return false;
c002af92:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002af97:	c9                   	leave  
c002af98:	c3                   	ret    

c002af99 <hash_clear>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), yields undefined behavior,
   whether done in DESTRUCTOR or elsewhere. */
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
c002af99:	55                   	push   %ebp
c002af9a:	89 e5                	mov    %esp,%ebp
c002af9c:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002af9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002afa6:	eb 72                	jmp    c002b01a <hash_clear+0x81>
    {
      struct list *bucket = &h->buckets[i];
c002afa8:	8b 45 08             	mov    0x8(%ebp),%eax
c002afab:	8b 40 08             	mov    0x8(%eax),%eax
c002afae:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002afb1:	c1 e2 04             	shl    $0x4,%edx
c002afb4:	01 d0                	add    %edx,%eax
c002afb6:	89 45 f0             	mov    %eax,-0x10(%ebp)

      if (destructor != NULL) 
c002afb9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002afbd:	74 49                	je     c002b008 <hash_clear+0x6f>
        while (!list_empty (bucket)) 
c002afbf:	eb 32                	jmp    c002aff3 <hash_clear+0x5a>
          {
            struct list_elem *list_elem = list_pop_front (bucket);
c002afc1:	83 ec 0c             	sub    $0xc,%esp
c002afc4:	ff 75 f0             	pushl  -0x10(%ebp)
c002afc7:	e8 7e ee ff ff       	call   c0029e4a <list_pop_front>
c002afcc:	83 c4 10             	add    $0x10,%esp
c002afcf:	89 45 ec             	mov    %eax,-0x14(%ebp)
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
c002afd2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002afd5:	83 c0 04             	add    $0x4,%eax
c002afd8:	83 e8 04             	sub    $0x4,%eax
c002afdb:	89 45 e8             	mov    %eax,-0x18(%ebp)
            destructor (hash_elem, h->aux);
c002afde:	8b 45 08             	mov    0x8(%ebp),%eax
c002afe1:	8b 40 14             	mov    0x14(%eax),%eax
c002afe4:	83 ec 08             	sub    $0x8,%esp
c002afe7:	50                   	push   %eax
c002afe8:	ff 75 e8             	pushl  -0x18(%ebp)
c002afeb:	8b 45 0c             	mov    0xc(%ebp),%eax
c002afee:	ff d0                	call   *%eax
c002aff0:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
    {
      struct list *bucket = &h->buckets[i];

      if (destructor != NULL) 
        while (!list_empty (bucket)) 
c002aff3:	83 ec 0c             	sub    $0xc,%esp
c002aff6:	ff 75 f0             	pushl  -0x10(%ebp)
c002aff9:	e8 75 ef ff ff       	call   c0029f73 <list_empty>
c002affe:	83 c4 10             	add    $0x10,%esp
c002b001:	83 f0 01             	xor    $0x1,%eax
c002b004:	84 c0                	test   %al,%al
c002b006:	75 b9                	jne    c002afc1 <hash_clear+0x28>
            struct list_elem *list_elem = list_pop_front (bucket);
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
            destructor (hash_elem, h->aux);
          }

      list_init (bucket); 
c002b008:	83 ec 0c             	sub    $0xc,%esp
c002b00b:	ff 75 f0             	pushl  -0x10(%ebp)
c002b00e:	e8 d8 e9 ff ff       	call   c00299eb <list_init>
c002b013:	83 c4 10             	add    $0x10,%esp
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002b016:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002b01a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b01d:	8b 40 04             	mov    0x4(%eax),%eax
c002b020:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b023:	77 83                	ja     c002afa8 <hash_clear+0xf>
          }

      list_init (bucket); 
    }    

  h->elem_cnt = 0;
c002b025:	8b 45 08             	mov    0x8(%ebp),%eax
c002b028:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c002b02e:	90                   	nop
c002b02f:	c9                   	leave  
c002b030:	c3                   	ret    

c002b031 <hash_destroy>:
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done in DESTRUCTOR or
   elsewhere. */
void
hash_destroy (struct hash *h, hash_action_func *destructor) 
{
c002b031:	55                   	push   %ebp
c002b032:	89 e5                	mov    %esp,%ebp
c002b034:	83 ec 08             	sub    $0x8,%esp
  if (destructor != NULL)
c002b037:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b03b:	74 11                	je     c002b04e <hash_destroy+0x1d>
    hash_clear (h, destructor);
c002b03d:	83 ec 08             	sub    $0x8,%esp
c002b040:	ff 75 0c             	pushl  0xc(%ebp)
c002b043:	ff 75 08             	pushl  0x8(%ebp)
c002b046:	e8 4e ff ff ff       	call   c002af99 <hash_clear>
c002b04b:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002b04e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b051:	8b 40 08             	mov    0x8(%eax),%eax
c002b054:	83 ec 0c             	sub    $0xc,%esp
c002b057:	50                   	push   %eax
c002b058:	e8 45 88 ff ff       	call   c00238a2 <free>
c002b05d:	83 c4 10             	add    $0x10,%esp
}
c002b060:	90                   	nop
c002b061:	c9                   	leave  
c002b062:	c3                   	ret    

c002b063 <hash_insert>:
   no equal element is already in the table.
   If an equal element is already in the table, returns it
   without inserting NEW. */   
struct hash_elem *
hash_insert (struct hash *h, struct hash_elem *new)
{
c002b063:	55                   	push   %ebp
c002b064:	89 e5                	mov    %esp,%ebp
c002b066:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002b069:	83 ec 08             	sub    $0x8,%esp
c002b06c:	ff 75 0c             	pushl  0xc(%ebp)
c002b06f:	ff 75 08             	pushl  0x8(%ebp)
c002b072:	e8 5a 04 00 00       	call   c002b4d1 <find_bucket>
c002b077:	83 c4 10             	add    $0x10,%esp
c002b07a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002b07d:	83 ec 04             	sub    $0x4,%esp
c002b080:	ff 75 0c             	pushl  0xc(%ebp)
c002b083:	ff 75 f4             	pushl  -0xc(%ebp)
c002b086:	ff 75 08             	pushl  0x8(%ebp)
c002b089:	e8 81 04 00 00       	call   c002b50f <find_elem>
c002b08e:	83 c4 10             	add    $0x10,%esp
c002b091:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old == NULL) 
c002b094:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002b098:	75 14                	jne    c002b0ae <hash_insert+0x4b>
    insert_elem (h, bucket, new);
c002b09a:	83 ec 04             	sub    $0x4,%esp
c002b09d:	ff 75 0c             	pushl  0xc(%ebp)
c002b0a0:	ff 75 f4             	pushl  -0xc(%ebp)
c002b0a3:	ff 75 08             	pushl  0x8(%ebp)
c002b0a6:	e8 d0 06 00 00       	call   c002b77b <insert_elem>
c002b0ab:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002b0ae:	83 ec 0c             	sub    $0xc,%esp
c002b0b1:	ff 75 08             	pushl  0x8(%ebp)
c002b0b4:	e8 23 05 00 00       	call   c002b5dc <rehash>
c002b0b9:	83 c4 10             	add    $0x10,%esp

  return old; 
c002b0bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b0bf:	c9                   	leave  
c002b0c0:	c3                   	ret    

c002b0c1 <hash_replace>:

/* Inserts NEW into hash table H, replacing any equal element
   already in the table, which is returned. */
struct hash_elem *
hash_replace (struct hash *h, struct hash_elem *new) 
{
c002b0c1:	55                   	push   %ebp
c002b0c2:	89 e5                	mov    %esp,%ebp
c002b0c4:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002b0c7:	83 ec 08             	sub    $0x8,%esp
c002b0ca:	ff 75 0c             	pushl  0xc(%ebp)
c002b0cd:	ff 75 08             	pushl  0x8(%ebp)
c002b0d0:	e8 fc 03 00 00       	call   c002b4d1 <find_bucket>
c002b0d5:	83 c4 10             	add    $0x10,%esp
c002b0d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002b0db:	83 ec 04             	sub    $0x4,%esp
c002b0de:	ff 75 0c             	pushl  0xc(%ebp)
c002b0e1:	ff 75 f4             	pushl  -0xc(%ebp)
c002b0e4:	ff 75 08             	pushl  0x8(%ebp)
c002b0e7:	e8 23 04 00 00       	call   c002b50f <find_elem>
c002b0ec:	83 c4 10             	add    $0x10,%esp
c002b0ef:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old != NULL)
c002b0f2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002b0f6:	74 11                	je     c002b109 <hash_replace+0x48>
    remove_elem (h, old);
c002b0f8:	83 ec 08             	sub    $0x8,%esp
c002b0fb:	ff 75 f0             	pushl  -0x10(%ebp)
c002b0fe:	ff 75 08             	pushl  0x8(%ebp)
c002b101:	e8 9d 06 00 00       	call   c002b7a3 <remove_elem>
c002b106:	83 c4 10             	add    $0x10,%esp
  insert_elem (h, bucket, new);
c002b109:	83 ec 04             	sub    $0x4,%esp
c002b10c:	ff 75 0c             	pushl  0xc(%ebp)
c002b10f:	ff 75 f4             	pushl  -0xc(%ebp)
c002b112:	ff 75 08             	pushl  0x8(%ebp)
c002b115:	e8 61 06 00 00       	call   c002b77b <insert_elem>
c002b11a:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002b11d:	83 ec 0c             	sub    $0xc,%esp
c002b120:	ff 75 08             	pushl  0x8(%ebp)
c002b123:	e8 b4 04 00 00       	call   c002b5dc <rehash>
c002b128:	83 c4 10             	add    $0x10,%esp

  return old;
c002b12b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b12e:	c9                   	leave  
c002b12f:	c3                   	ret    

c002b130 <hash_find>:

/* Finds and returns an element equal to E in hash table H, or a
   null pointer if no equal element exists in the table. */
struct hash_elem *
hash_find (struct hash *h, struct hash_elem *e) 
{
c002b130:	55                   	push   %ebp
c002b131:	89 e5                	mov    %esp,%ebp
c002b133:	83 ec 08             	sub    $0x8,%esp
  return find_elem (h, find_bucket (h, e), e);
c002b136:	83 ec 08             	sub    $0x8,%esp
c002b139:	ff 75 0c             	pushl  0xc(%ebp)
c002b13c:	ff 75 08             	pushl  0x8(%ebp)
c002b13f:	e8 8d 03 00 00       	call   c002b4d1 <find_bucket>
c002b144:	83 c4 10             	add    $0x10,%esp
c002b147:	83 ec 04             	sub    $0x4,%esp
c002b14a:	ff 75 0c             	pushl  0xc(%ebp)
c002b14d:	50                   	push   %eax
c002b14e:	ff 75 08             	pushl  0x8(%ebp)
c002b151:	e8 b9 03 00 00       	call   c002b50f <find_elem>
c002b156:	83 c4 10             	add    $0x10,%esp
}
c002b159:	c9                   	leave  
c002b15a:	c3                   	ret    

c002b15b <hash_delete>:
   If the elements of the hash table are dynamically allocated,
   or own resources that are, then it is the caller's
   responsibility to deallocate them. */
struct hash_elem *
hash_delete (struct hash *h, struct hash_elem *e)
{
c002b15b:	55                   	push   %ebp
c002b15c:	89 e5                	mov    %esp,%ebp
c002b15e:	83 ec 18             	sub    $0x18,%esp
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002b161:	83 ec 08             	sub    $0x8,%esp
c002b164:	ff 75 0c             	pushl  0xc(%ebp)
c002b167:	ff 75 08             	pushl  0x8(%ebp)
c002b16a:	e8 62 03 00 00       	call   c002b4d1 <find_bucket>
c002b16f:	83 c4 10             	add    $0x10,%esp
c002b172:	83 ec 04             	sub    $0x4,%esp
c002b175:	ff 75 0c             	pushl  0xc(%ebp)
c002b178:	50                   	push   %eax
c002b179:	ff 75 08             	pushl  0x8(%ebp)
c002b17c:	e8 8e 03 00 00       	call   c002b50f <find_elem>
c002b181:	83 c4 10             	add    $0x10,%esp
c002b184:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (found != NULL) 
c002b187:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b18b:	74 1f                	je     c002b1ac <hash_delete+0x51>
    {
      remove_elem (h, found);
c002b18d:	83 ec 08             	sub    $0x8,%esp
c002b190:	ff 75 f4             	pushl  -0xc(%ebp)
c002b193:	ff 75 08             	pushl  0x8(%ebp)
c002b196:	e8 08 06 00 00       	call   c002b7a3 <remove_elem>
c002b19b:	83 c4 10             	add    $0x10,%esp
      rehash (h); 
c002b19e:	83 ec 0c             	sub    $0xc,%esp
c002b1a1:	ff 75 08             	pushl  0x8(%ebp)
c002b1a4:	e8 33 04 00 00       	call   c002b5dc <rehash>
c002b1a9:	83 c4 10             	add    $0x10,%esp
    }
  return found;
c002b1ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b1af:	c9                   	leave  
c002b1b0:	c3                   	ret    

c002b1b1 <hash_apply>:
   any of the functions hash_clear(), hash_destroy(),
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done from ACTION or elsewhere. */
void
hash_apply (struct hash *h, hash_action_func *action) 
{
c002b1b1:	55                   	push   %ebp
c002b1b2:	89 e5                	mov    %esp,%ebp
c002b1b4:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  
  ASSERT (action != NULL);
c002b1b7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b1bb:	75 21                	jne    c002b1de <hash_apply+0x2d>
c002b1bd:	83 ec 0c             	sub    $0xc,%esp
c002b1c0:	68 80 12 03 c0       	push   $0xc0031280
c002b1c5:	68 8f 12 03 c0       	push   $0xc003128f
c002b1ca:	68 e8 12 03 c0       	push   $0xc00312e8
c002b1cf:	68 a7 00 00 00       	push   $0xa7
c002b1d4:	68 a6 12 03 c0       	push   $0xc00312a6
c002b1d9:	e8 9a e5 ff ff       	call   c0029778 <debug_panic>

  for (i = 0; i < h->bucket_cnt; i++) 
c002b1de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b1e5:	eb 6e                	jmp    c002b255 <hash_apply+0xa4>
    {
      struct list *bucket = &h->buckets[i];
c002b1e7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b1ea:	8b 40 08             	mov    0x8(%eax),%eax
c002b1ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b1f0:	c1 e2 04             	shl    $0x4,%edx
c002b1f3:	01 d0                	add    %edx,%eax
c002b1f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002b1f8:	83 ec 0c             	sub    $0xc,%esp
c002b1fb:	ff 75 ec             	pushl  -0x14(%ebp)
c002b1fe:	e8 3d e8 ff ff       	call   c0029a40 <list_begin>
c002b203:	83 c4 10             	add    $0x10,%esp
c002b206:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b209:	eb 33                	jmp    c002b23e <hash_apply+0x8d>
        {
          next = list_next (elem);
c002b20b:	83 ec 0c             	sub    $0xc,%esp
c002b20e:	ff 75 f0             	pushl  -0x10(%ebp)
c002b211:	e8 5c e8 ff ff       	call   c0029a72 <list_next>
c002b216:	83 c4 10             	add    $0x10,%esp
c002b219:	89 45 e8             	mov    %eax,-0x18(%ebp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002b21c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b21f:	8b 40 14             	mov    0x14(%eax),%eax
c002b222:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b225:	83 c2 04             	add    $0x4,%edx
c002b228:	83 ea 04             	sub    $0x4,%edx
c002b22b:	83 ec 08             	sub    $0x8,%esp
c002b22e:	50                   	push   %eax
c002b22f:	52                   	push   %edx
c002b230:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b233:	ff d0                	call   *%eax
c002b235:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
    {
      struct list *bucket = &h->buckets[i];
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002b238:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b23b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b23e:	83 ec 0c             	sub    $0xc,%esp
c002b241:	ff 75 ec             	pushl  -0x14(%ebp)
c002b244:	e8 73 e8 ff ff       	call   c0029abc <list_end>
c002b249:	83 c4 10             	add    $0x10,%esp
c002b24c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b24f:	75 ba                	jne    c002b20b <hash_apply+0x5a>
{
  size_t i;
  
  ASSERT (action != NULL);

  for (i = 0; i < h->bucket_cnt; i++) 
c002b251:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002b255:	8b 45 08             	mov    0x8(%ebp),%eax
c002b258:	8b 40 04             	mov    0x4(%eax),%eax
c002b25b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b25e:	77 87                	ja     c002b1e7 <hash_apply+0x36>
        {
          next = list_next (elem);
          action (list_elem_to_hash_elem (elem), h->aux);
        }
    }
}
c002b260:	90                   	nop
c002b261:	c9                   	leave  
c002b262:	c3                   	ret    

c002b263 <hash_first>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
void
hash_first (struct hash_iterator *i, struct hash *h) 
{
c002b263:	55                   	push   %ebp
c002b264:	89 e5                	mov    %esp,%ebp
c002b266:	83 ec 08             	sub    $0x8,%esp
  ASSERT (i != NULL);
c002b269:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b26d:	75 21                	jne    c002b290 <hash_first+0x2d>
c002b26f:	83 ec 0c             	sub    $0xc,%esp
c002b272:	68 be 12 03 c0       	push   $0xc00312be
c002b277:	68 8f 12 03 c0       	push   $0xc003128f
c002b27c:	68 f4 12 03 c0       	push   $0xc00312f4
c002b281:	68 ca 00 00 00       	push   $0xca
c002b286:	68 a6 12 03 c0       	push   $0xc00312a6
c002b28b:	e8 e8 e4 ff ff       	call   c0029778 <debug_panic>
  ASSERT (h != NULL);
c002b290:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b294:	75 21                	jne    c002b2b7 <hash_first+0x54>
c002b296:	83 ec 0c             	sub    $0xc,%esp
c002b299:	68 c8 12 03 c0       	push   $0xc00312c8
c002b29e:	68 8f 12 03 c0       	push   $0xc003128f
c002b2a3:	68 f4 12 03 c0       	push   $0xc00312f4
c002b2a8:	68 cb 00 00 00       	push   $0xcb
c002b2ad:	68 a6 12 03 c0       	push   $0xc00312a6
c002b2b2:	e8 c1 e4 ff ff       	call   c0029778 <debug_panic>

  i->hash = h;
c002b2b7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2ba:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b2bd:	89 10                	mov    %edx,(%eax)
  i->bucket = i->hash->buckets;
c002b2bf:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2c2:	8b 00                	mov    (%eax),%eax
c002b2c4:	8b 50 08             	mov    0x8(%eax),%edx
c002b2c7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2ca:	89 50 04             	mov    %edx,0x4(%eax)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002b2cd:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2d0:	8b 40 04             	mov    0x4(%eax),%eax
c002b2d3:	83 ec 0c             	sub    $0xc,%esp
c002b2d6:	50                   	push   %eax
c002b2d7:	e8 bf e8 ff ff       	call   c0029b9b <list_head>
c002b2dc:	83 c4 10             	add    $0x10,%esp
c002b2df:	83 c0 04             	add    $0x4,%eax
c002b2e2:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b2e5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2e8:	89 50 08             	mov    %edx,0x8(%eax)
}
c002b2eb:	90                   	nop
c002b2ec:	c9                   	leave  
c002b2ed:	c3                   	ret    

c002b2ee <hash_next>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
struct hash_elem *
hash_next (struct hash_iterator *i)
{
c002b2ee:	55                   	push   %ebp
c002b2ef:	89 e5                	mov    %esp,%ebp
c002b2f1:	53                   	push   %ebx
c002b2f2:	83 ec 04             	sub    $0x4,%esp
  ASSERT (i != NULL);
c002b2f5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b2f9:	75 21                	jne    c002b31c <hash_next+0x2e>
c002b2fb:	83 ec 0c             	sub    $0xc,%esp
c002b2fe:	68 be 12 03 c0       	push   $0xc00312be
c002b303:	68 8f 12 03 c0       	push   $0xc003128f
c002b308:	68 00 13 03 c0       	push   $0xc0031300
c002b30d:	68 dd 00 00 00       	push   $0xdd
c002b312:	68 a6 12 03 c0       	push   $0xc00312a6
c002b317:	e8 5c e4 ff ff       	call   c0029778 <debug_panic>

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002b31c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b31f:	8b 40 08             	mov    0x8(%eax),%eax
c002b322:	83 ec 0c             	sub    $0xc,%esp
c002b325:	50                   	push   %eax
c002b326:	e8 47 e7 ff ff       	call   c0029a72 <list_next>
c002b32b:	83 c4 10             	add    $0x10,%esp
c002b32e:	83 c0 04             	add    $0x4,%eax
c002b331:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b334:	8b 45 08             	mov    0x8(%ebp),%eax
c002b337:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b33a:	eb 58                	jmp    c002b394 <hash_next+0xa6>
    {
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002b33c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b33f:	8b 40 04             	mov    0x4(%eax),%eax
c002b342:	8d 50 10             	lea    0x10(%eax),%edx
c002b345:	8b 45 08             	mov    0x8(%ebp),%eax
c002b348:	89 50 04             	mov    %edx,0x4(%eax)
c002b34b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b34e:	8b 50 04             	mov    0x4(%eax),%edx
c002b351:	8b 45 08             	mov    0x8(%ebp),%eax
c002b354:	8b 00                	mov    (%eax),%eax
c002b356:	8b 48 08             	mov    0x8(%eax),%ecx
c002b359:	8b 45 08             	mov    0x8(%ebp),%eax
c002b35c:	8b 00                	mov    (%eax),%eax
c002b35e:	8b 40 04             	mov    0x4(%eax),%eax
c002b361:	c1 e0 04             	shl    $0x4,%eax
c002b364:	01 c8                	add    %ecx,%eax
c002b366:	39 c2                	cmp    %eax,%edx
c002b368:	72 0c                	jb     c002b376 <hash_next+0x88>
        {
          i->elem = NULL;
c002b36a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b36d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          break;
c002b374:	eb 40                	jmp    c002b3b6 <hash_next+0xc8>
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002b376:	8b 45 08             	mov    0x8(%ebp),%eax
c002b379:	8b 40 04             	mov    0x4(%eax),%eax
c002b37c:	83 ec 0c             	sub    $0xc,%esp
c002b37f:	50                   	push   %eax
c002b380:	e8 bb e6 ff ff       	call   c0029a40 <list_begin>
c002b385:	83 c4 10             	add    $0x10,%esp
c002b388:	83 c0 04             	add    $0x4,%eax
c002b38b:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b38e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b391:	89 50 08             	mov    %edx,0x8(%eax)
hash_next (struct hash_iterator *i)
{
  ASSERT (i != NULL);

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b394:	8b 45 08             	mov    0x8(%ebp),%eax
c002b397:	8b 58 08             	mov    0x8(%eax),%ebx
c002b39a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b39d:	8b 40 04             	mov    0x4(%eax),%eax
c002b3a0:	83 ec 0c             	sub    $0xc,%esp
c002b3a3:	50                   	push   %eax
c002b3a4:	e8 13 e7 ff ff       	call   c0029abc <list_end>
c002b3a9:	83 c4 10             	add    $0x10,%esp
c002b3ac:	83 c0 04             	add    $0x4,%eax
c002b3af:	83 e8 04             	sub    $0x4,%eax
c002b3b2:	39 c3                	cmp    %eax,%ebx
c002b3b4:	74 86                	je     c002b33c <hash_next+0x4e>
          break;
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
    }
  
  return i->elem;
c002b3b6:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3b9:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b3bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b3bf:	c9                   	leave  
c002b3c0:	c3                   	ret    

c002b3c1 <hash_cur>:
/* Returns the current element in the hash table iteration, or a
   null pointer at the end of the table.  Undefined behavior
   after calling hash_first() but before hash_next(). */
struct hash_elem *
hash_cur (struct hash_iterator *i) 
{
c002b3c1:	55                   	push   %ebp
c002b3c2:	89 e5                	mov    %esp,%ebp
  return i->elem;
c002b3c4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3c7:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b3ca:	5d                   	pop    %ebp
c002b3cb:	c3                   	ret    

c002b3cc <hash_size>:

/* Returns the number of elements in H. */
size_t
hash_size (struct hash *h) 
{
c002b3cc:	55                   	push   %ebp
c002b3cd:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt;
c002b3cf:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3d2:	8b 00                	mov    (%eax),%eax
}
c002b3d4:	5d                   	pop    %ebp
c002b3d5:	c3                   	ret    

c002b3d6 <hash_empty>:

/* Returns true if H contains no elements, false otherwise. */
bool
hash_empty (struct hash *h) 
{
c002b3d6:	55                   	push   %ebp
c002b3d7:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt == 0;
c002b3d9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3dc:	8b 00                	mov    (%eax),%eax
c002b3de:	85 c0                	test   %eax,%eax
c002b3e0:	0f 94 c0             	sete   %al
}
c002b3e3:	5d                   	pop    %ebp
c002b3e4:	c3                   	ret    

c002b3e5 <hash_bytes>:
#define FNV_32_BASIS 2166136261u

/* Returns a hash of the SIZE bytes in BUF. */
unsigned
hash_bytes (const void *buf_, size_t size)
{
c002b3e5:	55                   	push   %ebp
c002b3e6:	89 e5                	mov    %esp,%ebp
c002b3e8:	83 ec 18             	sub    $0x18,%esp
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
c002b3eb:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);
c002b3f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b3f5:	75 21                	jne    c002b418 <hash_bytes+0x33>
c002b3f7:	83 ec 0c             	sub    $0xc,%esp
c002b3fa:	68 d2 12 03 c0       	push   $0xc00312d2
c002b3ff:	68 8f 12 03 c0       	push   $0xc003128f
c002b404:	68 0c 13 03 c0       	push   $0xc003130c
c002b409:	68 10 01 00 00       	push   $0x110
c002b40e:	68 a6 12 03 c0       	push   $0xc00312a6
c002b413:	e8 60 e3 ff ff       	call   c0029778 <debug_panic>

  hash = FNV_32_BASIS;
c002b418:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (size-- > 0)
c002b41f:	eb 1d                	jmp    c002b43e <hash_bytes+0x59>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002b421:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b424:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002b42a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b42d:	8d 50 01             	lea    0x1(%eax),%edx
c002b430:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b433:	0f b6 00             	movzbl (%eax),%eax
c002b436:	0f b6 c0             	movzbl %al,%eax
c002b439:	31 c8                	xor    %ecx,%eax
c002b43b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);

  hash = FNV_32_BASIS;
  while (size-- > 0)
c002b43e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b441:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b444:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b447:	85 c0                	test   %eax,%eax
c002b449:	75 d6                	jne    c002b421 <hash_bytes+0x3c>
    hash = (hash * FNV_32_PRIME) ^ *buf++;

  return hash;
c002b44b:	8b 45 f0             	mov    -0x10(%ebp),%eax
} 
c002b44e:	c9                   	leave  
c002b44f:	c3                   	ret    

c002b450 <hash_string>:

/* Returns a hash of string S. */
unsigned
hash_string (const char *s_) 
{
c002b450:	55                   	push   %ebp
c002b451:	89 e5                	mov    %esp,%ebp
c002b453:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *s = (const unsigned char *) s_;
c002b456:	8b 45 08             	mov    0x8(%ebp),%eax
c002b459:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (s != NULL);
c002b45c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b460:	75 21                	jne    c002b483 <hash_string+0x33>
c002b462:	83 ec 0c             	sub    $0xc,%esp
c002b465:	68 de 12 03 c0       	push   $0xc00312de
c002b46a:	68 8f 12 03 c0       	push   $0xc003128f
c002b46f:	68 18 13 03 c0       	push   $0xc0031318
c002b474:	68 20 01 00 00       	push   $0x120
c002b479:	68 a6 12 03 c0       	push   $0xc00312a6
c002b47e:	e8 f5 e2 ff ff       	call   c0029778 <debug_panic>

  hash = FNV_32_BASIS;
c002b483:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (*s != '\0')
c002b48a:	eb 1d                	jmp    c002b4a9 <hash_string+0x59>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002b48c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b48f:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002b495:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b498:	8d 50 01             	lea    0x1(%eax),%edx
c002b49b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b49e:	0f b6 00             	movzbl (%eax),%eax
c002b4a1:	0f b6 c0             	movzbl %al,%eax
c002b4a4:	31 c8                	xor    %ecx,%eax
c002b4a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  unsigned hash;

  ASSERT (s != NULL);

  hash = FNV_32_BASIS;
  while (*s != '\0')
c002b4a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b4ac:	0f b6 00             	movzbl (%eax),%eax
c002b4af:	84 c0                	test   %al,%al
c002b4b1:	75 d9                	jne    c002b48c <hash_string+0x3c>
    hash = (hash * FNV_32_PRIME) ^ *s++;

  return hash;
c002b4b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b4b6:	c9                   	leave  
c002b4b7:	c3                   	ret    

c002b4b8 <hash_int>:

/* Returns a hash of integer I. */
unsigned
hash_int (int i) 
{
c002b4b8:	55                   	push   %ebp
c002b4b9:	89 e5                	mov    %esp,%ebp
c002b4bb:	83 ec 08             	sub    $0x8,%esp
  return hash_bytes (&i, sizeof i);
c002b4be:	83 ec 08             	sub    $0x8,%esp
c002b4c1:	6a 04                	push   $0x4
c002b4c3:	8d 45 08             	lea    0x8(%ebp),%eax
c002b4c6:	50                   	push   %eax
c002b4c7:	e8 19 ff ff ff       	call   c002b3e5 <hash_bytes>
c002b4cc:	83 c4 10             	add    $0x10,%esp
}
c002b4cf:	c9                   	leave  
c002b4d0:	c3                   	ret    

c002b4d1 <find_bucket>:

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002b4d1:	55                   	push   %ebp
c002b4d2:	89 e5                	mov    %esp,%ebp
c002b4d4:	83 ec 18             	sub    $0x18,%esp
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002b4d7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4da:	8b 40 0c             	mov    0xc(%eax),%eax
c002b4dd:	8b 55 08             	mov    0x8(%ebp),%edx
c002b4e0:	8b 52 14             	mov    0x14(%edx),%edx
c002b4e3:	83 ec 08             	sub    $0x8,%esp
c002b4e6:	52                   	push   %edx
c002b4e7:	ff 75 0c             	pushl  0xc(%ebp)
c002b4ea:	ff d0                	call   *%eax
c002b4ec:	83 c4 10             	add    $0x10,%esp
c002b4ef:	89 c2                	mov    %eax,%edx
c002b4f1:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4f4:	8b 40 04             	mov    0x4(%eax),%eax
c002b4f7:	83 e8 01             	sub    $0x1,%eax
c002b4fa:	21 d0                	and    %edx,%eax
c002b4fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return &h->buckets[bucket_idx];
c002b4ff:	8b 45 08             	mov    0x8(%ebp),%eax
c002b502:	8b 40 08             	mov    0x8(%eax),%eax
c002b505:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b508:	c1 e2 04             	shl    $0x4,%edx
c002b50b:	01 d0                	add    %edx,%eax
}
c002b50d:	c9                   	leave  
c002b50e:	c3                   	ret    

c002b50f <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b50f:	55                   	push   %ebp
c002b510:	89 e5                	mov    %esp,%ebp
c002b512:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b515:	83 ec 0c             	sub    $0xc,%esp
c002b518:	ff 75 0c             	pushl  0xc(%ebp)
c002b51b:	e8 20 e5 ff ff       	call   c0029a40 <list_begin>
c002b520:	83 c4 10             	add    $0x10,%esp
c002b523:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b526:	eb 66                	jmp    c002b58e <find_elem+0x7f>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
c002b528:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b52b:	83 c0 04             	add    $0x4,%eax
c002b52e:	83 e8 04             	sub    $0x4,%eax
c002b531:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002b534:	8b 45 08             	mov    0x8(%ebp),%eax
c002b537:	8b 40 10             	mov    0x10(%eax),%eax
c002b53a:	8b 55 08             	mov    0x8(%ebp),%edx
c002b53d:	8b 52 14             	mov    0x14(%edx),%edx
c002b540:	83 ec 04             	sub    $0x4,%esp
c002b543:	52                   	push   %edx
c002b544:	ff 75 10             	pushl  0x10(%ebp)
c002b547:	ff 75 f0             	pushl  -0x10(%ebp)
c002b54a:	ff d0                	call   *%eax
c002b54c:	83 c4 10             	add    $0x10,%esp
c002b54f:	83 f0 01             	xor    $0x1,%eax
c002b552:	84 c0                	test   %al,%al
c002b554:	74 27                	je     c002b57d <find_elem+0x6e>
c002b556:	8b 45 08             	mov    0x8(%ebp),%eax
c002b559:	8b 40 10             	mov    0x10(%eax),%eax
c002b55c:	8b 55 08             	mov    0x8(%ebp),%edx
c002b55f:	8b 52 14             	mov    0x14(%edx),%edx
c002b562:	83 ec 04             	sub    $0x4,%esp
c002b565:	52                   	push   %edx
c002b566:	ff 75 f0             	pushl  -0x10(%ebp)
c002b569:	ff 75 10             	pushl  0x10(%ebp)
c002b56c:	ff d0                	call   *%eax
c002b56e:	83 c4 10             	add    $0x10,%esp
c002b571:	83 f0 01             	xor    $0x1,%eax
c002b574:	84 c0                	test   %al,%al
c002b576:	74 05                	je     c002b57d <find_elem+0x6e>
        return hi; 
c002b578:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b57b:	eb 29                	jmp    c002b5a6 <find_elem+0x97>
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b57d:	83 ec 0c             	sub    $0xc,%esp
c002b580:	ff 75 f4             	pushl  -0xc(%ebp)
c002b583:	e8 ea e4 ff ff       	call   c0029a72 <list_next>
c002b588:	83 c4 10             	add    $0x10,%esp
c002b58b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b58e:	83 ec 0c             	sub    $0xc,%esp
c002b591:	ff 75 0c             	pushl  0xc(%ebp)
c002b594:	e8 23 e5 ff ff       	call   c0029abc <list_end>
c002b599:	83 c4 10             	add    $0x10,%esp
c002b59c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b59f:	75 87                	jne    c002b528 <find_elem+0x19>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
        return hi; 
    }
  return NULL;
c002b5a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b5a6:	c9                   	leave  
c002b5a7:	c3                   	ret    

c002b5a8 <turn_off_least_1bit>:

/* Returns X with its lowest-order bit set to 1 turned off. */
static inline size_t
turn_off_least_1bit (size_t x) 
{
c002b5a8:	55                   	push   %ebp
c002b5a9:	89 e5                	mov    %esp,%ebp
  return x & (x - 1);
c002b5ab:	8b 45 08             	mov    0x8(%ebp),%eax
c002b5ae:	83 e8 01             	sub    $0x1,%eax
c002b5b1:	23 45 08             	and    0x8(%ebp),%eax
}
c002b5b4:	5d                   	pop    %ebp
c002b5b5:	c3                   	ret    

c002b5b6 <is_power_of_2>:

/* Returns true if X is a power of 2, otherwise false. */
static inline size_t
is_power_of_2 (size_t x) 
{
c002b5b6:	55                   	push   %ebp
c002b5b7:	89 e5                	mov    %esp,%ebp
  return x != 0 && turn_off_least_1bit (x) == 0;
c002b5b9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b5bd:	74 16                	je     c002b5d5 <is_power_of_2+0x1f>
c002b5bf:	ff 75 08             	pushl  0x8(%ebp)
c002b5c2:	e8 e1 ff ff ff       	call   c002b5a8 <turn_off_least_1bit>
c002b5c7:	83 c4 04             	add    $0x4,%esp
c002b5ca:	85 c0                	test   %eax,%eax
c002b5cc:	75 07                	jne    c002b5d5 <is_power_of_2+0x1f>
c002b5ce:	b8 01 00 00 00       	mov    $0x1,%eax
c002b5d3:	eb 05                	jmp    c002b5da <is_power_of_2+0x24>
c002b5d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b5da:	c9                   	leave  
c002b5db:	c3                   	ret    

c002b5dc <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002b5dc:	55                   	push   %ebp
c002b5dd:	89 e5                	mov    %esp,%ebp
c002b5df:	83 ec 38             	sub    $0x38,%esp
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002b5e2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b5e6:	75 21                	jne    c002b609 <rehash+0x2d>
c002b5e8:	83 ec 0c             	sub    $0xc,%esp
c002b5eb:	68 c8 12 03 c0       	push   $0xc00312c8
c002b5f0:	68 8f 12 03 c0       	push   $0xc003128f
c002b5f5:	68 24 13 03 c0       	push   $0xc0031324
c002b5fa:	68 66 01 00 00       	push   $0x166
c002b5ff:	68 a6 12 03 c0       	push   $0xc00312a6
c002b604:	e8 6f e1 ff ff       	call   c0029778 <debug_panic>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
c002b609:	8b 45 08             	mov    0x8(%ebp),%eax
c002b60c:	8b 40 08             	mov    0x8(%eax),%eax
c002b60f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  old_bucket_cnt = h->bucket_cnt;
c002b612:	8b 45 08             	mov    0x8(%ebp),%eax
c002b615:	8b 40 04             	mov    0x4(%eax),%eax
c002b618:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002b61b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b61e:	8b 00                	mov    (%eax),%eax
c002b620:	d1 e8                	shr    %eax
c002b622:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (new_bucket_cnt < 4)
c002b625:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002b629:	77 1a                	ja     c002b645 <rehash+0x69>
    new_bucket_cnt = 4;
c002b62b:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002b632:	eb 11                	jmp    c002b645 <rehash+0x69>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);
c002b634:	83 ec 0c             	sub    $0xc,%esp
c002b637:	ff 75 f4             	pushl  -0xc(%ebp)
c002b63a:	e8 69 ff ff ff       	call   c002b5a8 <turn_off_least_1bit>
c002b63f:	83 c4 10             	add    $0x10,%esp
c002b642:	89 45 f4             	mov    %eax,-0xc(%ebp)
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c002b645:	83 ec 0c             	sub    $0xc,%esp
c002b648:	ff 75 f4             	pushl  -0xc(%ebp)
c002b64b:	e8 66 ff ff ff       	call   c002b5b6 <is_power_of_2>
c002b650:	83 c4 10             	add    $0x10,%esp
c002b653:	85 c0                	test   %eax,%eax
c002b655:	74 dd                	je     c002b634 <rehash+0x58>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002b657:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b65a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002b65d:	0f 84 12 01 00 00    	je     c002b775 <rehash+0x199>
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002b663:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b666:	c1 e0 04             	shl    $0x4,%eax
c002b669:	83 ec 0c             	sub    $0xc,%esp
c002b66c:	50                   	push   %eax
c002b66d:	e8 37 7f ff ff       	call   c00235a9 <malloc>
c002b672:	83 c4 10             	add    $0x10,%esp
c002b675:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (new_buckets == NULL) 
c002b678:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002b67c:	0f 84 f6 00 00 00    	je     c002b778 <rehash+0x19c>
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002b682:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002b689:	eb 1d                	jmp    c002b6a8 <rehash+0xcc>
    list_init (&new_buckets[i]);
c002b68b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b68e:	c1 e0 04             	shl    $0x4,%eax
c002b691:	89 c2                	mov    %eax,%edx
c002b693:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002b696:	01 d0                	add    %edx,%eax
c002b698:	83 ec 0c             	sub    $0xc,%esp
c002b69b:	50                   	push   %eax
c002b69c:	e8 4a e3 ff ff       	call   c00299eb <list_init>
c002b6a1:	83 c4 10             	add    $0x10,%esp
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002b6a4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002b6a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b6ab:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b6ae:	72 db                	jb     c002b68b <rehash+0xaf>
    list_init (&new_buckets[i]);

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002b6b0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b6b3:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002b6b6:	89 50 08             	mov    %edx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002b6b9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b6bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b6bf:	89 50 04             	mov    %edx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002b6c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002b6c9:	e9 8b 00 00 00       	jmp    c002b759 <rehash+0x17d>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002b6ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b6d1:	c1 e0 04             	shl    $0x4,%eax
c002b6d4:	89 c2                	mov    %eax,%edx
c002b6d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b6d9:	01 d0                	add    %edx,%eax
c002b6db:	89 45 dc             	mov    %eax,-0x24(%ebp)
      for (elem = list_begin (old_bucket);
c002b6de:	83 ec 0c             	sub    $0xc,%esp
c002b6e1:	ff 75 dc             	pushl  -0x24(%ebp)
c002b6e4:	e8 57 e3 ff ff       	call   c0029a40 <list_begin>
c002b6e9:	83 c4 10             	add    $0x10,%esp
c002b6ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002b6ef:	eb 51                	jmp    c002b742 <rehash+0x166>
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002b6f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b6f4:	83 c0 04             	add    $0x4,%eax
c002b6f7:	83 e8 04             	sub    $0x4,%eax

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
c002b6fa:	83 ec 08             	sub    $0x8,%esp
c002b6fd:	50                   	push   %eax
c002b6fe:	ff 75 08             	pushl  0x8(%ebp)
c002b701:	e8 cb fd ff ff       	call   c002b4d1 <find_bucket>
c002b706:	83 c4 10             	add    $0x10,%esp
c002b709:	89 45 d8             	mov    %eax,-0x28(%ebp)
            = find_bucket (h, list_elem_to_hash_elem (elem));
          next = list_next (elem);
c002b70c:	83 ec 0c             	sub    $0xc,%esp
c002b70f:	ff 75 ec             	pushl  -0x14(%ebp)
c002b712:	e8 5b e3 ff ff       	call   c0029a72 <list_next>
c002b717:	83 c4 10             	add    $0x10,%esp
c002b71a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          list_remove (elem);
c002b71d:	83 ec 0c             	sub    $0xc,%esp
c002b720:	ff 75 ec             	pushl  -0x14(%ebp)
c002b723:	e8 c9 e6 ff ff       	call   c0029df1 <list_remove>
c002b728:	83 c4 10             	add    $0x10,%esp
          list_push_front (new_bucket, elem);
c002b72b:	83 ec 08             	sub    $0x8,%esp
c002b72e:	ff 75 ec             	pushl  -0x14(%ebp)
c002b731:	ff 75 d8             	pushl  -0x28(%ebp)
c002b734:	e8 6c e6 ff ff       	call   c0029da5 <list_push_front>
c002b739:	83 c4 10             	add    $0x10,%esp
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
c002b73c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002b73f:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002b742:	83 ec 0c             	sub    $0xc,%esp
c002b745:	ff 75 dc             	pushl  -0x24(%ebp)
c002b748:	e8 6f e3 ff ff       	call   c0029abc <list_end>
c002b74d:	83 c4 10             	add    $0x10,%esp
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
c002b750:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002b753:	75 9c                	jne    c002b6f1 <rehash+0x115>
  /* Install new bucket info. */
  h->buckets = new_buckets;
  h->bucket_cnt = new_bucket_cnt;

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002b755:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002b759:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b75c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002b75f:	0f 82 69 ff ff ff    	jb     c002b6ce <rehash+0xf2>
          list_remove (elem);
          list_push_front (new_bucket, elem);
        }
    }

  free (old_buckets);
c002b765:	83 ec 0c             	sub    $0xc,%esp
c002b768:	ff 75 e8             	pushl  -0x18(%ebp)
c002b76b:	e8 32 81 ff ff       	call   c00238a2 <free>
c002b770:	83 c4 10             	add    $0x10,%esp
c002b773:	eb 04                	jmp    c002b779 <rehash+0x19d>
  while (!is_power_of_2 (new_bucket_cnt))
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
    return;
c002b775:	90                   	nop
c002b776:	eb 01                	jmp    c002b779 <rehash+0x19d>
  if (new_buckets == NULL) 
    {
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
c002b778:	90                   	nop
          list_push_front (new_bucket, elem);
        }
    }

  free (old_buckets);
}
c002b779:	c9                   	leave  
c002b77a:	c3                   	ret    

c002b77b <insert_elem>:

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b77b:	55                   	push   %ebp
c002b77c:	89 e5                	mov    %esp,%ebp
c002b77e:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt++;
c002b781:	8b 45 08             	mov    0x8(%ebp),%eax
c002b784:	8b 00                	mov    (%eax),%eax
c002b786:	8d 50 01             	lea    0x1(%eax),%edx
c002b789:	8b 45 08             	mov    0x8(%ebp),%eax
c002b78c:	89 10                	mov    %edx,(%eax)
  list_push_front (bucket, &e->list_elem);
c002b78e:	8b 45 10             	mov    0x10(%ebp),%eax
c002b791:	83 ec 08             	sub    $0x8,%esp
c002b794:	50                   	push   %eax
c002b795:	ff 75 0c             	pushl  0xc(%ebp)
c002b798:	e8 08 e6 ff ff       	call   c0029da5 <list_push_front>
c002b79d:	83 c4 10             	add    $0x10,%esp
}
c002b7a0:	90                   	nop
c002b7a1:	c9                   	leave  
c002b7a2:	c3                   	ret    

c002b7a3 <remove_elem>:

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
c002b7a3:	55                   	push   %ebp
c002b7a4:	89 e5                	mov    %esp,%ebp
c002b7a6:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt--;
c002b7a9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7ac:	8b 00                	mov    (%eax),%eax
c002b7ae:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b7b1:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7b4:	89 10                	mov    %edx,(%eax)
  list_remove (&e->list_elem);
c002b7b6:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b7b9:	83 ec 0c             	sub    $0xc,%esp
c002b7bc:	50                   	push   %eax
c002b7bd:	e8 2f e6 ff ff       	call   c0029df1 <list_remove>
c002b7c2:	83 c4 10             	add    $0x10,%esp
}
c002b7c5:	90                   	nop
c002b7c6:	c9                   	leave  
c002b7c7:	c3                   	ret    

c002b7c8 <console_init>:
static int64_t write_cnt;

/* Enable console locking. */
void
console_init (void) 
{
c002b7c8:	55                   	push   %ebp
c002b7c9:	89 e5                	mov    %esp,%ebp
c002b7cb:	83 ec 08             	sub    $0x8,%esp
  lock_init (&console_lock);
c002b7ce:	83 ec 0c             	sub    $0xc,%esp
c002b7d1:	68 28 9c 03 c0       	push   $0xc0039c28
c002b7d6:	e8 b8 73 ff ff       	call   c0022b93 <lock_init>
c002b7db:	83 c4 10             	add    $0x10,%esp
  use_console_lock = true;
c002b7de:	c6 05 40 9c 03 c0 01 	movb   $0x1,0xc0039c40
}
c002b7e5:	90                   	nop
c002b7e6:	c9                   	leave  
c002b7e7:	c3                   	ret    

c002b7e8 <console_panic>:
/* Notifies the console that a kernel panic is underway,
   which warns it to avoid trying to take the console lock from
   now on. */
void
console_panic (void) 
{
c002b7e8:	55                   	push   %ebp
c002b7e9:	89 e5                	mov    %esp,%ebp
  use_console_lock = false;
c002b7eb:	c6 05 40 9c 03 c0 00 	movb   $0x0,0xc0039c40
}
c002b7f2:	90                   	nop
c002b7f3:	5d                   	pop    %ebp
c002b7f4:	c3                   	ret    

c002b7f5 <console_print_stats>:

/* Prints console statistics. */
void
console_print_stats (void) 
{
c002b7f5:	55                   	push   %ebp
c002b7f6:	89 e5                	mov    %esp,%ebp
c002b7f8:	83 ec 08             	sub    $0x8,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c002b7fb:	a1 48 9c 03 c0       	mov    0xc0039c48,%eax
c002b800:	8b 15 4c 9c 03 c0    	mov    0xc0039c4c,%edx
c002b806:	83 ec 04             	sub    $0x4,%esp
c002b809:	52                   	push   %edx
c002b80a:	50                   	push   %eax
c002b80b:	68 2c 13 03 c0       	push   $0xc003132c
c002b810:	e8 30 bb ff ff       	call   c0027345 <printf>
c002b815:	83 c4 10             	add    $0x10,%esp
}
c002b818:	90                   	nop
c002b819:	c9                   	leave  
c002b81a:	c3                   	ret    

c002b81b <acquire_console>:

/* Acquires the console lock. */
static void
acquire_console (void) 
{
c002b81b:	55                   	push   %ebp
c002b81c:	89 e5                	mov    %esp,%ebp
c002b81e:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002b821:	e8 75 5f ff ff       	call   c002179b <intr_context>
c002b826:	83 f0 01             	xor    $0x1,%eax
c002b829:	84 c0                	test   %al,%al
c002b82b:	74 3e                	je     c002b86b <acquire_console+0x50>
c002b82d:	0f b6 05 40 9c 03 c0 	movzbl 0xc0039c40,%eax
c002b834:	84 c0                	test   %al,%al
c002b836:	74 33                	je     c002b86b <acquire_console+0x50>
    {
      if (lock_held_by_current_thread (&console_lock)) 
c002b838:	83 ec 0c             	sub    $0xc,%esp
c002b83b:	68 28 9c 03 c0       	push   $0xc0039c28
c002b840:	e8 5a 75 ff ff       	call   c0022d9f <lock_held_by_current_thread>
c002b845:	83 c4 10             	add    $0x10,%esp
c002b848:	84 c0                	test   %al,%al
c002b84a:	74 0f                	je     c002b85b <acquire_console+0x40>
        console_lock_depth++; 
c002b84c:	a1 44 9c 03 c0       	mov    0xc0039c44,%eax
c002b851:	83 c0 01             	add    $0x1,%eax
c002b854:	a3 44 9c 03 c0       	mov    %eax,0xc0039c44
      else
        lock_acquire (&console_lock); 
    }
}
c002b859:	eb 10                	jmp    c002b86b <acquire_console+0x50>
  if (!intr_context () && use_console_lock) 
    {
      if (lock_held_by_current_thread (&console_lock)) 
        console_lock_depth++; 
      else
        lock_acquire (&console_lock); 
c002b85b:	83 ec 0c             	sub    $0xc,%esp
c002b85e:	68 28 9c 03 c0       	push   $0xc0039c28
c002b863:	e8 78 73 ff ff       	call   c0022be0 <lock_acquire>
c002b868:	83 c4 10             	add    $0x10,%esp
    }
}
c002b86b:	90                   	nop
c002b86c:	c9                   	leave  
c002b86d:	c3                   	ret    

c002b86e <release_console>:

/* Releases the console lock. */
static void
release_console (void) 
{
c002b86e:	55                   	push   %ebp
c002b86f:	89 e5                	mov    %esp,%ebp
c002b871:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002b874:	e8 22 5f ff ff       	call   c002179b <intr_context>
c002b879:	83 f0 01             	xor    $0x1,%eax
c002b87c:	84 c0                	test   %al,%al
c002b87e:	74 33                	je     c002b8b3 <release_console+0x45>
c002b880:	0f b6 05 40 9c 03 c0 	movzbl 0xc0039c40,%eax
c002b887:	84 c0                	test   %al,%al
c002b889:	74 28                	je     c002b8b3 <release_console+0x45>
    {
      if (console_lock_depth > 0)
c002b88b:	a1 44 9c 03 c0       	mov    0xc0039c44,%eax
c002b890:	85 c0                	test   %eax,%eax
c002b892:	7e 0f                	jle    c002b8a3 <release_console+0x35>
        console_lock_depth--;
c002b894:	a1 44 9c 03 c0       	mov    0xc0039c44,%eax
c002b899:	83 e8 01             	sub    $0x1,%eax
c002b89c:	a3 44 9c 03 c0       	mov    %eax,0xc0039c44
      else
        lock_release (&console_lock); 
    }
}
c002b8a1:	eb 10                	jmp    c002b8b3 <release_console+0x45>
  if (!intr_context () && use_console_lock) 
    {
      if (console_lock_depth > 0)
        console_lock_depth--;
      else
        lock_release (&console_lock); 
c002b8a3:	83 ec 0c             	sub    $0xc,%esp
c002b8a6:	68 28 9c 03 c0       	push   $0xc0039c28
c002b8ab:	e8 71 74 ff ff       	call   c0022d21 <lock_release>
c002b8b0:	83 c4 10             	add    $0x10,%esp
    }
}
c002b8b3:	90                   	nop
c002b8b4:	c9                   	leave  
c002b8b5:	c3                   	ret    

c002b8b6 <console_locked_by_current_thread>:

/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
c002b8b6:	55                   	push   %ebp
c002b8b7:	89 e5                	mov    %esp,%ebp
c002b8b9:	83 ec 08             	sub    $0x8,%esp
  return (intr_context ()
c002b8bc:	e8 da 5e ff ff       	call   c002179b <intr_context>
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
c002b8c1:	84 c0                	test   %al,%al
c002b8c3:	75 22                	jne    c002b8e7 <console_locked_by_current_thread+0x31>
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
  return (intr_context ()
          || !use_console_lock
c002b8c5:	0f b6 05 40 9c 03 c0 	movzbl 0xc0039c40,%eax
c002b8cc:	83 f0 01             	xor    $0x1,%eax
c002b8cf:	84 c0                	test   %al,%al
c002b8d1:	75 14                	jne    c002b8e7 <console_locked_by_current_thread+0x31>
          || lock_held_by_current_thread (&console_lock));
c002b8d3:	83 ec 0c             	sub    $0xc,%esp
c002b8d6:	68 28 9c 03 c0       	push   $0xc0039c28
c002b8db:	e8 bf 74 ff ff       	call   c0022d9f <lock_held_by_current_thread>
c002b8e0:	83 c4 10             	add    $0x10,%esp
c002b8e3:	84 c0                	test   %al,%al
c002b8e5:	74 07                	je     c002b8ee <console_locked_by_current_thread+0x38>
c002b8e7:	b8 01 00 00 00       	mov    $0x1,%eax
c002b8ec:	eb 05                	jmp    c002b8f3 <console_locked_by_current_thread+0x3d>
c002b8ee:	b8 00 00 00 00       	mov    $0x0,%eax
/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
  return (intr_context ()
c002b8f3:	83 e0 01             	and    $0x1,%eax
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
}
c002b8f6:	c9                   	leave  
c002b8f7:	c3                   	ret    

c002b8f8 <vprintf>:
/* The standard vprintf() function,
   which is like printf() but uses a va_list.
   Writes its output to both vga display and serial port. */
int
vprintf (const char *format, va_list args) 
{
c002b8f8:	55                   	push   %ebp
c002b8f9:	89 e5                	mov    %esp,%ebp
c002b8fb:	83 ec 18             	sub    $0x18,%esp
  int char_cnt = 0;
c002b8fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  acquire_console ();
c002b905:	e8 11 ff ff ff       	call   c002b81b <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002b90a:	8d 45 f4             	lea    -0xc(%ebp),%eax
c002b90d:	50                   	push   %eax
c002b90e:	68 da b9 02 c0       	push   $0xc002b9da
c002b913:	ff 75 0c             	pushl  0xc(%ebp)
c002b916:	ff 75 08             	pushl  0x8(%ebp)
c002b919:	e8 4d ba ff ff       	call   c002736b <__vprintf>
c002b91e:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b921:	e8 48 ff ff ff       	call   c002b86e <release_console>

  return char_cnt;
c002b926:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b929:	c9                   	leave  
c002b92a:	c3                   	ret    

c002b92b <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
c002b92b:	55                   	push   %ebp
c002b92c:	89 e5                	mov    %esp,%ebp
c002b92e:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b931:	e8 e5 fe ff ff       	call   c002b81b <acquire_console>
  while (*s != '\0')
c002b936:	eb 1b                	jmp    c002b953 <puts+0x28>
    putchar_have_lock (*s++);
c002b938:	8b 45 08             	mov    0x8(%ebp),%eax
c002b93b:	8d 50 01             	lea    0x1(%eax),%edx
c002b93e:	89 55 08             	mov    %edx,0x8(%ebp)
c002b941:	0f b6 00             	movzbl (%eax),%eax
c002b944:	0f b6 c0             	movzbl %al,%eax
c002b947:	83 ec 0c             	sub    $0xc,%esp
c002b94a:	50                   	push   %eax
c002b94b:	e8 bf 00 00 00       	call   c002ba0f <putchar_have_lock>
c002b950:	83 c4 10             	add    $0x10,%esp
   character. */
int
puts (const char *s) 
{
  acquire_console ();
  while (*s != '\0')
c002b953:	8b 45 08             	mov    0x8(%ebp),%eax
c002b956:	0f b6 00             	movzbl (%eax),%eax
c002b959:	84 c0                	test   %al,%al
c002b95b:	75 db                	jne    c002b938 <puts+0xd>
    putchar_have_lock (*s++);
  putchar_have_lock ('\n');
c002b95d:	83 ec 0c             	sub    $0xc,%esp
c002b960:	6a 0a                	push   $0xa
c002b962:	e8 a8 00 00 00       	call   c002ba0f <putchar_have_lock>
c002b967:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b96a:	e8 ff fe ff ff       	call   c002b86e <release_console>

  return 0;
c002b96f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b974:	c9                   	leave  
c002b975:	c3                   	ret    

c002b976 <putbuf>:

/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
c002b976:	55                   	push   %ebp
c002b977:	89 e5                	mov    %esp,%ebp
c002b979:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b97c:	e8 9a fe ff ff       	call   c002b81b <acquire_console>
  while (n-- > 0)
c002b981:	eb 1b                	jmp    c002b99e <putbuf+0x28>
    putchar_have_lock (*buffer++);
c002b983:	8b 45 08             	mov    0x8(%ebp),%eax
c002b986:	8d 50 01             	lea    0x1(%eax),%edx
c002b989:	89 55 08             	mov    %edx,0x8(%ebp)
c002b98c:	0f b6 00             	movzbl (%eax),%eax
c002b98f:	0f b6 c0             	movzbl %al,%eax
c002b992:	83 ec 0c             	sub    $0xc,%esp
c002b995:	50                   	push   %eax
c002b996:	e8 74 00 00 00       	call   c002ba0f <putchar_have_lock>
c002b99b:	83 c4 10             	add    $0x10,%esp
/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
  acquire_console ();
  while (n-- > 0)
c002b99e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b9a1:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b9a4:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b9a7:	85 c0                	test   %eax,%eax
c002b9a9:	75 d8                	jne    c002b983 <putbuf+0xd>
    putchar_have_lock (*buffer++);
  release_console ();
c002b9ab:	e8 be fe ff ff       	call   c002b86e <release_console>
}
c002b9b0:	90                   	nop
c002b9b1:	c9                   	leave  
c002b9b2:	c3                   	ret    

c002b9b3 <putchar>:

/* Writes C to the vga display and serial port. */
int
putchar (int c) 
{
c002b9b3:	55                   	push   %ebp
c002b9b4:	89 e5                	mov    %esp,%ebp
c002b9b6:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b9b9:	e8 5d fe ff ff       	call   c002b81b <acquire_console>
  putchar_have_lock (c);
c002b9be:	8b 45 08             	mov    0x8(%ebp),%eax
c002b9c1:	0f b6 c0             	movzbl %al,%eax
c002b9c4:	83 ec 0c             	sub    $0xc,%esp
c002b9c7:	50                   	push   %eax
c002b9c8:	e8 42 00 00 00       	call   c002ba0f <putchar_have_lock>
c002b9cd:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b9d0:	e8 99 fe ff ff       	call   c002b86e <release_console>
  
  return c;
c002b9d5:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002b9d8:	c9                   	leave  
c002b9d9:	c3                   	ret    

c002b9da <vprintf_helper>:

/* Helper function for vprintf(). */
static void
vprintf_helper (char c, void *char_cnt_) 
{
c002b9da:	55                   	push   %ebp
c002b9db:	89 e5                	mov    %esp,%ebp
c002b9dd:	83 ec 28             	sub    $0x28,%esp
c002b9e0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b9e3:	88 45 e4             	mov    %al,-0x1c(%ebp)
  int *char_cnt = char_cnt_;
c002b9e6:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b9e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  (*char_cnt)++;
c002b9ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b9ef:	8b 00                	mov    (%eax),%eax
c002b9f1:	8d 50 01             	lea    0x1(%eax),%edx
c002b9f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b9f7:	89 10                	mov    %edx,(%eax)
  putchar_have_lock (c);
c002b9f9:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b9fd:	0f b6 c0             	movzbl %al,%eax
c002ba00:	83 ec 0c             	sub    $0xc,%esp
c002ba03:	50                   	push   %eax
c002ba04:	e8 06 00 00 00       	call   c002ba0f <putchar_have_lock>
c002ba09:	83 c4 10             	add    $0x10,%esp
}
c002ba0c:	90                   	nop
c002ba0d:	c9                   	leave  
c002ba0e:	c3                   	ret    

c002ba0f <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002ba0f:	55                   	push   %ebp
c002ba10:	89 e5                	mov    %esp,%ebp
c002ba12:	83 ec 18             	sub    $0x18,%esp
c002ba15:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba18:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (console_locked_by_current_thread ());
c002ba1b:	e8 96 fe ff ff       	call   c002b8b6 <console_locked_by_current_thread>
c002ba20:	84 c0                	test   %al,%al
c002ba22:	75 21                	jne    c002ba45 <putchar_have_lock+0x36>
c002ba24:	83 ec 0c             	sub    $0xc,%esp
c002ba27:	68 50 13 03 c0       	push   $0xc0031350
c002ba2c:	68 74 13 03 c0       	push   $0xc0031374
c002ba31:	68 a8 13 03 c0       	push   $0xc00313a8
c002ba36:	68 bb 00 00 00       	push   $0xbb
c002ba3b:	68 8b 13 03 c0       	push   $0xc003138b
c002ba40:	e8 33 dd ff ff       	call   c0029778 <debug_panic>
  write_cnt++;
c002ba45:	a1 48 9c 03 c0       	mov    0xc0039c48,%eax
c002ba4a:	8b 15 4c 9c 03 c0    	mov    0xc0039c4c,%edx
c002ba50:	83 c0 01             	add    $0x1,%eax
c002ba53:	83 d2 00             	adc    $0x0,%edx
c002ba56:	a3 48 9c 03 c0       	mov    %eax,0xc0039c48
c002ba5b:	89 15 4c 9c 03 c0    	mov    %edx,0xc0039c4c
  serial_putc (c);
c002ba61:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002ba65:	83 ec 0c             	sub    $0xc,%esp
c002ba68:	50                   	push   %eax
c002ba69:	e8 d9 90 ff ff       	call   c0024b47 <serial_putc>
c002ba6e:	83 c4 10             	add    $0x10,%esp
  vga_putc (c);
c002ba71:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002ba75:	83 ec 0c             	sub    $0xc,%esp
c002ba78:	50                   	push   %eax
c002ba79:	e8 5b 8c ff ff       	call   c00246d9 <vga_putc>
c002ba7e:	83 c4 10             	add    $0x10,%esp
}
c002ba81:	90                   	nop
c002ba82:	c9                   	leave  
c002ba83:	c3                   	ret    

c002ba84 <run_test>:
static const char *test_name;

/* Runs the test named NAME. */
void
run_test (const char *name) 
{
c002ba84:	55                   	push   %ebp
c002ba85:	89 e5                	mov    %esp,%ebp
c002ba87:	83 ec 18             	sub    $0x18,%esp
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002ba8a:	c7 45 f4 80 15 03 c0 	movl   $0xc0031580,-0xc(%ebp)
c002ba91:	eb 4e                	jmp    c002bae1 <run_test+0x5d>
    if (!strcmp (name, t->name))
c002ba93:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ba96:	8b 00                	mov    (%eax),%eax
c002ba98:	83 ec 08             	sub    $0x8,%esp
c002ba9b:	50                   	push   %eax
c002ba9c:	ff 75 08             	pushl  0x8(%ebp)
c002ba9f:	e8 ca cc ff ff       	call   c002876e <strcmp>
c002baa4:	83 c4 10             	add    $0x10,%esp
c002baa7:	85 c0                	test   %eax,%eax
c002baa9:	75 32                	jne    c002badd <run_test+0x59>
      {
        test_name = name;
c002baab:	8b 45 08             	mov    0x8(%ebp),%eax
c002baae:	a3 50 9c 03 c0       	mov    %eax,0xc0039c50
        msg ("begin");
c002bab3:	83 ec 0c             	sub    $0xc,%esp
c002bab6:	68 58 16 03 c0       	push   $0xc0031658
c002babb:	e8 49 00 00 00       	call   c002bb09 <msg>
c002bac0:	83 c4 10             	add    $0x10,%esp
        t->function ();
c002bac3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bac6:	8b 40 04             	mov    0x4(%eax),%eax
c002bac9:	ff d0                	call   *%eax
        msg ("end");
c002bacb:	83 ec 0c             	sub    $0xc,%esp
c002bace:	68 5e 16 03 c0       	push   $0xc003165e
c002bad3:	e8 31 00 00 00       	call   c002bb09 <msg>
c002bad8:	83 c4 10             	add    $0x10,%esp
        return;
c002badb:	eb 2a                	jmp    c002bb07 <run_test+0x83>
void
run_test (const char *name) 
{
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002badd:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
c002bae1:	b8 58 16 03 c0       	mov    $0xc0031658,%eax
c002bae6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002bae9:	72 a8                	jb     c002ba93 <run_test+0xf>
        msg ("begin");
        t->function ();
        msg ("end");
        return;
      }
  PANIC ("no test named \"%s\"", name);
c002baeb:	83 ec 0c             	sub    $0xc,%esp
c002baee:	ff 75 08             	pushl  0x8(%ebp)
c002baf1:	68 62 16 03 c0       	push   $0xc0031662
c002baf6:	68 bc 16 03 c0       	push   $0xc00316bc
c002bafb:	6a 3c                	push   $0x3c
c002bafd:	68 75 16 03 c0       	push   $0xc0031675
c002bb02:	e8 71 dc ff ff       	call   c0029778 <debug_panic>
}
c002bb07:	c9                   	leave  
c002bb08:	c3                   	ret    

c002bb09 <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c002bb09:	55                   	push   %ebp
c002bb0a:	89 e5                	mov    %esp,%ebp
c002bb0c:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) ", test_name);
c002bb0f:	a1 50 9c 03 c0       	mov    0xc0039c50,%eax
c002bb14:	83 ec 08             	sub    $0x8,%esp
c002bb17:	50                   	push   %eax
c002bb18:	68 91 16 03 c0       	push   $0xc0031691
c002bb1d:	e8 23 b8 ff ff       	call   c0027345 <printf>
c002bb22:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002bb25:	8d 45 0c             	lea    0xc(%ebp),%eax
c002bb28:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002bb2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bb2e:	83 ec 08             	sub    $0x8,%esp
c002bb31:	50                   	push   %eax
c002bb32:	ff 75 08             	pushl  0x8(%ebp)
c002bb35:	e8 be fd ff ff       	call   c002b8f8 <vprintf>
c002bb3a:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002bb3d:	83 ec 0c             	sub    $0xc,%esp
c002bb40:	6a 0a                	push   $0xa
c002bb42:	e8 6c fe ff ff       	call   c002b9b3 <putchar>
c002bb47:	83 c4 10             	add    $0x10,%esp
}
c002bb4a:	90                   	nop
c002bb4b:	c9                   	leave  
c002bb4c:	c3                   	ret    

c002bb4d <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c002bb4d:	55                   	push   %ebp
c002bb4e:	89 e5                	mov    %esp,%ebp
c002bb50:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c002bb53:	a1 50 9c 03 c0       	mov    0xc0039c50,%eax
c002bb58:	83 ec 08             	sub    $0x8,%esp
c002bb5b:	50                   	push   %eax
c002bb5c:	68 97 16 03 c0       	push   $0xc0031697
c002bb61:	e8 df b7 ff ff       	call   c0027345 <printf>
c002bb66:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002bb69:	8d 45 0c             	lea    0xc(%ebp),%eax
c002bb6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002bb6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bb72:	83 ec 08             	sub    $0x8,%esp
c002bb75:	50                   	push   %eax
c002bb76:	ff 75 08             	pushl  0x8(%ebp)
c002bb79:	e8 7a fd ff ff       	call   c002b8f8 <vprintf>
c002bb7e:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002bb81:	83 ec 0c             	sub    $0xc,%esp
c002bb84:	6a 0a                	push   $0xa
c002bb86:	e8 28 fe ff ff       	call   c002b9b3 <putchar>
c002bb8b:	83 c4 10             	add    $0x10,%esp

  PANIC ("test failed");
c002bb8e:	68 a3 16 03 c0       	push   $0xc00316a3
c002bb93:	68 c8 16 03 c0       	push   $0xc00316c8
c002bb98:	6a 5d                	push   $0x5d
c002bb9a:	68 75 16 03 c0       	push   $0xc0031675
c002bb9f:	e8 d4 db ff ff       	call   c0029778 <debug_panic>

c002bba4 <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c002bba4:	55                   	push   %ebp
c002bba5:	89 e5                	mov    %esp,%ebp
c002bba7:	83 ec 08             	sub    $0x8,%esp
  printf ("(%s) PASS\n", test_name);
c002bbaa:	a1 50 9c 03 c0       	mov    0xc0039c50,%eax
c002bbaf:	83 ec 08             	sub    $0x8,%esp
c002bbb2:	50                   	push   %eax
c002bbb3:	68 af 16 03 c0       	push   $0xc00316af
c002bbb8:	e8 88 b7 ff ff       	call   c0027345 <printf>
c002bbbd:	83 c4 10             	add    $0x10,%esp
}
c002bbc0:	90                   	nop
c002bbc1:	c9                   	leave  
c002bbc2:	c3                   	ret    

c002bbc3 <test_alarm_single>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_single (void) 
{
c002bbc3:	55                   	push   %ebp
c002bbc4:	89 e5                	mov    %esp,%ebp
c002bbc6:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 1);
c002bbc9:	83 ec 08             	sub    $0x8,%esp
c002bbcc:	6a 01                	push   $0x1
c002bbce:	6a 05                	push   $0x5
c002bbd0:	e8 1e 00 00 00       	call   c002bbf3 <test_sleep>
c002bbd5:	83 c4 10             	add    $0x10,%esp
}
c002bbd8:	90                   	nop
c002bbd9:	c9                   	leave  
c002bbda:	c3                   	ret    

c002bbdb <test_alarm_multiple>:

void
test_alarm_multiple (void) 
{
c002bbdb:	55                   	push   %ebp
c002bbdc:	89 e5                	mov    %esp,%ebp
c002bbde:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 7);
c002bbe1:	83 ec 08             	sub    $0x8,%esp
c002bbe4:	6a 07                	push   $0x7
c002bbe6:	6a 05                	push   $0x5
c002bbe8:	e8 06 00 00 00       	call   c002bbf3 <test_sleep>
c002bbed:	83 c4 10             	add    $0x10,%esp
}
c002bbf0:	90                   	nop
c002bbf1:	c9                   	leave  
c002bbf2:	c3                   	ret    

c002bbf3 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002bbf3:	55                   	push   %ebp
c002bbf4:	89 e5                	mov    %esp,%ebp
c002bbf6:	83 ec 68             	sub    $0x68,%esp
  int *output, *op;
  int product;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002bbf9:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002bc00:	83 f0 01             	xor    $0x1,%eax
c002bc03:	84 c0                	test   %al,%al
c002bc05:	75 1e                	jne    c002bc25 <test_sleep+0x32>
c002bc07:	83 ec 0c             	sub    $0xc,%esp
c002bc0a:	68 d0 16 03 c0       	push   $0xc00316d0
c002bc0f:	68 de 16 03 c0       	push   $0xc00316de
c002bc14:	68 e4 18 03 c0       	push   $0xc00318e4
c002bc19:	6a 3c                	push   $0x3c
c002bc1b:	68 f8 16 03 c0       	push   $0xc00316f8
c002bc20:	e8 53 db ff ff       	call   c0029778 <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002bc25:	83 ec 04             	sub    $0x4,%esp
c002bc28:	ff 75 0c             	pushl  0xc(%ebp)
c002bc2b:	ff 75 08             	pushl  0x8(%ebp)
c002bc2e:	68 1c 17 03 c0       	push   $0xc003171c
c002bc33:	e8 d1 fe ff ff       	call   c002bb09 <msg>
c002bc38:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 0 sleeps 10 ticks each time,");
c002bc3b:	83 ec 0c             	sub    $0xc,%esp
c002bc3e:	68 48 17 03 c0       	push   $0xc0031748
c002bc43:	e8 c1 fe ff ff       	call   c002bb09 <msg>
c002bc48:	83 c4 10             	add    $0x10,%esp
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c002bc4b:	83 ec 0c             	sub    $0xc,%esp
c002bc4e:	68 6c 17 03 c0       	push   $0xc003176c
c002bc53:	e8 b1 fe ff ff       	call   c002bb09 <msg>
c002bc58:	83 c4 10             	add    $0x10,%esp
  msg ("If successful, product of iteration count and");
c002bc5b:	83 ec 0c             	sub    $0xc,%esp
c002bc5e:	68 9c 17 03 c0       	push   $0xc003179c
c002bc63:	e8 a1 fe ff ff       	call   c002bb09 <msg>
c002bc68:	83 c4 10             	add    $0x10,%esp
  msg ("sleep duration will appear in nondescending order.");
c002bc6b:	83 ec 0c             	sub    $0xc,%esp
c002bc6e:	68 cc 17 03 c0       	push   $0xc00317cc
c002bc73:	e8 91 fe ff ff       	call   c002bb09 <msg>
c002bc78:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  threads = malloc (sizeof *threads * thread_cnt);
c002bc7b:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc7e:	c1 e0 04             	shl    $0x4,%eax
c002bc81:	83 ec 0c             	sub    $0xc,%esp
c002bc84:	50                   	push   %eax
c002bc85:	e8 1f 79 ff ff       	call   c00235a9 <malloc>
c002bc8a:	83 c4 10             	add    $0x10,%esp
c002bc8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002bc90:	8b 55 0c             	mov    0xc(%ebp),%edx
c002bc93:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc96:	0f af c2             	imul   %edx,%eax
c002bc99:	c1 e0 03             	shl    $0x3,%eax
c002bc9c:	83 ec 0c             	sub    $0xc,%esp
c002bc9f:	50                   	push   %eax
c002bca0:	e8 04 79 ff ff       	call   c00235a9 <malloc>
c002bca5:	83 c4 10             	add    $0x10,%esp
c002bca8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (threads == NULL || output == NULL)
c002bcab:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002bcaf:	74 06                	je     c002bcb7 <test_sleep+0xc4>
c002bcb1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002bcb5:	75 16                	jne    c002bccd <test_sleep+0xda>
    PANIC ("couldn't allocate memory for test");
c002bcb7:	68 00 18 03 c0       	push   $0xc0031800
c002bcbc:	68 e4 18 03 c0       	push   $0xc00318e4
c002bcc1:	6a 48                	push   $0x48
c002bcc3:	68 f8 16 03 c0       	push   $0xc00316f8
c002bcc8:	e8 ab da ff ff       	call   c0029778 <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002bccd:	e8 1c 81 ff ff       	call   c0023dee <timer_ticks>
c002bcd2:	83 c0 64             	add    $0x64,%eax
c002bcd5:	83 d2 00             	adc    $0x0,%edx
c002bcd8:	89 45 b0             	mov    %eax,-0x50(%ebp)
c002bcdb:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  test.iterations = iterations;
c002bcde:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bce1:	89 45 b8             	mov    %eax,-0x48(%ebp)
  lock_init (&test.output_lock);
c002bce4:	83 ec 0c             	sub    $0xc,%esp
c002bce7:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002bcea:	83 c0 0c             	add    $0xc,%eax
c002bced:	50                   	push   %eax
c002bcee:	e8 a0 6e ff ff       	call   c0022b93 <lock_init>
c002bcf3:	83 c4 10             	add    $0x10,%esp
  test.output_pos = output;
c002bcf6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002bcf9:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002bcfc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002bd00:	75 1e                	jne    c002bd20 <test_sleep+0x12d>
c002bd02:	83 ec 0c             	sub    $0xc,%esp
c002bd05:	68 22 18 03 c0       	push   $0xc0031822
c002bd0a:	68 de 16 03 c0       	push   $0xc00316de
c002bd0f:	68 e4 18 03 c0       	push   $0xc00318e4
c002bd14:	6a 51                	push   $0x51
c002bd16:	68 f8 16 03 c0       	push   $0xc00316f8
c002bd1b:	e8 58 da ff ff       	call   c0029778 <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002bd20:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002bd27:	eb 72                	jmp    c002bd9b <test_sleep+0x1a8>
    {
      struct sleep_thread *t = threads + i;
c002bd29:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd2c:	c1 e0 04             	shl    $0x4,%eax
c002bd2f:	89 c2                	mov    %eax,%edx
c002bd31:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bd34:	01 d0                	add    %edx,%eax
c002bd36:	89 45 e0             	mov    %eax,-0x20(%ebp)
      char name[16];
      
      t->test = &test;
c002bd39:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bd3c:	8d 55 b0             	lea    -0x50(%ebp),%edx
c002bd3f:	89 10                	mov    %edx,(%eax)
      t->id = i;
c002bd41:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bd44:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002bd47:	89 50 04             	mov    %edx,0x4(%eax)
      t->duration = (i + 1) * 10;
c002bd4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd4d:	8d 50 01             	lea    0x1(%eax),%edx
c002bd50:	89 d0                	mov    %edx,%eax
c002bd52:	c1 e0 02             	shl    $0x2,%eax
c002bd55:	01 d0                	add    %edx,%eax
c002bd57:	01 c0                	add    %eax,%eax
c002bd59:	89 c2                	mov    %eax,%edx
c002bd5b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bd5e:	89 50 08             	mov    %edx,0x8(%eax)
      t->iterations = 0;
c002bd61:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bd64:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

      snprintf (name, sizeof name, "thread %d", i);
c002bd6b:	ff 75 ec             	pushl  -0x14(%ebp)
c002bd6e:	68 31 18 03 c0       	push   $0xc0031831
c002bd73:	6a 10                	push   $0x10
c002bd75:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bd78:	50                   	push   %eax
c002bd79:	e8 9e b5 ff ff       	call   c002731c <snprintf>
c002bd7e:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, t);
c002bd81:	ff 75 e0             	pushl  -0x20(%ebp)
c002bd84:	68 31 bf 02 c0       	push   $0xc002bf31
c002bd89:	6a 1f                	push   $0x1f
c002bd8b:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bd8e:	50                   	push   %eax
c002bd8f:	e8 f2 4d ff ff       	call   c0020b86 <thread_create>
c002bd94:	83 c4 10             	add    $0x10,%esp
  lock_init (&test.output_lock);
  test.output_pos = output;

  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
c002bd97:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002bd9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd9e:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bda1:	7c 86                	jl     c002bd29 <test_sleep+0x136>
      snprintf (name, sizeof name, "thread %d", i);
      thread_create (name, PRI_DEFAULT, sleeper, t);
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002bda3:	8b 45 08             	mov    0x8(%ebp),%eax
c002bda6:	0f af 45 0c          	imul   0xc(%ebp),%eax
c002bdaa:	89 c2                	mov    %eax,%edx
c002bdac:	89 d0                	mov    %edx,%eax
c002bdae:	c1 e0 02             	shl    $0x2,%eax
c002bdb1:	01 d0                	add    %edx,%eax
c002bdb3:	01 c0                	add    %eax,%eax
c002bdb5:	05 c8 00 00 00       	add    $0xc8,%eax
c002bdba:	99                   	cltd   
c002bdbb:	83 ec 08             	sub    $0x8,%esp
c002bdbe:	52                   	push   %edx
c002bdbf:	50                   	push   %eax
c002bdc0:	e8 7d 80 ff ff       	call   c0023e42 <timer_sleep>
c002bdc5:	83 c4 10             	add    $0x10,%esp

  /* Acquire the output lock in case some rogue thread is still
     running. */
  lock_acquire (&test.output_lock);
c002bdc8:	83 ec 0c             	sub    $0xc,%esp
c002bdcb:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002bdce:	83 c0 0c             	add    $0xc,%eax
c002bdd1:	50                   	push   %eax
c002bdd2:	e8 09 6e ff ff       	call   c0022be0 <lock_acquire>
c002bdd7:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  product = 0;
c002bdda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (op = output; op < test.output_pos; op++) 
c002bde1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002bde4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002bde7:	e9 ba 00 00 00       	jmp    c002bea6 <test_sleep+0x2b3>
    {
      struct sleep_thread *t;
      int new_prod;

      ASSERT (*op >= 0 && *op < thread_cnt);
c002bdec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bdef:	8b 00                	mov    (%eax),%eax
c002bdf1:	85 c0                	test   %eax,%eax
c002bdf3:	78 0a                	js     c002bdff <test_sleep+0x20c>
c002bdf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bdf8:	8b 00                	mov    (%eax),%eax
c002bdfa:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bdfd:	7c 1e                	jl     c002be1d <test_sleep+0x22a>
c002bdff:	83 ec 0c             	sub    $0xc,%esp
c002be02:	68 3b 18 03 c0       	push   $0xc003183b
c002be07:	68 de 16 03 c0       	push   $0xc00316de
c002be0c:	68 e4 18 03 c0       	push   $0xc00318e4
c002be11:	6a 6e                	push   $0x6e
c002be13:	68 f8 16 03 c0       	push   $0xc00316f8
c002be18:	e8 5b d9 ff ff       	call   c0029778 <debug_panic>
      t = threads + *op;
c002be1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002be20:	8b 00                	mov    (%eax),%eax
c002be22:	c1 e0 04             	shl    $0x4,%eax
c002be25:	89 c2                	mov    %eax,%edx
c002be27:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002be2a:	01 d0                	add    %edx,%eax
c002be2c:	89 45 dc             	mov    %eax,-0x24(%ebp)

      new_prod = ++t->iterations * t->duration;
c002be2f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002be32:	8b 40 0c             	mov    0xc(%eax),%eax
c002be35:	8d 50 01             	lea    0x1(%eax),%edx
c002be38:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002be3b:	89 50 0c             	mov    %edx,0xc(%eax)
c002be3e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002be41:	8b 50 0c             	mov    0xc(%eax),%edx
c002be44:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002be47:	8b 40 08             	mov    0x8(%eax),%eax
c002be4a:	0f af c2             	imul   %edx,%eax
c002be4d:	89 45 d8             	mov    %eax,-0x28(%ebp)
        
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002be50:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002be53:	8b 48 0c             	mov    0xc(%eax),%ecx
c002be56:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002be59:	8b 50 08             	mov    0x8(%eax),%edx
c002be5c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002be5f:	8b 40 04             	mov    0x4(%eax),%eax
c002be62:	83 ec 0c             	sub    $0xc,%esp
c002be65:	ff 75 d8             	pushl  -0x28(%ebp)
c002be68:	51                   	push   %ecx
c002be69:	52                   	push   %edx
c002be6a:	50                   	push   %eax
c002be6b:	68 58 18 03 c0       	push   $0xc0031858
c002be70:	e8 94 fc ff ff       	call   c002bb09 <msg>
c002be75:	83 c4 20             	add    $0x20,%esp
           t->id, t->duration, t->iterations, new_prod);
      
      if (new_prod >= product)
c002be78:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002be7b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002be7e:	7c 08                	jl     c002be88 <test_sleep+0x295>
        product = new_prod;
c002be80:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002be83:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002be86:	eb 1a                	jmp    c002bea2 <test_sleep+0x2af>
      else
        fail ("thread %d woke up out of order (%d > %d)!",
c002be88:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002be8b:	8b 40 04             	mov    0x4(%eax),%eax
c002be8e:	ff 75 d8             	pushl  -0x28(%ebp)
c002be91:	ff 75 f0             	pushl  -0x10(%ebp)
c002be94:	50                   	push   %eax
c002be95:	68 8c 18 03 c0       	push   $0xc003188c
c002be9a:	e8 ae fc ff ff       	call   c002bb4d <fail>
c002be9f:	83 c4 10             	add    $0x10,%esp
     running. */
  lock_acquire (&test.output_lock);

  /* Print completion order. */
  product = 0;
  for (op = output; op < test.output_pos; op++) 
c002bea2:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002bea6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002bea9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002beac:	0f 87 3a ff ff ff    	ja     c002bdec <test_sleep+0x1f9>
        fail ("thread %d woke up out of order (%d > %d)!",
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c002beb2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002beb9:	eb 3d                	jmp    c002bef8 <test_sleep+0x305>
    if (threads[i].iterations != iterations)
c002bebb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bebe:	c1 e0 04             	shl    $0x4,%eax
c002bec1:	89 c2                	mov    %eax,%edx
c002bec3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bec6:	01 d0                	add    %edx,%eax
c002bec8:	8b 40 0c             	mov    0xc(%eax),%eax
c002becb:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002bece:	74 24                	je     c002bef4 <test_sleep+0x301>
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
c002bed0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bed3:	c1 e0 04             	shl    $0x4,%eax
c002bed6:	89 c2                	mov    %eax,%edx
c002bed8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bedb:	01 d0                	add    %edx,%eax
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
    if (threads[i].iterations != iterations)
      fail ("thread %d woke up %d times instead of %d",
c002bedd:	8b 40 0c             	mov    0xc(%eax),%eax
c002bee0:	ff 75 0c             	pushl  0xc(%ebp)
c002bee3:	50                   	push   %eax
c002bee4:	ff 75 ec             	pushl  -0x14(%ebp)
c002bee7:	68 b8 18 03 c0       	push   $0xc00318b8
c002beec:	e8 5c fc ff ff       	call   c002bb4d <fail>
c002bef1:	83 c4 10             	add    $0x10,%esp
        fail ("thread %d woke up out of order (%d > %d)!",
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c002bef4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002bef8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002befb:	3b 45 08             	cmp    0x8(%ebp),%eax
c002befe:	7c bb                	jl     c002bebb <test_sleep+0x2c8>
    if (threads[i].iterations != iterations)
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
  
  lock_release (&test.output_lock);
c002bf00:	83 ec 0c             	sub    $0xc,%esp
c002bf03:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002bf06:	83 c0 0c             	add    $0xc,%eax
c002bf09:	50                   	push   %eax
c002bf0a:	e8 12 6e ff ff       	call   c0022d21 <lock_release>
c002bf0f:	83 c4 10             	add    $0x10,%esp
  free (output);
c002bf12:	83 ec 0c             	sub    $0xc,%esp
c002bf15:	ff 75 e4             	pushl  -0x1c(%ebp)
c002bf18:	e8 85 79 ff ff       	call   c00238a2 <free>
c002bf1d:	83 c4 10             	add    $0x10,%esp
  free (threads);
c002bf20:	83 ec 0c             	sub    $0xc,%esp
c002bf23:	ff 75 e8             	pushl  -0x18(%ebp)
c002bf26:	e8 77 79 ff ff       	call   c00238a2 <free>
c002bf2b:	83 c4 10             	add    $0x10,%esp
}
c002bf2e:	90                   	nop
c002bf2f:	c9                   	leave  
c002bf30:	c3                   	ret    

c002bf31 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c002bf31:	55                   	push   %ebp
c002bf32:	89 e5                	mov    %esp,%ebp
c002bf34:	53                   	push   %ebx
c002bf35:	83 ec 24             	sub    $0x24,%esp
  struct sleep_thread *t = t_;
c002bf38:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct sleep_test *test = t->test;
c002bf3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf41:	8b 00                	mov    (%eax),%eax
c002bf43:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002bf46:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002bf4d:	eb 7c                	jmp    c002bfcb <sleeper+0x9a>
    {
      int64_t sleep_until = test->start + i * t->duration;
c002bf4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bf52:	8b 08                	mov    (%eax),%ecx
c002bf54:	8b 58 04             	mov    0x4(%eax),%ebx
c002bf57:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf5a:	8b 40 08             	mov    0x8(%eax),%eax
c002bf5d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
c002bf61:	99                   	cltd   
c002bf62:	01 c8                	add    %ecx,%eax
c002bf64:	11 da                	adc    %ebx,%edx
c002bf66:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002bf69:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002bf6c:	e8 7d 7e ff ff       	call   c0023dee <timer_ticks>
c002bf71:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002bf74:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002bf77:	29 c1                	sub    %eax,%ecx
c002bf79:	19 d3                	sbb    %edx,%ebx
c002bf7b:	89 c8                	mov    %ecx,%eax
c002bf7d:	89 da                	mov    %ebx,%edx
c002bf7f:	83 ec 08             	sub    $0x8,%esp
c002bf82:	52                   	push   %edx
c002bf83:	50                   	push   %eax
c002bf84:	e8 b9 7e ff ff       	call   c0023e42 <timer_sleep>
c002bf89:	83 c4 10             	add    $0x10,%esp
      lock_acquire (&test->output_lock);
c002bf8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bf8f:	83 c0 0c             	add    $0xc,%eax
c002bf92:	83 ec 0c             	sub    $0xc,%esp
c002bf95:	50                   	push   %eax
c002bf96:	e8 45 6c ff ff       	call   c0022be0 <lock_acquire>
c002bf9b:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = t->id;
c002bf9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bfa1:	8b 40 24             	mov    0x24(%eax),%eax
c002bfa4:	8d 48 04             	lea    0x4(%eax),%ecx
c002bfa7:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002bfaa:	89 4a 24             	mov    %ecx,0x24(%edx)
c002bfad:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002bfb0:	8b 52 04             	mov    0x4(%edx),%edx
c002bfb3:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c002bfb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bfb8:	83 c0 0c             	add    $0xc,%eax
c002bfbb:	83 ec 0c             	sub    $0xc,%esp
c002bfbe:	50                   	push   %eax
c002bfbf:	e8 5d 6d ff ff       	call   c0022d21 <lock_release>
c002bfc4:	83 c4 10             	add    $0x10,%esp
{
  struct sleep_thread *t = t_;
  struct sleep_test *test = t->test;
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002bfc7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002bfcb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bfce:	8b 40 08             	mov    0x8(%eax),%eax
c002bfd1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002bfd4:	0f 8d 75 ff ff ff    	jge    c002bf4f <sleeper+0x1e>
      timer_sleep (sleep_until - timer_ticks ());
      lock_acquire (&test->output_lock);
      *test->output_pos++ = t->id;
      lock_release (&test->output_lock);
    }
}
c002bfda:	90                   	nop
c002bfdb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bfde:	c9                   	leave  
c002bfdf:	c3                   	ret    

c002bfe0 <test_alarm_simultaneous>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_simultaneous (void) 
{
c002bfe0:	55                   	push   %ebp
c002bfe1:	89 e5                	mov    %esp,%ebp
c002bfe3:	83 ec 08             	sub    $0x8,%esp
  test_sleep (3, 5);
c002bfe6:	83 ec 08             	sub    $0x8,%esp
c002bfe9:	6a 05                	push   $0x5
c002bfeb:	6a 03                	push   $0x3
c002bfed:	e8 06 00 00 00       	call   c002bff8 <test_sleep>
c002bff2:	83 c4 10             	add    $0x10,%esp
}
c002bff5:	90                   	nop
c002bff6:	c9                   	leave  
c002bff7:	c3                   	ret    

c002bff8 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002bff8:	55                   	push   %ebp
c002bff9:	89 e5                	mov    %esp,%ebp
c002bffb:	53                   	push   %ebx
c002bffc:	83 ec 34             	sub    $0x34,%esp
  struct sleep_test test;
  int *output;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002bfff:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002c006:	83 f0 01             	xor    $0x1,%eax
c002c009:	84 c0                	test   %al,%al
c002c00b:	75 1e                	jne    c002c02b <test_sleep+0x33>
c002c00d:	83 ec 0c             	sub    $0xc,%esp
c002c010:	68 f0 18 03 c0       	push   $0xc00318f0
c002c015:	68 fe 18 03 c0       	push   $0xc00318fe
c002c01a:	68 78 1a 03 c0       	push   $0xc0031a78
c002c01f:	6a 28                	push   $0x28
c002c021:	68 18 19 03 c0       	push   $0xc0031918
c002c026:	e8 4d d7 ff ff       	call   c0029778 <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002c02b:	83 ec 04             	sub    $0x4,%esp
c002c02e:	ff 75 0c             	pushl  0xc(%ebp)
c002c031:	ff 75 08             	pushl  0x8(%ebp)
c002c034:	68 44 19 03 c0       	push   $0xc0031944
c002c039:	e8 cb fa ff ff       	call   c002bb09 <msg>
c002c03e:	83 c4 10             	add    $0x10,%esp
  msg ("Each thread sleeps 10 ticks each time.");
c002c041:	83 ec 0c             	sub    $0xc,%esp
c002c044:	68 70 19 03 c0       	push   $0xc0031970
c002c049:	e8 bb fa ff ff       	call   c002bb09 <msg>
c002c04e:	83 c4 10             	add    $0x10,%esp
  msg ("Within an iteration, all threads should wake up on the same tick.");
c002c051:	83 ec 0c             	sub    $0xc,%esp
c002c054:	68 98 19 03 c0       	push   $0xc0031998
c002c059:	e8 ab fa ff ff       	call   c002bb09 <msg>
c002c05e:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002c061:	8b 55 0c             	mov    0xc(%ebp),%edx
c002c064:	8b 45 08             	mov    0x8(%ebp),%eax
c002c067:	0f af c2             	imul   %edx,%eax
c002c06a:	c1 e0 03             	shl    $0x3,%eax
c002c06d:	83 ec 0c             	sub    $0xc,%esp
c002c070:	50                   	push   %eax
c002c071:	e8 33 75 ff ff       	call   c00235a9 <malloc>
c002c076:	83 c4 10             	add    $0x10,%esp
c002c079:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (output == NULL)
c002c07c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c080:	75 16                	jne    c002c098 <test_sleep+0xa0>
    PANIC ("couldn't allocate memory for test");
c002c082:	68 dc 19 03 c0       	push   $0xc00319dc
c002c087:	68 78 1a 03 c0       	push   $0xc0031a78
c002c08c:	6a 31                	push   $0x31
c002c08e:	68 18 19 03 c0       	push   $0xc0031918
c002c093:	e8 e0 d6 ff ff       	call   c0029778 <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002c098:	e8 51 7d ff ff       	call   c0023dee <timer_ticks>
c002c09d:	83 c0 64             	add    $0x64,%eax
c002c0a0:	83 d2 00             	adc    $0x0,%edx
c002c0a3:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002c0a6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  test.iterations = iterations;
c002c0a9:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c0ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
  test.output_pos = output;
c002c0af:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c0b2:	89 45 ec             	mov    %eax,-0x14(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002c0b5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c0b9:	75 1e                	jne    c002c0d9 <test_sleep+0xe1>
c002c0bb:	83 ec 0c             	sub    $0xc,%esp
c002c0be:	68 fe 19 03 c0       	push   $0xc00319fe
c002c0c3:	68 fe 18 03 c0       	push   $0xc00318fe
c002c0c8:	68 78 1a 03 c0       	push   $0xc0031a78
c002c0cd:	6a 39                	push   $0x39
c002c0cf:	68 18 19 03 c0       	push   $0xc0031918
c002c0d4:	e8 9f d6 ff ff       	call   c0029778 <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002c0d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c0e0:	eb 31                	jmp    c002c113 <test_sleep+0x11b>
    {
      char name[16];
      snprintf (name, sizeof name, "thread %d", i);
c002c0e2:	ff 75 f4             	pushl  -0xc(%ebp)
c002c0e5:	68 0d 1a 03 c0       	push   $0xc0031a0d
c002c0ea:	6a 10                	push   $0x10
c002c0ec:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002c0ef:	50                   	push   %eax
c002c0f0:	e8 27 b2 ff ff       	call   c002731c <snprintf>
c002c0f5:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002c0f8:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c0fb:	50                   	push   %eax
c002c0fc:	68 d0 c1 02 c0       	push   $0xc002c1d0
c002c101:	6a 1f                	push   $0x1f
c002c103:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002c106:	50                   	push   %eax
c002c107:	e8 7a 4a ff ff       	call   c0020b86 <thread_create>
c002c10c:	83 c4 10             	add    $0x10,%esp
  test.iterations = iterations;
  test.output_pos = output;

  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
c002c10f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c113:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c116:	3b 45 08             	cmp    0x8(%ebp),%eax
c002c119:	7c c7                	jl     c002c0e2 <test_sleep+0xea>
      snprintf (name, sizeof name, "thread %d", i);
      thread_create (name, PRI_DEFAULT, sleeper, &test);
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);
c002c11b:	8b 55 0c             	mov    0xc(%ebp),%edx
c002c11e:	89 d0                	mov    %edx,%eax
c002c120:	c1 e0 02             	shl    $0x2,%eax
c002c123:	01 d0                	add    %edx,%eax
c002c125:	01 c0                	add    %eax,%eax
c002c127:	05 c8 00 00 00       	add    $0xc8,%eax
c002c12c:	99                   	cltd   
c002c12d:	83 ec 08             	sub    $0x8,%esp
c002c130:	52                   	push   %edx
c002c131:	50                   	push   %eax
c002c132:	e8 0b 7d ff ff       	call   c0023e42 <timer_sleep>
c002c137:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c002c13a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c13d:	8b 00                	mov    (%eax),%eax
c002c13f:	83 ec 08             	sub    $0x8,%esp
c002c142:	50                   	push   %eax
c002c143:	68 18 1a 03 c0       	push   $0xc0031a18
c002c148:	e8 bc f9 ff ff       	call   c002bb09 <msg>
c002c14d:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002c150:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002c157:	eb 4f                	jmp    c002c1a8 <test_sleep+0x1b0>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
c002c159:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c15c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c163:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c166:	01 d0                	add    %edx,%eax
c002c168:	8b 10                	mov    (%eax),%edx
c002c16a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c16d:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
c002c172:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c002c179:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c17c:	01 c8                	add    %ecx,%eax
c002c17e:	8b 00                	mov    (%eax),%eax
  timer_sleep (100 + iterations * 10 + 100);

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
  for (i = 1; i < test.output_pos - output; i++) 
    msg ("iteration %d, thread %d: woke up %d ticks later",
c002c180:	89 d1                	mov    %edx,%ecx
c002c182:	29 c1                	sub    %eax,%ecx
c002c184:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c187:	99                   	cltd   
c002c188:	f7 7d 08             	idivl  0x8(%ebp)
c002c18b:	89 d3                	mov    %edx,%ebx
c002c18d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c190:	99                   	cltd   
c002c191:	f7 7d 08             	idivl  0x8(%ebp)
c002c194:	51                   	push   %ecx
c002c195:	53                   	push   %ebx
c002c196:	50                   	push   %eax
c002c197:	68 48 1a 03 c0       	push   $0xc0031a48
c002c19c:	e8 68 f9 ff ff       	call   c002bb09 <msg>
c002c1a1:	83 c4 10             	add    $0x10,%esp
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
  for (i = 1; i < test.output_pos - output; i++) 
c002c1a4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c1a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c1ab:	89 c2                	mov    %eax,%edx
c002c1ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c1b0:	29 c2                	sub    %eax,%edx
c002c1b2:	89 d0                	mov    %edx,%eax
c002c1b4:	c1 f8 02             	sar    $0x2,%eax
c002c1b7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c1ba:	7f 9d                	jg     c002c159 <test_sleep+0x161>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
  
  free (output);
c002c1bc:	83 ec 0c             	sub    $0xc,%esp
c002c1bf:	ff 75 f0             	pushl  -0x10(%ebp)
c002c1c2:	e8 db 76 ff ff       	call   c00238a2 <free>
c002c1c7:	83 c4 10             	add    $0x10,%esp
}
c002c1ca:	90                   	nop
c002c1cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c1ce:	c9                   	leave  
c002c1cf:	c3                   	ret    

c002c1d0 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c002c1d0:	55                   	push   %ebp
c002c1d1:	89 e5                	mov    %esp,%ebp
c002c1d3:	53                   	push   %ebx
c002c1d4:	83 ec 14             	sub    $0x14,%esp
  struct sleep_test *test = test_;
c002c1d7:	8b 45 08             	mov    0x8(%ebp),%eax
c002c1da:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c002c1dd:	83 ec 08             	sub    $0x8,%esp
c002c1e0:	6a 00                	push   $0x0
c002c1e2:	6a 01                	push   $0x1
c002c1e4:	e8 59 7c ff ff       	call   c0023e42 <timer_sleep>
c002c1e9:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i <= test->iterations; i++) 
c002c1ec:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002c1f3:	eb 6c                	jmp    c002c261 <sleeper+0x91>
    {
      int64_t sleep_until = test->start + i * 10;
c002c1f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c1f8:	8b 08                	mov    (%eax),%ecx
c002c1fa:	8b 58 04             	mov    0x4(%eax),%ebx
c002c1fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002c200:	89 d0                	mov    %edx,%eax
c002c202:	c1 e0 02             	shl    $0x2,%eax
c002c205:	01 d0                	add    %edx,%eax
c002c207:	01 c0                	add    %eax,%eax
c002c209:	99                   	cltd   
c002c20a:	01 c8                	add    %ecx,%eax
c002c20c:	11 da                	adc    %ebx,%edx
c002c20e:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002c211:	89 55 ec             	mov    %edx,-0x14(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002c214:	e8 d5 7b ff ff       	call   c0023dee <timer_ticks>
c002c219:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002c21c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002c21f:	29 c1                	sub    %eax,%ecx
c002c221:	19 d3                	sbb    %edx,%ebx
c002c223:	89 c8                	mov    %ecx,%eax
c002c225:	89 da                	mov    %ebx,%edx
c002c227:	83 ec 08             	sub    $0x8,%esp
c002c22a:	52                   	push   %edx
c002c22b:	50                   	push   %eax
c002c22c:	e8 11 7c ff ff       	call   c0023e42 <timer_sleep>
c002c231:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = timer_ticks () - test->start;
c002c234:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c237:	8b 58 0c             	mov    0xc(%eax),%ebx
c002c23a:	8d 53 04             	lea    0x4(%ebx),%edx
c002c23d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c240:	89 50 0c             	mov    %edx,0xc(%eax)
c002c243:	e8 a6 7b ff ff       	call   c0023dee <timer_ticks>
c002c248:	89 c1                	mov    %eax,%ecx
c002c24a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c24d:	8b 50 04             	mov    0x4(%eax),%edx
c002c250:	8b 00                	mov    (%eax),%eax
c002c252:	29 c1                	sub    %eax,%ecx
c002c254:	89 c8                	mov    %ecx,%eax
c002c256:	89 03                	mov    %eax,(%ebx)
      thread_yield ();
c002c258:	e8 38 4c ff ff       	call   c0020e95 <thread_yield>
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);

  for (i = 1; i <= test->iterations; i++) 
c002c25d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c261:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c264:	8b 40 08             	mov    0x8(%eax),%eax
c002c267:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c26a:	7d 89                	jge    c002c1f5 <sleeper+0x25>
      int64_t sleep_until = test->start + i * 10;
      timer_sleep (sleep_until - timer_ticks ());
      *test->output_pos++ = timer_ticks () - test->start;
      thread_yield ();
    }
}
c002c26c:	90                   	nop
c002c26d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c270:	c9                   	leave  
c002c271:	c3                   	ret    

c002c272 <test_alarm_priority>:
static int64_t wake_time;
static struct semaphore wait_sema;

void
test_alarm_priority (void) 
{
c002c272:	55                   	push   %ebp
c002c273:	89 e5                	mov    %esp,%ebp
c002c275:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c278:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002c27f:	83 f0 01             	xor    $0x1,%eax
c002c282:	84 c0                	test   %al,%al
c002c284:	75 1e                	jne    c002c2a4 <test_alarm_priority+0x32>
c002c286:	83 ec 0c             	sub    $0xc,%esp
c002c289:	68 84 1a 03 c0       	push   $0xc0031a84
c002c28e:	68 92 1a 03 c0       	push   $0xc0031a92
c002c293:	68 f0 1a 03 c0       	push   $0xc0031af0
c002c298:	6a 16                	push   $0x16
c002c29a:	68 ac 1a 03 c0       	push   $0xc0031aac
c002c29f:	e8 d4 d4 ff ff       	call   c0029778 <debug_panic>

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c002c2a4:	e8 45 7b ff ff       	call   c0023dee <timer_ticks>
c002c2a9:	05 f4 01 00 00       	add    $0x1f4,%eax
c002c2ae:	83 d2 00             	adc    $0x0,%edx
c002c2b1:	a3 58 9c 03 c0       	mov    %eax,0xc0039c58
c002c2b6:	89 15 5c 9c 03 c0    	mov    %edx,0xc0039c5c
  sema_init (&wait_sema, 0);
c002c2bc:	83 ec 08             	sub    $0x8,%esp
c002c2bf:	6a 00                	push   $0x0
c002c2c1:	68 60 9c 03 c0       	push   $0xc0039c60
c002c2c6:	e8 0d 66 ff ff       	call   c00228d8 <sema_init>
c002c2cb:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 10; i++) 
c002c2ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c2d5:	eb 60                	jmp    c002c337 <test_alarm_priority+0xc5>
    {
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002c2d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c2da:	8d 48 05             	lea    0x5(%eax),%ecx
c002c2dd:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002c2e2:	89 c8                	mov    %ecx,%eax
c002c2e4:	f7 ea                	imul   %edx
c002c2e6:	c1 fa 02             	sar    $0x2,%edx
c002c2e9:	89 c8                	mov    %ecx,%eax
c002c2eb:	c1 f8 1f             	sar    $0x1f,%eax
c002c2ee:	29 c2                	sub    %eax,%edx
c002c2f0:	89 d0                	mov    %edx,%eax
c002c2f2:	c1 e0 02             	shl    $0x2,%eax
c002c2f5:	01 d0                	add    %edx,%eax
c002c2f7:	01 c0                	add    %eax,%eax
c002c2f9:	29 c1                	sub    %eax,%ecx
c002c2fb:	89 ca                	mov    %ecx,%edx
c002c2fd:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002c302:	29 d0                	sub    %edx,%eax
c002c304:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002c307:	ff 75 f0             	pushl  -0x10(%ebp)
c002c30a:	68 d1 1a 03 c0       	push   $0xc0031ad1
c002c30f:	6a 10                	push   $0x10
c002c311:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c314:	50                   	push   %eax
c002c315:	e8 02 b0 ff ff       	call   c002731c <snprintf>
c002c31a:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, alarm_priority_thread, NULL);
c002c31d:	6a 00                	push   $0x0
c002c31f:	68 70 c3 02 c0       	push   $0xc002c370
c002c324:	ff 75 f0             	pushl  -0x10(%ebp)
c002c327:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c32a:	50                   	push   %eax
c002c32b:	e8 56 48 ff ff       	call   c0020b86 <thread_create>
c002c330:	83 c4 10             	add    $0x10,%esp
  ASSERT (!thread_mlfqs);

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
  sema_init (&wait_sema, 0);
  
  for (i = 0; i < 10; i++) 
c002c333:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c337:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002c33b:	7e 9a                	jle    c002c2d7 <test_alarm_priority+0x65>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, alarm_priority_thread, NULL);
    }

  thread_set_priority (PRI_MIN);
c002c33d:	83 ec 0c             	sub    $0xc,%esp
c002c340:	6a 00                	push   $0x0
c002c342:	e8 5d 4c ff ff       	call   c0020fa4 <thread_set_priority>
c002c347:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 10; i++)
c002c34a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c351:	eb 14                	jmp    c002c367 <test_alarm_priority+0xf5>
    sema_down (&wait_sema);
c002c353:	83 ec 0c             	sub    $0xc,%esp
c002c356:	68 60 9c 03 c0       	push   $0xc0039c60
c002c35b:	e8 bf 65 ff ff       	call   c002291f <sema_down>
c002c360:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, alarm_priority_thread, NULL);
    }

  thread_set_priority (PRI_MIN);

  for (i = 0; i < 10; i++)
c002c363:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c367:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002c36b:	7e e6                	jle    c002c353 <test_alarm_priority+0xe1>
    sema_down (&wait_sema);
}
c002c36d:	90                   	nop
c002c36e:	c9                   	leave  
c002c36f:	c3                   	ret    

c002c370 <alarm_priority_thread>:

static void
alarm_priority_thread (void *aux UNUSED) 
{
c002c370:	55                   	push   %ebp
c002c371:	89 e5                	mov    %esp,%ebp
c002c373:	56                   	push   %esi
c002c374:	53                   	push   %ebx
c002c375:	83 ec 10             	sub    $0x10,%esp
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c002c378:	e8 71 7a ff ff       	call   c0023dee <timer_ticks>
c002c37d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c380:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) == 0)
c002c383:	eb 01                	jmp    c002c386 <alarm_priority_thread+0x16>
    continue;
c002c385:	90                   	nop
static void
alarm_priority_thread (void *aux UNUSED) 
{
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
  while (timer_elapsed (start_time) == 0)
c002c386:	83 ec 08             	sub    $0x8,%esp
c002c389:	ff 75 f4             	pushl  -0xc(%ebp)
c002c38c:	ff 75 f0             	pushl  -0x10(%ebp)
c002c38f:	e8 8f 7a ff ff       	call   c0023e23 <timer_elapsed>
c002c394:	83 c4 10             	add    $0x10,%esp
c002c397:	09 d0                	or     %edx,%eax
c002c399:	85 c0                	test   %eax,%eax
c002c39b:	74 e8                	je     c002c385 <alarm_priority_thread+0x15>
    continue;

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c002c39d:	8b 1d 58 9c 03 c0    	mov    0xc0039c58,%ebx
c002c3a3:	8b 35 5c 9c 03 c0    	mov    0xc0039c5c,%esi
c002c3a9:	e8 40 7a ff ff       	call   c0023dee <timer_ticks>
c002c3ae:	29 c3                	sub    %eax,%ebx
c002c3b0:	19 d6                	sbb    %edx,%esi
c002c3b2:	89 d8                	mov    %ebx,%eax
c002c3b4:	89 f2                	mov    %esi,%edx
c002c3b6:	83 ec 08             	sub    $0x8,%esp
c002c3b9:	52                   	push   %edx
c002c3ba:	50                   	push   %eax
c002c3bb:	e8 82 7a ff ff       	call   c0023e42 <timer_sleep>
c002c3c0:	83 c4 10             	add    $0x10,%esp

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c002c3c3:	e8 c7 49 ff ff       	call   c0020d8f <thread_name>
c002c3c8:	83 ec 08             	sub    $0x8,%esp
c002c3cb:	50                   	push   %eax
c002c3cc:	68 dd 1a 03 c0       	push   $0xc0031add
c002c3d1:	e8 33 f7 ff ff       	call   c002bb09 <msg>
c002c3d6:	83 c4 10             	add    $0x10,%esp

  sema_up (&wait_sema);
c002c3d9:	83 ec 0c             	sub    $0xc,%esp
c002c3dc:	68 60 9c 03 c0       	push   $0xc0039c60
c002c3e1:	e8 44 66 ff ff       	call   c0022a2a <sema_up>
c002c3e6:	83 c4 10             	add    $0x10,%esp
}
c002c3e9:	90                   	nop
c002c3ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002c3ed:	5b                   	pop    %ebx
c002c3ee:	5e                   	pop    %esi
c002c3ef:	5d                   	pop    %ebp
c002c3f0:	c3                   	ret    

c002c3f1 <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c002c3f1:	55                   	push   %ebp
c002c3f2:	89 e5                	mov    %esp,%ebp
c002c3f4:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (0);
c002c3f7:	83 ec 08             	sub    $0x8,%esp
c002c3fa:	6a 00                	push   $0x0
c002c3fc:	6a 00                	push   $0x0
c002c3fe:	e8 3f 7a ff ff       	call   c0023e42 <timer_sleep>
c002c403:	83 c4 10             	add    $0x10,%esp
  pass ();
c002c406:	e8 99 f7 ff ff       	call   c002bba4 <pass>
}
c002c40b:	90                   	nop
c002c40c:	c9                   	leave  
c002c40d:	c3                   	ret    

c002c40e <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c002c40e:	55                   	push   %ebp
c002c40f:	89 e5                	mov    %esp,%ebp
c002c411:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (-100);
c002c414:	83 ec 08             	sub    $0x8,%esp
c002c417:	6a ff                	push   $0xffffffff
c002c419:	6a 9c                	push   $0xffffff9c
c002c41b:	e8 22 7a ff ff       	call   c0023e42 <timer_sleep>
c002c420:	83 c4 10             	add    $0x10,%esp
  pass ();
c002c423:	e8 7c f7 ff ff       	call   c002bba4 <pass>
}
c002c428:	90                   	nop
c002c429:	c9                   	leave  
c002c42a:	c3                   	ret    

c002c42b <test_priority_change>:

static thread_func changing_thread;

void
test_priority_change (void) 
{
c002c42b:	55                   	push   %ebp
c002c42c:	89 e5                	mov    %esp,%ebp
c002c42e:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c431:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002c438:	83 f0 01             	xor    $0x1,%eax
c002c43b:	84 c0                	test   %al,%al
c002c43d:	75 1e                	jne    c002c45d <test_priority_change+0x32>
c002c43f:	83 ec 0c             	sub    $0xc,%esp
c002c442:	68 04 1b 03 c0       	push   $0xc0031b04
c002c447:	68 12 1b 03 c0       	push   $0xc0031b12
c002c44c:	68 08 1c 03 c0       	push   $0xc0031c08
c002c451:	6a 10                	push   $0x10
c002c453:	68 2c 1b 03 c0       	push   $0xc0031b2c
c002c458:	e8 1b d3 ff ff       	call   c0029778 <debug_panic>

  msg ("Creating a high-priority thread 2.");
c002c45d:	83 ec 0c             	sub    $0xc,%esp
c002c460:	68 54 1b 03 c0       	push   $0xc0031b54
c002c465:	e8 9f f6 ff ff       	call   c002bb09 <msg>
c002c46a:	83 c4 10             	add    $0x10,%esp
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c002c46d:	6a 00                	push   $0x0
c002c46f:	68 b3 c4 02 c0       	push   $0xc002c4b3
c002c474:	6a 20                	push   $0x20
c002c476:	68 77 1b 03 c0       	push   $0xc0031b77
c002c47b:	e8 06 47 ff ff       	call   c0020b86 <thread_create>
c002c480:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just lowered its priority.");
c002c483:	83 ec 0c             	sub    $0xc,%esp
c002c486:	68 80 1b 03 c0       	push   $0xc0031b80
c002c48b:	e8 79 f6 ff ff       	call   c002bb09 <msg>
c002c490:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 2);
c002c493:	83 ec 0c             	sub    $0xc,%esp
c002c496:	6a 1d                	push   $0x1d
c002c498:	e8 07 4b ff ff       	call   c0020fa4 <thread_set_priority>
c002c49d:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just exited.");
c002c4a0:	83 ec 0c             	sub    $0xc,%esp
c002c4a3:	68 b0 1b 03 c0       	push   $0xc0031bb0
c002c4a8:	e8 5c f6 ff ff       	call   c002bb09 <msg>
c002c4ad:	83 c4 10             	add    $0x10,%esp
}
c002c4b0:	90                   	nop
c002c4b1:	c9                   	leave  
c002c4b2:	c3                   	ret    

c002c4b3 <changing_thread>:

static void
changing_thread (void *aux UNUSED) 
{
c002c4b3:	55                   	push   %ebp
c002c4b4:	89 e5                	mov    %esp,%ebp
c002c4b6:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread 2 now lowering priority.");
c002c4b9:	83 ec 0c             	sub    $0xc,%esp
c002c4bc:	68 d4 1b 03 c0       	push   $0xc0031bd4
c002c4c1:	e8 43 f6 ff ff       	call   c002bb09 <msg>
c002c4c6:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 1);
c002c4c9:	83 ec 0c             	sub    $0xc,%esp
c002c4cc:	6a 1e                	push   $0x1e
c002c4ce:	e8 d1 4a ff ff       	call   c0020fa4 <thread_set_priority>
c002c4d3:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 exiting.");
c002c4d6:	83 ec 0c             	sub    $0xc,%esp
c002c4d9:	68 f4 1b 03 c0       	push   $0xc0031bf4
c002c4de:	e8 26 f6 ff ff       	call   c002bb09 <msg>
c002c4e3:	83 c4 10             	add    $0x10,%esp
}
c002c4e6:	90                   	nop
c002c4e7:	c9                   	leave  
c002c4e8:	c3                   	ret    

c002c4e9 <test_priority_donate_one>:
static thread_func acquire1_thread_func;
static thread_func acquire2_thread_func;

void
test_priority_donate_one (void) 
{
c002c4e9:	55                   	push   %ebp
c002c4ea:	89 e5                	mov    %esp,%ebp
c002c4ec:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c4ef:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002c4f6:	83 f0 01             	xor    $0x1,%eax
c002c4f9:	84 c0                	test   %al,%al
c002c4fb:	75 1e                	jne    c002c51b <test_priority_donate_one+0x32>
c002c4fd:	83 ec 0c             	sub    $0xc,%esp
c002c500:	68 20 1c 03 c0       	push   $0xc0031c20
c002c505:	68 2e 1c 03 c0       	push   $0xc0031c2e
c002c50a:	68 b0 1d 03 c0       	push   $0xc0031db0
c002c50f:	6a 1b                	push   $0x1b
c002c511:	68 48 1c 03 c0       	push   $0xc0031c48
c002c516:	e8 5d d2 ff ff       	call   c0029778 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c51b:	e8 9a 4a ff ff       	call   c0020fba <thread_get_priority>
c002c520:	83 f8 1f             	cmp    $0x1f,%eax
c002c523:	74 1e                	je     c002c543 <test_priority_donate_one+0x5a>
c002c525:	83 ec 0c             	sub    $0xc,%esp
c002c528:	68 74 1c 03 c0       	push   $0xc0031c74
c002c52d:	68 2e 1c 03 c0       	push   $0xc0031c2e
c002c532:	68 b0 1d 03 c0       	push   $0xc0031db0
c002c537:	6a 1e                	push   $0x1e
c002c539:	68 48 1c 03 c0       	push   $0xc0031c48
c002c53e:	e8 35 d2 ff ff       	call   c0029778 <debug_panic>

  lock_init (&lock);
c002c543:	83 ec 0c             	sub    $0xc,%esp
c002c546:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c549:	50                   	push   %eax
c002c54a:	e8 44 66 ff ff       	call   c0022b93 <lock_init>
c002c54f:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002c552:	83 ec 0c             	sub    $0xc,%esp
c002c555:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c558:	50                   	push   %eax
c002c559:	e8 82 66 ff ff       	call   c0022be0 <lock_acquire>
c002c55e:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002c561:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c564:	50                   	push   %eax
c002c565:	68 f3 c5 02 c0       	push   $0xc002c5f3
c002c56a:	6a 20                	push   $0x20
c002c56c:	68 9a 1c 03 c0       	push   $0xc0031c9a
c002c571:	e8 10 46 ff ff       	call   c0020b86 <thread_create>
c002c576:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002c579:	e8 3c 4a ff ff       	call   c0020fba <thread_get_priority>
c002c57e:	83 ec 04             	sub    $0x4,%esp
c002c581:	50                   	push   %eax
c002c582:	6a 20                	push   $0x20
c002c584:	68 a4 1c 03 c0       	push   $0xc0031ca4
c002c589:	e8 7b f5 ff ff       	call   c002bb09 <msg>
c002c58e:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002c591:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c594:	50                   	push   %eax
c002c595:	68 3e c6 02 c0       	push   $0xc002c63e
c002c59a:	6a 21                	push   $0x21
c002c59c:	68 df 1c 03 c0       	push   $0xc0031cdf
c002c5a1:	e8 e0 45 ff ff       	call   c0020b86 <thread_create>
c002c5a6:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002c5a9:	e8 0c 4a ff ff       	call   c0020fba <thread_get_priority>
c002c5ae:	83 ec 04             	sub    $0x4,%esp
c002c5b1:	50                   	push   %eax
c002c5b2:	6a 21                	push   $0x21
c002c5b4:	68 a4 1c 03 c0       	push   $0xc0031ca4
c002c5b9:	e8 4b f5 ff ff       	call   c002bb09 <msg>
c002c5be:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  lock_release (&lock);
c002c5c1:	83 ec 0c             	sub    $0xc,%esp
c002c5c4:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c5c7:	50                   	push   %eax
c002c5c8:	e8 54 67 ff ff       	call   c0022d21 <lock_release>
c002c5cd:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002c5d0:	83 ec 0c             	sub    $0xc,%esp
c002c5d3:	68 e8 1c 03 c0       	push   $0xc0031ce8
c002c5d8:	e8 2c f5 ff ff       	call   c002bb09 <msg>
c002c5dd:	83 c4 10             	add    $0x10,%esp
  msg ("This should be the last line before finishing this test.");
c002c5e0:	83 ec 0c             	sub    $0xc,%esp
c002c5e3:	68 28 1d 03 c0       	push   $0xc0031d28
c002c5e8:	e8 1c f5 ff ff       	call   c002bb09 <msg>
c002c5ed:	83 c4 10             	add    $0x10,%esp
}
c002c5f0:	90                   	nop
c002c5f1:	c9                   	leave  
c002c5f2:	c3                   	ret    

c002c5f3 <acquire1_thread_func>:

static void
acquire1_thread_func (void *lock_) 
{
c002c5f3:	55                   	push   %ebp
c002c5f4:	89 e5                	mov    %esp,%ebp
c002c5f6:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c5f9:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5fc:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c5ff:	83 ec 0c             	sub    $0xc,%esp
c002c602:	ff 75 f4             	pushl  -0xc(%ebp)
c002c605:	e8 d6 65 ff ff       	call   c0022be0 <lock_acquire>
c002c60a:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: got the lock");
c002c60d:	83 ec 0c             	sub    $0xc,%esp
c002c610:	68 61 1d 03 c0       	push   $0xc0031d61
c002c615:	e8 ef f4 ff ff       	call   c002bb09 <msg>
c002c61a:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c61d:	83 ec 0c             	sub    $0xc,%esp
c002c620:	ff 75 f4             	pushl  -0xc(%ebp)
c002c623:	e8 f9 66 ff ff       	call   c0022d21 <lock_release>
c002c628:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: done");
c002c62b:	83 ec 0c             	sub    $0xc,%esp
c002c62e:	68 78 1d 03 c0       	push   $0xc0031d78
c002c633:	e8 d1 f4 ff ff       	call   c002bb09 <msg>
c002c638:	83 c4 10             	add    $0x10,%esp
}
c002c63b:	90                   	nop
c002c63c:	c9                   	leave  
c002c63d:	c3                   	ret    

c002c63e <acquire2_thread_func>:

static void
acquire2_thread_func (void *lock_) 
{
c002c63e:	55                   	push   %ebp
c002c63f:	89 e5                	mov    %esp,%ebp
c002c641:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c644:	8b 45 08             	mov    0x8(%ebp),%eax
c002c647:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c64a:	83 ec 0c             	sub    $0xc,%esp
c002c64d:	ff 75 f4             	pushl  -0xc(%ebp)
c002c650:	e8 8b 65 ff ff       	call   c0022be0 <lock_acquire>
c002c655:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: got the lock");
c002c658:	83 ec 0c             	sub    $0xc,%esp
c002c65b:	68 87 1d 03 c0       	push   $0xc0031d87
c002c660:	e8 a4 f4 ff ff       	call   c002bb09 <msg>
c002c665:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c668:	83 ec 0c             	sub    $0xc,%esp
c002c66b:	ff 75 f4             	pushl  -0xc(%ebp)
c002c66e:	e8 ae 66 ff ff       	call   c0022d21 <lock_release>
c002c673:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: done");
c002c676:	83 ec 0c             	sub    $0xc,%esp
c002c679:	68 9e 1d 03 c0       	push   $0xc0031d9e
c002c67e:	e8 86 f4 ff ff       	call   c002bb09 <msg>
c002c683:	83 c4 10             	add    $0x10,%esp
}
c002c686:	90                   	nop
c002c687:	c9                   	leave  
c002c688:	c3                   	ret    

c002c689 <test_priority_donate_multiple>:
static thread_func a_thread_func;
static thread_func b_thread_func;

void
test_priority_donate_multiple (void) 
{
c002c689:	55                   	push   %ebp
c002c68a:	89 e5                	mov    %esp,%ebp
c002c68c:	83 ec 38             	sub    $0x38,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c68f:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002c696:	83 f0 01             	xor    $0x1,%eax
c002c699:	84 c0                	test   %al,%al
c002c69b:	75 1e                	jne    c002c6bb <test_priority_donate_multiple+0x32>
c002c69d:	83 ec 0c             	sub    $0xc,%esp
c002c6a0:	68 cc 1d 03 c0       	push   $0xc0031dcc
c002c6a5:	68 da 1d 03 c0       	push   $0xc0031dda
c002c6aa:	68 30 1f 03 c0       	push   $0xc0031f30
c002c6af:	6a 1b                	push   $0x1b
c002c6b1:	68 f4 1d 03 c0       	push   $0xc0031df4
c002c6b6:	e8 bd d0 ff ff       	call   c0029778 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c6bb:	e8 fa 48 ff ff       	call   c0020fba <thread_get_priority>
c002c6c0:	83 f8 1f             	cmp    $0x1f,%eax
c002c6c3:	74 1e                	je     c002c6e3 <test_priority_donate_multiple+0x5a>
c002c6c5:	83 ec 0c             	sub    $0xc,%esp
c002c6c8:	68 24 1e 03 c0       	push   $0xc0031e24
c002c6cd:	68 da 1d 03 c0       	push   $0xc0031dda
c002c6d2:	68 30 1f 03 c0       	push   $0xc0031f30
c002c6d7:	6a 1e                	push   $0x1e
c002c6d9:	68 f4 1d 03 c0       	push   $0xc0031df4
c002c6de:	e8 95 d0 ff ff       	call   c0029778 <debug_panic>

  lock_init (&a);
c002c6e3:	83 ec 0c             	sub    $0xc,%esp
c002c6e6:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c6e9:	50                   	push   %eax
c002c6ea:	e8 a4 64 ff ff       	call   c0022b93 <lock_init>
c002c6ef:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c6f2:	83 ec 0c             	sub    $0xc,%esp
c002c6f5:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c6f8:	50                   	push   %eax
c002c6f9:	e8 95 64 ff ff       	call   c0022b93 <lock_init>
c002c6fe:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c701:	83 ec 0c             	sub    $0xc,%esp
c002c704:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c707:	50                   	push   %eax
c002c708:	e8 d3 64 ff ff       	call   c0022be0 <lock_acquire>
c002c70d:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002c710:	83 ec 0c             	sub    $0xc,%esp
c002c713:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c716:	50                   	push   %eax
c002c717:	e8 c4 64 ff ff       	call   c0022be0 <lock_acquire>
c002c71c:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002c71f:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c722:	50                   	push   %eax
c002c723:	68 f0 c7 02 c0       	push   $0xc002c7f0
c002c728:	6a 20                	push   $0x20
c002c72a:	68 4a 1e 03 c0       	push   $0xc0031e4a
c002c72f:	e8 52 44 ff ff       	call   c0020b86 <thread_create>
c002c734:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c737:	e8 7e 48 ff ff       	call   c0020fba <thread_get_priority>
c002c73c:	83 ec 04             	sub    $0x4,%esp
c002c73f:	50                   	push   %eax
c002c740:	6a 20                	push   $0x20
c002c742:	68 4c 1e 03 c0       	push   $0xc0031e4c
c002c747:	e8 bd f3 ff ff       	call   c002bb09 <msg>
c002c74c:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002c74f:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c752:	50                   	push   %eax
c002c753:	68 3b c8 02 c0       	push   $0xc002c83b
c002c758:	6a 21                	push   $0x21
c002c75a:	68 87 1e 03 c0       	push   $0xc0031e87
c002c75f:	e8 22 44 ff ff       	call   c0020b86 <thread_create>
c002c764:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c767:	e8 4e 48 ff ff       	call   c0020fba <thread_get_priority>
c002c76c:	83 ec 04             	sub    $0x4,%esp
c002c76f:	50                   	push   %eax
c002c770:	6a 21                	push   $0x21
c002c772:	68 4c 1e 03 c0       	push   $0xc0031e4c
c002c777:	e8 8d f3 ff ff       	call   c002bb09 <msg>
c002c77c:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&b);
c002c77f:	83 ec 0c             	sub    $0xc,%esp
c002c782:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c785:	50                   	push   %eax
c002c786:	e8 96 65 ff ff       	call   c0022d21 <lock_release>
c002c78b:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b should have just finished.");
c002c78e:	83 ec 0c             	sub    $0xc,%esp
c002c791:	68 8c 1e 03 c0       	push   $0xc0031e8c
c002c796:	e8 6e f3 ff ff       	call   c002bb09 <msg>
c002c79b:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c79e:	e8 17 48 ff ff       	call   c0020fba <thread_get_priority>
c002c7a3:	83 ec 04             	sub    $0x4,%esp
c002c7a6:	50                   	push   %eax
c002c7a7:	6a 20                	push   $0x20
c002c7a9:	68 4c 1e 03 c0       	push   $0xc0031e4c
c002c7ae:	e8 56 f3 ff ff       	call   c002bb09 <msg>
c002c7b3:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  lock_release (&a);
c002c7b6:	83 ec 0c             	sub    $0xc,%esp
c002c7b9:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c7bc:	50                   	push   %eax
c002c7bd:	e8 5f 65 ff ff       	call   c0022d21 <lock_release>
c002c7c2:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a should have just finished.");
c002c7c5:	83 ec 0c             	sub    $0xc,%esp
c002c7c8:	68 b0 1e 03 c0       	push   $0xc0031eb0
c002c7cd:	e8 37 f3 ff ff       	call   c002bb09 <msg>
c002c7d2:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c7d5:	e8 e0 47 ff ff       	call   c0020fba <thread_get_priority>
c002c7da:	83 ec 04             	sub    $0x4,%esp
c002c7dd:	50                   	push   %eax
c002c7de:	6a 1f                	push   $0x1f
c002c7e0:	68 4c 1e 03 c0       	push   $0xc0031e4c
c002c7e5:	e8 1f f3 ff ff       	call   c002bb09 <msg>
c002c7ea:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002c7ed:	90                   	nop
c002c7ee:	c9                   	leave  
c002c7ef:	c3                   	ret    

c002c7f0 <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002c7f0:	55                   	push   %ebp
c002c7f1:	89 e5                	mov    %esp,%ebp
c002c7f3:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c7f6:	8b 45 08             	mov    0x8(%ebp),%eax
c002c7f9:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c7fc:	83 ec 0c             	sub    $0xc,%esp
c002c7ff:	ff 75 f4             	pushl  -0xc(%ebp)
c002c802:	e8 d9 63 ff ff       	call   c0022be0 <lock_acquire>
c002c807:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002c80a:	83 ec 0c             	sub    $0xc,%esp
c002c80d:	68 d4 1e 03 c0       	push   $0xc0031ed4
c002c812:	e8 f2 f2 ff ff       	call   c002bb09 <msg>
c002c817:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c81a:	83 ec 0c             	sub    $0xc,%esp
c002c81d:	ff 75 f4             	pushl  -0xc(%ebp)
c002c820:	e8 fc 64 ff ff       	call   c0022d21 <lock_release>
c002c825:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002c828:	83 ec 0c             	sub    $0xc,%esp
c002c82b:	68 ee 1e 03 c0       	push   $0xc0031eee
c002c830:	e8 d4 f2 ff ff       	call   c002bb09 <msg>
c002c835:	83 c4 10             	add    $0x10,%esp
}
c002c838:	90                   	nop
c002c839:	c9                   	leave  
c002c83a:	c3                   	ret    

c002c83b <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002c83b:	55                   	push   %ebp
c002c83c:	89 e5                	mov    %esp,%ebp
c002c83e:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c841:	8b 45 08             	mov    0x8(%ebp),%eax
c002c844:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c847:	83 ec 0c             	sub    $0xc,%esp
c002c84a:	ff 75 f4             	pushl  -0xc(%ebp)
c002c84d:	e8 8e 63 ff ff       	call   c0022be0 <lock_acquire>
c002c852:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002c855:	83 ec 0c             	sub    $0xc,%esp
c002c858:	68 01 1f 03 c0       	push   $0xc0031f01
c002c85d:	e8 a7 f2 ff ff       	call   c002bb09 <msg>
c002c862:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c865:	83 ec 0c             	sub    $0xc,%esp
c002c868:	ff 75 f4             	pushl  -0xc(%ebp)
c002c86b:	e8 b1 64 ff ff       	call   c0022d21 <lock_release>
c002c870:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002c873:	83 ec 0c             	sub    $0xc,%esp
c002c876:	68 1b 1f 03 c0       	push   $0xc0031f1b
c002c87b:	e8 89 f2 ff ff       	call   c002bb09 <msg>
c002c880:	83 c4 10             	add    $0x10,%esp
}
c002c883:	90                   	nop
c002c884:	c9                   	leave  
c002c885:	c3                   	ret    

c002c886 <test_priority_donate_multiple2>:
static thread_func b_thread_func;
static thread_func c_thread_func;

void
test_priority_donate_multiple2 (void) 
{
c002c886:	55                   	push   %ebp
c002c887:	89 e5                	mov    %esp,%ebp
c002c889:	83 ec 38             	sub    $0x38,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c88c:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002c893:	83 f0 01             	xor    $0x1,%eax
c002c896:	84 c0                	test   %al,%al
c002c898:	75 1e                	jne    c002c8b8 <test_priority_donate_multiple2+0x32>
c002c89a:	83 ec 0c             	sub    $0xc,%esp
c002c89d:	68 50 1f 03 c0       	push   $0xc0031f50
c002c8a2:	68 5e 1f 03 c0       	push   $0xc0031f5e
c002c8a7:	68 b8 20 03 c0       	push   $0xc00320b8
c002c8ac:	6a 21                	push   $0x21
c002c8ae:	68 78 1f 03 c0       	push   $0xc0031f78
c002c8b3:	e8 c0 ce ff ff       	call   c0029778 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c8b8:	e8 fd 46 ff ff       	call   c0020fba <thread_get_priority>
c002c8bd:	83 f8 1f             	cmp    $0x1f,%eax
c002c8c0:	74 1e                	je     c002c8e0 <test_priority_donate_multiple2+0x5a>
c002c8c2:	83 ec 0c             	sub    $0xc,%esp
c002c8c5:	68 a8 1f 03 c0       	push   $0xc0031fa8
c002c8ca:	68 5e 1f 03 c0       	push   $0xc0031f5e
c002c8cf:	68 b8 20 03 c0       	push   $0xc00320b8
c002c8d4:	6a 24                	push   $0x24
c002c8d6:	68 78 1f 03 c0       	push   $0xc0031f78
c002c8db:	e8 98 ce ff ff       	call   c0029778 <debug_panic>

  lock_init (&a);
c002c8e0:	83 ec 0c             	sub    $0xc,%esp
c002c8e3:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c8e6:	50                   	push   %eax
c002c8e7:	e8 a7 62 ff ff       	call   c0022b93 <lock_init>
c002c8ec:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c8ef:	83 ec 0c             	sub    $0xc,%esp
c002c8f2:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c8f5:	50                   	push   %eax
c002c8f6:	e8 98 62 ff ff       	call   c0022b93 <lock_init>
c002c8fb:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c8fe:	83 ec 0c             	sub    $0xc,%esp
c002c901:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c904:	50                   	push   %eax
c002c905:	e8 d6 62 ff ff       	call   c0022be0 <lock_acquire>
c002c90a:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002c90d:	83 ec 0c             	sub    $0xc,%esp
c002c910:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c913:	50                   	push   %eax
c002c914:	e8 c7 62 ff ff       	call   c0022be0 <lock_acquire>
c002c919:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002c91c:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c91f:	50                   	push   %eax
c002c920:	68 f3 c9 02 c0       	push   $0xc002c9f3
c002c925:	6a 22                	push   $0x22
c002c927:	68 ce 1f 03 c0       	push   $0xc0031fce
c002c92c:	e8 55 42 ff ff       	call   c0020b86 <thread_create>
c002c931:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c934:	e8 81 46 ff ff       	call   c0020fba <thread_get_priority>
c002c939:	83 ec 04             	sub    $0x4,%esp
c002c93c:	50                   	push   %eax
c002c93d:	6a 22                	push   $0x22
c002c93f:	68 d0 1f 03 c0       	push   $0xc0031fd0
c002c944:	e8 c0 f1 ff ff       	call   c002bb09 <msg>
c002c949:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 3, thread_get_priority ());

  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002c94c:	6a 00                	push   $0x0
c002c94e:	68 89 ca 02 c0       	push   $0xc002ca89
c002c953:	6a 20                	push   $0x20
c002c955:	68 0b 20 03 c0       	push   $0xc003200b
c002c95a:	e8 27 42 ff ff       	call   c0020b86 <thread_create>
c002c95f:	83 c4 10             	add    $0x10,%esp

  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002c962:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c965:	50                   	push   %eax
c002c966:	68 3e ca 02 c0       	push   $0xc002ca3e
c002c96b:	6a 24                	push   $0x24
c002c96d:	68 0d 20 03 c0       	push   $0xc003200d
c002c972:	e8 0f 42 ff ff       	call   c0020b86 <thread_create>
c002c977:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c97a:	e8 3b 46 ff ff       	call   c0020fba <thread_get_priority>
c002c97f:	83 ec 04             	sub    $0x4,%esp
c002c982:	50                   	push   %eax
c002c983:	6a 24                	push   $0x24
c002c985:	68 d0 1f 03 c0       	push   $0xc0031fd0
c002c98a:	e8 7a f1 ff ff       	call   c002bb09 <msg>
c002c98f:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&a);
c002c992:	83 ec 0c             	sub    $0xc,%esp
c002c995:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c998:	50                   	push   %eax
c002c999:	e8 83 63 ff ff       	call   c0022d21 <lock_release>
c002c99e:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c9a1:	e8 14 46 ff ff       	call   c0020fba <thread_get_priority>
c002c9a6:	83 ec 04             	sub    $0x4,%esp
c002c9a9:	50                   	push   %eax
c002c9aa:	6a 24                	push   $0x24
c002c9ac:	68 d0 1f 03 c0       	push   $0xc0031fd0
c002c9b1:	e8 53 f1 ff ff       	call   c002bb09 <msg>
c002c9b6:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&b);
c002c9b9:	83 ec 0c             	sub    $0xc,%esp
c002c9bc:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c9bf:	50                   	push   %eax
c002c9c0:	e8 5c 63 ff ff       	call   c0022d21 <lock_release>
c002c9c5:	83 c4 10             	add    $0x10,%esp
  msg ("Threads b, a, c should have just finished, in that order.");
c002c9c8:	83 ec 0c             	sub    $0xc,%esp
c002c9cb:	68 10 20 03 c0       	push   $0xc0032010
c002c9d0:	e8 34 f1 ff ff       	call   c002bb09 <msg>
c002c9d5:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c9d8:	e8 dd 45 ff ff       	call   c0020fba <thread_get_priority>
c002c9dd:	83 ec 04             	sub    $0x4,%esp
c002c9e0:	50                   	push   %eax
c002c9e1:	6a 1f                	push   $0x1f
c002c9e3:	68 d0 1f 03 c0       	push   $0xc0031fd0
c002c9e8:	e8 1c f1 ff ff       	call   c002bb09 <msg>
c002c9ed:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002c9f0:	90                   	nop
c002c9f1:	c9                   	leave  
c002c9f2:	c3                   	ret    

c002c9f3 <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002c9f3:	55                   	push   %ebp
c002c9f4:	89 e5                	mov    %esp,%ebp
c002c9f6:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c9f9:	8b 45 08             	mov    0x8(%ebp),%eax
c002c9fc:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c9ff:	83 ec 0c             	sub    $0xc,%esp
c002ca02:	ff 75 f4             	pushl  -0xc(%ebp)
c002ca05:	e8 d6 61 ff ff       	call   c0022be0 <lock_acquire>
c002ca0a:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002ca0d:	83 ec 0c             	sub    $0xc,%esp
c002ca10:	68 4a 20 03 c0       	push   $0xc003204a
c002ca15:	e8 ef f0 ff ff       	call   c002bb09 <msg>
c002ca1a:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002ca1d:	83 ec 0c             	sub    $0xc,%esp
c002ca20:	ff 75 f4             	pushl  -0xc(%ebp)
c002ca23:	e8 f9 62 ff ff       	call   c0022d21 <lock_release>
c002ca28:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002ca2b:	83 ec 0c             	sub    $0xc,%esp
c002ca2e:	68 64 20 03 c0       	push   $0xc0032064
c002ca33:	e8 d1 f0 ff ff       	call   c002bb09 <msg>
c002ca38:	83 c4 10             	add    $0x10,%esp
}
c002ca3b:	90                   	nop
c002ca3c:	c9                   	leave  
c002ca3d:	c3                   	ret    

c002ca3e <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002ca3e:	55                   	push   %ebp
c002ca3f:	89 e5                	mov    %esp,%ebp
c002ca41:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002ca44:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca47:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002ca4a:	83 ec 0c             	sub    $0xc,%esp
c002ca4d:	ff 75 f4             	pushl  -0xc(%ebp)
c002ca50:	e8 8b 61 ff ff       	call   c0022be0 <lock_acquire>
c002ca55:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002ca58:	83 ec 0c             	sub    $0xc,%esp
c002ca5b:	68 77 20 03 c0       	push   $0xc0032077
c002ca60:	e8 a4 f0 ff ff       	call   c002bb09 <msg>
c002ca65:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002ca68:	83 ec 0c             	sub    $0xc,%esp
c002ca6b:	ff 75 f4             	pushl  -0xc(%ebp)
c002ca6e:	e8 ae 62 ff ff       	call   c0022d21 <lock_release>
c002ca73:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002ca76:	83 ec 0c             	sub    $0xc,%esp
c002ca79:	68 91 20 03 c0       	push   $0xc0032091
c002ca7e:	e8 86 f0 ff ff       	call   c002bb09 <msg>
c002ca83:	83 c4 10             	add    $0x10,%esp
}
c002ca86:	90                   	nop
c002ca87:	c9                   	leave  
c002ca88:	c3                   	ret    

c002ca89 <c_thread_func>:

static void
c_thread_func (void *a_ UNUSED) 
{
c002ca89:	55                   	push   %ebp
c002ca8a:	89 e5                	mov    %esp,%ebp
c002ca8c:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread c finished.");
c002ca8f:	83 ec 0c             	sub    $0xc,%esp
c002ca92:	68 a4 20 03 c0       	push   $0xc00320a4
c002ca97:	e8 6d f0 ff ff       	call   c002bb09 <msg>
c002ca9c:	83 c4 10             	add    $0x10,%esp
}
c002ca9f:	90                   	nop
c002caa0:	c9                   	leave  
c002caa1:	c3                   	ret    

c002caa2 <test_priority_donate_nest>:
static thread_func medium_thread_func;
static thread_func high_thread_func;

void
test_priority_donate_nest (void) 
{
c002caa2:	55                   	push   %ebp
c002caa3:	89 e5                	mov    %esp,%ebp
c002caa5:	83 ec 48             	sub    $0x48,%esp
  struct lock a, b;
  struct locks locks;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002caa8:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002caaf:	83 f0 01             	xor    $0x1,%eax
c002cab2:	84 c0                	test   %al,%al
c002cab4:	75 1e                	jne    c002cad4 <test_priority_donate_nest+0x32>
c002cab6:	83 ec 0c             	sub    $0xc,%esp
c002cab9:	68 d8 20 03 c0       	push   $0xc00320d8
c002cabe:	68 e6 20 03 c0       	push   $0xc00320e6
c002cac3:	68 94 22 03 c0       	push   $0xc0032294
c002cac8:	6a 22                	push   $0x22
c002caca:	68 00 21 03 c0       	push   $0xc0032100
c002cacf:	e8 a4 cc ff ff       	call   c0029778 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cad4:	e8 e1 44 ff ff       	call   c0020fba <thread_get_priority>
c002cad9:	83 f8 1f             	cmp    $0x1f,%eax
c002cadc:	74 1e                	je     c002cafc <test_priority_donate_nest+0x5a>
c002cade:	83 ec 0c             	sub    $0xc,%esp
c002cae1:	68 2c 21 03 c0       	push   $0xc003212c
c002cae6:	68 e6 20 03 c0       	push   $0xc00320e6
c002caeb:	68 94 22 03 c0       	push   $0xc0032294
c002caf0:	6a 25                	push   $0x25
c002caf2:	68 00 21 03 c0       	push   $0xc0032100
c002caf7:	e8 7c cc ff ff       	call   c0029778 <debug_panic>

  lock_init (&a);
c002cafc:	83 ec 0c             	sub    $0xc,%esp
c002caff:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cb02:	50                   	push   %eax
c002cb03:	e8 8b 60 ff ff       	call   c0022b93 <lock_init>
c002cb08:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002cb0b:	83 ec 0c             	sub    $0xc,%esp
c002cb0e:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002cb11:	50                   	push   %eax
c002cb12:	e8 7c 60 ff ff       	call   c0022b93 <lock_init>
c002cb17:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002cb1a:	83 ec 0c             	sub    $0xc,%esp
c002cb1d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cb20:	50                   	push   %eax
c002cb21:	e8 ba 60 ff ff       	call   c0022be0 <lock_acquire>
c002cb26:	83 c4 10             	add    $0x10,%esp

  locks.a = &a;
c002cb29:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cb2c:	89 45 c0             	mov    %eax,-0x40(%ebp)
  locks.b = &b;
c002cb2f:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002cb32:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002cb35:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002cb38:	50                   	push   %eax
c002cb39:	68 de cb 02 c0       	push   $0xc002cbde
c002cb3e:	6a 20                	push   $0x20
c002cb40:	68 52 21 03 c0       	push   $0xc0032152
c002cb45:	e8 3c 40 ff ff       	call   c0020b86 <thread_create>
c002cb4a:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002cb4d:	e8 43 43 ff ff       	call   c0020e95 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002cb52:	e8 63 44 ff ff       	call   c0020fba <thread_get_priority>
c002cb57:	83 ec 04             	sub    $0x4,%esp
c002cb5a:	50                   	push   %eax
c002cb5b:	6a 20                	push   $0x20
c002cb5d:	68 5c 21 03 c0       	push   $0xc003215c
c002cb62:	e8 a2 ef ff ff       	call   c002bb09 <msg>
c002cb67:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002cb6a:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002cb6d:	50                   	push   %eax
c002cb6e:	68 85 cc 02 c0       	push   $0xc002cc85
c002cb73:	6a 21                	push   $0x21
c002cb75:	68 96 21 03 c0       	push   $0xc0032196
c002cb7a:	e8 07 40 ff ff       	call   c0020b86 <thread_create>
c002cb7f:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002cb82:	e8 0e 43 ff ff       	call   c0020e95 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002cb87:	e8 2e 44 ff ff       	call   c0020fba <thread_get_priority>
c002cb8c:	83 ec 04             	sub    $0x4,%esp
c002cb8f:	50                   	push   %eax
c002cb90:	6a 21                	push   $0x21
c002cb92:	68 5c 21 03 c0       	push   $0xc003215c
c002cb97:	e8 6d ef ff ff       	call   c002bb09 <msg>
c002cb9c:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&a);
c002cb9f:	83 ec 0c             	sub    $0xc,%esp
c002cba2:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cba5:	50                   	push   %eax
c002cba6:	e8 76 61 ff ff       	call   c0022d21 <lock_release>
c002cbab:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002cbae:	e8 e2 42 ff ff       	call   c0020e95 <thread_yield>
  msg ("Medium thread should just have finished.");
c002cbb3:	83 ec 0c             	sub    $0xc,%esp
c002cbb6:	68 9c 21 03 c0       	push   $0xc003219c
c002cbbb:	e8 49 ef ff ff       	call   c002bb09 <msg>
c002cbc0:	83 c4 10             	add    $0x10,%esp
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002cbc3:	e8 f2 43 ff ff       	call   c0020fba <thread_get_priority>
c002cbc8:	83 ec 04             	sub    $0x4,%esp
c002cbcb:	50                   	push   %eax
c002cbcc:	6a 1f                	push   $0x1f
c002cbce:	68 5c 21 03 c0       	push   $0xc003215c
c002cbd3:	e8 31 ef ff ff       	call   c002bb09 <msg>
c002cbd8:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002cbdb:	90                   	nop
c002cbdc:	c9                   	leave  
c002cbdd:	c3                   	ret    

c002cbde <medium_thread_func>:

static void
medium_thread_func (void *locks_) 
{
c002cbde:	55                   	push   %ebp
c002cbdf:	89 e5                	mov    %esp,%ebp
c002cbe1:	83 ec 18             	sub    $0x18,%esp
  struct locks *locks = locks_;
c002cbe4:	8b 45 08             	mov    0x8(%ebp),%eax
c002cbe7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (locks->b);
c002cbea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cbed:	8b 40 04             	mov    0x4(%eax),%eax
c002cbf0:	83 ec 0c             	sub    $0xc,%esp
c002cbf3:	50                   	push   %eax
c002cbf4:	e8 e7 5f ff ff       	call   c0022be0 <lock_acquire>
c002cbf9:	83 c4 10             	add    $0x10,%esp
  lock_acquire (locks->a);
c002cbfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cbff:	8b 00                	mov    (%eax),%eax
c002cc01:	83 ec 0c             	sub    $0xc,%esp
c002cc04:	50                   	push   %eax
c002cc05:	e8 d6 5f ff ff       	call   c0022be0 <lock_acquire>
c002cc0a:	83 c4 10             	add    $0x10,%esp

  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002cc0d:	e8 a8 43 ff ff       	call   c0020fba <thread_get_priority>
c002cc12:	83 ec 04             	sub    $0x4,%esp
c002cc15:	50                   	push   %eax
c002cc16:	6a 21                	push   $0x21
c002cc18:	68 c8 21 03 c0       	push   $0xc00321c8
c002cc1d:	e8 e7 ee ff ff       	call   c002bb09 <msg>
c002cc22:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  msg ("Medium thread got the lock.");
c002cc25:	83 ec 0c             	sub    $0xc,%esp
c002cc28:	68 05 22 03 c0       	push   $0xc0032205
c002cc2d:	e8 d7 ee ff ff       	call   c002bb09 <msg>
c002cc32:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->a);
c002cc35:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc38:	8b 00                	mov    (%eax),%eax
c002cc3a:	83 ec 0c             	sub    $0xc,%esp
c002cc3d:	50                   	push   %eax
c002cc3e:	e8 de 60 ff ff       	call   c0022d21 <lock_release>
c002cc43:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002cc46:	e8 4a 42 ff ff       	call   c0020e95 <thread_yield>

  lock_release (locks->b);
c002cc4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc4e:	8b 40 04             	mov    0x4(%eax),%eax
c002cc51:	83 ec 0c             	sub    $0xc,%esp
c002cc54:	50                   	push   %eax
c002cc55:	e8 c7 60 ff ff       	call   c0022d21 <lock_release>
c002cc5a:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002cc5d:	e8 33 42 ff ff       	call   c0020e95 <thread_yield>

  msg ("High thread should have just finished.");
c002cc62:	83 ec 0c             	sub    $0xc,%esp
c002cc65:	68 24 22 03 c0       	push   $0xc0032224
c002cc6a:	e8 9a ee ff ff       	call   c002bb09 <msg>
c002cc6f:	83 c4 10             	add    $0x10,%esp
  msg ("Middle thread finished.");
c002cc72:	83 ec 0c             	sub    $0xc,%esp
c002cc75:	68 4b 22 03 c0       	push   $0xc003224b
c002cc7a:	e8 8a ee ff ff       	call   c002bb09 <msg>
c002cc7f:	83 c4 10             	add    $0x10,%esp
}
c002cc82:	90                   	nop
c002cc83:	c9                   	leave  
c002cc84:	c3                   	ret    

c002cc85 <high_thread_func>:

static void
high_thread_func (void *lock_) 
{
c002cc85:	55                   	push   %ebp
c002cc86:	89 e5                	mov    %esp,%ebp
c002cc88:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002cc8b:	8b 45 08             	mov    0x8(%ebp),%eax
c002cc8e:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002cc91:	83 ec 0c             	sub    $0xc,%esp
c002cc94:	ff 75 f4             	pushl  -0xc(%ebp)
c002cc97:	e8 44 5f ff ff       	call   c0022be0 <lock_acquire>
c002cc9c:	83 c4 10             	add    $0x10,%esp
  msg ("High thread got the lock.");
c002cc9f:	83 ec 0c             	sub    $0xc,%esp
c002cca2:	68 63 22 03 c0       	push   $0xc0032263
c002cca7:	e8 5d ee ff ff       	call   c002bb09 <msg>
c002ccac:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002ccaf:	83 ec 0c             	sub    $0xc,%esp
c002ccb2:	ff 75 f4             	pushl  -0xc(%ebp)
c002ccb5:	e8 67 60 ff ff       	call   c0022d21 <lock_release>
c002ccba:	83 c4 10             	add    $0x10,%esp
  msg ("High thread finished.");
c002ccbd:	83 ec 0c             	sub    $0xc,%esp
c002ccc0:	68 7d 22 03 c0       	push   $0xc003227d
c002ccc5:	e8 3f ee ff ff       	call   c002bb09 <msg>
c002ccca:	83 c4 10             	add    $0x10,%esp
}
c002cccd:	90                   	nop
c002ccce:	c9                   	leave  
c002cccf:	c3                   	ret    

c002ccd0 <test_priority_donate_sema>:
static thread_func m_thread_func;
static thread_func h_thread_func;

void
test_priority_donate_sema (void) 
{
c002ccd0:	55                   	push   %ebp
c002ccd1:	89 e5                	mov    %esp,%ebp
c002ccd3:	83 ec 38             	sub    $0x38,%esp
  struct lock_and_sema ls;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002ccd6:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002ccdd:	83 f0 01             	xor    $0x1,%eax
c002cce0:	84 c0                	test   %al,%al
c002cce2:	75 1e                	jne    c002cd02 <test_priority_donate_sema+0x32>
c002cce4:	83 ec 0c             	sub    $0xc,%esp
c002cce7:	68 b0 22 03 c0       	push   $0xc00322b0
c002ccec:	68 be 22 03 c0       	push   $0xc00322be
c002ccf1:	68 d4 23 03 c0       	push   $0xc00323d4
c002ccf6:	6a 23                	push   $0x23
c002ccf8:	68 d8 22 03 c0       	push   $0xc00322d8
c002ccfd:	e8 76 ca ff ff       	call   c0029778 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cd02:	e8 b3 42 ff ff       	call   c0020fba <thread_get_priority>
c002cd07:	83 f8 1f             	cmp    $0x1f,%eax
c002cd0a:	74 1e                	je     c002cd2a <test_priority_donate_sema+0x5a>
c002cd0c:	83 ec 0c             	sub    $0xc,%esp
c002cd0f:	68 04 23 03 c0       	push   $0xc0032304
c002cd14:	68 be 22 03 c0       	push   $0xc00322be
c002cd19:	68 d4 23 03 c0       	push   $0xc00323d4
c002cd1e:	6a 26                	push   $0x26
c002cd20:	68 d8 22 03 c0       	push   $0xc00322d8
c002cd25:	e8 4e ca ff ff       	call   c0029778 <debug_panic>

  lock_init (&ls.lock);
c002cd2a:	83 ec 0c             	sub    $0xc,%esp
c002cd2d:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cd30:	50                   	push   %eax
c002cd31:	e8 5d 5e ff ff       	call   c0022b93 <lock_init>
c002cd36:	83 c4 10             	add    $0x10,%esp
  sema_init (&ls.sema, 0);
c002cd39:	83 ec 08             	sub    $0x8,%esp
c002cd3c:	6a 00                	push   $0x0
c002cd3e:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cd41:	83 c0 18             	add    $0x18,%eax
c002cd44:	50                   	push   %eax
c002cd45:	e8 8e 5b ff ff       	call   c00228d8 <sema_init>
c002cd4a:	83 c4 10             	add    $0x10,%esp
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002cd4d:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cd50:	50                   	push   %eax
c002cd51:	68 ba cd 02 c0       	push   $0xc002cdba
c002cd56:	6a 20                	push   $0x20
c002cd58:	68 2a 23 03 c0       	push   $0xc003232a
c002cd5d:	e8 24 3e ff ff       	call   c0020b86 <thread_create>
c002cd62:	83 c4 10             	add    $0x10,%esp
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002cd65:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cd68:	50                   	push   %eax
c002cd69:	68 29 ce 02 c0       	push   $0xc002ce29
c002cd6e:	6a 22                	push   $0x22
c002cd70:	68 2e 23 03 c0       	push   $0xc003232e
c002cd75:	e8 0c 3e ff ff       	call   c0020b86 <thread_create>
c002cd7a:	83 c4 10             	add    $0x10,%esp
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002cd7d:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cd80:	50                   	push   %eax
c002cd81:	68 5a ce 02 c0       	push   $0xc002ce5a
c002cd86:	6a 24                	push   $0x24
c002cd88:	68 32 23 03 c0       	push   $0xc0032332
c002cd8d:	e8 f4 3d ff ff       	call   c0020b86 <thread_create>
c002cd92:	83 c4 10             	add    $0x10,%esp
  sema_up (&ls.sema);
c002cd95:	83 ec 0c             	sub    $0xc,%esp
c002cd98:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cd9b:	83 c0 18             	add    $0x18,%eax
c002cd9e:	50                   	push   %eax
c002cd9f:	e8 86 5c ff ff       	call   c0022a2a <sema_up>
c002cda4:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread finished.");
c002cda7:	83 ec 0c             	sub    $0xc,%esp
c002cdaa:	68 37 23 03 c0       	push   $0xc0032337
c002cdaf:	e8 55 ed ff ff       	call   c002bb09 <msg>
c002cdb4:	83 c4 10             	add    $0x10,%esp
}
c002cdb7:	90                   	nop
c002cdb8:	c9                   	leave  
c002cdb9:	c3                   	ret    

c002cdba <l_thread_func>:

static void
l_thread_func (void *ls_) 
{
c002cdba:	55                   	push   %ebp
c002cdbb:	89 e5                	mov    %esp,%ebp
c002cdbd:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002cdc0:	8b 45 08             	mov    0x8(%ebp),%eax
c002cdc3:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002cdc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cdc9:	83 ec 0c             	sub    $0xc,%esp
c002cdcc:	50                   	push   %eax
c002cdcd:	e8 0e 5e ff ff       	call   c0022be0 <lock_acquire>
c002cdd2:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L acquired lock.");
c002cdd5:	83 ec 0c             	sub    $0xc,%esp
c002cdd8:	68 4d 23 03 c0       	push   $0xc003234d
c002cddd:	e8 27 ed ff ff       	call   c002bb09 <msg>
c002cde2:	83 c4 10             	add    $0x10,%esp
  sema_down (&ls->sema);
c002cde5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cde8:	83 c0 18             	add    $0x18,%eax
c002cdeb:	83 ec 0c             	sub    $0xc,%esp
c002cdee:	50                   	push   %eax
c002cdef:	e8 2b 5b ff ff       	call   c002291f <sema_down>
c002cdf4:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L downed semaphore.");
c002cdf7:	83 ec 0c             	sub    $0xc,%esp
c002cdfa:	68 65 23 03 c0       	push   $0xc0032365
c002cdff:	e8 05 ed ff ff       	call   c002bb09 <msg>
c002ce04:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002ce07:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ce0a:	83 ec 0c             	sub    $0xc,%esp
c002ce0d:	50                   	push   %eax
c002ce0e:	e8 0e 5f ff ff       	call   c0022d21 <lock_release>
c002ce13:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L finished.");
c002ce16:	83 ec 0c             	sub    $0xc,%esp
c002ce19:	68 80 23 03 c0       	push   $0xc0032380
c002ce1e:	e8 e6 ec ff ff       	call   c002bb09 <msg>
c002ce23:	83 c4 10             	add    $0x10,%esp
}
c002ce26:	90                   	nop
c002ce27:	c9                   	leave  
c002ce28:	c3                   	ret    

c002ce29 <m_thread_func>:

static void
m_thread_func (void *ls_) 
{
c002ce29:	55                   	push   %ebp
c002ce2a:	89 e5                	mov    %esp,%ebp
c002ce2c:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002ce2f:	8b 45 08             	mov    0x8(%ebp),%eax
c002ce32:	89 45 f4             	mov    %eax,-0xc(%ebp)

  sema_down (&ls->sema);
c002ce35:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ce38:	83 c0 18             	add    $0x18,%eax
c002ce3b:	83 ec 0c             	sub    $0xc,%esp
c002ce3e:	50                   	push   %eax
c002ce3f:	e8 db 5a ff ff       	call   c002291f <sema_down>
c002ce44:	83 c4 10             	add    $0x10,%esp
  msg ("Thread M finished.");
c002ce47:	83 ec 0c             	sub    $0xc,%esp
c002ce4a:	68 93 23 03 c0       	push   $0xc0032393
c002ce4f:	e8 b5 ec ff ff       	call   c002bb09 <msg>
c002ce54:	83 c4 10             	add    $0x10,%esp
}
c002ce57:	90                   	nop
c002ce58:	c9                   	leave  
c002ce59:	c3                   	ret    

c002ce5a <h_thread_func>:

static void
h_thread_func (void *ls_) 
{
c002ce5a:	55                   	push   %ebp
c002ce5b:	89 e5                	mov    %esp,%ebp
c002ce5d:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002ce60:	8b 45 08             	mov    0x8(%ebp),%eax
c002ce63:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002ce66:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ce69:	83 ec 0c             	sub    $0xc,%esp
c002ce6c:	50                   	push   %eax
c002ce6d:	e8 6e 5d ff ff       	call   c0022be0 <lock_acquire>
c002ce72:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H acquired lock.");
c002ce75:	83 ec 0c             	sub    $0xc,%esp
c002ce78:	68 a6 23 03 c0       	push   $0xc00323a6
c002ce7d:	e8 87 ec ff ff       	call   c002bb09 <msg>
c002ce82:	83 c4 10             	add    $0x10,%esp

  sema_up (&ls->sema);
c002ce85:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ce88:	83 c0 18             	add    $0x18,%eax
c002ce8b:	83 ec 0c             	sub    $0xc,%esp
c002ce8e:	50                   	push   %eax
c002ce8f:	e8 96 5b ff ff       	call   c0022a2a <sema_up>
c002ce94:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002ce97:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ce9a:	83 ec 0c             	sub    $0xc,%esp
c002ce9d:	50                   	push   %eax
c002ce9e:	e8 7e 5e ff ff       	call   c0022d21 <lock_release>
c002cea3:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H finished.");
c002cea6:	83 ec 0c             	sub    $0xc,%esp
c002cea9:	68 be 23 03 c0       	push   $0xc00323be
c002ceae:	e8 56 ec ff ff       	call   c002bb09 <msg>
c002ceb3:	83 c4 10             	add    $0x10,%esp
}
c002ceb6:	90                   	nop
c002ceb7:	c9                   	leave  
c002ceb8:	c3                   	ret    

c002ceb9 <test_priority_donate_lower>:

static thread_func acquire_thread_func;

void
test_priority_donate_lower (void) 
{
c002ceb9:	55                   	push   %ebp
c002ceba:	89 e5                	mov    %esp,%ebp
c002cebc:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cebf:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002cec6:	83 f0 01             	xor    $0x1,%eax
c002cec9:	84 c0                	test   %al,%al
c002cecb:	75 1e                	jne    c002ceeb <test_priority_donate_lower+0x32>
c002cecd:	83 ec 0c             	sub    $0xc,%esp
c002ced0:	68 f0 23 03 c0       	push   $0xc00323f0
c002ced5:	68 fe 23 03 c0       	push   $0xc00323fe
c002ceda:	68 14 25 03 c0       	push   $0xc0032514
c002cedf:	6a 15                	push   $0x15
c002cee1:	68 18 24 03 c0       	push   $0xc0032418
c002cee6:	e8 8d c8 ff ff       	call   c0029778 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002ceeb:	e8 ca 40 ff ff       	call   c0020fba <thread_get_priority>
c002cef0:	83 f8 1f             	cmp    $0x1f,%eax
c002cef3:	74 1e                	je     c002cf13 <test_priority_donate_lower+0x5a>
c002cef5:	83 ec 0c             	sub    $0xc,%esp
c002cef8:	68 44 24 03 c0       	push   $0xc0032444
c002cefd:	68 fe 23 03 c0       	push   $0xc00323fe
c002cf02:	68 14 25 03 c0       	push   $0xc0032514
c002cf07:	6a 18                	push   $0x18
c002cf09:	68 18 24 03 c0       	push   $0xc0032418
c002cf0e:	e8 65 c8 ff ff       	call   c0029778 <debug_panic>

  lock_init (&lock);
c002cf13:	83 ec 0c             	sub    $0xc,%esp
c002cf16:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cf19:	50                   	push   %eax
c002cf1a:	e8 74 5c ff ff       	call   c0022b93 <lock_init>
c002cf1f:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002cf22:	83 ec 0c             	sub    $0xc,%esp
c002cf25:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cf28:	50                   	push   %eax
c002cf29:	e8 b2 5c ff ff       	call   c0022be0 <lock_acquire>
c002cf2e:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002cf31:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cf34:	50                   	push   %eax
c002cf35:	68 d0 cf 02 c0       	push   $0xc002cfd0
c002cf3a:	6a 29                	push   $0x29
c002cf3c:	68 6a 24 03 c0       	push   $0xc003246a
c002cf41:	e8 40 3c ff ff       	call   c0020b86 <thread_create>
c002cf46:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cf49:	e8 6c 40 ff ff       	call   c0020fba <thread_get_priority>
c002cf4e:	83 ec 04             	sub    $0x4,%esp
c002cf51:	50                   	push   %eax
c002cf52:	6a 29                	push   $0x29
c002cf54:	68 74 24 03 c0       	push   $0xc0032474
c002cf59:	e8 ab eb ff ff       	call   c002bb09 <msg>
c002cf5e:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());

  msg ("Lowering base priority...");
c002cf61:	83 ec 0c             	sub    $0xc,%esp
c002cf64:	68 af 24 03 c0       	push   $0xc00324af
c002cf69:	e8 9b eb ff ff       	call   c002bb09 <msg>
c002cf6e:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 10);
c002cf71:	83 ec 0c             	sub    $0xc,%esp
c002cf74:	6a 15                	push   $0x15
c002cf76:	e8 29 40 ff ff       	call   c0020fa4 <thread_set_priority>
c002cf7b:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cf7e:	e8 37 40 ff ff       	call   c0020fba <thread_get_priority>
c002cf83:	83 ec 04             	sub    $0x4,%esp
c002cf86:	50                   	push   %eax
c002cf87:	6a 29                	push   $0x29
c002cf89:	68 74 24 03 c0       	push   $0xc0032474
c002cf8e:	e8 76 eb ff ff       	call   c002bb09 <msg>
c002cf93:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());
  lock_release (&lock);
c002cf96:	83 ec 0c             	sub    $0xc,%esp
c002cf99:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cf9c:	50                   	push   %eax
c002cf9d:	e8 7f 5d ff ff       	call   c0022d21 <lock_release>
c002cfa2:	83 c4 10             	add    $0x10,%esp
  msg ("acquire must already have finished.");
c002cfa5:	83 ec 0c             	sub    $0xc,%esp
c002cfa8:	68 cc 24 03 c0       	push   $0xc00324cc
c002cfad:	e8 57 eb ff ff       	call   c002bb09 <msg>
c002cfb2:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cfb5:	e8 00 40 ff ff       	call   c0020fba <thread_get_priority>
c002cfba:	83 ec 04             	sub    $0x4,%esp
c002cfbd:	50                   	push   %eax
c002cfbe:	6a 15                	push   $0x15
c002cfc0:	68 74 24 03 c0       	push   $0xc0032474
c002cfc5:	e8 3f eb ff ff       	call   c002bb09 <msg>
c002cfca:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT - 10, thread_get_priority ());
}
c002cfcd:	90                   	nop
c002cfce:	c9                   	leave  
c002cfcf:	c3                   	ret    

c002cfd0 <acquire_thread_func>:

static void
acquire_thread_func (void *lock_) 
{
c002cfd0:	55                   	push   %ebp
c002cfd1:	89 e5                	mov    %esp,%ebp
c002cfd3:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002cfd6:	8b 45 08             	mov    0x8(%ebp),%eax
c002cfd9:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002cfdc:	83 ec 0c             	sub    $0xc,%esp
c002cfdf:	ff 75 f4             	pushl  -0xc(%ebp)
c002cfe2:	e8 f9 5b ff ff       	call   c0022be0 <lock_acquire>
c002cfe7:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: got the lock");
c002cfea:	83 ec 0c             	sub    $0xc,%esp
c002cfed:	68 f0 24 03 c0       	push   $0xc00324f0
c002cff2:	e8 12 eb ff ff       	call   c002bb09 <msg>
c002cff7:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cffa:	83 ec 0c             	sub    $0xc,%esp
c002cffd:	ff 75 f4             	pushl  -0xc(%ebp)
c002d000:	e8 1c 5d ff ff       	call   c0022d21 <lock_release>
c002d005:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: done");
c002d008:	83 ec 0c             	sub    $0xc,%esp
c002d00b:	68 06 25 03 c0       	push   $0xc0032506
c002d010:	e8 f4 ea ff ff       	call   c002bb09 <msg>
c002d015:	83 c4 10             	add    $0x10,%esp
}
c002d018:	90                   	nop
c002d019:	c9                   	leave  
c002d01a:	c3                   	ret    

c002d01b <test_priority_fifo>:

static thread_func simple_thread_func;

void
test_priority_fifo (void) 
{
c002d01b:	55                   	push   %ebp
c002d01c:	89 e5                	mov    %esp,%ebp
c002d01e:	81 ec 48 01 00 00    	sub    $0x148,%esp
  struct lock lock;
  int *output, *op;
  int i, cnt;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d024:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002d02b:	83 f0 01             	xor    $0x1,%eax
c002d02e:	84 c0                	test   %al,%al
c002d030:	75 1e                	jne    c002d050 <test_priority_fifo+0x35>
c002d032:	83 ec 0c             	sub    $0xc,%esp
c002d035:	68 30 25 03 c0       	push   $0xc0032530
c002d03a:	68 3e 25 03 c0       	push   $0xc003253e
c002d03f:	68 78 26 03 c0       	push   $0xc0032678
c002d044:	6a 28                	push   $0x28
c002d046:	68 58 25 03 c0       	push   $0xc0032558
c002d04b:	e8 28 c7 ff ff       	call   c0029778 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d050:	e8 65 3f ff ff       	call   c0020fba <thread_get_priority>
c002d055:	83 f8 1f             	cmp    $0x1f,%eax
c002d058:	74 1e                	je     c002d078 <test_priority_fifo+0x5d>
c002d05a:	83 ec 0c             	sub    $0xc,%esp
c002d05d:	68 7c 25 03 c0       	push   $0xc003257c
c002d062:	68 3e 25 03 c0       	push   $0xc003253e
c002d067:	68 78 26 03 c0       	push   $0xc0032678
c002d06c:	6a 2b                	push   $0x2b
c002d06e:	68 58 25 03 c0       	push   $0xc0032558
c002d073:	e8 00 c7 ff ff       	call   c0029778 <debug_panic>

  msg ("%d threads will iterate %d times in the same order each time.",
c002d078:	83 ec 04             	sub    $0x4,%esp
c002d07b:	6a 10                	push   $0x10
c002d07d:	6a 10                	push   $0x10
c002d07f:	68 a4 25 03 c0       	push   $0xc00325a4
c002d084:	e8 80 ea ff ff       	call   c002bb09 <msg>
c002d089:	83 c4 10             	add    $0x10,%esp
       THREAD_CNT, ITER_CNT);
  msg ("If the order varies then there is a bug.");
c002d08c:	83 ec 0c             	sub    $0xc,%esp
c002d08f:	68 e4 25 03 c0       	push   $0xc00325e4
c002d094:	e8 70 ea ff ff       	call   c002bb09 <msg>
c002d099:	83 c4 10             	add    $0x10,%esp

  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002d09c:	83 ec 0c             	sub    $0xc,%esp
c002d09f:	68 00 08 00 00       	push   $0x800
c002d0a4:	e8 00 65 ff ff       	call   c00235a9 <malloc>
c002d0a9:	83 c4 10             	add    $0x10,%esp
c002d0ac:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
c002d0b2:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
c002d0b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (output != NULL);
c002d0bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d0bf:	75 1e                	jne    c002d0df <test_priority_fifo+0xc4>
c002d0c1:	83 ec 0c             	sub    $0xc,%esp
c002d0c4:	68 0d 26 03 c0       	push   $0xc003260d
c002d0c9:	68 3e 25 03 c0       	push   $0xc003253e
c002d0ce:	68 78 26 03 c0       	push   $0xc0032678
c002d0d3:	6a 32                	push   $0x32
c002d0d5:	68 58 25 03 c0       	push   $0xc0032558
c002d0da:	e8 99 c6 ff ff       	call   c0029778 <debug_panic>
  lock_init (&lock);
c002d0df:	83 ec 0c             	sub    $0xc,%esp
c002d0e2:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
c002d0e8:	50                   	push   %eax
c002d0e9:	e8 a5 5a ff ff       	call   c0022b93 <lock_init>
c002d0ee:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_DEFAULT + 2);
c002d0f1:	83 ec 0c             	sub    $0xc,%esp
c002d0f4:	6a 21                	push   $0x21
c002d0f6:	e8 a9 3e ff ff       	call   c0020fa4 <thread_set_priority>
c002d0fb:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002d0fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002d105:	eb 73                	jmp    c002d17a <test_priority_fifo+0x15f>
    {
      char name[16];
      struct simple_thread_data *d = data + i;
c002d107:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d10a:	c1 e0 04             	shl    $0x4,%eax
c002d10d:	89 c2                	mov    %eax,%edx
c002d10f:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002d115:	01 d0                	add    %edx,%eax
c002d117:	89 45 e8             	mov    %eax,-0x18(%ebp)
      snprintf (name, sizeof name, "%d", i);
c002d11a:	ff 75 f0             	pushl  -0x10(%ebp)
c002d11d:	68 1c 26 03 c0       	push   $0xc003261c
c002d122:	6a 10                	push   $0x10
c002d124:	8d 85 b8 fe ff ff    	lea    -0x148(%ebp),%eax
c002d12a:	50                   	push   %eax
c002d12b:	e8 ec a1 ff ff       	call   c002731c <snprintf>
c002d130:	83 c4 10             	add    $0x10,%esp
      d->id = i;
c002d133:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d136:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002d139:	89 10                	mov    %edx,(%eax)
      d->iterations = 0;
c002d13b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d13e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      d->lock = &lock;
c002d145:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d148:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
c002d14e:	89 50 08             	mov    %edx,0x8(%eax)
      d->op = &op;
c002d151:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d154:	8d 95 c8 fe ff ff    	lea    -0x138(%ebp),%edx
c002d15a:	89 50 0c             	mov    %edx,0xc(%eax)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002d15d:	ff 75 e8             	pushl  -0x18(%ebp)
c002d160:	68 77 d2 02 c0       	push   $0xc002d277
c002d165:	6a 20                	push   $0x20
c002d167:	8d 85 b8 fe ff ff    	lea    -0x148(%ebp),%eax
c002d16d:	50                   	push   %eax
c002d16e:	e8 13 3a ff ff       	call   c0020b86 <thread_create>
c002d173:	83 c4 10             	add    $0x10,%esp
  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
  ASSERT (output != NULL);
  lock_init (&lock);

  thread_set_priority (PRI_DEFAULT + 2);
  for (i = 0; i < THREAD_CNT; i++) 
c002d176:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002d17a:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
c002d17e:	7e 87                	jle    c002d107 <test_priority_fifo+0xec>
      d->lock = &lock;
      d->op = &op;
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
    }

  thread_set_priority (PRI_DEFAULT);
c002d180:	83 ec 0c             	sub    $0xc,%esp
c002d183:	6a 1f                	push   $0x1f
c002d185:	e8 1a 3e ff ff       	call   c0020fa4 <thread_set_priority>
c002d18a:	83 c4 10             	add    $0x10,%esp
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);
c002d18d:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
c002d193:	85 c0                	test   %eax,%eax
c002d195:	74 1e                	je     c002d1b5 <test_priority_fifo+0x19a>
c002d197:	83 ec 0c             	sub    $0xc,%esp
c002d19a:	68 1f 26 03 c0       	push   $0xc003261f
c002d19f:	68 3e 25 03 c0       	push   $0xc003253e
c002d1a4:	68 78 26 03 c0       	push   $0xc0032678
c002d1a9:	6a 44                	push   $0x44
c002d1ab:	68 58 25 03 c0       	push   $0xc0032558
c002d1b0:	e8 c3 c5 ff ff       	call   c0029778 <debug_panic>

  cnt = 0;
c002d1b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  for (; output < op; output++) 
c002d1bc:	e9 a4 00 00 00       	jmp    c002d265 <test_priority_fifo+0x24a>
    {
      struct simple_thread_data *d;

      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002d1c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d1c4:	8b 00                	mov    (%eax),%eax
c002d1c6:	85 c0                	test   %eax,%eax
c002d1c8:	78 0a                	js     c002d1d4 <test_priority_fifo+0x1b9>
c002d1ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d1cd:	8b 00                	mov    (%eax),%eax
c002d1cf:	83 f8 0f             	cmp    $0xf,%eax
c002d1d2:	7e 1e                	jle    c002d1f2 <test_priority_fifo+0x1d7>
c002d1d4:	83 ec 0c             	sub    $0xc,%esp
c002d1d7:	68 34 26 03 c0       	push   $0xc0032634
c002d1dc:	68 3e 25 03 c0       	push   $0xc003253e
c002d1e1:	68 78 26 03 c0       	push   $0xc0032678
c002d1e6:	6a 4b                	push   $0x4b
c002d1e8:	68 58 25 03 c0       	push   $0xc0032558
c002d1ed:	e8 86 c5 ff ff       	call   c0029778 <debug_panic>
      d = data + *output;
c002d1f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d1f5:	8b 00                	mov    (%eax),%eax
c002d1f7:	c1 e0 04             	shl    $0x4,%eax
c002d1fa:	89 c2                	mov    %eax,%edx
c002d1fc:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002d202:	01 d0                	add    %edx,%eax
c002d204:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if (cnt % THREAD_CNT == 0)
c002d207:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d20a:	83 e0 0f             	and    $0xf,%eax
c002d20d:	85 c0                	test   %eax,%eax
c002d20f:	75 10                	jne    c002d221 <test_priority_fifo+0x206>
        printf ("(priority-fifo) iteration:");
c002d211:	83 ec 0c             	sub    $0xc,%esp
c002d214:	68 59 26 03 c0       	push   $0xc0032659
c002d219:	e8 27 a1 ff ff       	call   c0027345 <printf>
c002d21e:	83 c4 10             	add    $0x10,%esp
      printf (" %d", d->id);
c002d221:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d224:	8b 00                	mov    (%eax),%eax
c002d226:	83 ec 08             	sub    $0x8,%esp
c002d229:	50                   	push   %eax
c002d22a:	68 74 26 03 c0       	push   $0xc0032674
c002d22f:	e8 11 a1 ff ff       	call   c0027345 <printf>
c002d234:	83 c4 10             	add    $0x10,%esp
      if (++cnt % THREAD_CNT == 0)
c002d237:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002d23b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d23e:	83 e0 0f             	and    $0xf,%eax
c002d241:	85 c0                	test   %eax,%eax
c002d243:	75 0d                	jne    c002d252 <test_priority_fifo+0x237>
        printf ("\n");
c002d245:	83 ec 0c             	sub    $0xc,%esp
c002d248:	6a 0a                	push   $0xa
c002d24a:	e8 64 e7 ff ff       	call   c002b9b3 <putchar>
c002d24f:	83 c4 10             	add    $0x10,%esp
      d->iterations++;
c002d252:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d255:	8b 40 04             	mov    0x4(%eax),%eax
c002d258:	8d 50 01             	lea    0x1(%eax),%edx
c002d25b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d25e:	89 50 04             	mov    %edx,0x4(%eax)
  thread_set_priority (PRI_DEFAULT);
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);

  cnt = 0;
  for (; output < op; output++) 
c002d261:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002d265:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
c002d26b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002d26e:	0f 82 4d ff ff ff    	jb     c002d1c1 <test_priority_fifo+0x1a6>
      printf (" %d", d->id);
      if (++cnt % THREAD_CNT == 0)
        printf ("\n");
      d->iterations++;
    }
}
c002d274:	90                   	nop
c002d275:	c9                   	leave  
c002d276:	c3                   	ret    

c002d277 <simple_thread_func>:

static void 
simple_thread_func (void *data_) 
{
c002d277:	55                   	push   %ebp
c002d278:	89 e5                	mov    %esp,%ebp
c002d27a:	83 ec 18             	sub    $0x18,%esp
  struct simple_thread_data *data = data_;
c002d27d:	8b 45 08             	mov    0x8(%ebp),%eax
c002d280:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002d283:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d28a:	eb 41                	jmp    c002d2cd <simple_thread_func+0x56>
    {
      lock_acquire (data->lock);
c002d28c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d28f:	8b 40 08             	mov    0x8(%eax),%eax
c002d292:	83 ec 0c             	sub    $0xc,%esp
c002d295:	50                   	push   %eax
c002d296:	e8 45 59 ff ff       	call   c0022be0 <lock_acquire>
c002d29b:	83 c4 10             	add    $0x10,%esp
      *(*data->op)++ = data->id;
c002d29e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d2a1:	8b 50 0c             	mov    0xc(%eax),%edx
c002d2a4:	8b 02                	mov    (%edx),%eax
c002d2a6:	8d 48 04             	lea    0x4(%eax),%ecx
c002d2a9:	89 0a                	mov    %ecx,(%edx)
c002d2ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002d2ae:	8b 12                	mov    (%edx),%edx
c002d2b0:	89 10                	mov    %edx,(%eax)
      lock_release (data->lock);
c002d2b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d2b5:	8b 40 08             	mov    0x8(%eax),%eax
c002d2b8:	83 ec 0c             	sub    $0xc,%esp
c002d2bb:	50                   	push   %eax
c002d2bc:	e8 60 5a ff ff       	call   c0022d21 <lock_release>
c002d2c1:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002d2c4:	e8 cc 3b ff ff       	call   c0020e95 <thread_yield>
simple_thread_func (void *data_) 
{
  struct simple_thread_data *data = data_;
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002d2c9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d2cd:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
c002d2d1:	7e b9                	jle    c002d28c <simple_thread_func+0x15>
      lock_acquire (data->lock);
      *(*data->op)++ = data->id;
      lock_release (data->lock);
      thread_yield ();
    }
}
c002d2d3:	90                   	nop
c002d2d4:	c9                   	leave  
c002d2d5:	c3                   	ret    

c002d2d6 <test_priority_preempt>:

static thread_func simple_thread_func;

void
test_priority_preempt (void) 
{
c002d2d6:	55                   	push   %ebp
c002d2d7:	89 e5                	mov    %esp,%ebp
c002d2d9:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d2dc:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002d2e3:	83 f0 01             	xor    $0x1,%eax
c002d2e6:	84 c0                	test   %al,%al
c002d2e8:	75 1e                	jne    c002d308 <test_priority_preempt+0x32>
c002d2ea:	83 ec 0c             	sub    $0xc,%esp
c002d2ed:	68 8c 26 03 c0       	push   $0xc003268c
c002d2f2:	68 9a 26 03 c0       	push   $0xc003269a
c002d2f7:	68 70 27 03 c0       	push   $0xc0032770
c002d2fc:	6a 15                	push   $0x15
c002d2fe:	68 b4 26 03 c0       	push   $0xc00326b4
c002d303:	e8 70 c4 ff ff       	call   c0029778 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d308:	e8 ad 3c ff ff       	call   c0020fba <thread_get_priority>
c002d30d:	83 f8 1f             	cmp    $0x1f,%eax
c002d310:	74 1e                	je     c002d330 <test_priority_preempt+0x5a>
c002d312:	83 ec 0c             	sub    $0xc,%esp
c002d315:	68 dc 26 03 c0       	push   $0xc00326dc
c002d31a:	68 9a 26 03 c0       	push   $0xc003269a
c002d31f:	68 70 27 03 c0       	push   $0xc0032770
c002d324:	6a 18                	push   $0x18
c002d326:	68 b4 26 03 c0       	push   $0xc00326b4
c002d32b:	e8 48 c4 ff ff       	call   c0029778 <debug_panic>

  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002d330:	6a 00                	push   $0x0
c002d332:	68 59 d3 02 c0       	push   $0xc002d359
c002d337:	6a 20                	push   $0x20
c002d339:	68 02 27 03 c0       	push   $0xc0032702
c002d33e:	e8 43 38 ff ff       	call   c0020b86 <thread_create>
c002d343:	83 c4 10             	add    $0x10,%esp
  msg ("The high-priority thread should have already completed.");
c002d346:	83 ec 0c             	sub    $0xc,%esp
c002d349:	68 10 27 03 c0       	push   $0xc0032710
c002d34e:	e8 b6 e7 ff ff       	call   c002bb09 <msg>
c002d353:	83 c4 10             	add    $0x10,%esp
}
c002d356:	90                   	nop
c002d357:	c9                   	leave  
c002d358:	c3                   	ret    

c002d359 <simple_thread_func>:

static void 
simple_thread_func (void *aux UNUSED) 
{
c002d359:	55                   	push   %ebp
c002d35a:	89 e5                	mov    %esp,%ebp
c002d35c:	83 ec 18             	sub    $0x18,%esp
  int i;
  
  for (i = 0; i < 5; i++) 
c002d35f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d366:	eb 22                	jmp    c002d38a <simple_thread_func+0x31>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002d368:	e8 22 3a ff ff       	call   c0020d8f <thread_name>
c002d36d:	83 ec 04             	sub    $0x4,%esp
c002d370:	ff 75 f4             	pushl  -0xc(%ebp)
c002d373:	50                   	push   %eax
c002d374:	68 48 27 03 c0       	push   $0xc0032748
c002d379:	e8 8b e7 ff ff       	call   c002bb09 <msg>
c002d37e:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002d381:	e8 0f 3b ff ff       	call   c0020e95 <thread_yield>
static void 
simple_thread_func (void *aux UNUSED) 
{
  int i;
  
  for (i = 0; i < 5; i++) 
c002d386:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d38a:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c002d38e:	7e d8                	jle    c002d368 <simple_thread_func+0xf>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
      thread_yield ();
    }
  msg ("Thread %s done!", thread_name ());
c002d390:	e8 fa 39 ff ff       	call   c0020d8f <thread_name>
c002d395:	83 ec 08             	sub    $0x8,%esp
c002d398:	50                   	push   %eax
c002d399:	68 5f 27 03 c0       	push   $0xc003275f
c002d39e:	e8 66 e7 ff ff       	call   c002bb09 <msg>
c002d3a3:	83 c4 10             	add    $0x10,%esp
}
c002d3a6:	90                   	nop
c002d3a7:	c9                   	leave  
c002d3a8:	c3                   	ret    

c002d3a9 <test_priority_sema>:
static thread_func priority_sema_thread;
static struct semaphore sema;

void
test_priority_sema (void) 
{
c002d3a9:	55                   	push   %ebp
c002d3aa:	89 e5                	mov    %esp,%ebp
c002d3ac:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d3af:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002d3b6:	83 f0 01             	xor    $0x1,%eax
c002d3b9:	84 c0                	test   %al,%al
c002d3bb:	75 1e                	jne    c002d3db <test_priority_sema+0x32>
c002d3bd:	83 ec 0c             	sub    $0xc,%esp
c002d3c0:	68 88 27 03 c0       	push   $0xc0032788
c002d3c5:	68 96 27 03 c0       	push   $0xc0032796
c002d3ca:	68 08 28 03 c0       	push   $0xc0032808
c002d3cf:	6a 15                	push   $0x15
c002d3d1:	68 b0 27 03 c0       	push   $0xc00327b0
c002d3d6:	e8 9d c3 ff ff       	call   c0029778 <debug_panic>

  sema_init (&sema, 0);
c002d3db:	83 ec 08             	sub    $0x8,%esp
c002d3de:	6a 00                	push   $0x0
c002d3e0:	68 74 9c 03 c0       	push   $0xc0039c74
c002d3e5:	e8 ee 54 ff ff       	call   c00228d8 <sema_init>
c002d3ea:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_MIN);
c002d3ed:	83 ec 0c             	sub    $0xc,%esp
c002d3f0:	6a 00                	push   $0x0
c002d3f2:	e8 ad 3b ff ff       	call   c0020fa4 <thread_set_priority>
c002d3f7:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d3fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d401:	eb 60                	jmp    c002d463 <test_priority_sema+0xba>
    {
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002d403:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d406:	8d 48 03             	lea    0x3(%eax),%ecx
c002d409:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002d40e:	89 c8                	mov    %ecx,%eax
c002d410:	f7 ea                	imul   %edx
c002d412:	c1 fa 02             	sar    $0x2,%edx
c002d415:	89 c8                	mov    %ecx,%eax
c002d417:	c1 f8 1f             	sar    $0x1f,%eax
c002d41a:	29 c2                	sub    %eax,%edx
c002d41c:	89 d0                	mov    %edx,%eax
c002d41e:	c1 e0 02             	shl    $0x2,%eax
c002d421:	01 d0                	add    %edx,%eax
c002d423:	01 c0                	add    %eax,%eax
c002d425:	29 c1                	sub    %eax,%ecx
c002d427:	89 ca                	mov    %ecx,%edx
c002d429:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002d42e:	29 d0                	sub    %edx,%eax
c002d430:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002d433:	ff 75 f0             	pushl  -0x10(%ebp)
c002d436:	68 d4 27 03 c0       	push   $0xc00327d4
c002d43b:	6a 10                	push   $0x10
c002d43d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d440:	50                   	push   %eax
c002d441:	e8 d6 9e ff ff       	call   c002731c <snprintf>
c002d446:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_sema_thread, NULL);
c002d449:	6a 00                	push   $0x0
c002d44b:	68 9f d4 02 c0       	push   $0xc002d49f
c002d450:	ff 75 f0             	pushl  -0x10(%ebp)
c002d453:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d456:	50                   	push   %eax
c002d457:	e8 2a 37 ff ff       	call   c0020b86 <thread_create>
c002d45c:	83 c4 10             	add    $0x10,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);

  sema_init (&sema, 0);
  thread_set_priority (PRI_MIN);
  for (i = 0; i < 10; i++) 
c002d45f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d463:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d467:	7e 9a                	jle    c002d403 <test_priority_sema+0x5a>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_sema_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002d469:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d470:	eb 24                	jmp    c002d496 <test_priority_sema+0xed>
    {
      sema_up (&sema);
c002d472:	83 ec 0c             	sub    $0xc,%esp
c002d475:	68 74 9c 03 c0       	push   $0xc0039c74
c002d47a:	e8 ab 55 ff ff       	call   c0022a2a <sema_up>
c002d47f:	83 c4 10             	add    $0x10,%esp
      msg ("Back in main thread."); 
c002d482:	83 ec 0c             	sub    $0xc,%esp
c002d485:	68 e0 27 03 c0       	push   $0xc00327e0
c002d48a:	e8 7a e6 ff ff       	call   c002bb09 <msg>
c002d48f:	83 c4 10             	add    $0x10,%esp
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_sema_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002d492:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d496:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d49a:	7e d6                	jle    c002d472 <test_priority_sema+0xc9>
    {
      sema_up (&sema);
      msg ("Back in main thread."); 
    }
}
c002d49c:	90                   	nop
c002d49d:	c9                   	leave  
c002d49e:	c3                   	ret    

c002d49f <priority_sema_thread>:

static void
priority_sema_thread (void *aux UNUSED) 
{
c002d49f:	55                   	push   %ebp
c002d4a0:	89 e5                	mov    %esp,%ebp
c002d4a2:	83 ec 08             	sub    $0x8,%esp
  sema_down (&sema);
c002d4a5:	83 ec 0c             	sub    $0xc,%esp
c002d4a8:	68 74 9c 03 c0       	push   $0xc0039c74
c002d4ad:	e8 6d 54 ff ff       	call   c002291f <sema_down>
c002d4b2:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002d4b5:	e8 d5 38 ff ff       	call   c0020d8f <thread_name>
c002d4ba:	83 ec 08             	sub    $0x8,%esp
c002d4bd:	50                   	push   %eax
c002d4be:	68 f5 27 03 c0       	push   $0xc00327f5
c002d4c3:	e8 41 e6 ff ff       	call   c002bb09 <msg>
c002d4c8:	83 c4 10             	add    $0x10,%esp
}
c002d4cb:	90                   	nop
c002d4cc:	c9                   	leave  
c002d4cd:	c3                   	ret    

c002d4ce <test_priority_condvar>:
static struct lock lock;
static struct condition condition;

void
test_priority_condvar (void) 
{
c002d4ce:	55                   	push   %ebp
c002d4cf:	89 e5                	mov    %esp,%ebp
c002d4d1:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d4d4:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002d4db:	83 f0 01             	xor    $0x1,%eax
c002d4de:	84 c0                	test   %al,%al
c002d4e0:	75 1e                	jne    c002d500 <test_priority_condvar+0x32>
c002d4e2:	83 ec 0c             	sub    $0xc,%esp
c002d4e5:	68 1c 28 03 c0       	push   $0xc003281c
c002d4ea:	68 2a 28 03 c0       	push   $0xc003282a
c002d4ef:	68 ac 28 03 c0       	push   $0xc00328ac
c002d4f4:	6a 16                	push   $0x16
c002d4f6:	68 44 28 03 c0       	push   $0xc0032844
c002d4fb:	e8 78 c2 ff ff       	call   c0029778 <debug_panic>

  lock_init (&lock);
c002d500:	83 ec 0c             	sub    $0xc,%esp
c002d503:	68 88 9c 03 c0       	push   $0xc0039c88
c002d508:	e8 86 56 ff ff       	call   c0022b93 <lock_init>
c002d50d:	83 c4 10             	add    $0x10,%esp
  cond_init (&condition);
c002d510:	83 ec 0c             	sub    $0xc,%esp
c002d513:	68 a0 9c 03 c0       	push   $0xc0039ca0
c002d518:	e8 c4 58 ff ff       	call   c0022de1 <cond_init>
c002d51d:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_MIN);
c002d520:	83 ec 0c             	sub    $0xc,%esp
c002d523:	6a 00                	push   $0x0
c002d525:	e8 7a 3a ff ff       	call   c0020fa4 <thread_set_priority>
c002d52a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d52d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d534:	eb 60                	jmp    c002d596 <test_priority_condvar+0xc8>
    {
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002d536:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d539:	8d 48 07             	lea    0x7(%eax),%ecx
c002d53c:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002d541:	89 c8                	mov    %ecx,%eax
c002d543:	f7 ea                	imul   %edx
c002d545:	c1 fa 02             	sar    $0x2,%edx
c002d548:	89 c8                	mov    %ecx,%eax
c002d54a:	c1 f8 1f             	sar    $0x1f,%eax
c002d54d:	29 c2                	sub    %eax,%edx
c002d54f:	89 d0                	mov    %edx,%eax
c002d551:	c1 e0 02             	shl    $0x2,%eax
c002d554:	01 d0                	add    %edx,%eax
c002d556:	01 c0                	add    %eax,%eax
c002d558:	29 c1                	sub    %eax,%ecx
c002d55a:	89 ca                	mov    %ecx,%edx
c002d55c:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002d561:	29 d0                	sub    %edx,%eax
c002d563:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002d566:	ff 75 f0             	pushl  -0x10(%ebp)
c002d569:	68 6b 28 03 c0       	push   $0xc003286b
c002d56e:	6a 10                	push   $0x10
c002d570:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d573:	50                   	push   %eax
c002d574:	e8 a3 9d ff ff       	call   c002731c <snprintf>
c002d579:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_condvar_thread, NULL);
c002d57c:	6a 00                	push   $0x0
c002d57e:	68 f7 d5 02 c0       	push   $0xc002d5f7
c002d583:	ff 75 f0             	pushl  -0x10(%ebp)
c002d586:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d589:	50                   	push   %eax
c002d58a:	e8 f7 35 ff ff       	call   c0020b86 <thread_create>
c002d58f:	83 c4 10             	add    $0x10,%esp

  lock_init (&lock);
  cond_init (&condition);

  thread_set_priority (PRI_MIN);
  for (i = 0; i < 10; i++) 
c002d592:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d596:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d59a:	7e 9a                	jle    c002d536 <test_priority_condvar+0x68>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_condvar_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002d59c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d5a3:	eb 49                	jmp    c002d5ee <test_priority_condvar+0x120>
    {
      lock_acquire (&lock);
c002d5a5:	83 ec 0c             	sub    $0xc,%esp
c002d5a8:	68 88 9c 03 c0       	push   $0xc0039c88
c002d5ad:	e8 2e 56 ff ff       	call   c0022be0 <lock_acquire>
c002d5b2:	83 c4 10             	add    $0x10,%esp
      msg ("Signaling...");
c002d5b5:	83 ec 0c             	sub    $0xc,%esp
c002d5b8:	68 77 28 03 c0       	push   $0xc0032877
c002d5bd:	e8 47 e5 ff ff       	call   c002bb09 <msg>
c002d5c2:	83 c4 10             	add    $0x10,%esp
      cond_signal (&condition, &lock);
c002d5c5:	83 ec 08             	sub    $0x8,%esp
c002d5c8:	68 88 9c 03 c0       	push   $0xc0039c88
c002d5cd:	68 a0 9c 03 c0       	push   $0xc0039ca0
c002d5d2:	e8 55 59 ff ff       	call   c0022f2c <cond_signal>
c002d5d7:	83 c4 10             	add    $0x10,%esp
      lock_release (&lock);
c002d5da:	83 ec 0c             	sub    $0xc,%esp
c002d5dd:	68 88 9c 03 c0       	push   $0xc0039c88
c002d5e2:	e8 3a 57 ff ff       	call   c0022d21 <lock_release>
c002d5e7:	83 c4 10             	add    $0x10,%esp
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_condvar_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002d5ea:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d5ee:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d5f2:	7e b1                	jle    c002d5a5 <test_priority_condvar+0xd7>
      lock_acquire (&lock);
      msg ("Signaling...");
      cond_signal (&condition, &lock);
      lock_release (&lock);
    }
}
c002d5f4:	90                   	nop
c002d5f5:	c9                   	leave  
c002d5f6:	c3                   	ret    

c002d5f7 <priority_condvar_thread>:

static void
priority_condvar_thread (void *aux UNUSED) 
{
c002d5f7:	55                   	push   %ebp
c002d5f8:	89 e5                	mov    %esp,%ebp
c002d5fa:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread %s starting.", thread_name ());
c002d5fd:	e8 8d 37 ff ff       	call   c0020d8f <thread_name>
c002d602:	83 ec 08             	sub    $0x8,%esp
c002d605:	50                   	push   %eax
c002d606:	68 84 28 03 c0       	push   $0xc0032884
c002d60b:	e8 f9 e4 ff ff       	call   c002bb09 <msg>
c002d610:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002d613:	83 ec 0c             	sub    $0xc,%esp
c002d616:	68 88 9c 03 c0       	push   $0xc0039c88
c002d61b:	e8 c0 55 ff ff       	call   c0022be0 <lock_acquire>
c002d620:	83 c4 10             	add    $0x10,%esp
  cond_wait (&condition, &lock);
c002d623:	83 ec 08             	sub    $0x8,%esp
c002d626:	68 88 9c 03 c0       	push   $0xc0039c88
c002d62b:	68 a0 9c 03 c0       	push   $0xc0039ca0
c002d630:	e8 eb 57 ff ff       	call   c0022e20 <cond_wait>
c002d635:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002d638:	e8 52 37 ff ff       	call   c0020d8f <thread_name>
c002d63d:	83 ec 08             	sub    $0x8,%esp
c002d640:	50                   	push   %eax
c002d641:	68 98 28 03 c0       	push   $0xc0032898
c002d646:	e8 be e4 ff ff       	call   c002bb09 <msg>
c002d64b:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002d64e:	83 ec 0c             	sub    $0xc,%esp
c002d651:	68 88 9c 03 c0       	push   $0xc0039c88
c002d656:	e8 c6 56 ff ff       	call   c0022d21 <lock_release>
c002d65b:	83 c4 10             	add    $0x10,%esp
}
c002d65e:	90                   	nop
c002d65f:	c9                   	leave  
c002d660:	c3                   	ret    

c002d661 <test_priority_donate_chain>:
static thread_func donor_thread_func;
static thread_func interloper_thread_func;

void
test_priority_donate_chain (void) 
{
c002d661:	55                   	push   %ebp
c002d662:	89 e5                	mov    %esp,%ebp
c002d664:	53                   	push   %ebx
c002d665:	81 ec 04 01 00 00    	sub    $0x104,%esp
  int i;  
  struct lock locks[NESTING_DEPTH - 1];
  struct lock_pair lock_pairs[NESTING_DEPTH];

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d66b:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002d672:	83 f0 01             	xor    $0x1,%eax
c002d675:	84 c0                	test   %al,%al
c002d677:	75 1e                	jne    c002d697 <test_priority_donate_chain+0x36>
c002d679:	83 ec 0c             	sub    $0xc,%esp
c002d67c:	68 c4 28 03 c0       	push   $0xc00328c4
c002d681:	68 d2 28 03 c0       	push   $0xc00328d2
c002d686:	68 dc 29 03 c0       	push   $0xc00329dc
c002d68b:	6a 34                	push   $0x34
c002d68d:	68 ec 28 03 c0       	push   $0xc00328ec
c002d692:	e8 e1 c0 ff ff       	call   c0029778 <debug_panic>

  thread_set_priority (PRI_MIN);
c002d697:	83 ec 0c             	sub    $0xc,%esp
c002d69a:	6a 00                	push   $0x0
c002d69c:	e8 03 39 ff ff       	call   c0020fa4 <thread_set_priority>
c002d6a1:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002d6a4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d6ab:	eb 24                	jmp    c002d6d1 <test_priority_donate_chain+0x70>
    lock_init (&locks[i]);
c002d6ad:	8d 8d 48 ff ff ff    	lea    -0xb8(%ebp),%ecx
c002d6b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d6b6:	89 d0                	mov    %edx,%eax
c002d6b8:	01 c0                	add    %eax,%eax
c002d6ba:	01 d0                	add    %edx,%eax
c002d6bc:	c1 e0 03             	shl    $0x3,%eax
c002d6bf:	01 c8                	add    %ecx,%eax
c002d6c1:	83 ec 0c             	sub    $0xc,%esp
c002d6c4:	50                   	push   %eax
c002d6c5:	e8 c9 54 ff ff       	call   c0022b93 <lock_init>
c002d6ca:	83 c4 10             	add    $0x10,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);

  thread_set_priority (PRI_MIN);

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002d6cd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d6d1:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002d6d5:	7e d6                	jle    c002d6ad <test_priority_donate_chain+0x4c>
    lock_init (&locks[i]);

  lock_acquire (&locks[0]);
c002d6d7:	83 ec 0c             	sub    $0xc,%esp
c002d6da:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d6e0:	50                   	push   %eax
c002d6e1:	e8 fa 54 ff ff       	call   c0022be0 <lock_acquire>
c002d6e6:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock.", thread_name ());
c002d6e9:	e8 a1 36 ff ff       	call   c0020d8f <thread_name>
c002d6ee:	83 ec 08             	sub    $0x8,%esp
c002d6f1:	50                   	push   %eax
c002d6f2:	68 18 29 03 c0       	push   $0xc0032918
c002d6f7:	e8 0d e4 ff ff       	call   c002bb09 <msg>
c002d6fc:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i < NESTING_DEPTH; i++)
c002d6ff:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002d706:	e9 f5 00 00 00       	jmp    c002d800 <test_priority_donate_chain+0x19f>
    {
      char name[16];
      int thread_priority;

      snprintf (name, sizeof name, "thread %d", i);
c002d70b:	ff 75 f4             	pushl  -0xc(%ebp)
c002d70e:	68 25 29 03 c0       	push   $0xc0032925
c002d713:	6a 10                	push   $0x10
c002d715:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d71b:	50                   	push   %eax
c002d71c:	e8 fb 9b ff ff       	call   c002731c <snprintf>
c002d721:	83 c4 10             	add    $0x10,%esp
      thread_priority = PRI_MIN + i * 3;
c002d724:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d727:	89 d0                	mov    %edx,%eax
c002d729:	01 c0                	add    %eax,%eax
c002d72b:	01 d0                	add    %edx,%eax
c002d72d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002d730:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002d734:	7f 18                	jg     c002d74e <test_priority_donate_chain+0xed>
c002d736:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d739:	89 d0                	mov    %edx,%eax
c002d73b:	01 c0                	add    %eax,%eax
c002d73d:	01 d0                	add    %edx,%eax
c002d73f:	c1 e0 03             	shl    $0x3,%eax
c002d742:	89 c2                	mov    %eax,%edx
c002d744:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d74a:	01 c2                	add    %eax,%edx
c002d74c:	eb 05                	jmp    c002d753 <test_priority_donate_chain+0xf2>
c002d74e:	ba 00 00 00 00       	mov    $0x0,%edx
c002d753:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d756:	89 94 c5 0c ff ff ff 	mov    %edx,-0xf4(%ebp,%eax,8)
      lock_pairs[i].second = locks + i - 1;
c002d75d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d760:	89 d0                	mov    %edx,%eax
c002d762:	01 c0                	add    %eax,%eax
c002d764:	01 d0                	add    %edx,%eax
c002d766:	c1 e0 03             	shl    $0x3,%eax
c002d769:	8d 50 e8             	lea    -0x18(%eax),%edx
c002d76c:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d772:	01 c2                	add    %eax,%edx
c002d774:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d777:	89 94 c5 08 ff ff ff 	mov    %edx,-0xf8(%ebp,%eax,8)

      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c002d77e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d781:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c002d788:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
c002d78e:	01 d0                	add    %edx,%eax
c002d790:	50                   	push   %eax
c002d791:	68 40 d8 02 c0       	push   $0xc002d840
c002d796:	ff 75 f0             	pushl  -0x10(%ebp)
c002d799:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d79f:	50                   	push   %eax
c002d7a0:	e8 e1 33 ff ff       	call   c0020b86 <thread_create>
c002d7a5:	83 c4 10             	add    $0x10,%esp
      msg ("%s should have priority %d.  Actual priority: %d.",
c002d7a8:	e8 0d 38 ff ff       	call   c0020fba <thread_get_priority>
c002d7ad:	89 c3                	mov    %eax,%ebx
c002d7af:	e8 db 35 ff ff       	call   c0020d8f <thread_name>
c002d7b4:	53                   	push   %ebx
c002d7b5:	ff 75 f0             	pushl  -0x10(%ebp)
c002d7b8:	50                   	push   %eax
c002d7b9:	68 30 29 03 c0       	push   $0xc0032930
c002d7be:	e8 46 e3 ff ff       	call   c002bb09 <msg>
c002d7c3:	83 c4 10             	add    $0x10,%esp
          thread_name (), thread_priority, thread_get_priority ());

      snprintf (name, sizeof name, "interloper %d", i);
c002d7c6:	ff 75 f4             	pushl  -0xc(%ebp)
c002d7c9:	68 62 29 03 c0       	push   $0xc0032962
c002d7ce:	6a 10                	push   $0x10
c002d7d0:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d7d6:	50                   	push   %eax
c002d7d7:	e8 40 9b ff ff       	call   c002731c <snprintf>
c002d7dc:	83 c4 10             	add    $0x10,%esp
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c002d7df:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d7e2:	83 e8 01             	sub    $0x1,%eax
c002d7e5:	6a 00                	push   $0x0
c002d7e7:	68 fe d8 02 c0       	push   $0xc002d8fe
c002d7ec:	50                   	push   %eax
c002d7ed:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d7f3:	50                   	push   %eax
c002d7f4:	e8 8d 33 ff ff       	call   c0020b86 <thread_create>
c002d7f9:	83 c4 10             	add    $0x10,%esp
    lock_init (&locks[i]);

  lock_acquire (&locks[0]);
  msg ("%s got lock.", thread_name ());

  for (i = 1; i < NESTING_DEPTH; i++)
c002d7fc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d800:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c002d804:	0f 8e 01 ff ff ff    	jle    c002d70b <test_priority_donate_chain+0xaa>

      snprintf (name, sizeof name, "interloper %d", i);
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
    }

  lock_release (&locks[0]);
c002d80a:	83 ec 0c             	sub    $0xc,%esp
c002d80d:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d813:	50                   	push   %eax
c002d814:	e8 08 55 ff ff       	call   c0022d21 <lock_release>
c002d819:	83 c4 10             	add    $0x10,%esp
  msg ("%s finishing with priority %d.", thread_name (),
c002d81c:	e8 99 37 ff ff       	call   c0020fba <thread_get_priority>
c002d821:	89 c3                	mov    %eax,%ebx
c002d823:	e8 67 35 ff ff       	call   c0020d8f <thread_name>
c002d828:	83 ec 04             	sub    $0x4,%esp
c002d82b:	53                   	push   %ebx
c002d82c:	50                   	push   %eax
c002d82d:	68 70 29 03 c0       	push   $0xc0032970
c002d832:	e8 d2 e2 ff ff       	call   c002bb09 <msg>
c002d837:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002d83a:	90                   	nop
c002d83b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d83e:	c9                   	leave  
c002d83f:	c3                   	ret    

c002d840 <donor_thread_func>:

static void
donor_thread_func (void *locks_) 
{
c002d840:	55                   	push   %ebp
c002d841:	89 e5                	mov    %esp,%ebp
c002d843:	53                   	push   %ebx
c002d844:	83 ec 14             	sub    $0x14,%esp
  struct lock_pair *locks = locks_;
c002d847:	8b 45 08             	mov    0x8(%ebp),%eax
c002d84a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (locks->first)
c002d84d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d850:	8b 40 04             	mov    0x4(%eax),%eax
c002d853:	85 c0                	test   %eax,%eax
c002d855:	74 12                	je     c002d869 <donor_thread_func+0x29>
    lock_acquire (locks->first);
c002d857:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d85a:	8b 40 04             	mov    0x4(%eax),%eax
c002d85d:	83 ec 0c             	sub    $0xc,%esp
c002d860:	50                   	push   %eax
c002d861:	e8 7a 53 ff ff       	call   c0022be0 <lock_acquire>
c002d866:	83 c4 10             	add    $0x10,%esp

  lock_acquire (locks->second);
c002d869:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d86c:	8b 00                	mov    (%eax),%eax
c002d86e:	83 ec 0c             	sub    $0xc,%esp
c002d871:	50                   	push   %eax
c002d872:	e8 69 53 ff ff       	call   c0022be0 <lock_acquire>
c002d877:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock", thread_name ());
c002d87a:	e8 10 35 ff ff       	call   c0020d8f <thread_name>
c002d87f:	83 ec 08             	sub    $0x8,%esp
c002d882:	50                   	push   %eax
c002d883:	68 8f 29 03 c0       	push   $0xc003298f
c002d888:	e8 7c e2 ff ff       	call   c002bb09 <msg>
c002d88d:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->second);
c002d890:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d893:	8b 00                	mov    (%eax),%eax
c002d895:	83 ec 0c             	sub    $0xc,%esp
c002d898:	50                   	push   %eax
c002d899:	e8 83 54 ff ff       	call   c0022d21 <lock_release>
c002d89e:	83 c4 10             	add    $0x10,%esp
  msg ("%s should have priority %d. Actual priority: %d", 
c002d8a1:	e8 14 37 ff ff       	call   c0020fba <thread_get_priority>
c002d8a6:	89 c3                	mov    %eax,%ebx
c002d8a8:	e8 e2 34 ff ff       	call   c0020d8f <thread_name>
c002d8ad:	53                   	push   %ebx
c002d8ae:	6a 15                	push   $0x15
c002d8b0:	50                   	push   %eax
c002d8b1:	68 9c 29 03 c0       	push   $0xc003299c
c002d8b6:	e8 4e e2 ff ff       	call   c002bb09 <msg>
c002d8bb:	83 c4 10             	add    $0x10,%esp
        thread_name (), (NESTING_DEPTH - 1) * 3,
        thread_get_priority ());

  if (locks->first)
c002d8be:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d8c1:	8b 40 04             	mov    0x4(%eax),%eax
c002d8c4:	85 c0                	test   %eax,%eax
c002d8c6:	74 12                	je     c002d8da <donor_thread_func+0x9a>
    lock_release (locks->first);
c002d8c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d8cb:	8b 40 04             	mov    0x4(%eax),%eax
c002d8ce:	83 ec 0c             	sub    $0xc,%esp
c002d8d1:	50                   	push   %eax
c002d8d2:	e8 4a 54 ff ff       	call   c0022d21 <lock_release>
c002d8d7:	83 c4 10             	add    $0x10,%esp

  msg ("%s finishing with priority %d.", thread_name (),
c002d8da:	e8 db 36 ff ff       	call   c0020fba <thread_get_priority>
c002d8df:	89 c3                	mov    %eax,%ebx
c002d8e1:	e8 a9 34 ff ff       	call   c0020d8f <thread_name>
c002d8e6:	83 ec 04             	sub    $0x4,%esp
c002d8e9:	53                   	push   %ebx
c002d8ea:	50                   	push   %eax
c002d8eb:	68 70 29 03 c0       	push   $0xc0032970
c002d8f0:	e8 14 e2 ff ff       	call   c002bb09 <msg>
c002d8f5:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002d8f8:	90                   	nop
c002d8f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d8fc:	c9                   	leave  
c002d8fd:	c3                   	ret    

c002d8fe <interloper_thread_func>:

static void
interloper_thread_func (void *arg_ UNUSED)
{
c002d8fe:	55                   	push   %ebp
c002d8ff:	89 e5                	mov    %esp,%ebp
c002d901:	83 ec 08             	sub    $0x8,%esp
  msg ("%s finished.", thread_name ());
c002d904:	e8 86 34 ff ff       	call   c0020d8f <thread_name>
c002d909:	83 ec 08             	sub    $0x8,%esp
c002d90c:	50                   	push   %eax
c002d90d:	68 cc 29 03 c0       	push   $0xc00329cc
c002d912:	e8 f2 e1 ff ff       	call   c002bb09 <msg>
c002d917:	83 c4 10             	add    $0x10,%esp
}
c002d91a:	90                   	nop
c002d91b:	c9                   	leave  
c002d91c:	c3                   	ret    

c002d91d <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c002d91d:	55                   	push   %ebp
c002d91e:	89 e5                	mov    %esp,%ebp
c002d920:	53                   	push   %ebx
c002d921:	83 ec 14             	sub    $0x14,%esp
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c002d924:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002d92b:	84 c0                	test   %al,%al
c002d92d:	75 1e                	jne    c002d94d <test_mlfqs_load_1+0x30>
c002d92f:	83 ec 0c             	sub    $0xc,%esp
c002d932:	68 f8 29 03 c0       	push   $0xc00329f8
c002d937:	68 05 2a 03 c0       	push   $0xc0032a05
c002d93c:	68 14 2c 03 c0       	push   $0xc0032c14
c002d941:	6a 18                	push   $0x18
c002d943:	68 1c 2a 03 c0       	push   $0xc0032a1c
c002d948:	e8 2b be ff ff       	call   c0029778 <debug_panic>

  msg ("spinning for up to 45 seconds, please wait...");
c002d94d:	83 ec 0c             	sub    $0xc,%esp
c002d950:	68 40 2a 03 c0       	push   $0xc0032a40
c002d955:	e8 af e1 ff ff       	call   c002bb09 <msg>
c002d95a:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002d95d:	e8 8c 64 ff ff       	call   c0023dee <timer_ticks>
c002d962:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002d965:	89 55 f4             	mov    %edx,-0xc(%ebp)
  for (;;) 
    {
      load_avg = thread_get_load_avg ();
c002d968:	e8 6d 36 ff ff       	call   c0020fda <thread_get_load_avg>
c002d96d:	89 45 ec             	mov    %eax,-0x14(%ebp)
      ASSERT (load_avg >= 0);
c002d970:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002d974:	79 1e                	jns    c002d994 <test_mlfqs_load_1+0x77>
c002d976:	83 ec 0c             	sub    $0xc,%esp
c002d979:	68 6e 2a 03 c0       	push   $0xc0032a6e
c002d97e:	68 05 2a 03 c0       	push   $0xc0032a05
c002d983:	68 14 2c 03 c0       	push   $0xc0032c14
c002d988:	6a 20                	push   $0x20
c002d98a:	68 1c 2a 03 c0       	push   $0xc0032a1c
c002d98f:	e8 e4 bd ff ff       	call   c0029778 <debug_panic>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c002d994:	83 ec 08             	sub    $0x8,%esp
c002d997:	ff 75 f4             	pushl  -0xc(%ebp)
c002d99a:	ff 75 f0             	pushl  -0x10(%ebp)
c002d99d:	e8 81 64 ff ff       	call   c0023e23 <timer_elapsed>
c002d9a2:	83 c4 10             	add    $0x10,%esp
c002d9a5:	6a 00                	push   $0x0
c002d9a7:	6a 64                	push   $0x64
c002d9a9:	52                   	push   %edx
c002d9aa:	50                   	push   %eax
c002d9ab:	e8 a2 b7 ff ff       	call   c0029152 <__divdi3>
c002d9b0:	83 c4 10             	add    $0x10,%esp
c002d9b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (load_avg > 100)
c002d9b6:	83 7d ec 64          	cmpl   $0x64,-0x14(%ebp)
c002d9ba:	7e 4e                	jle    c002da0a <test_mlfqs_load_1+0xed>
        fail ("load average is %d.%02d "
c002d9bc:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d9bf:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002d9c4:	89 d8                	mov    %ebx,%eax
c002d9c6:	f7 ea                	imul   %edx
c002d9c8:	c1 fa 05             	sar    $0x5,%edx
c002d9cb:	89 d8                	mov    %ebx,%eax
c002d9cd:	c1 f8 1f             	sar    $0x1f,%eax
c002d9d0:	89 d1                	mov    %edx,%ecx
c002d9d2:	29 c1                	sub    %eax,%ecx
c002d9d4:	6b c1 64             	imul   $0x64,%ecx,%eax
c002d9d7:	89 d9                	mov    %ebx,%ecx
c002d9d9:	29 c1                	sub    %eax,%ecx
c002d9db:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d9de:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002d9e3:	89 d8                	mov    %ebx,%eax
c002d9e5:	f7 ea                	imul   %edx
c002d9e7:	c1 fa 05             	sar    $0x5,%edx
c002d9ea:	89 d8                	mov    %ebx,%eax
c002d9ec:	c1 f8 1f             	sar    $0x1f,%eax
c002d9ef:	29 c2                	sub    %eax,%edx
c002d9f1:	89 d0                	mov    %edx,%eax
c002d9f3:	ff 75 e8             	pushl  -0x18(%ebp)
c002d9f6:	51                   	push   %ecx
c002d9f7:	50                   	push   %eax
c002d9f8:	68 7c 2a 03 c0       	push   $0xc0032a7c
c002d9fd:	e8 4b e1 ff ff       	call   c002bb4d <fail>
c002da02:	83 c4 10             	add    $0x10,%esp
c002da05:	e9 5e ff ff ff       	jmp    c002d968 <test_mlfqs_load_1+0x4b>
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
c002da0a:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002da0e:	7f 1f                	jg     c002da2f <test_mlfqs_load_1+0x112>
        break;
      else if (elapsed > 45)
c002da10:	83 7d e8 2d          	cmpl   $0x2d,-0x18(%ebp)
c002da14:	0f 8e 4e ff ff ff    	jle    c002d968 <test_mlfqs_load_1+0x4b>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002da1a:	83 ec 0c             	sub    $0xc,%esp
c002da1d:	68 c8 2a 03 c0       	push   $0xc0032ac8
c002da22:	e8 26 e1 ff ff       	call   c002bb4d <fail>
c002da27:	83 c4 10             	add    $0x10,%esp
    }
c002da2a:	e9 39 ff ff ff       	jmp    c002d968 <test_mlfqs_load_1+0x4b>
      if (load_avg > 100)
        fail ("load average is %d.%02d "
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
        break;
c002da2f:	90                   	nop
      else if (elapsed > 45)
        fail ("load average stayed below 0.5 for more than 45 seconds");
    }

  if (elapsed < 38)
c002da30:	83 7d e8 25          	cmpl   $0x25,-0x18(%ebp)
c002da34:	7f 13                	jg     c002da49 <test_mlfqs_load_1+0x12c>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c002da36:	83 ec 08             	sub    $0x8,%esp
c002da39:	ff 75 e8             	pushl  -0x18(%ebp)
c002da3c:	68 00 2b 03 c0       	push   $0xc0032b00
c002da41:	e8 07 e1 ff ff       	call   c002bb4d <fail>
c002da46:	83 c4 10             	add    $0x10,%esp
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c002da49:	83 ec 08             	sub    $0x8,%esp
c002da4c:	ff 75 e8             	pushl  -0x18(%ebp)
c002da4f:	68 34 2b 03 c0       	push   $0xc0032b34
c002da54:	e8 b0 e0 ff ff       	call   c002bb09 <msg>
c002da59:	83 c4 10             	add    $0x10,%esp

  msg ("sleeping for another 10 seconds, please wait...");
c002da5c:	83 ec 0c             	sub    $0xc,%esp
c002da5f:	68 60 2b 03 c0       	push   $0xc0032b60
c002da64:	e8 a0 e0 ff ff       	call   c002bb09 <msg>
c002da69:	83 c4 10             	add    $0x10,%esp
  timer_sleep (TIMER_FREQ * 10);
c002da6c:	83 ec 08             	sub    $0x8,%esp
c002da6f:	6a 00                	push   $0x0
c002da71:	68 e8 03 00 00       	push   $0x3e8
c002da76:	e8 c7 63 ff ff       	call   c0023e42 <timer_sleep>
c002da7b:	83 c4 10             	add    $0x10,%esp

  load_avg = thread_get_load_avg ();
c002da7e:	e8 57 35 ff ff       	call   c0020fda <thread_get_load_avg>
c002da83:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (load_avg < 0)
c002da86:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002da8a:	79 10                	jns    c002da9c <test_mlfqs_load_1+0x17f>
    fail ("load average fell below 0");
c002da8c:	83 ec 0c             	sub    $0xc,%esp
c002da8f:	68 90 2b 03 c0       	push   $0xc0032b90
c002da94:	e8 b4 e0 ff ff       	call   c002bb4d <fail>
c002da99:	83 c4 10             	add    $0x10,%esp
  if (load_avg > 50)
c002da9c:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002daa0:	7e 10                	jle    c002dab2 <test_mlfqs_load_1+0x195>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c002daa2:	83 ec 0c             	sub    $0xc,%esp
c002daa5:	68 ac 2b 03 c0       	push   $0xc0032bac
c002daaa:	e8 9e e0 ff ff       	call   c002bb4d <fail>
c002daaf:	83 c4 10             	add    $0x10,%esp
  msg ("load average fell back below 0.5 (to %d.%02d)",
c002dab2:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002dab5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002daba:	89 d8                	mov    %ebx,%eax
c002dabc:	f7 ea                	imul   %edx
c002dabe:	c1 fa 05             	sar    $0x5,%edx
c002dac1:	89 d8                	mov    %ebx,%eax
c002dac3:	c1 f8 1f             	sar    $0x1f,%eax
c002dac6:	89 d1                	mov    %edx,%ecx
c002dac8:	29 c1                	sub    %eax,%ecx
c002daca:	6b c1 64             	imul   $0x64,%ecx,%eax
c002dacd:	29 c3                	sub    %eax,%ebx
c002dacf:	89 d9                	mov    %ebx,%ecx
c002dad1:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002dad4:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dad9:	89 d8                	mov    %ebx,%eax
c002dadb:	f7 ea                	imul   %edx
c002dadd:	c1 fa 05             	sar    $0x5,%edx
c002dae0:	89 d8                	mov    %ebx,%eax
c002dae2:	c1 f8 1f             	sar    $0x1f,%eax
c002dae5:	29 c2                	sub    %eax,%edx
c002dae7:	89 d0                	mov    %edx,%eax
c002dae9:	83 ec 04             	sub    $0x4,%esp
c002daec:	51                   	push   %ecx
c002daed:	50                   	push   %eax
c002daee:	68 e4 2b 03 c0       	push   $0xc0032be4
c002daf3:	e8 11 e0 ff ff       	call   c002bb09 <msg>
c002daf8:	83 c4 10             	add    $0x10,%esp
       load_avg / 100, load_avg % 100);

  pass ();
c002dafb:	e8 a4 e0 ff ff       	call   c002bba4 <pass>
}
c002db00:	90                   	nop
c002db01:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002db04:	c9                   	leave  
c002db05:	c3                   	ret    

c002db06 <test_mlfqs_load_60>:

#define THREAD_CNT 60

void
test_mlfqs_load_60 (void) 
{
c002db06:	55                   	push   %ebp
c002db07:	89 e5                	mov    %esp,%ebp
c002db09:	53                   	push   %ebx
c002db0a:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002db0d:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002db14:	84 c0                	test   %al,%al
c002db16:	75 1e                	jne    c002db36 <test_mlfqs_load_60+0x30>
c002db18:	83 ec 0c             	sub    $0xc,%esp
c002db1b:	68 28 2c 03 c0       	push   $0xc0032c28
c002db20:	68 35 2c 03 c0       	push   $0xc0032c35
c002db25:	68 e8 2c 03 c0       	push   $0xc0032ce8
c002db2a:	6a 77                	push   $0x77
c002db2c:	68 4c 2c 03 c0       	push   $0xc0032c4c
c002db31:	e8 42 bc ff ff       	call   c0029778 <debug_panic>

  start_time = timer_ticks ();
c002db36:	e8 b3 62 ff ff       	call   c0023dee <timer_ticks>
c002db3b:	a3 b0 9c 03 c0       	mov    %eax,0xc0039cb0
c002db40:	89 15 b4 9c 03 c0    	mov    %edx,0xc0039cb4
  msg ("Starting %d niced load threads...", THREAD_CNT);
c002db46:	83 ec 08             	sub    $0x8,%esp
c002db49:	6a 3c                	push   $0x3c
c002db4b:	68 70 2c 03 c0       	push   $0xc0032c70
c002db50:	e8 b4 df ff ff       	call   c002bb09 <msg>
c002db55:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002db58:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002db5f:	eb 2f                	jmp    c002db90 <test_mlfqs_load_60+0x8a>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002db61:	ff 75 f4             	pushl  -0xc(%ebp)
c002db64:	68 92 2c 03 c0       	push   $0xc0032c92
c002db69:	6a 10                	push   $0x10
c002db6b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002db6e:	50                   	push   %eax
c002db6f:	e8 a8 97 ff ff       	call   c002731c <snprintf>
c002db74:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c002db77:	6a 00                	push   $0x0
c002db79:	68 88 dc 02 c0       	push   $0xc002dc88
c002db7e:	6a 1f                	push   $0x1f
c002db80:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002db83:	50                   	push   %eax
c002db84:	e8 fd 2f ff ff       	call   c0020b86 <thread_create>
c002db89:	83 c4 10             	add    $0x10,%esp
  
  ASSERT (thread_mlfqs);

  start_time = timer_ticks ();
  msg ("Starting %d niced load threads...", THREAD_CNT);
  for (i = 0; i < THREAD_CNT; i++) 
c002db8c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002db90:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002db94:	7e cb                	jle    c002db61 <test_mlfqs_load_60+0x5b>
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002db96:	a1 b0 9c 03 c0       	mov    0xc0039cb0,%eax
c002db9b:	8b 15 b4 9c 03 c0    	mov    0xc0039cb4,%edx
c002dba1:	83 ec 08             	sub    $0x8,%esp
c002dba4:	52                   	push   %edx
c002dba5:	50                   	push   %eax
c002dba6:	e8 78 62 ff ff       	call   c0023e23 <timer_elapsed>
c002dbab:	83 c4 10             	add    $0x10,%esp
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
c002dbae:	6a 00                	push   $0x0
c002dbb0:	6a 64                	push   $0x64
c002dbb2:	52                   	push   %edx
c002dbb3:	50                   	push   %eax
c002dbb4:	e8 99 b5 ff ff       	call   c0029152 <__divdi3>
c002dbb9:	83 c4 10             	add    $0x10,%esp
c002dbbc:	83 ec 04             	sub    $0x4,%esp
c002dbbf:	52                   	push   %edx
c002dbc0:	50                   	push   %eax
c002dbc1:	68 9c 2c 03 c0       	push   $0xc0032c9c
c002dbc6:	e8 3e df ff ff       	call   c002bb09 <msg>
c002dbcb:	83 c4 10             	add    $0x10,%esp
       timer_elapsed (start_time) / TIMER_FREQ);
  
  for (i = 0; i < 90; i++) 
c002dbce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002dbd5:	e9 9e 00 00 00       	jmp    c002dc78 <test_mlfqs_load_60+0x172>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002dbda:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dbdd:	83 c0 05             	add    $0x5,%eax
c002dbe0:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c002dbe6:	89 c1                	mov    %eax,%ecx
c002dbe8:	89 c3                	mov    %eax,%ebx
c002dbea:	c1 fb 1f             	sar    $0x1f,%ebx
c002dbed:	a1 b0 9c 03 c0       	mov    0xc0039cb0,%eax
c002dbf2:	8b 15 b4 9c 03 c0    	mov    0xc0039cb4,%edx
c002dbf8:	01 c8                	add    %ecx,%eax
c002dbfa:	11 da                	adc    %ebx,%edx
c002dbfc:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002dbff:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002dc02:	e8 e7 61 ff ff       	call   c0023dee <timer_ticks>
c002dc07:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002dc0a:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002dc0d:	29 c1                	sub    %eax,%ecx
c002dc0f:	19 d3                	sbb    %edx,%ebx
c002dc11:	89 c8                	mov    %ecx,%eax
c002dc13:	89 da                	mov    %ebx,%edx
c002dc15:	83 ec 08             	sub    $0x8,%esp
c002dc18:	52                   	push   %edx
c002dc19:	50                   	push   %eax
c002dc1a:	e8 23 62 ff ff       	call   c0023e42 <timer_sleep>
c002dc1f:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002dc22:	e8 b3 33 ff ff       	call   c0020fda <thread_get_load_avg>
c002dc27:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002dc2a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dc2d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dc32:	89 d8                	mov    %ebx,%eax
c002dc34:	f7 ea                	imul   %edx
c002dc36:	c1 fa 05             	sar    $0x5,%edx
c002dc39:	89 d8                	mov    %ebx,%eax
c002dc3b:	c1 f8 1f             	sar    $0x1f,%eax
c002dc3e:	89 d1                	mov    %edx,%ecx
c002dc40:	29 c1                	sub    %eax,%ecx
c002dc42:	6b c1 64             	imul   $0x64,%ecx,%eax
c002dc45:	29 c3                	sub    %eax,%ebx
c002dc47:	89 d9                	mov    %ebx,%ecx
c002dc49:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dc4c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dc51:	89 d8                	mov    %ebx,%eax
c002dc53:	f7 ea                	imul   %edx
c002dc55:	c1 fa 05             	sar    $0x5,%edx
c002dc58:	89 d8                	mov    %ebx,%eax
c002dc5a:	c1 f8 1f             	sar    $0x1f,%eax
c002dc5d:	29 c2                	sub    %eax,%edx
c002dc5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dc62:	01 c0                	add    %eax,%eax
c002dc64:	51                   	push   %ecx
c002dc65:	52                   	push   %edx
c002dc66:	50                   	push   %eax
c002dc67:	68 c0 2c 03 c0       	push   $0xc0032cc0
c002dc6c:	e8 98 de ff ff       	call   c002bb09 <msg>
c002dc71:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
  
  for (i = 0; i < 90; i++) 
c002dc74:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002dc78:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002dc7c:	0f 8e 58 ff ff ff    	jle    c002dbda <test_mlfqs_load_60+0xd4>
      timer_sleep (sleep_until - timer_ticks ());
      load_avg = thread_get_load_avg ();
      msg ("After %d seconds, load average=%d.%02d.",
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002dc82:	90                   	nop
c002dc83:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dc86:	c9                   	leave  
c002dc87:	c3                   	ret    

c002dc88 <load_thread>:

static void
load_thread (void *aux UNUSED) 
{
c002dc88:	55                   	push   %ebp
c002dc89:	89 e5                	mov    %esp,%ebp
c002dc8b:	53                   	push   %ebx
c002dc8c:	83 ec 24             	sub    $0x24,%esp
  int64_t sleep_time = 10 * TIMER_FREQ;
c002dc8f:	c7 45 f0 e8 03 00 00 	movl   $0x3e8,-0x10(%ebp)
c002dc96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
c002dc9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dca0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002dca3:	05 70 17 00 00       	add    $0x1770,%eax
c002dca8:	83 d2 00             	adc    $0x0,%edx
c002dcab:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002dcae:	89 55 ec             	mov    %edx,-0x14(%ebp)
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;
c002dcb1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002dcb4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002dcb7:	05 70 17 00 00       	add    $0x1770,%eax
c002dcbc:	83 d2 00             	adc    $0x0,%edx
c002dcbf:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002dcc2:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  thread_set_nice (20);
c002dcc5:	83 ec 0c             	sub    $0xc,%esp
c002dcc8:	6a 14                	push   $0x14
c002dcca:	e8 fb 32 ff ff       	call   c0020fca <thread_set_nice>
c002dccf:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (start_time));
c002dcd2:	a1 b0 9c 03 c0       	mov    0xc0039cb0,%eax
c002dcd7:	8b 15 b4 9c 03 c0    	mov    0xc0039cb4,%edx
c002dcdd:	83 ec 08             	sub    $0x8,%esp
c002dce0:	52                   	push   %edx
c002dce1:	50                   	push   %eax
c002dce2:	e8 3c 61 ff ff       	call   c0023e23 <timer_elapsed>
c002dce7:	83 c4 10             	add    $0x10,%esp
c002dcea:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c002dced:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c002dcf0:	29 c1                	sub    %eax,%ecx
c002dcf2:	19 d3                	sbb    %edx,%ebx
c002dcf4:	89 c8                	mov    %ecx,%eax
c002dcf6:	89 da                	mov    %ebx,%edx
c002dcf8:	83 ec 08             	sub    $0x8,%esp
c002dcfb:	52                   	push   %edx
c002dcfc:	50                   	push   %eax
c002dcfd:	e8 40 61 ff ff       	call   c0023e42 <timer_sleep>
c002dd02:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002dd05:	eb 01                	jmp    c002dd08 <load_thread+0x80>
    continue;
c002dd07:	90                   	nop
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;

  thread_set_nice (20);
  timer_sleep (sleep_time - timer_elapsed (start_time));
  while (timer_elapsed (start_time) < spin_time)
c002dd08:	a1 b0 9c 03 c0       	mov    0xc0039cb0,%eax
c002dd0d:	8b 15 b4 9c 03 c0    	mov    0xc0039cb4,%edx
c002dd13:	83 ec 08             	sub    $0x8,%esp
c002dd16:	52                   	push   %edx
c002dd17:	50                   	push   %eax
c002dd18:	e8 06 61 ff ff       	call   c0023e23 <timer_elapsed>
c002dd1d:	83 c4 10             	add    $0x10,%esp
c002dd20:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c002dd23:	7c e2                	jl     c002dd07 <load_thread+0x7f>
c002dd25:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c002dd28:	7f 05                	jg     c002dd2f <load_thread+0xa7>
c002dd2a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002dd2d:	72 d8                	jb     c002dd07 <load_thread+0x7f>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002dd2f:	a1 b0 9c 03 c0       	mov    0xc0039cb0,%eax
c002dd34:	8b 15 b4 9c 03 c0    	mov    0xc0039cb4,%edx
c002dd3a:	83 ec 08             	sub    $0x8,%esp
c002dd3d:	52                   	push   %edx
c002dd3e:	50                   	push   %eax
c002dd3f:	e8 df 60 ff ff       	call   c0023e23 <timer_elapsed>
c002dd44:	83 c4 10             	add    $0x10,%esp
c002dd47:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002dd4a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dd4d:	29 c1                	sub    %eax,%ecx
c002dd4f:	19 d3                	sbb    %edx,%ebx
c002dd51:	89 c8                	mov    %ecx,%eax
c002dd53:	89 da                	mov    %ebx,%edx
c002dd55:	83 ec 08             	sub    $0x8,%esp
c002dd58:	52                   	push   %edx
c002dd59:	50                   	push   %eax
c002dd5a:	e8 e3 60 ff ff       	call   c0023e42 <timer_sleep>
c002dd5f:	83 c4 10             	add    $0x10,%esp
}
c002dd62:	90                   	nop
c002dd63:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dd66:	c9                   	leave  
c002dd67:	c3                   	ret    

c002dd68 <test_mlfqs_load_avg>:

#define THREAD_CNT 60

void
test_mlfqs_load_avg (void) 
{
c002dd68:	55                   	push   %ebp
c002dd69:	89 e5                	mov    %esp,%ebp
c002dd6b:	53                   	push   %ebx
c002dd6c:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002dd6f:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002dd76:	84 c0                	test   %al,%al
c002dd78:	75 21                	jne    c002dd9b <test_mlfqs_load_avg+0x33>
c002dd7a:	83 ec 0c             	sub    $0xc,%esp
c002dd7d:	68 fc 2c 03 c0       	push   $0xc0032cfc
c002dd82:	68 09 2d 03 c0       	push   $0xc0032d09
c002dd87:	68 b8 2d 03 c0       	push   $0xc0032db8
c002dd8c:	68 82 00 00 00       	push   $0x82
c002dd91:	68 20 2d 03 c0       	push   $0xc0032d20
c002dd96:	e8 dd b9 ff ff       	call   c0029778 <debug_panic>

  start_time = timer_ticks ();
c002dd9b:	e8 4e 60 ff ff       	call   c0023dee <timer_ticks>
c002dda0:	a3 b8 9c 03 c0       	mov    %eax,0xc0039cb8
c002dda5:	89 15 bc 9c 03 c0    	mov    %edx,0xc0039cbc
  msg ("Starting %d load threads...", THREAD_CNT);
c002ddab:	83 ec 08             	sub    $0x8,%esp
c002ddae:	6a 3c                	push   $0x3c
c002ddb0:	68 45 2d 03 c0       	push   $0xc0032d45
c002ddb5:	e8 4f dd ff ff       	call   c002bb09 <msg>
c002ddba:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002ddbd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ddc4:	eb 31                	jmp    c002ddf7 <test_mlfqs_load_avg+0x8f>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002ddc6:	ff 75 f4             	pushl  -0xc(%ebp)
c002ddc9:	68 61 2d 03 c0       	push   $0xc0032d61
c002ddce:	6a 10                	push   $0x10
c002ddd0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002ddd3:	50                   	push   %eax
c002ddd4:	e8 43 95 ff ff       	call   c002731c <snprintf>
c002ddd9:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c002dddc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dddf:	50                   	push   %eax
c002dde0:	68 fc de 02 c0       	push   $0xc002defc
c002dde5:	6a 1f                	push   $0x1f
c002dde7:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002ddea:	50                   	push   %eax
c002ddeb:	e8 96 2d ff ff       	call   c0020b86 <thread_create>
c002ddf0:	83 c4 10             	add    $0x10,%esp
  
  ASSERT (thread_mlfqs);

  start_time = timer_ticks ();
  msg ("Starting %d load threads...", THREAD_CNT);
  for (i = 0; i < THREAD_CNT; i++) 
c002ddf3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002ddf7:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002ddfb:	7e c9                	jle    c002ddc6 <test_mlfqs_load_avg+0x5e>
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002ddfd:	a1 b8 9c 03 c0       	mov    0xc0039cb8,%eax
c002de02:	8b 15 bc 9c 03 c0    	mov    0xc0039cbc,%edx
c002de08:	83 ec 08             	sub    $0x8,%esp
c002de0b:	52                   	push   %edx
c002de0c:	50                   	push   %eax
c002de0d:	e8 11 60 ff ff       	call   c0023e23 <timer_elapsed>
c002de12:	83 c4 10             	add    $0x10,%esp
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
    }
  msg ("Starting threads took %d seconds.",
c002de15:	6a 00                	push   $0x0
c002de17:	6a 64                	push   $0x64
c002de19:	52                   	push   %edx
c002de1a:	50                   	push   %eax
c002de1b:	e8 32 b3 ff ff       	call   c0029152 <__divdi3>
c002de20:	83 c4 10             	add    $0x10,%esp
c002de23:	83 ec 04             	sub    $0x4,%esp
c002de26:	52                   	push   %edx
c002de27:	50                   	push   %eax
c002de28:	68 6c 2d 03 c0       	push   $0xc0032d6c
c002de2d:	e8 d7 dc ff ff       	call   c002bb09 <msg>
c002de32:	83 c4 10             	add    $0x10,%esp
       timer_elapsed (start_time) / TIMER_FREQ);
  thread_set_nice (-20);
c002de35:	83 ec 0c             	sub    $0xc,%esp
c002de38:	6a ec                	push   $0xffffffec
c002de3a:	e8 8b 31 ff ff       	call   c0020fca <thread_set_nice>
c002de3f:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 90; i++) 
c002de42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002de49:	e9 9e 00 00 00       	jmp    c002deec <test_mlfqs_load_avg+0x184>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002de4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002de51:	83 c0 05             	add    $0x5,%eax
c002de54:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c002de5a:	89 c1                	mov    %eax,%ecx
c002de5c:	89 c3                	mov    %eax,%ebx
c002de5e:	c1 fb 1f             	sar    $0x1f,%ebx
c002de61:	a1 b8 9c 03 c0       	mov    0xc0039cb8,%eax
c002de66:	8b 15 bc 9c 03 c0    	mov    0xc0039cbc,%edx
c002de6c:	01 c8                	add    %ecx,%eax
c002de6e:	11 da                	adc    %ebx,%edx
c002de70:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002de73:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002de76:	e8 73 5f ff ff       	call   c0023dee <timer_ticks>
c002de7b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002de7e:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002de81:	29 c1                	sub    %eax,%ecx
c002de83:	19 d3                	sbb    %edx,%ebx
c002de85:	89 c8                	mov    %ecx,%eax
c002de87:	89 da                	mov    %ebx,%edx
c002de89:	83 ec 08             	sub    $0x8,%esp
c002de8c:	52                   	push   %edx
c002de8d:	50                   	push   %eax
c002de8e:	e8 af 5f ff ff       	call   c0023e42 <timer_sleep>
c002de93:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002de96:	e8 3f 31 ff ff       	call   c0020fda <thread_get_load_avg>
c002de9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002de9e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dea1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dea6:	89 d8                	mov    %ebx,%eax
c002dea8:	f7 ea                	imul   %edx
c002deaa:	c1 fa 05             	sar    $0x5,%edx
c002dead:	89 d8                	mov    %ebx,%eax
c002deaf:	c1 f8 1f             	sar    $0x1f,%eax
c002deb2:	89 d1                	mov    %edx,%ecx
c002deb4:	29 c1                	sub    %eax,%ecx
c002deb6:	6b c1 64             	imul   $0x64,%ecx,%eax
c002deb9:	29 c3                	sub    %eax,%ebx
c002debb:	89 d9                	mov    %ebx,%ecx
c002debd:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dec0:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002dec5:	89 d8                	mov    %ebx,%eax
c002dec7:	f7 ea                	imul   %edx
c002dec9:	c1 fa 05             	sar    $0x5,%edx
c002decc:	89 d8                	mov    %ebx,%eax
c002dece:	c1 f8 1f             	sar    $0x1f,%eax
c002ded1:	29 c2                	sub    %eax,%edx
c002ded3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ded6:	01 c0                	add    %eax,%eax
c002ded8:	51                   	push   %ecx
c002ded9:	52                   	push   %edx
c002deda:	50                   	push   %eax
c002dedb:	68 90 2d 03 c0       	push   $0xc0032d90
c002dee0:	e8 24 dc ff ff       	call   c002bb09 <msg>
c002dee5:	83 c4 10             	add    $0x10,%esp
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
  thread_set_nice (-20);

  for (i = 0; i < 90; i++) 
c002dee8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002deec:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002def0:	0f 8e 58 ff ff ff    	jle    c002de4e <test_mlfqs_load_avg+0xe6>
      timer_sleep (sleep_until - timer_ticks ());
      load_avg = thread_get_load_avg ();
      msg ("After %d seconds, load average=%d.%02d.",
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002def6:	90                   	nop
c002def7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002defa:	c9                   	leave  
c002defb:	c3                   	ret    

c002defc <load_thread>:

static void
load_thread (void *seq_no_) 
{
c002defc:	55                   	push   %ebp
c002defd:	89 e5                	mov    %esp,%ebp
c002deff:	56                   	push   %esi
c002df00:	53                   	push   %ebx
c002df01:	83 ec 10             	sub    $0x10,%esp
  int seq_no = (int) seq_no_;
c002df04:	8b 45 08             	mov    0x8(%ebp),%eax
c002df07:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c002df0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002df0d:	83 c0 0a             	add    $0xa,%eax
c002df10:	6b c0 64             	imul   $0x64,%eax,%eax
c002df13:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c002df16:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002df19:	05 70 17 00 00       	add    $0x1770,%eax
c002df1e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);
c002df21:	c7 45 e8 e0 2e 00 00 	movl   $0x2ee0,-0x18(%ebp)

  timer_sleep (sleep_time - timer_elapsed (start_time));
c002df28:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002df2b:	89 c3                	mov    %eax,%ebx
c002df2d:	89 c6                	mov    %eax,%esi
c002df2f:	c1 fe 1f             	sar    $0x1f,%esi
c002df32:	a1 b8 9c 03 c0       	mov    0xc0039cb8,%eax
c002df37:	8b 15 bc 9c 03 c0    	mov    0xc0039cbc,%edx
c002df3d:	83 ec 08             	sub    $0x8,%esp
c002df40:	52                   	push   %edx
c002df41:	50                   	push   %eax
c002df42:	e8 dc 5e ff ff       	call   c0023e23 <timer_elapsed>
c002df47:	83 c4 10             	add    $0x10,%esp
c002df4a:	29 c3                	sub    %eax,%ebx
c002df4c:	19 d6                	sbb    %edx,%esi
c002df4e:	89 d8                	mov    %ebx,%eax
c002df50:	89 f2                	mov    %esi,%edx
c002df52:	83 ec 08             	sub    $0x8,%esp
c002df55:	52                   	push   %edx
c002df56:	50                   	push   %eax
c002df57:	e8 e6 5e ff ff       	call   c0023e42 <timer_sleep>
c002df5c:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002df5f:	eb 01                	jmp    c002df62 <load_thread+0x66>
    continue;
c002df61:	90                   	nop
  int sleep_time = TIMER_FREQ * (10 + seq_no);
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);

  timer_sleep (sleep_time - timer_elapsed (start_time));
  while (timer_elapsed (start_time) < spin_time)
c002df62:	a1 b8 9c 03 c0       	mov    0xc0039cb8,%eax
c002df67:	8b 15 bc 9c 03 c0    	mov    0xc0039cbc,%edx
c002df6d:	83 ec 08             	sub    $0x8,%esp
c002df70:	52                   	push   %edx
c002df71:	50                   	push   %eax
c002df72:	e8 ac 5e ff ff       	call   c0023e23 <timer_elapsed>
c002df77:	83 c4 10             	add    $0x10,%esp
c002df7a:	89 c1                	mov    %eax,%ecx
c002df7c:	89 d3                	mov    %edx,%ebx
c002df7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002df81:	99                   	cltd   
c002df82:	39 d3                	cmp    %edx,%ebx
c002df84:	7c db                	jl     c002df61 <load_thread+0x65>
c002df86:	39 d3                	cmp    %edx,%ebx
c002df88:	7f 04                	jg     c002df8e <load_thread+0x92>
c002df8a:	39 c1                	cmp    %eax,%ecx
c002df8c:	72 d3                	jb     c002df61 <load_thread+0x65>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002df8e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002df91:	89 c3                	mov    %eax,%ebx
c002df93:	89 c6                	mov    %eax,%esi
c002df95:	c1 fe 1f             	sar    $0x1f,%esi
c002df98:	a1 b8 9c 03 c0       	mov    0xc0039cb8,%eax
c002df9d:	8b 15 bc 9c 03 c0    	mov    0xc0039cbc,%edx
c002dfa3:	83 ec 08             	sub    $0x8,%esp
c002dfa6:	52                   	push   %edx
c002dfa7:	50                   	push   %eax
c002dfa8:	e8 76 5e ff ff       	call   c0023e23 <timer_elapsed>
c002dfad:	83 c4 10             	add    $0x10,%esp
c002dfb0:	29 c3                	sub    %eax,%ebx
c002dfb2:	19 d6                	sbb    %edx,%esi
c002dfb4:	89 d8                	mov    %ebx,%eax
c002dfb6:	89 f2                	mov    %esi,%edx
c002dfb8:	83 ec 08             	sub    $0x8,%esp
c002dfbb:	52                   	push   %edx
c002dfbc:	50                   	push   %eax
c002dfbd:	e8 80 5e ff ff       	call   c0023e42 <timer_sleep>
c002dfc2:	83 c4 10             	add    $0x10,%esp
}
c002dfc5:	90                   	nop
c002dfc6:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002dfc9:	5b                   	pop    %ebx
c002dfca:	5e                   	pop    %esi
c002dfcb:	5d                   	pop    %ebp
c002dfcc:	c3                   	ret    

c002dfcd <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002dfcd:	55                   	push   %ebp
c002dfce:	89 e5                	mov    %esp,%ebp
c002dfd0:	57                   	push   %edi
c002dfd1:	56                   	push   %esi
c002dfd2:	53                   	push   %ebx
c002dfd3:	83 ec 2c             	sub    $0x2c,%esp
  int64_t start_time;
  int last_elapsed = 0;
c002dfd6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  
  ASSERT (thread_mlfqs);
c002dfdd:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002dfe4:	84 c0                	test   %al,%al
c002dfe6:	75 1e                	jne    c002e006 <test_mlfqs_recent_1+0x39>
c002dfe8:	83 ec 0c             	sub    $0xc,%esp
c002dfeb:	68 cc 2d 03 c0       	push   $0xc0032dcc
c002dff0:	68 d9 2d 03 c0       	push   $0xc0032dd9
c002dff5:	68 9c 2e 03 c0       	push   $0xc0032e9c
c002dffa:	6a 73                	push   $0x73
c002dffc:	68 f0 2d 03 c0       	push   $0xc0032df0
c002e001:	e8 72 b7 ff ff       	call   c0029778 <debug_panic>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c002e006:	83 ec 0c             	sub    $0xc,%esp
c002e009:	68 18 2e 03 c0       	push   $0xc0032e18
c002e00e:	e8 f6 da ff ff       	call   c002bb09 <msg>
c002e013:	83 c4 10             	add    $0x10,%esp
      start_time = timer_ticks ();
c002e016:	e8 d3 5d ff ff       	call   c0023dee <timer_ticks>
c002e01b:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002e01e:	89 55 dc             	mov    %edx,-0x24(%ebp)
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c002e021:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002e024:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002e027:	83 c0 63             	add    $0x63,%eax
c002e02a:	83 d2 00             	adc    $0x0,%edx
c002e02d:	6a 00                	push   $0x0
c002e02f:	6a 64                	push   $0x64
c002e031:	52                   	push   %edx
c002e032:	50                   	push   %eax
c002e033:	e8 1a b1 ff ff       	call   c0029152 <__divdi3>
c002e038:	83 c4 10             	add    $0x10,%esp
c002e03b:	2b 45 d8             	sub    -0x28(%ebp),%eax
c002e03e:	1b 55 dc             	sbb    -0x24(%ebp),%edx
c002e041:	05 e8 03 00 00       	add    $0x3e8,%eax
c002e046:	83 d2 00             	adc    $0x0,%edx
c002e049:	83 ec 08             	sub    $0x8,%esp
c002e04c:	52                   	push   %edx
c002e04d:	50                   	push   %eax
c002e04e:	e8 ef 5d ff ff       	call   c0023e42 <timer_sleep>
c002e053:	83 c4 10             	add    $0x10,%esp
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c002e056:	e8 89 2f ff ff       	call   c0020fe4 <thread_get_recent_cpu>
c002e05b:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c002e060:	7f a4                	jg     c002e006 <test_mlfqs_recent_1+0x39>

  start_time = timer_ticks ();
c002e062:	e8 87 5d ff ff       	call   c0023dee <timer_ticks>
c002e067:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002e06a:	89 55 dc             	mov    %edx,-0x24(%ebp)
  for (;;) 
    {
      int elapsed = timer_elapsed (start_time);
c002e06d:	83 ec 08             	sub    $0x8,%esp
c002e070:	ff 75 dc             	pushl  -0x24(%ebp)
c002e073:	ff 75 d8             	pushl  -0x28(%ebp)
c002e076:	e8 a8 5d ff ff       	call   c0023e23 <timer_elapsed>
c002e07b:	83 c4 10             	add    $0x10,%esp
c002e07e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c002e081:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c002e084:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e089:	89 c8                	mov    %ecx,%eax
c002e08b:	f7 ea                	imul   %edx
c002e08d:	c1 fa 06             	sar    $0x6,%edx
c002e090:	89 c8                	mov    %ecx,%eax
c002e092:	c1 f8 1f             	sar    $0x1f,%eax
c002e095:	29 c2                	sub    %eax,%edx
c002e097:	89 d0                	mov    %edx,%eax
c002e099:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c002e09f:	29 c1                	sub    %eax,%ecx
c002e0a1:	89 c8                	mov    %ecx,%eax
c002e0a3:	85 c0                	test   %eax,%eax
c002e0a5:	0f 85 c5 00 00 00    	jne    c002e170 <test_mlfqs_recent_1+0x1a3>
c002e0ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002e0ae:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002e0b1:	0f 8e b9 00 00 00    	jle    c002e170 <test_mlfqs_recent_1+0x1a3>
        {
          int recent_cpu = thread_get_recent_cpu ();
c002e0b7:	e8 28 2f ff ff       	call   c0020fe4 <thread_get_recent_cpu>
c002e0bc:	89 45 d0             	mov    %eax,-0x30(%ebp)
          int load_avg = thread_get_load_avg ();
c002e0bf:	e8 16 2f ff ff       	call   c0020fda <thread_get_load_avg>
c002e0c4:	89 45 cc             	mov    %eax,-0x34(%ebp)
          int elapsed_seconds = elapsed / TIMER_FREQ;
c002e0c7:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c002e0ca:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e0cf:	89 c8                	mov    %ecx,%eax
c002e0d1:	f7 ea                	imul   %edx
c002e0d3:	c1 fa 05             	sar    $0x5,%edx
c002e0d6:	89 c8                	mov    %ecx,%eax
c002e0d8:	c1 f8 1f             	sar    $0x1f,%eax
c002e0db:	29 c2                	sub    %eax,%edx
c002e0dd:	89 d0                	mov    %edx,%eax
c002e0df:	89 45 c8             	mov    %eax,-0x38(%ebp)
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002e0e2:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002e0e5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e0ea:	89 c8                	mov    %ecx,%eax
c002e0ec:	f7 ea                	imul   %edx
c002e0ee:	c1 fa 05             	sar    $0x5,%edx
c002e0f1:	89 c8                	mov    %ecx,%eax
c002e0f3:	c1 f8 1f             	sar    $0x1f,%eax
c002e0f6:	89 d3                	mov    %edx,%ebx
c002e0f8:	29 c3                	sub    %eax,%ebx
c002e0fa:	6b c3 64             	imul   $0x64,%ebx,%eax
c002e0fd:	89 cb                	mov    %ecx,%ebx
c002e0ff:	29 c3                	sub    %eax,%ebx
c002e101:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002e104:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e109:	89 c8                	mov    %ecx,%eax
c002e10b:	f7 ea                	imul   %edx
c002e10d:	c1 fa 05             	sar    $0x5,%edx
c002e110:	89 c8                	mov    %ecx,%eax
c002e112:	c1 f8 1f             	sar    $0x1f,%eax
c002e115:	89 d7                	mov    %edx,%edi
c002e117:	29 c7                	sub    %eax,%edi
c002e119:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002e11c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e121:	89 f0                	mov    %esi,%eax
c002e123:	f7 ea                	imul   %edx
c002e125:	c1 fa 05             	sar    $0x5,%edx
c002e128:	89 f0                	mov    %esi,%eax
c002e12a:	c1 f8 1f             	sar    $0x1f,%eax
c002e12d:	89 d1                	mov    %edx,%ecx
c002e12f:	29 c1                	sub    %eax,%ecx
c002e131:	6b c1 64             	imul   $0x64,%ecx,%eax
c002e134:	29 c6                	sub    %eax,%esi
c002e136:	89 f1                	mov    %esi,%ecx
c002e138:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002e13b:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e140:	89 f0                	mov    %esi,%eax
c002e142:	f7 ea                	imul   %edx
c002e144:	c1 fa 05             	sar    $0x5,%edx
c002e147:	89 f0                	mov    %esi,%eax
c002e149:	c1 f8 1f             	sar    $0x1f,%eax
c002e14c:	29 c2                	sub    %eax,%edx
c002e14e:	89 d0                	mov    %edx,%eax
c002e150:	83 ec 08             	sub    $0x8,%esp
c002e153:	53                   	push   %ebx
c002e154:	57                   	push   %edi
c002e155:	51                   	push   %ecx
c002e156:	50                   	push   %eax
c002e157:	ff 75 c8             	pushl  -0x38(%ebp)
c002e15a:	68 5c 2e 03 c0       	push   $0xc0032e5c
c002e15f:	e8 a5 d9 ff ff       	call   c002bb09 <msg>
c002e164:	83 c4 20             	add    $0x20,%esp
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c002e167:	81 7d c8 b3 00 00 00 	cmpl   $0xb3,-0x38(%ebp)
c002e16e:	7f 0b                	jg     c002e17b <test_mlfqs_recent_1+0x1ae>
            break;
        } 
      last_elapsed = elapsed;
c002e170:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002e173:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
c002e176:	e9 f2 fe ff ff       	jmp    c002e06d <test_mlfqs_recent_1+0xa0>
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
            break;
c002e17b:	90                   	nop
        } 
      last_elapsed = elapsed;
    }
}
c002e17c:	90                   	nop
c002e17d:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002e180:	5b                   	pop    %ebx
c002e181:	5e                   	pop    %esi
c002e182:	5f                   	pop    %edi
c002e183:	5d                   	pop    %ebp
c002e184:	c3                   	ret    

c002e185 <test_mlfqs_fair_2>:

static void test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step);

void
test_mlfqs_fair_2 (void) 
{
c002e185:	55                   	push   %ebp
c002e186:	89 e5                	mov    %esp,%ebp
c002e188:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 0);
c002e18b:	83 ec 04             	sub    $0x4,%esp
c002e18e:	6a 00                	push   $0x0
c002e190:	6a 00                	push   $0x0
c002e192:	6a 02                	push   $0x2
c002e194:	e8 54 00 00 00       	call   c002e1ed <test_mlfqs_fair>
c002e199:	83 c4 10             	add    $0x10,%esp
}
c002e19c:	90                   	nop
c002e19d:	c9                   	leave  
c002e19e:	c3                   	ret    

c002e19f <test_mlfqs_fair_20>:

void
test_mlfqs_fair_20 (void) 
{
c002e19f:	55                   	push   %ebp
c002e1a0:	89 e5                	mov    %esp,%ebp
c002e1a2:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (20, 0, 0);
c002e1a5:	83 ec 04             	sub    $0x4,%esp
c002e1a8:	6a 00                	push   $0x0
c002e1aa:	6a 00                	push   $0x0
c002e1ac:	6a 14                	push   $0x14
c002e1ae:	e8 3a 00 00 00       	call   c002e1ed <test_mlfqs_fair>
c002e1b3:	83 c4 10             	add    $0x10,%esp
}
c002e1b6:	90                   	nop
c002e1b7:	c9                   	leave  
c002e1b8:	c3                   	ret    

c002e1b9 <test_mlfqs_nice_2>:

void
test_mlfqs_nice_2 (void) 
{
c002e1b9:	55                   	push   %ebp
c002e1ba:	89 e5                	mov    %esp,%ebp
c002e1bc:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 5);
c002e1bf:	83 ec 04             	sub    $0x4,%esp
c002e1c2:	6a 05                	push   $0x5
c002e1c4:	6a 00                	push   $0x0
c002e1c6:	6a 02                	push   $0x2
c002e1c8:	e8 20 00 00 00       	call   c002e1ed <test_mlfqs_fair>
c002e1cd:	83 c4 10             	add    $0x10,%esp
}
c002e1d0:	90                   	nop
c002e1d1:	c9                   	leave  
c002e1d2:	c3                   	ret    

c002e1d3 <test_mlfqs_nice_10>:

void
test_mlfqs_nice_10 (void) 
{
c002e1d3:	55                   	push   %ebp
c002e1d4:	89 e5                	mov    %esp,%ebp
c002e1d6:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (10, 0, 1);
c002e1d9:	83 ec 04             	sub    $0x4,%esp
c002e1dc:	6a 01                	push   $0x1
c002e1de:	6a 00                	push   $0x0
c002e1e0:	6a 0a                	push   $0xa
c002e1e2:	e8 06 00 00 00       	call   c002e1ed <test_mlfqs_fair>
c002e1e7:	83 c4 10             	add    $0x10,%esp
}
c002e1ea:	90                   	nop
c002e1eb:	c9                   	leave  
c002e1ec:	c3                   	ret    

c002e1ed <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c002e1ed:	55                   	push   %ebp
c002e1ee:	89 e5                	mov    %esp,%ebp
c002e1f0:	81 ec 78 01 00 00    	sub    $0x178,%esp
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c002e1f6:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002e1fd:	84 c0                	test   %al,%al
c002e1ff:	75 1e                	jne    c002e21f <test_mlfqs_fair+0x32>
c002e201:	83 ec 0c             	sub    $0xc,%esp
c002e204:	68 b0 2e 03 c0       	push   $0xc0032eb0
c002e209:	68 bd 2e 03 c0       	push   $0xc0032ebd
c002e20e:	68 fc 2f 03 c0       	push   $0xc0032ffc
c002e213:	6a 49                	push   $0x49
c002e215:	68 d4 2e 03 c0       	push   $0xc0032ed4
c002e21a:	e8 59 b5 ff ff       	call   c0029778 <debug_panic>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002e21f:	83 7d 08 14          	cmpl   $0x14,0x8(%ebp)
c002e223:	7e 1e                	jle    c002e243 <test_mlfqs_fair+0x56>
c002e225:	83 ec 0c             	sub    $0xc,%esp
c002e228:	68 f5 2e 03 c0       	push   $0xc0032ef5
c002e22d:	68 bd 2e 03 c0       	push   $0xc0032ebd
c002e232:	68 fc 2f 03 c0       	push   $0xc0032ffc
c002e237:	6a 4a                	push   $0x4a
c002e239:	68 d4 2e 03 c0       	push   $0xc0032ed4
c002e23e:	e8 35 b5 ff ff       	call   c0029778 <debug_panic>
  ASSERT (nice_min >= -10);
c002e243:	83 7d 0c f6          	cmpl   $0xfffffff6,0xc(%ebp)
c002e247:	7d 1e                	jge    c002e267 <test_mlfqs_fair+0x7a>
c002e249:	83 ec 0c             	sub    $0xc,%esp
c002e24c:	68 12 2f 03 c0       	push   $0xc0032f12
c002e251:	68 bd 2e 03 c0       	push   $0xc0032ebd
c002e256:	68 fc 2f 03 c0       	push   $0xc0032ffc
c002e25b:	6a 4b                	push   $0x4b
c002e25d:	68 d4 2e 03 c0       	push   $0xc0032ed4
c002e262:	e8 11 b5 ff ff       	call   c0029778 <debug_panic>
  ASSERT (nice_step >= 0);
c002e267:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e26b:	79 1e                	jns    c002e28b <test_mlfqs_fair+0x9e>
c002e26d:	83 ec 0c             	sub    $0xc,%esp
c002e270:	68 22 2f 03 c0       	push   $0xc0032f22
c002e275:	68 bd 2e 03 c0       	push   $0xc0032ebd
c002e27a:	68 fc 2f 03 c0       	push   $0xc0032ffc
c002e27f:	6a 4c                	push   $0x4c
c002e281:	68 d4 2e 03 c0       	push   $0xc0032ed4
c002e286:	e8 ed b4 ff ff       	call   c0029778 <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002e28b:	8b 45 08             	mov    0x8(%ebp),%eax
c002e28e:	83 e8 01             	sub    $0x1,%eax
c002e291:	0f af 45 10          	imul   0x10(%ebp),%eax
c002e295:	89 c2                	mov    %eax,%edx
c002e297:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e29a:	01 d0                	add    %edx,%eax
c002e29c:	83 f8 14             	cmp    $0x14,%eax
c002e29f:	7e 1e                	jle    c002e2bf <test_mlfqs_fair+0xd2>
c002e2a1:	83 ec 0c             	sub    $0xc,%esp
c002e2a4:	68 34 2f 03 c0       	push   $0xc0032f34
c002e2a9:	68 bd 2e 03 c0       	push   $0xc0032ebd
c002e2ae:	68 fc 2f 03 c0       	push   $0xc0032ffc
c002e2b3:	6a 4d                	push   $0x4d
c002e2b5:	68 d4 2e 03 c0       	push   $0xc0032ed4
c002e2ba:	e8 b9 b4 ff ff       	call   c0029778 <debug_panic>

  thread_set_nice (-20);
c002e2bf:	83 ec 0c             	sub    $0xc,%esp
c002e2c2:	6a ec                	push   $0xffffffec
c002e2c4:	e8 01 2d ff ff       	call   c0020fca <thread_set_nice>
c002e2c9:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002e2cc:	e8 1d 5b ff ff       	call   c0023dee <timer_ticks>
c002e2d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e2d4:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg ("Starting %d threads...", thread_cnt);
c002e2d7:	83 ec 08             	sub    $0x8,%esp
c002e2da:	ff 75 08             	pushl  0x8(%ebp)
c002e2dd:	68 62 2f 03 c0       	push   $0xc0032f62
c002e2e2:	e8 22 d8 ff ff       	call   c002bb09 <msg>
c002e2e7:	83 c4 10             	add    $0x10,%esp
  nice = nice_min;
c002e2ea:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e2ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c002e2f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e2f7:	eb 6e                	jmp    c002e367 <test_mlfqs_fair+0x17a>
    {
      struct thread_info *ti = &info[i];
c002e2f9:	8d 85 a4 fe ff ff    	lea    -0x15c(%ebp),%eax
c002e2ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002e302:	c1 e2 04             	shl    $0x4,%edx
c002e305:	01 d0                	add    %edx,%eax
c002e307:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      char name[16];

      ti->start_time = start_time;
c002e30a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002e30d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e310:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002e313:	89 01                	mov    %eax,(%ecx)
c002e315:	89 51 04             	mov    %edx,0x4(%ecx)
      ti->tick_count = 0;
c002e318:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e31b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      ti->nice = nice;
c002e322:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e325:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002e328:	89 50 0c             	mov    %edx,0xc(%eax)

      snprintf(name, sizeof name, "load %d", i);
c002e32b:	ff 75 f0             	pushl  -0x10(%ebp)
c002e32e:	68 79 2f 03 c0       	push   $0xc0032f79
c002e333:	6a 10                	push   $0x10
c002e335:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002e33b:	50                   	push   %eax
c002e33c:	e8 db 8f ff ff       	call   c002731c <snprintf>
c002e341:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c002e344:	ff 75 e4             	pushl  -0x1c(%ebp)
c002e347:	68 f2 e3 02 c0       	push   $0xc002e3f2
c002e34c:	6a 1f                	push   $0x1f
c002e34e:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002e354:	50                   	push   %eax
c002e355:	e8 2c 28 ff ff       	call   c0020b86 <thread_create>
c002e35a:	83 c4 10             	add    $0x10,%esp

      nice += nice_step;
c002e35d:	8b 45 10             	mov    0x10(%ebp),%eax
c002e360:	01 45 f4             	add    %eax,-0xc(%ebp)
  thread_set_nice (-20);

  start_time = timer_ticks ();
  msg ("Starting %d threads...", thread_cnt);
  nice = nice_min;
  for (i = 0; i < thread_cnt; i++) 
c002e363:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002e367:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e36a:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e36d:	7c 8a                	jl     c002e2f9 <test_mlfqs_fair+0x10c>
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, ti);

      nice += nice_step;
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002e36f:	83 ec 08             	sub    $0x8,%esp
c002e372:	ff 75 ec             	pushl  -0x14(%ebp)
c002e375:	ff 75 e8             	pushl  -0x18(%ebp)
c002e378:	e8 a6 5a ff ff       	call   c0023e23 <timer_elapsed>
c002e37d:	83 c4 10             	add    $0x10,%esp
c002e380:	83 ec 04             	sub    $0x4,%esp
c002e383:	52                   	push   %edx
c002e384:	50                   	push   %eax
c002e385:	68 84 2f 03 c0       	push   $0xc0032f84
c002e38a:	e8 7a d7 ff ff       	call   c002bb09 <msg>
c002e38f:	83 c4 10             	add    $0x10,%esp

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002e392:	83 ec 0c             	sub    $0xc,%esp
c002e395:	68 a8 2f 03 c0       	push   $0xc0032fa8
c002e39a:	e8 6a d7 ff ff       	call   c002bb09 <msg>
c002e39f:	83 c4 10             	add    $0x10,%esp
  timer_sleep (40 * TIMER_FREQ);
c002e3a2:	83 ec 08             	sub    $0x8,%esp
c002e3a5:	6a 00                	push   $0x0
c002e3a7:	68 a0 0f 00 00       	push   $0xfa0
c002e3ac:	e8 91 5a ff ff       	call   c0023e42 <timer_sleep>
c002e3b1:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < thread_cnt; i++)
c002e3b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e3bb:	eb 2a                	jmp    c002e3e7 <test_mlfqs_fair+0x1fa>
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002e3bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e3c0:	c1 e0 04             	shl    $0x4,%eax
c002e3c3:	8d 4d f8             	lea    -0x8(%ebp),%ecx
c002e3c6:	01 c8                	add    %ecx,%eax
c002e3c8:	2d 4c 01 00 00       	sub    $0x14c,%eax
c002e3cd:	8b 00                	mov    (%eax),%eax
c002e3cf:	83 ec 04             	sub    $0x4,%esp
c002e3d2:	50                   	push   %eax
c002e3d3:	ff 75 f0             	pushl  -0x10(%ebp)
c002e3d6:	68 df 2f 03 c0       	push   $0xc0032fdf
c002e3db:	e8 29 d7 ff ff       	call   c002bb09 <msg>
c002e3e0:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));

  msg ("Sleeping 40 seconds to let threads run, please wait...");
  timer_sleep (40 * TIMER_FREQ);
  
  for (i = 0; i < thread_cnt; i++)
c002e3e3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002e3e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e3ea:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e3ed:	7c ce                	jl     c002e3bd <test_mlfqs_fair+0x1d0>
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
}
c002e3ef:	90                   	nop
c002e3f0:	c9                   	leave  
c002e3f1:	c3                   	ret    

c002e3f2 <load_thread>:

static void
load_thread (void *ti_) 
{
c002e3f2:	55                   	push   %ebp
c002e3f3:	89 e5                	mov    %esp,%ebp
c002e3f5:	53                   	push   %ebx
c002e3f6:	83 ec 34             	sub    $0x34,%esp
  struct thread_info *ti = ti_;
c002e3f9:	8b 45 08             	mov    0x8(%ebp),%eax
c002e3fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int64_t sleep_time = 5 * TIMER_FREQ;
c002e3ff:	c7 45 e0 f4 01 00 00 	movl   $0x1f4,-0x20(%ebp)
c002e406:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
c002e40d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e410:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002e413:	05 b8 0b 00 00       	add    $0xbb8,%eax
c002e418:	83 d2 00             	adc    $0x0,%edx
c002e41b:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002e41e:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int64_t last_time = 0;
c002e421:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e428:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  thread_set_nice (ti->nice);
c002e42f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e432:	8b 40 0c             	mov    0xc(%eax),%eax
c002e435:	83 ec 0c             	sub    $0xc,%esp
c002e438:	50                   	push   %eax
c002e439:	e8 8c 2b ff ff       	call   c0020fca <thread_set_nice>
c002e43e:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c002e441:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e444:	8b 50 04             	mov    0x4(%eax),%edx
c002e447:	8b 00                	mov    (%eax),%eax
c002e449:	83 ec 08             	sub    $0x8,%esp
c002e44c:	52                   	push   %edx
c002e44d:	50                   	push   %eax
c002e44e:	e8 d0 59 ff ff       	call   c0023e23 <timer_elapsed>
c002e453:	83 c4 10             	add    $0x10,%esp
c002e456:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002e459:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e45c:	29 c1                	sub    %eax,%ecx
c002e45e:	19 d3                	sbb    %edx,%ebx
c002e460:	89 c8                	mov    %ecx,%eax
c002e462:	89 da                	mov    %ebx,%edx
c002e464:	83 ec 08             	sub    $0x8,%esp
c002e467:	52                   	push   %edx
c002e468:	50                   	push   %eax
c002e469:	e8 d4 59 ff ff       	call   c0023e42 <timer_sleep>
c002e46e:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (ti->start_time) < spin_time) 
c002e471:	eb 3a                	jmp    c002e4ad <load_thread+0xbb>
    {
      int64_t cur_time = timer_ticks ();
c002e473:	e8 76 59 ff ff       	call   c0023dee <timer_ticks>
c002e478:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002e47b:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      if (cur_time != last_time)
c002e47e:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e481:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e484:	89 d1                	mov    %edx,%ecx
c002e486:	33 4d f4             	xor    -0xc(%ebp),%ecx
c002e489:	33 45 f0             	xor    -0x10(%ebp),%eax
c002e48c:	09 c8                	or     %ecx,%eax
c002e48e:	85 c0                	test   %eax,%eax
c002e490:	74 0f                	je     c002e4a1 <load_thread+0xaf>
        ti->tick_count++;
c002e492:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e495:	8b 40 08             	mov    0x8(%eax),%eax
c002e498:	8d 50 01             	lea    0x1(%eax),%edx
c002e49b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e49e:	89 50 08             	mov    %edx,0x8(%eax)
      last_time = cur_time;
c002e4a1:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e4a4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e4a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e4aa:	89 55 f4             	mov    %edx,-0xc(%ebp)
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
  int64_t last_time = 0;

  thread_set_nice (ti->nice);
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
  while (timer_elapsed (ti->start_time) < spin_time) 
c002e4ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e4b0:	8b 50 04             	mov    0x4(%eax),%edx
c002e4b3:	8b 00                	mov    (%eax),%eax
c002e4b5:	83 ec 08             	sub    $0x8,%esp
c002e4b8:	52                   	push   %edx
c002e4b9:	50                   	push   %eax
c002e4ba:	e8 64 59 ff ff       	call   c0023e23 <timer_elapsed>
c002e4bf:	83 c4 10             	add    $0x10,%esp
c002e4c2:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c002e4c5:	7c ac                	jl     c002e473 <load_thread+0x81>
c002e4c7:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c002e4ca:	7f 05                	jg     c002e4d1 <load_thread+0xdf>
c002e4cc:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c002e4cf:	72 a2                	jb     c002e473 <load_thread+0x81>
      int64_t cur_time = timer_ticks ();
      if (cur_time != last_time)
        ti->tick_count++;
      last_time = cur_time;
    }
}
c002e4d1:	90                   	nop
c002e4d2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e4d5:	c9                   	leave  
c002e4d6:	c3                   	ret    

c002e4d7 <test_mlfqs_block>:

static void block_thread (void *lock_);

void
test_mlfqs_block (void) 
{
c002e4d7:	55                   	push   %ebp
c002e4d8:	89 e5                	mov    %esp,%ebp
c002e4da:	83 ec 28             	sub    $0x28,%esp
  int64_t start_time;
  struct lock lock;
  
  ASSERT (thread_mlfqs);
c002e4dd:	0f b6 05 c4 9c 03 c0 	movzbl 0xc0039cc4,%eax
c002e4e4:	84 c0                	test   %al,%al
c002e4e6:	75 1e                	jne    c002e506 <test_mlfqs_block+0x2f>
c002e4e8:	83 ec 0c             	sub    $0xc,%esp
c002e4eb:	68 0c 30 03 c0       	push   $0xc003300c
c002e4f0:	68 19 30 03 c0       	push   $0xc0033019
c002e4f5:	68 78 31 03 c0       	push   $0xc0033178
c002e4fa:	6a 1c                	push   $0x1c
c002e4fc:	68 30 30 03 c0       	push   $0xc0033030
c002e501:	e8 72 b2 ff ff       	call   c0029778 <debug_panic>

  msg ("Main thread acquiring lock.");
c002e506:	83 ec 0c             	sub    $0xc,%esp
c002e509:	68 52 30 03 c0       	push   $0xc0033052
c002e50e:	e8 f6 d5 ff ff       	call   c002bb09 <msg>
c002e513:	83 c4 10             	add    $0x10,%esp
  lock_init (&lock);
c002e516:	83 ec 0c             	sub    $0xc,%esp
c002e519:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e51c:	50                   	push   %eax
c002e51d:	e8 71 46 ff ff       	call   c0022b93 <lock_init>
c002e522:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002e525:	83 ec 0c             	sub    $0xc,%esp
c002e528:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e52b:	50                   	push   %eax
c002e52c:	e8 af 46 ff ff       	call   c0022be0 <lock_acquire>
c002e531:	83 c4 10             	add    $0x10,%esp
  
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c002e534:	83 ec 0c             	sub    $0xc,%esp
c002e537:	68 70 30 03 c0       	push   $0xc0033070
c002e53c:	e8 c8 d5 ff ff       	call   c002bb09 <msg>
c002e541:	83 c4 10             	add    $0x10,%esp
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c002e544:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e547:	50                   	push   %eax
c002e548:	68 de e5 02 c0       	push   $0xc002e5de
c002e54d:	6a 1f                	push   $0x1f
c002e54f:	68 aa 30 03 c0       	push   $0xc00330aa
c002e554:	e8 2d 26 ff ff       	call   c0020b86 <thread_create>
c002e559:	83 c4 10             	add    $0x10,%esp
  timer_sleep (25 * TIMER_FREQ);
c002e55c:	83 ec 08             	sub    $0x8,%esp
c002e55f:	6a 00                	push   $0x0
c002e561:	68 c4 09 00 00       	push   $0x9c4
c002e566:	e8 d7 58 ff ff       	call   c0023e42 <timer_sleep>
c002e56b:	83 c4 10             	add    $0x10,%esp

  msg ("Main thread spinning for 5 seconds...");
c002e56e:	83 ec 0c             	sub    $0xc,%esp
c002e571:	68 b0 30 03 c0       	push   $0xc00330b0
c002e576:	e8 8e d5 ff ff       	call   c002bb09 <msg>
c002e57b:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002e57e:	e8 6b 58 ff ff       	call   c0023dee <timer_ticks>
c002e583:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e586:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002e589:	eb 01                	jmp    c002e58c <test_mlfqs_block+0xb5>
    continue;
c002e58b:	90                   	nop
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
  timer_sleep (25 * TIMER_FREQ);

  msg ("Main thread spinning for 5 seconds...");
  start_time = timer_ticks ();
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002e58c:	83 ec 08             	sub    $0x8,%esp
c002e58f:	ff 75 f4             	pushl  -0xc(%ebp)
c002e592:	ff 75 f0             	pushl  -0x10(%ebp)
c002e595:	e8 89 58 ff ff       	call   c0023e23 <timer_elapsed>
c002e59a:	83 c4 10             	add    $0x10,%esp
c002e59d:	85 d2                	test   %edx,%edx
c002e59f:	78 ea                	js     c002e58b <test_mlfqs_block+0xb4>
c002e5a1:	85 d2                	test   %edx,%edx
c002e5a3:	7f 07                	jg     c002e5ac <test_mlfqs_block+0xd5>
c002e5a5:	3d f3 01 00 00       	cmp    $0x1f3,%eax
c002e5aa:	76 df                	jbe    c002e58b <test_mlfqs_block+0xb4>
    continue;

  msg ("Main thread releasing lock.");
c002e5ac:	83 ec 0c             	sub    $0xc,%esp
c002e5af:	68 d6 30 03 c0       	push   $0xc00330d6
c002e5b4:	e8 50 d5 ff ff       	call   c002bb09 <msg>
c002e5b9:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002e5bc:	83 ec 0c             	sub    $0xc,%esp
c002e5bf:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e5c2:	50                   	push   %eax
c002e5c3:	e8 59 47 ff ff       	call   c0022d21 <lock_release>
c002e5c8:	83 c4 10             	add    $0x10,%esp

  msg ("Block thread should have already acquired lock.");
c002e5cb:	83 ec 0c             	sub    $0xc,%esp
c002e5ce:	68 f4 30 03 c0       	push   $0xc00330f4
c002e5d3:	e8 31 d5 ff ff       	call   c002bb09 <msg>
c002e5d8:	83 c4 10             	add    $0x10,%esp
}
c002e5db:	90                   	nop
c002e5dc:	c9                   	leave  
c002e5dd:	c3                   	ret    

c002e5de <block_thread>:

static void
block_thread (void *lock_) 
{
c002e5de:	55                   	push   %ebp
c002e5df:	89 e5                	mov    %esp,%ebp
c002e5e1:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002e5e4:	8b 45 08             	mov    0x8(%ebp),%eax
c002e5e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c002e5ea:	83 ec 0c             	sub    $0xc,%esp
c002e5ed:	68 24 31 03 c0       	push   $0xc0033124
c002e5f2:	e8 12 d5 ff ff       	call   c002bb09 <msg>
c002e5f7:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002e5fa:	e8 ef 57 ff ff       	call   c0023dee <timer_ticks>
c002e5ff:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e602:	89 55 ec             	mov    %edx,-0x14(%ebp)
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002e605:	eb 01                	jmp    c002e608 <block_thread+0x2a>
    continue;
c002e607:	90                   	nop
  struct lock *lock = lock_;
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
  start_time = timer_ticks ();
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002e608:	83 ec 08             	sub    $0x8,%esp
c002e60b:	ff 75 ec             	pushl  -0x14(%ebp)
c002e60e:	ff 75 e8             	pushl  -0x18(%ebp)
c002e611:	e8 0d 58 ff ff       	call   c0023e23 <timer_elapsed>
c002e616:	83 c4 10             	add    $0x10,%esp
c002e619:	85 d2                	test   %edx,%edx
c002e61b:	78 ea                	js     c002e607 <block_thread+0x29>
c002e61d:	85 d2                	test   %edx,%edx
c002e61f:	7f 07                	jg     c002e628 <block_thread+0x4a>
c002e621:	3d cf 07 00 00       	cmp    $0x7cf,%eax
c002e626:	76 df                	jbe    c002e607 <block_thread+0x29>
    continue;

  msg ("Block thread acquiring lock...");
c002e628:	83 ec 0c             	sub    $0xc,%esp
c002e62b:	68 4c 31 03 c0       	push   $0xc003314c
c002e630:	e8 d4 d4 ff ff       	call   c002bb09 <msg>
c002e635:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c002e638:	83 ec 0c             	sub    $0xc,%esp
c002e63b:	ff 75 f4             	pushl  -0xc(%ebp)
c002e63e:	e8 9d 45 ff ff       	call   c0022be0 <lock_acquire>
c002e643:	83 c4 10             	add    $0x10,%esp

  msg ("...got it.");
c002e646:	83 ec 0c             	sub    $0xc,%esp
c002e649:	68 6b 31 03 c0       	push   $0xc003316b
c002e64e:	e8 b6 d4 ff ff       	call   c002bb09 <msg>
c002e653:	83 c4 10             	add    $0x10,%esp
}
c002e656:	90                   	nop
c002e657:	c9                   	leave  
c002e658:	c3                   	ret    
